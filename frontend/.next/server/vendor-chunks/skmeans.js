"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/skmeans";
exports.ids = ["vendor-chunks/skmeans"];
exports.modules = {

/***/ "(ssr)/./node_modules/skmeans/dist/node/distance.js":
/*!****************************************************!*\
  !*** ./node_modules/skmeans/dist/node/distance.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = {\n\t/**\n  * Euclidean distance\n  */\n\teudist: function eudist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar d = (v1[i] || 0) - (v2[i] || 0);\n\t\t\tsum += d * d;\n\t\t}\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\tmandist: function mandist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tsum += Math.abs((v1[i] || 0) - (v2[i] || 0));\n\t\t}\n\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\n\n\t/**\n  * Unidimensional distance\n  */\n\tdist: function dist(v1, v2, sqrt) {\n\t\tvar d = Math.abs(v1 - v2);\n\t\treturn sqrt ? d : d * d;\n\t}\n};\n//# sourceMappingURL=distance.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUvZGlzdGFuY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUvZGlzdGFuY2UuanM/ZTQwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdC8qKlxuICAqIEV1Y2xpZGVhbiBkaXN0YW5jZVxuICAqL1xuXHRldWRpc3Q6IGZ1bmN0aW9uIGV1ZGlzdCh2MSwgdjIsIHNxcnQpIHtcblx0XHR2YXIgbGVuID0gdjEubGVuZ3RoO1xuXHRcdHZhciBzdW0gPSAwO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIGQgPSAodjFbaV0gfHwgMCkgLSAodjJbaV0gfHwgMCk7XG5cdFx0XHRzdW0gKz0gZCAqIGQ7XG5cdFx0fVxuXHRcdC8vIFNxdWFyZSByb290IG5vdCByZWFsbHkgbmVlZGVkXG5cdFx0cmV0dXJuIHNxcnQgPyBNYXRoLnNxcnQoc3VtKSA6IHN1bTtcblx0fSxcblx0bWFuZGlzdDogZnVuY3Rpb24gbWFuZGlzdCh2MSwgdjIsIHNxcnQpIHtcblx0XHR2YXIgbGVuID0gdjEubGVuZ3RoO1xuXHRcdHZhciBzdW0gPSAwO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0c3VtICs9IE1hdGguYWJzKCh2MVtpXSB8fCAwKSAtICh2MltpXSB8fCAwKSk7XG5cdFx0fVxuXG5cdFx0Ly8gU3F1YXJlIHJvb3Qgbm90IHJlYWxseSBuZWVkZWRcblx0XHRyZXR1cm4gc3FydCA/IE1hdGguc3FydChzdW0pIDogc3VtO1xuXHR9LFxuXG5cblx0LyoqXG4gICogVW5pZGltZW5zaW9uYWwgZGlzdGFuY2VcbiAgKi9cblx0ZGlzdDogZnVuY3Rpb24gZGlzdCh2MSwgdjIsIHNxcnQpIHtcblx0XHR2YXIgZCA9IE1hdGguYWJzKHYxIC0gdjIpO1xuXHRcdHJldHVybiBzcXJ0ID8gZCA6IGQgKiBkO1xuXHR9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGFuY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/skmeans/dist/node/distance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/skmeans/dist/node/kinit.js":
/*!*************************************************!*\
  !*** ./node_modules/skmeans/dist/node/kinit.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar Distance = __webpack_require__(/*! ./distance.js */ \"(ssr)/./node_modules/skmeans/dist/node/distance.js\"),\n    eudist = Distance.eudist,\n    dist = Distance.dist;\n\nmodule.exports = {\n\tkmrand: function kmrand(data, k) {\n\t\tvar map = {},\n\t\t    ks = [],\n\t\t    t = k << 2;\n\t\tvar len = data.length;\n\t\tvar multi = data[0].length > 0;\n\n\t\twhile (ks.length < k && t-- > 0) {\n\t\t\tvar d = data[Math.floor(Math.random() * len)];\n\t\t\tvar key = multi ? d.join(\"_\") : \"\" + d;\n\t\t\tif (!map[key]) {\n\t\t\t\tmap[key] = true;\n\t\t\t\tks.push(d);\n\t\t\t}\n\t\t}\n\n\t\tif (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n\t},\n\n\n\t/**\n  * K-means++ initial centroid selection\n  */\n\tkmpp: function kmpp(data, k) {\n\t\tvar distance = data[0].length ? eudist : dist;\n\t\tvar ks = [],\n\t\t    len = data.length;\n\t\tvar multi = data[0].length > 0;\n\t\tvar map = {};\n\n\t\t// First random centroid\n\t\tvar c = data[Math.floor(Math.random() * len)];\n\t\tvar key = multi ? c.join(\"_\") : \"\" + c;\n\t\tks.push(c);\n\t\tmap[key] = true;\n\n\t\t// Retrieve next centroids\n\t\twhile (ks.length < k) {\n\t\t\t// Min Distances between current centroids and data points\n\t\t\tvar dists = [],\n\t\t\t    lk = ks.length;\n\t\t\tvar dsum = 0,\n\t\t\t    prs = [];\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar min = Infinity;\n\t\t\t\tfor (var j = 0; j < lk; j++) {\n\t\t\t\t\tvar _dist = distance(data[i], ks[j]);\n\t\t\t\t\tif (_dist <= min) min = _dist;\n\t\t\t\t}\n\t\t\t\tdists[i] = min;\n\t\t\t}\n\n\t\t\t// Sum all min distances\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tdsum += dists[_i];\n\t\t\t}\n\n\t\t\t// Probabilities and cummulative prob (cumsum)\n\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\tprs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };\n\t\t\t}\n\n\t\t\t// Sort Probabilities\n\t\t\tprs.sort(function (a, b) {\n\t\t\t\treturn a.pr - b.pr;\n\t\t\t});\n\n\t\t\t// Cummulative Probabilities\n\t\t\tprs[0].cs = prs[0].pr;\n\t\t\tfor (var _i3 = 1; _i3 < len; _i3++) {\n\t\t\t\tprs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n\t\t\t}\n\n\t\t\t// Randomize\n\t\t\tvar rnd = Math.random();\n\n\t\t\t// Gets only the items whose cumsum >= rnd\n\t\t\tvar idx = 0;\n\t\t\twhile (idx < len - 1 && prs[idx++].cs < rnd) {}\n\t\t\tks.push(prs[idx - 1].v);\n\t\t\t/*\n   let done = false;\n   while(!done) {\n   \t// this is our new centroid\n   \tc = prs[idx-1].v\n   \tkey = multi? c.join(\"_\") : `${c}`;\n   \tif(!map[key]) {\n   \t\tmap[key] = true;\n   \t\tks.push(c);\n   \t\tdone = true;\n   \t}\n   \telse {\n   \t\tidx++;\n   \t}\n   }\n   */\n\t\t}\n\n\t\treturn ks;\n\t}\n};\n//# sourceMappingURL=kinit.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUva2luaXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHlFQUFlO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTtBQUN0RSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEMsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsRUFBRTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUva2luaXQuanM/MDZjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIERpc3RhbmNlID0gcmVxdWlyZShcIi4vZGlzdGFuY2UuanNcIiksXG4gICAgZXVkaXN0ID0gRGlzdGFuY2UuZXVkaXN0LFxuICAgIGRpc3QgPSBEaXN0YW5jZS5kaXN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0a21yYW5kOiBmdW5jdGlvbiBrbXJhbmQoZGF0YSwgaykge1xuXHRcdHZhciBtYXAgPSB7fSxcblx0XHQgICAga3MgPSBbXSxcblx0XHQgICAgdCA9IGsgPDwgMjtcblx0XHR2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG5cdFx0dmFyIG11bHRpID0gZGF0YVswXS5sZW5ndGggPiAwO1xuXG5cdFx0d2hpbGUgKGtzLmxlbmd0aCA8IGsgJiYgdC0tID4gMCkge1xuXHRcdFx0dmFyIGQgPSBkYXRhW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGxlbildO1xuXHRcdFx0dmFyIGtleSA9IG11bHRpID8gZC5qb2luKFwiX1wiKSA6IFwiXCIgKyBkO1xuXHRcdFx0aWYgKCFtYXBba2V5XSkge1xuXHRcdFx0XHRtYXBba2V5XSA9IHRydWU7XG5cdFx0XHRcdGtzLnB1c2goZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGtzLmxlbmd0aCA8IGspIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGluaXRpYWxpemF0aW5nIGNsdXN0ZXJzXCIpO2Vsc2UgcmV0dXJuIGtzO1xuXHR9LFxuXG5cblx0LyoqXG4gICogSy1tZWFucysrIGluaXRpYWwgY2VudHJvaWQgc2VsZWN0aW9uXG4gICovXG5cdGttcHA6IGZ1bmN0aW9uIGttcHAoZGF0YSwgaykge1xuXHRcdHZhciBkaXN0YW5jZSA9IGRhdGFbMF0ubGVuZ3RoID8gZXVkaXN0IDogZGlzdDtcblx0XHR2YXIga3MgPSBbXSxcblx0XHQgICAgbGVuID0gZGF0YS5sZW5ndGg7XG5cdFx0dmFyIG11bHRpID0gZGF0YVswXS5sZW5ndGggPiAwO1xuXHRcdHZhciBtYXAgPSB7fTtcblxuXHRcdC8vIEZpcnN0IHJhbmRvbSBjZW50cm9pZFxuXHRcdHZhciBjID0gZGF0YVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsZW4pXTtcblx0XHR2YXIga2V5ID0gbXVsdGkgPyBjLmpvaW4oXCJfXCIpIDogXCJcIiArIGM7XG5cdFx0a3MucHVzaChjKTtcblx0XHRtYXBba2V5XSA9IHRydWU7XG5cblx0XHQvLyBSZXRyaWV2ZSBuZXh0IGNlbnRyb2lkc1xuXHRcdHdoaWxlIChrcy5sZW5ndGggPCBrKSB7XG5cdFx0XHQvLyBNaW4gRGlzdGFuY2VzIGJldHdlZW4gY3VycmVudCBjZW50cm9pZHMgYW5kIGRhdGEgcG9pbnRzXG5cdFx0XHR2YXIgZGlzdHMgPSBbXSxcblx0XHRcdCAgICBsayA9IGtzLmxlbmd0aDtcblx0XHRcdHZhciBkc3VtID0gMCxcblx0XHRcdCAgICBwcnMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHR2YXIgbWluID0gSW5maW5pdHk7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGs7IGorKykge1xuXHRcdFx0XHRcdHZhciBfZGlzdCA9IGRpc3RhbmNlKGRhdGFbaV0sIGtzW2pdKTtcblx0XHRcdFx0XHRpZiAoX2Rpc3QgPD0gbWluKSBtaW4gPSBfZGlzdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRkaXN0c1tpXSA9IG1pbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VtIGFsbCBtaW4gZGlzdGFuY2VzXG5cdFx0XHRmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuOyBfaSsrKSB7XG5cdFx0XHRcdGRzdW0gKz0gZGlzdHNbX2ldO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQcm9iYWJpbGl0aWVzIGFuZCBjdW1tdWxhdGl2ZSBwcm9iIChjdW1zdW0pXG5cdFx0XHRmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBsZW47IF9pMisrKSB7XG5cdFx0XHRcdHByc1tfaTJdID0geyBpOiBfaTIsIHY6IGRhdGFbX2kyXSwgcHI6IGRpc3RzW19pMl0gLyBkc3VtLCBjczogMCB9O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTb3J0IFByb2JhYmlsaXRpZXNcblx0XHRcdHBycy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhLnByIC0gYi5wcjtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBDdW1tdWxhdGl2ZSBQcm9iYWJpbGl0aWVzXG5cdFx0XHRwcnNbMF0uY3MgPSBwcnNbMF0ucHI7XG5cdFx0XHRmb3IgKHZhciBfaTMgPSAxOyBfaTMgPCBsZW47IF9pMysrKSB7XG5cdFx0XHRcdHByc1tfaTNdLmNzID0gcHJzW19pMyAtIDFdLmNzICsgcHJzW19pM10ucHI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJhbmRvbWl6ZVxuXHRcdFx0dmFyIHJuZCA9IE1hdGgucmFuZG9tKCk7XG5cblx0XHRcdC8vIEdldHMgb25seSB0aGUgaXRlbXMgd2hvc2UgY3Vtc3VtID49IHJuZFxuXHRcdFx0dmFyIGlkeCA9IDA7XG5cdFx0XHR3aGlsZSAoaWR4IDwgbGVuIC0gMSAmJiBwcnNbaWR4KytdLmNzIDwgcm5kKSB7fVxuXHRcdFx0a3MucHVzaChwcnNbaWR4IC0gMV0udik7XG5cdFx0XHQvKlxuICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgIHdoaWxlKCFkb25lKSB7XG4gICBcdC8vIHRoaXMgaXMgb3VyIG5ldyBjZW50cm9pZFxuICAgXHRjID0gcHJzW2lkeC0xXS52XG4gICBcdGtleSA9IG11bHRpPyBjLmpvaW4oXCJfXCIpIDogYCR7Y31gO1xuICAgXHRpZighbWFwW2tleV0pIHtcbiAgIFx0XHRtYXBba2V5XSA9IHRydWU7XG4gICBcdFx0a3MucHVzaChjKTtcbiAgIFx0XHRkb25lID0gdHJ1ZTtcbiAgIFx0fVxuICAgXHRlbHNlIHtcbiAgIFx0XHRpZHgrKztcbiAgIFx0fVxuICAgfVxuICAgKi9cblx0XHR9XG5cblx0XHRyZXR1cm4ga3M7XG5cdH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1raW5pdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/skmeans/dist/node/kinit.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/skmeans/dist/node/main.js":
/*!************************************************!*\
  !*** ./node_modules/skmeans/dist/node/main.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*jshint esversion: 6 */\n\nvar Distance = __webpack_require__(/*! ./distance.js */ \"(ssr)/./node_modules/skmeans/dist/node/distance.js\"),\n    ClusterInit = __webpack_require__(/*! ./kinit.js */ \"(ssr)/./node_modules/skmeans/dist/node/kinit.js\"),\n    eudist = Distance.eudist,\n    mandist = Distance.mandist,\n    dist = Distance.dist,\n    kmrand = ClusterInit.kmrand,\n    kmpp = ClusterInit.kmpp;\n\nvar MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len, val, v) {\n\tv = v || [];\n\tfor (var i = 0; i < len; i++) {\n\t\tv[i] = val;\n\t}return v;\n}\n\nfunction skmeans(data, k, initial, maxit) {\n\tvar ks = [],\n\t    old = [],\n\t    idxs = [],\n\t    dist = [];\n\tvar conv = false,\n\t    it = maxit || MAX;\n\tvar len = data.length,\n\t    vlen = data[0].length,\n\t    multi = vlen > 0;\n\tvar count = [];\n\n\tif (!initial) {\n\t\tvar _idxs = {};\n\t\twhile (ks.length < k) {\n\t\t\tvar idx = Math.floor(Math.random() * len);\n\t\t\tif (!_idxs[idx]) {\n\t\t\t\t_idxs[idx] = true;\n\t\t\t\tks.push(data[idx]);\n\t\t\t}\n\t\t}\n\t} else if (initial == \"kmrand\") {\n\t\tks = kmrand(data, k);\n\t} else if (initial == \"kmpp\") {\n\t\tks = kmpp(data, k);\n\t} else {\n\t\tks = initial;\n\t}\n\n\tdo {\n\t\t// Reset k count\n\t\tinit(k, 0, count);\n\n\t\t// For each value in data, find the nearest centroid\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar min = Infinity,\n\t\t\t    _idx = 0;\n\t\t\tfor (var j = 0; j < k; j++) {\n\t\t\t\t// Multidimensional or unidimensional\n\t\t\t\tvar dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n\t\t\t\tif (dist <= min) {\n\t\t\t\t\tmin = dist;\n\t\t\t\t\t_idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidxs[i] = _idx; // Index of the selected centroid for that value\n\t\t\tcount[_idx]++; // Number of values for this centroid\n\t\t}\n\n\t\t// Recalculate centroids\n\t\tvar sum = [],\n\t\t    old = [],\n\t\t    dif = 0;\n\t\tfor (var _j = 0; _j < k; _j++) {\n\t\t\t// Multidimensional or unidimensional\n\t\t\tsum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n\t\t\told[_j] = ks[_j];\n\t\t}\n\n\t\t// If multidimensional\n\t\tif (multi) {\n\t\t\tfor (var _j2 = 0; _j2 < k; _j2++) {\n\t\t\t\tks[_j2] = [];\n\t\t\t} // Sum values and count for each centroid\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tvar _idx2 = idxs[_i],\n\t\t\t\t    // Centroid for that item\n\t\t\t\tvsum = sum[_idx2],\n\t\t\t\t    // Sum values for this centroid\n\t\t\t\tvect = data[_i]; // Current vector\n\n\t\t\t\t// Accumulate value on the centroid for current vector\n\t\t\t\tfor (var h = 0; h < vlen; h++) {\n\t\t\t\t\tvsum[h] += vect[h];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tconv = true;\n\t\t\tfor (var _j3 = 0; _j3 < k; _j3++) {\n\t\t\t\tvar ksj = ks[_j3],\n\t\t\t\t    // Current centroid\n\t\t\t\tsumj = sum[_j3],\n\t\t\t\t    // Accumulated centroid values\n\t\t\t\toldj = old[_j3],\n\t\t\t\t    // Old centroid value\n\t\t\t\tcj = count[_j3]; // Number of elements for this centroid\n\n\t\t\t\t// New average\n\t\t\t\tfor (var _h = 0; _h < vlen; _h++) {\n\t\t\t\t\tksj[_h] = sumj[_h] / cj || 0; // New centroid\n\t\t\t\t}\n\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tif (conv) {\n\t\t\t\t\tfor (var _h2 = 0; _h2 < vlen; _h2++) {\n\t\t\t\t\t\tif (oldj[_h2] != ksj[_h2]) {\n\t\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If unidimensional\n\t\telse {\n\t\t\t\t// Sum values and count for each centroid\n\t\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\t\tvar _idx3 = idxs[_i2];\n\t\t\t\t\tsum[_idx3] += data[_i2];\n\t\t\t\t}\n\t\t\t\t// Calculate the average for each centroid\n\t\t\t\tfor (var _j4 = 0; _j4 < k; _j4++) {\n\t\t\t\t\tks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n\t\t\t\t}\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tconv = true;\n\t\t\t\tfor (var _j5 = 0; _j5 < k; _j5++) {\n\t\t\t\t\tif (old[_j5] != ks[_j5]) {\n\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tconv = conv || --it <= 0;\n\t} while (!conv);\n\n\treturn {\n\t\tit: MAX - it,\n\t\tk: k,\n\t\tidxs: idxs,\n\t\tcentroids: ks\n\t};\n}\n\nmodule.exports = skmeans;\n//# sourceMappingURL=main.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUvbWFpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxlQUFlLG1CQUFPLENBQUMseUVBQWU7QUFDdEMsa0JBQWtCLG1CQUFPLENBQUMsbUVBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEMsbUNBQW1DO0FBQ25DOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvc2ttZWFucy9kaXN0L25vZGUvbWFpbi5qcz84OGRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKmpzaGludCBlc3ZlcnNpb246IDYgKi9cblxudmFyIERpc3RhbmNlID0gcmVxdWlyZShcIi4vZGlzdGFuY2UuanNcIiksXG4gICAgQ2x1c3RlckluaXQgPSByZXF1aXJlKFwiLi9raW5pdC5qc1wiKSxcbiAgICBldWRpc3QgPSBEaXN0YW5jZS5ldWRpc3QsXG4gICAgbWFuZGlzdCA9IERpc3RhbmNlLm1hbmRpc3QsXG4gICAgZGlzdCA9IERpc3RhbmNlLmRpc3QsXG4gICAga21yYW5kID0gQ2x1c3RlckluaXQua21yYW5kLFxuICAgIGttcHAgPSBDbHVzdGVySW5pdC5rbXBwO1xuXG52YXIgTUFYID0gMTAwMDA7XG5cbi8qKlxuICogSW5pdHMgYW4gYXJyYXkgd2l0aCB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gaW5pdChsZW4sIHZhbCwgdikge1xuXHR2ID0gdiB8fCBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdHZbaV0gPSB2YWw7XG5cdH1yZXR1cm4gdjtcbn1cblxuZnVuY3Rpb24gc2ttZWFucyhkYXRhLCBrLCBpbml0aWFsLCBtYXhpdCkge1xuXHR2YXIga3MgPSBbXSxcblx0ICAgIG9sZCA9IFtdLFxuXHQgICAgaWR4cyA9IFtdLFxuXHQgICAgZGlzdCA9IFtdO1xuXHR2YXIgY29udiA9IGZhbHNlLFxuXHQgICAgaXQgPSBtYXhpdCB8fCBNQVg7XG5cdHZhciBsZW4gPSBkYXRhLmxlbmd0aCxcblx0ICAgIHZsZW4gPSBkYXRhWzBdLmxlbmd0aCxcblx0ICAgIG11bHRpID0gdmxlbiA+IDA7XG5cdHZhciBjb3VudCA9IFtdO1xuXG5cdGlmICghaW5pdGlhbCkge1xuXHRcdHZhciBfaWR4cyA9IHt9O1xuXHRcdHdoaWxlIChrcy5sZW5ndGggPCBrKSB7XG5cdFx0XHR2YXIgaWR4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGVuKTtcblx0XHRcdGlmICghX2lkeHNbaWR4XSkge1xuXHRcdFx0XHRfaWR4c1tpZHhdID0gdHJ1ZTtcblx0XHRcdFx0a3MucHVzaChkYXRhW2lkeF0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmIChpbml0aWFsID09IFwia21yYW5kXCIpIHtcblx0XHRrcyA9IGttcmFuZChkYXRhLCBrKTtcblx0fSBlbHNlIGlmIChpbml0aWFsID09IFwia21wcFwiKSB7XG5cdFx0a3MgPSBrbXBwKGRhdGEsIGspO1xuXHR9IGVsc2Uge1xuXHRcdGtzID0gaW5pdGlhbDtcblx0fVxuXG5cdGRvIHtcblx0XHQvLyBSZXNldCBrIGNvdW50XG5cdFx0aW5pdChrLCAwLCBjb3VudCk7XG5cblx0XHQvLyBGb3IgZWFjaCB2YWx1ZSBpbiBkYXRhLCBmaW5kIHRoZSBuZWFyZXN0IGNlbnRyb2lkXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0dmFyIG1pbiA9IEluZmluaXR5LFxuXHRcdFx0ICAgIF9pZHggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBrOyBqKyspIHtcblx0XHRcdFx0Ly8gTXVsdGlkaW1lbnNpb25hbCBvciB1bmlkaW1lbnNpb25hbFxuXHRcdFx0XHR2YXIgZGlzdCA9IG11bHRpID8gZXVkaXN0KGRhdGFbaV0sIGtzW2pdKSA6IE1hdGguYWJzKGRhdGFbaV0gLSBrc1tqXSk7XG5cdFx0XHRcdGlmIChkaXN0IDw9IG1pbikge1xuXHRcdFx0XHRcdG1pbiA9IGRpc3Q7XG5cdFx0XHRcdFx0X2lkeCA9IGo7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlkeHNbaV0gPSBfaWR4OyAvLyBJbmRleCBvZiB0aGUgc2VsZWN0ZWQgY2VudHJvaWQgZm9yIHRoYXQgdmFsdWVcblx0XHRcdGNvdW50W19pZHhdKys7IC8vIE51bWJlciBvZiB2YWx1ZXMgZm9yIHRoaXMgY2VudHJvaWRcblx0XHR9XG5cblx0XHQvLyBSZWNhbGN1bGF0ZSBjZW50cm9pZHNcblx0XHR2YXIgc3VtID0gW10sXG5cdFx0ICAgIG9sZCA9IFtdLFxuXHRcdCAgICBkaWYgPSAwO1xuXHRcdGZvciAodmFyIF9qID0gMDsgX2ogPCBrOyBfaisrKSB7XG5cdFx0XHQvLyBNdWx0aWRpbWVuc2lvbmFsIG9yIHVuaWRpbWVuc2lvbmFsXG5cdFx0XHRzdW1bX2pdID0gbXVsdGkgPyBpbml0KHZsZW4sIDAsIHN1bVtfal0pIDogMDtcblx0XHRcdG9sZFtfal0gPSBrc1tfal07XG5cdFx0fVxuXG5cdFx0Ly8gSWYgbXVsdGlkaW1lbnNpb25hbFxuXHRcdGlmIChtdWx0aSkge1xuXHRcdFx0Zm9yICh2YXIgX2oyID0gMDsgX2oyIDwgazsgX2oyKyspIHtcblx0XHRcdFx0a3NbX2oyXSA9IFtdO1xuXHRcdFx0fSAvLyBTdW0gdmFsdWVzIGFuZCBjb3VudCBmb3IgZWFjaCBjZW50cm9pZFxuXHRcdFx0Zm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbjsgX2krKykge1xuXHRcdFx0XHR2YXIgX2lkeDIgPSBpZHhzW19pXSxcblx0XHRcdFx0ICAgIC8vIENlbnRyb2lkIGZvciB0aGF0IGl0ZW1cblx0XHRcdFx0dnN1bSA9IHN1bVtfaWR4Ml0sXG5cdFx0XHRcdCAgICAvLyBTdW0gdmFsdWVzIGZvciB0aGlzIGNlbnRyb2lkXG5cdFx0XHRcdHZlY3QgPSBkYXRhW19pXTsgLy8gQ3VycmVudCB2ZWN0b3JcblxuXHRcdFx0XHQvLyBBY2N1bXVsYXRlIHZhbHVlIG9uIHRoZSBjZW50cm9pZCBmb3IgY3VycmVudCB2ZWN0b3Jcblx0XHRcdFx0Zm9yICh2YXIgaCA9IDA7IGggPCB2bGVuOyBoKyspIHtcblx0XHRcdFx0XHR2c3VtW2hdICs9IHZlY3RbaF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIENhbGN1bGF0ZSB0aGUgYXZlcmFnZSBmb3IgZWFjaCBjZW50cm9pZFxuXHRcdFx0Y29udiA9IHRydWU7XG5cdFx0XHRmb3IgKHZhciBfajMgPSAwOyBfajMgPCBrOyBfajMrKykge1xuXHRcdFx0XHR2YXIga3NqID0ga3NbX2ozXSxcblx0XHRcdFx0ICAgIC8vIEN1cnJlbnQgY2VudHJvaWRcblx0XHRcdFx0c3VtaiA9IHN1bVtfajNdLFxuXHRcdFx0XHQgICAgLy8gQWNjdW11bGF0ZWQgY2VudHJvaWQgdmFsdWVzXG5cdFx0XHRcdG9sZGogPSBvbGRbX2ozXSxcblx0XHRcdFx0ICAgIC8vIE9sZCBjZW50cm9pZCB2YWx1ZVxuXHRcdFx0XHRjaiA9IGNvdW50W19qM107IC8vIE51bWJlciBvZiBlbGVtZW50cyBmb3IgdGhpcyBjZW50cm9pZFxuXG5cdFx0XHRcdC8vIE5ldyBhdmVyYWdlXG5cdFx0XHRcdGZvciAodmFyIF9oID0gMDsgX2ggPCB2bGVuOyBfaCsrKSB7XG5cdFx0XHRcdFx0a3NqW19oXSA9IHN1bWpbX2hdIC8gY2ogfHwgMDsgLy8gTmV3IGNlbnRyb2lkXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGaW5kIGlmIGNlbnRyb2lkcyBoYXZlIG1vdmVkXG5cdFx0XHRcdGlmIChjb252KSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgX2gyID0gMDsgX2gyIDwgdmxlbjsgX2gyKyspIHtcblx0XHRcdFx0XHRcdGlmIChvbGRqW19oMl0gIT0ga3NqW19oMl0pIHtcblx0XHRcdFx0XHRcdFx0Y29udiA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gSWYgdW5pZGltZW5zaW9uYWxcblx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gU3VtIHZhbHVlcyBhbmQgY291bnQgZm9yIGVhY2ggY2VudHJvaWRcblx0XHRcdFx0Zm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGVuOyBfaTIrKykge1xuXHRcdFx0XHRcdHZhciBfaWR4MyA9IGlkeHNbX2kyXTtcblx0XHRcdFx0XHRzdW1bX2lkeDNdICs9IGRhdGFbX2kyXTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDYWxjdWxhdGUgdGhlIGF2ZXJhZ2UgZm9yIGVhY2ggY2VudHJvaWRcblx0XHRcdFx0Zm9yICh2YXIgX2o0ID0gMDsgX2o0IDwgazsgX2o0KyspIHtcblx0XHRcdFx0XHRrc1tfajRdID0gc3VtW19qNF0gLyBjb3VudFtfajRdIHx8IDA7IC8vIE5ldyBjZW50cm9pZFxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEZpbmQgaWYgY2VudHJvaWRzIGhhdmUgbW92ZWRcblx0XHRcdFx0Y29udiA9IHRydWU7XG5cdFx0XHRcdGZvciAodmFyIF9qNSA9IDA7IF9qNSA8IGs7IF9qNSsrKSB7XG5cdFx0XHRcdFx0aWYgKG9sZFtfajVdICE9IGtzW19qNV0pIHtcblx0XHRcdFx0XHRcdGNvbnYgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Y29udiA9IGNvbnYgfHwgLS1pdCA8PSAwO1xuXHR9IHdoaWxlICghY29udik7XG5cblx0cmV0dXJuIHtcblx0XHRpdDogTUFYIC0gaXQsXG5cdFx0azogayxcblx0XHRpZHhzOiBpZHhzLFxuXHRcdGNlbnRyb2lkczoga3Ncblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBza21lYW5zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/skmeans/dist/node/main.js\n");

/***/ })

};
;