"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/splaytree";
exports.ids = ["vendor-chunks/splaytree"];
exports.modules = {

/***/ "(ssr)/./node_modules/splaytree/dist/splay.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/splaytree/dist/splay.esm.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * splaytree v3.1.2\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    return Node;\r\n}());\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    var N = new Node(null, null);\r\n    var l = N;\r\n    var r = N;\r\n    while (true) {\r\n        var cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                var y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                var y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    var node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    var cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    var left = null;\r\n    var right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        var cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\r\n        var indent = prefix + (isTail ? '    ' : '│   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nvar Tree = /** @class */ (function () {\r\n    function Tree(comparator) {\r\n        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    Tree.prototype.insert = function (key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    Tree.prototype.add = function (key, data) {\r\n        var node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        var comparator = this._comparator;\r\n        var t = splay(key, this._root, comparator);\r\n        var cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    };\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    Tree.prototype.remove = function (key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    Tree.prototype._remove = function (i, t, comparator) {\r\n        var x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    };\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    Tree.prototype.pop = function () {\r\n        var node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    Tree.prototype.findStatic = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.find = function (key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    };\r\n    Tree.prototype.contains = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    };\r\n    Tree.prototype.forEach = function (visitor, ctx) {\r\n        var current = this._root;\r\n        var Q = []; /* Initialize stack s */\r\n        var done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    Tree.prototype.range = function (low, high, fn, ctx) {\r\n        var Q = [];\r\n        var compare = this._comparator;\r\n        var node = this._root;\r\n        var cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    Tree.prototype.keys = function () {\r\n        var keys = [];\r\n        this.forEach(function (_a) {\r\n            var key = _a.key;\r\n            return keys.push(key);\r\n        });\r\n        return keys;\r\n    };\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    Tree.prototype.values = function () {\r\n        var values = [];\r\n        this.forEach(function (_a) {\r\n            var data = _a.data;\r\n            return values.push(data);\r\n        });\r\n        return values;\r\n    };\r\n    Tree.prototype.min = function () {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.max = function () {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.minNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    };\r\n    Tree.prototype.maxNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    };\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    Tree.prototype.at = function (index) {\r\n        var current = this._root;\r\n        var done = false;\r\n        var i = 0;\r\n        var Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.next = function (d) {\r\n        var root = this._root;\r\n        var successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    };\r\n    Tree.prototype.prev = function (d) {\r\n        var root = this._root;\r\n        var predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    };\r\n    Tree.prototype.clear = function () {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    };\r\n    Tree.prototype.toList = function () {\r\n        return toList(this._root);\r\n    };\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    Tree.prototype.load = function (keys, values, presort) {\r\n        if (values === void 0) { values = []; }\r\n        if (presort === void 0) { presort = false; }\r\n        var size = keys.length;\r\n        var comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    };\r\n    Tree.prototype.isEmpty = function () { return this._root === null; };\r\n    Object.defineProperty(Tree.prototype, \"size\", {\r\n        get: function () { return this._size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"root\", {\r\n        get: function () { return this._root; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.toString = function (printNode) {\r\n        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n        var out = [];\r\n        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n        return out.join('');\r\n    };\r\n    Tree.prototype.update = function (key, newKey, newData) {\r\n        var comparator = this._comparator;\r\n        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    };\r\n    Tree.prototype.split = function (key) {\r\n        return split(key, this._root, this._comparator);\r\n    };\r\n    Tree.prototype[Symbol.iterator] = function () {\r\n        var current, Q, done;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    current = this._root;\r\n                    Q = [];\r\n                    done = false;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!!done) return [3 /*break*/, 6];\r\n                    if (!(current !== null)) return [3 /*break*/, 2];\r\n                    Q.push(current);\r\n                    current = current.left;\r\n                    return [3 /*break*/, 5];\r\n                case 2:\r\n                    if (!(Q.length !== 0)) return [3 /*break*/, 4];\r\n                    current = Q.pop();\r\n                    return [4 /*yield*/, current];\r\n                case 3:\r\n                    _a.sent();\r\n                    current = current.right;\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    done = true;\r\n                    _a.label = 5;\r\n                case 5: return [3 /*break*/, 1];\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tree;\r\n}());\r\nfunction loadRecursive(keys, values, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var key = keys[middle];\r\n        var data = values[middle];\r\n        var node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    for (var i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    var current = root;\r\n    var Q = [];\r\n    var done = false;\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var left = sortedListToBST(list, start, middle);\r\n        var root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    var head = new Node(null, null); // dummy\r\n    var p = head;\r\n    var p1 = l1;\r\n    var p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    var pivot = keys[(left + right) >> 1];\r\n    var i = left - 1;\r\n    var j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        var tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tree);\n//# sourceMappingURL=splay.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3BsYXl0cmVlL2Rpc3Qvc3BsYXkuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxJQUFJLEVBQUM7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9zcGxheXRyZWUvZGlzdC9zcGxheS5lc20uanM/MTE5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHNwbGF5dHJlZSB2My4xLjJcbiAqIEZhc3QgU3BsYXkgdHJlZSBmb3IgTm9kZSBhbmQgYnJvd3NlclxuICpcbiAqIEBhdXRob3IgQWxleGFuZGVyIE1pbGV2c2tpIDxpbmZvQHc4ci5uYW1lPlxuICogQGxpY2Vuc2UgTUlUXG4gKiBAcHJlc2VydmVcbiAqL1xuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cblxudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlKGtleSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5vZGU7XHJcbn0oKSk7XG5cbi8qIGZvbGxvd3MgXCJBbiBpbXBsZW1lbnRhdGlvbiBvZiB0b3AtZG93biBzcGxheWluZ1wiXHJcbiAqIGJ5IEQuIFNsZWF0b3IgPHNsZWF0b3JAY3MuY211LmVkdT4gTWFyY2ggMTk5MlxyXG4gKi9cclxuZnVuY3Rpb24gREVGQVVMVF9DT01QQVJFKGEsIGIpIHtcclxuICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcclxufVxyXG4vKipcclxuICogU2ltcGxlIHRvcCBkb3duIHNwbGF5LCBub3QgcmVxdWlyaW5nIGkgdG8gYmUgaW4gdGhlIHRyZWUgdC5cclxuICovXHJcbmZ1bmN0aW9uIHNwbGF5KGksIHQsIGNvbXBhcmF0b3IpIHtcclxuICAgIHZhciBOID0gbmV3IE5vZGUobnVsbCwgbnVsbCk7XHJcbiAgICB2YXIgbCA9IE47XHJcbiAgICB2YXIgciA9IE47XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcclxuICAgICAgICAvL2lmIChpIDwgdC5rZXkpIHtcclxuICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAodC5sZWZ0ID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8vaWYgKGkgPCB0LmxlZnQua2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGksIHQubGVmdC5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0LmxlZnQ7IC8qIHJvdGF0ZSByaWdodCAqL1xyXG4gICAgICAgICAgICAgICAgdC5sZWZ0ID0geS5yaWdodDtcclxuICAgICAgICAgICAgICAgIHkucmlnaHQgPSB0O1xyXG4gICAgICAgICAgICAgICAgdCA9IHk7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5sZWZ0ID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHIubGVmdCA9IHQ7IC8qIGxpbmsgcmlnaHQgKi9cclxuICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgIHQgPSB0LmxlZnQ7XHJcbiAgICAgICAgICAgIC8vfSBlbHNlIGlmIChpID4gdC5rZXkpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICBpZiAodC5yaWdodCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvL2lmIChpID4gdC5yaWdodC5rZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IoaSwgdC5yaWdodC5rZXkpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHkgPSB0LnJpZ2h0OyAvKiByb3RhdGUgbGVmdCAqL1xyXG4gICAgICAgICAgICAgICAgdC5yaWdodCA9IHkubGVmdDtcclxuICAgICAgICAgICAgICAgIHkubGVmdCA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0ID0geTtcclxuICAgICAgICAgICAgICAgIGlmICh0LnJpZ2h0ID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGwucmlnaHQgPSB0OyAvKiBsaW5rIGxlZnQgKi9cclxuICAgICAgICAgICAgbCA9IHQ7XHJcbiAgICAgICAgICAgIHQgPSB0LnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgLyogYXNzZW1ibGUgKi9cclxuICAgIGwucmlnaHQgPSB0LmxlZnQ7XHJcbiAgICByLmxlZnQgPSB0LnJpZ2h0O1xyXG4gICAgdC5sZWZ0ID0gTi5yaWdodDtcclxuICAgIHQucmlnaHQgPSBOLmxlZnQ7XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5mdW5jdGlvbiBpbnNlcnQoaSwgZGF0YSwgdCwgY29tcGFyYXRvcikge1xyXG4gICAgdmFyIG5vZGUgPSBuZXcgTm9kZShpLCBkYXRhKTtcclxuICAgIGlmICh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgbm9kZS5sZWZ0ID0gbm9kZS5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XHJcbiAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XHJcbiAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgIG5vZGUubGVmdCA9IHQubGVmdDtcclxuICAgICAgICBub2RlLnJpZ2h0ID0gdDtcclxuICAgICAgICB0LmxlZnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY21wID49IDApIHtcclxuICAgICAgICBub2RlLnJpZ2h0ID0gdC5yaWdodDtcclxuICAgICAgICBub2RlLmxlZnQgPSB0O1xyXG4gICAgICAgIHQucmlnaHQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn1cclxuZnVuY3Rpb24gc3BsaXQoa2V5LCB2LCBjb21wYXJhdG9yKSB7XHJcbiAgICB2YXIgbGVmdCA9IG51bGw7XHJcbiAgICB2YXIgcmlnaHQgPSBudWxsO1xyXG4gICAgaWYgKHYpIHtcclxuICAgICAgICB2ID0gc3BsYXkoa2V5LCB2LCBjb21wYXJhdG9yKTtcclxuICAgICAgICB2YXIgY21wID0gY29tcGFyYXRvcih2LmtleSwga2V5KTtcclxuICAgICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSB2LmxlZnQ7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gdi5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICByaWdodCA9IHYucmlnaHQ7XHJcbiAgICAgICAgICAgIHYucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICBsZWZ0ID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSB2LmxlZnQ7XHJcbiAgICAgICAgICAgIHYubGVmdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gdjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZShsZWZ0LCByaWdodCwgY29tcGFyYXRvcikge1xyXG4gICAgaWYgKHJpZ2h0ID09PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgaWYgKGxlZnQgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgcmlnaHQgPSBzcGxheShsZWZ0LmtleSwgcmlnaHQsIGNvbXBhcmF0b3IpO1xyXG4gICAgcmlnaHQubGVmdCA9IGxlZnQ7XHJcbiAgICByZXR1cm4gcmlnaHQ7XHJcbn1cclxuLyoqXHJcbiAqIFByaW50cyBsZXZlbCBvZiB0aGUgdHJlZVxyXG4gKi9cclxuZnVuY3Rpb24gcHJpbnRSb3cocm9vdCwgcHJlZml4LCBpc1RhaWwsIG91dCwgcHJpbnROb2RlKSB7XHJcbiAgICBpZiAocm9vdCkge1xyXG4gICAgICAgIG91dChcIlwiICsgcHJlZml4ICsgKGlzVGFpbCA/ICfilJTilIDilIAgJyA6ICfilJzilIDilIAgJykgKyBwcmludE5vZGUocm9vdCkgKyBcIlxcblwiKTtcclxuICAgICAgICB2YXIgaW5kZW50ID0gcHJlZml4ICsgKGlzVGFpbCA/ICcgICAgJyA6ICfilIIgICAnKTtcclxuICAgICAgICBpZiAocm9vdC5sZWZ0KVxyXG4gICAgICAgICAgICBwcmludFJvdyhyb290LmxlZnQsIGluZGVudCwgZmFsc2UsIG91dCwgcHJpbnROb2RlKTtcclxuICAgICAgICBpZiAocm9vdC5yaWdodClcclxuICAgICAgICAgICAgcHJpbnRSb3cocm9vdC5yaWdodCwgaW5kZW50LCB0cnVlLCBvdXQsIHByaW50Tm9kZSk7XHJcbiAgICB9XHJcbn1cclxudmFyIFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUcmVlKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICBpZiAoY29tcGFyYXRvciA9PT0gdm9pZCAwKSB7IGNvbXBhcmF0b3IgPSBERUZBVUxUX0NPTVBBUkU7IH1cclxuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zaXplID0gMDtcclxuICAgICAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBhIGtleSwgYWxsb3dzIGR1cGxpY2F0ZXNcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX3NpemUrKztcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA9IGluc2VydChrZXksIGRhdGEsIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGtleSwgaWYgaXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIHRyZWVcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGtleSwgZGF0YSkge1xyXG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoa2V5LCBkYXRhKTtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBub2RlLmxlZnQgPSBub2RlLnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIHZhciB0ID0gc3BsYXkoa2V5LCB0aGlzLl9yb290LCBjb21wYXJhdG9yKTtcclxuICAgICAgICB2YXIgY21wID0gY29tcGFyYXRvcihrZXksIHQua2V5KTtcclxuICAgICAgICBpZiAoY21wID09PSAwKVxyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IHQubGVmdDtcclxuICAgICAgICAgICAgICAgIG5vZGUucmlnaHQgPSB0O1xyXG4gICAgICAgICAgICAgICAgdC5sZWZ0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gdC5yaWdodDtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0LnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zaXplKys7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSAge0tleX0ga2V5XHJcbiAgICAgKiBAcmV0dXJuIHtOb2RlfG51bGx9XHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fcmVtb3ZlKGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIGkgZnJvbSB0aGUgdHJlZSBpZiBpdCdzIHRoZXJlXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAoaSwgdCwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHZhciB4O1xyXG4gICAgICAgIGlmICh0ID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB0ID0gc3BsYXkoaSwgdCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xyXG4gICAgICAgIGlmIChjbXAgPT09IDApIHsgLyogZm91bmQgaXQgKi9cclxuICAgICAgICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgeCA9IHQucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gc3BsYXkoaSwgdC5sZWZ0LCBjb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgIHgucmlnaHQgPSB0LnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0OyAvKiBJdCB3YXNuJ3QgdGhlcmUgKi9cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIG5vZGUgd2l0aCBzbWFsbGVzdCBrZXlcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICB3aGlsZSAobm9kZS5sZWZ0KVxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHNwbGF5KG5vZGUua2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3JlbW92ZShub2RlLmtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIGRhdGE6IG5vZGUuZGF0YSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgd2l0aG91dCBzcGxheWluZ1xyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5maW5kU3RhdGljID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmUoa2V5LCBjdXJyZW50LmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMClcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBzcGxheShrZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGFyYXRvcihrZXksIHRoaXMuX3Jvb3Qua2V5KSAhPT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJlKGtleSwgY3VycmVudC5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAodmlzaXRvciwgY3R4KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBRID0gW107IC8qIEluaXRpYWxpemUgc3RhY2sgcyAqL1xyXG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBRLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKFEubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlzaXRvci5jYWxsKGN0eCwgY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWxrIGtleSByYW5nZSBmcm9tIGBsb3dgIHRvIGBoaWdoYC4gU3RvcHMgaWYgYGZuYCByZXR1cm5zIGEgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLnJhbmdlID0gZnVuY3Rpb24gKGxvdywgaGlnaCwgZm4sIGN0eCkge1xyXG4gICAgICAgIHZhciBRID0gW107XHJcbiAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgY21wO1xyXG4gICAgICAgIHdoaWxlIChRLmxlbmd0aCAhPT0gMCB8fCBub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBRLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKG5vZGUua2V5LCBoaWdoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wYXJlKG5vZGUua2V5LCBsb3cpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm4uY2FsbChjdHgsIG5vZGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gc3RvcCBpZiBzbXRoIGlzIHJldHVybmVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYXJyYXkgb2Yga2V5c1xyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gX2Eua2V5O1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFycmF5IG9mIGFsbCB0aGUgZGF0YSBpbiB0aGUgbm9kZXNcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gX2EuZGF0YTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290KVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5Ob2RlKHRoaXMuX3Jvb3QpLmtleTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1heE5vZGUodGhpcy5fcm9vdCkua2V5O1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLm1pbk5vZGUgPSBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGlmICh0ID09PSB2b2lkIDApIHsgdCA9IHRoaXMuX3Jvb3Q7IH1cclxuICAgICAgICBpZiAodClcclxuICAgICAgICAgICAgd2hpbGUgKHQubGVmdClcclxuICAgICAgICAgICAgICAgIHQgPSB0LmxlZnQ7XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUubWF4Tm9kZSA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgaWYgKHQgPT09IHZvaWQgMCkgeyB0ID0gdGhpcy5fcm9vdDsgfVxyXG4gICAgICAgIGlmICh0KVxyXG4gICAgICAgICAgICB3aGlsZSAodC5yaWdodClcclxuICAgICAgICAgICAgICAgIHQgPSB0LnJpZ2h0O1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBub2RlIGF0IGdpdmVuIGluZGV4XHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBRID0gW107XHJcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBRLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKFEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBpbmRleClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgc3VjY2Vzc29yID0gbnVsbDtcclxuICAgICAgICBpZiAoZC5yaWdodCkge1xyXG4gICAgICAgICAgICBzdWNjZXNzb3IgPSBkLnJpZ2h0O1xyXG4gICAgICAgICAgICB3aGlsZSAoc3VjY2Vzc29yLmxlZnQpXHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzb3IgPSBzdWNjZXNzb3IubGVmdDtcclxuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3NvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIHdoaWxlIChyb290KSB7XHJcbiAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGQua2V5LCByb290LmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc29yID0gcm9vdDtcclxuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWNjZXNzb3I7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBwcmVkZWNlc3NvciA9IG51bGw7XHJcbiAgICAgICAgaWYgKGQubGVmdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwcmVkZWNlc3NvciA9IGQubGVmdDtcclxuICAgICAgICAgICAgd2hpbGUgKHByZWRlY2Vzc29yLnJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgcHJlZGVjZXNzb3IgPSBwcmVkZWNlc3Nvci5yaWdodDtcclxuICAgICAgICAgICAgcmV0dXJuIHByZWRlY2Vzc29yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgd2hpbGUgKHJvb3QpIHtcclxuICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoZC5rZXksIHJvb3Qua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKVxyXG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QubGVmdDtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcmVkZWNlc3NvciA9IHJvb3Q7XHJcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJlZGVjZXNzb3I7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUudG9MaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0b0xpc3QodGhpcy5fcm9vdCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBCdWxrLWxvYWQgaXRlbXMuIEJvdGggYXJyYXkgaGF2ZSB0byBiZSBzYW1lIHNpemVcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChrZXlzLCB2YWx1ZXMsIHByZXNvcnQpIHtcclxuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gW107IH1cclxuICAgICAgICBpZiAocHJlc29ydCA9PT0gdm9pZCAwKSB7IHByZXNvcnQgPSBmYWxzZTsgfVxyXG4gICAgICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIC8vIHNvcnQgaWYgbmVlZGVkXHJcbiAgICAgICAgaWYgKHByZXNvcnQpXHJcbiAgICAgICAgICAgIHNvcnQoa2V5cywgdmFsdWVzLCAwLCBzaXplIC0gMSwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT09IG51bGwpIHsgLy8gZW1wdHkgdHJlZVxyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gbG9hZFJlY3Vyc2l2ZShrZXlzLCB2YWx1ZXMsIDAsIHNpemUpO1xyXG4gICAgICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIHRoYXQgcmUtYnVpbGRzIHRoZSB3aG9sZSB0cmVlIGZyb20gdHdvIGluLW9yZGVyIHRyYXZlcnNhbHNcclxuICAgICAgICAgICAgdmFyIG1lcmdlZExpc3QgPSBtZXJnZUxpc3RzKHRoaXMudG9MaXN0KCksIGNyZWF0ZUxpc3Qoa2V5cywgdmFsdWVzKSwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLl9zaXplICsgc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHNvcnRlZExpc3RUb0JTVCh7IGhlYWQ6IG1lcmdlZExpc3QgfSwgMCwgc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb290ID09PSBudWxsOyB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWUucHJvdG90eXBlLCBcInNpemVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2l6ZTsgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZS5wcm90b3R5cGUsIFwicm9vdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9yb290OyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFRyZWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHByaW50Tm9kZSkge1xyXG4gICAgICAgIGlmIChwcmludE5vZGUgPT09IHZvaWQgMCkgeyBwcmludE5vZGUgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gU3RyaW5nKG4ua2V5KTsgfTsgfVxyXG4gICAgICAgIHZhciBvdXQgPSBbXTtcclxuICAgICAgICBwcmludFJvdyh0aGlzLl9yb290LCAnJywgdHJ1ZSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG91dC5wdXNoKHYpOyB9LCBwcmludE5vZGUpO1xyXG4gICAgICAgIHJldHVybiBvdXQuam9pbignJyk7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbmV3S2V5LCBuZXdEYXRhKSB7XHJcbiAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIHZhciBfYSA9IHNwbGl0KGtleSwgdGhpcy5fcm9vdCwgY29tcGFyYXRvciksIGxlZnQgPSBfYS5sZWZ0LCByaWdodCA9IF9hLnJpZ2h0O1xyXG4gICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbmV3S2V5KSA8IDApIHtcclxuICAgICAgICAgICAgcmlnaHQgPSBpbnNlcnQobmV3S2V5LCBuZXdEYXRhLCByaWdodCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0ID0gaW5zZXJ0KG5ld0tleSwgbmV3RGF0YSwgbGVmdCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBtZXJnZShsZWZ0LCByaWdodCwgY29tcGFyYXRvcik7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHNwbGl0KGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VycmVudCwgUSwgZG9uZTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICAgICAgICAgICAgICBRID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISFkb25lKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShjdXJyZW50ICE9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoUS5sZW5ndGggIT09IDApKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjdXJyZW50XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRyZWU7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGxvYWRSZWN1cnNpdmUoa2V5cywgdmFsdWVzLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICAgICAgdmFyIG1pZGRsZSA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzaXplIC8gMik7XHJcbiAgICAgICAgdmFyIGtleSA9IGtleXNbbWlkZGxlXTtcclxuICAgICAgICB2YXIgZGF0YSA9IHZhbHVlc1ttaWRkbGVdO1xyXG4gICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoa2V5LCBkYXRhKTtcclxuICAgICAgICBub2RlLmxlZnQgPSBsb2FkUmVjdXJzaXZlKGtleXMsIHZhbHVlcywgc3RhcnQsIG1pZGRsZSk7XHJcbiAgICAgICAgbm9kZS5yaWdodCA9IGxvYWRSZWN1cnNpdmUoa2V5cywgdmFsdWVzLCBtaWRkbGUgKyAxLCBlbmQpO1xyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlTGlzdChrZXlzLCB2YWx1ZXMpIHtcclxuICAgIHZhciBoZWFkID0gbmV3IE5vZGUobnVsbCwgbnVsbCk7XHJcbiAgICB2YXIgcCA9IGhlYWQ7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwID0gcC5uZXh0ID0gbmV3IE5vZGUoa2V5c1tpXSwgdmFsdWVzW2ldKTtcclxuICAgIH1cclxuICAgIHAubmV4dCA9IG51bGw7XHJcbiAgICByZXR1cm4gaGVhZC5uZXh0O1xyXG59XHJcbmZ1bmN0aW9uIHRvTGlzdChyb290KSB7XHJcbiAgICB2YXIgY3VycmVudCA9IHJvb3Q7XHJcbiAgICB2YXIgUSA9IFtdO1xyXG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgIHZhciBoZWFkID0gbmV3IE5vZGUobnVsbCwgbnVsbCk7XHJcbiAgICB2YXIgcCA9IGhlYWQ7XHJcbiAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICBRLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoUS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gcCA9IHAubmV4dCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwLm5leHQgPSBudWxsOyAvLyB0aGF0J2xsIHdvcmsgZXZlbiBpZiB0aGUgdHJlZSB3YXMgZW1wdHlcclxuICAgIHJldHVybiBoZWFkLm5leHQ7XHJcbn1cclxuZnVuY3Rpb24gc29ydGVkTGlzdFRvQlNUKGxpc3QsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBzaXplID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAoc2l6ZSA+IDApIHtcclxuICAgICAgICB2YXIgbWlkZGxlID0gc3RhcnQgKyBNYXRoLmZsb29yKHNpemUgLyAyKTtcclxuICAgICAgICB2YXIgbGVmdCA9IHNvcnRlZExpc3RUb0JTVChsaXN0LCBzdGFydCwgbWlkZGxlKTtcclxuICAgICAgICB2YXIgcm9vdCA9IGxpc3QuaGVhZDtcclxuICAgICAgICByb290LmxlZnQgPSBsZWZ0O1xyXG4gICAgICAgIGxpc3QuaGVhZCA9IGxpc3QuaGVhZC5uZXh0O1xyXG4gICAgICAgIHJvb3QucmlnaHQgPSBzb3J0ZWRMaXN0VG9CU1QobGlzdCwgbWlkZGxlICsgMSwgZW5kKTtcclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlTGlzdHMobDEsIGwyLCBjb21wYXJlKSB7XHJcbiAgICB2YXIgaGVhZCA9IG5ldyBOb2RlKG51bGwsIG51bGwpOyAvLyBkdW1teVxyXG4gICAgdmFyIHAgPSBoZWFkO1xyXG4gICAgdmFyIHAxID0gbDE7XHJcbiAgICB2YXIgcDIgPSBsMjtcclxuICAgIHdoaWxlIChwMSAhPT0gbnVsbCAmJiBwMiAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChjb21wYXJlKHAxLmtleSwgcDIua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgcC5uZXh0ID0gcDE7XHJcbiAgICAgICAgICAgIHAxID0gcDEubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHAubmV4dCA9IHAyO1xyXG4gICAgICAgICAgICBwMiA9IHAyLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICB9XHJcbiAgICBpZiAocDEgIT09IG51bGwpIHtcclxuICAgICAgICBwLm5leHQgPSBwMTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHAyICE9PSBudWxsKSB7XHJcbiAgICAgICAgcC5uZXh0ID0gcDI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGVhZC5uZXh0O1xyXG59XHJcbmZ1bmN0aW9uIHNvcnQoa2V5cywgdmFsdWVzLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xyXG4gICAgaWYgKGxlZnQgPj0gcmlnaHQpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHBpdm90ID0ga2V5c1sobGVmdCArIHJpZ2h0KSA+PiAxXTtcclxuICAgIHZhciBpID0gbGVmdCAtIDE7XHJcbiAgICB2YXIgaiA9IHJpZ2h0ICsgMTtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgZG9cclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIHdoaWxlIChjb21wYXJlKGtleXNbaV0sIHBpdm90KSA8IDApO1xyXG4gICAgICAgIGRvXHJcbiAgICAgICAgICAgIGotLTtcclxuICAgICAgICB3aGlsZSAoY29tcGFyZShrZXlzW2pdLCBwaXZvdCkgPiAwKTtcclxuICAgICAgICBpZiAoaSA+PSBqKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB2YXIgdG1wID0ga2V5c1tpXTtcclxuICAgICAgICBrZXlzW2ldID0ga2V5c1tqXTtcclxuICAgICAgICBrZXlzW2pdID0gdG1wO1xyXG4gICAgICAgIHRtcCA9IHZhbHVlc1tpXTtcclxuICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbal07XHJcbiAgICAgICAgdmFsdWVzW2pdID0gdG1wO1xyXG4gICAgfVxyXG4gICAgc29ydChrZXlzLCB2YWx1ZXMsIGxlZnQsIGosIGNvbXBhcmUpO1xyXG4gICAgc29ydChrZXlzLCB2YWx1ZXMsIGogKyAxLCByaWdodCwgY29tcGFyZSk7XHJcbn1cblxuZXhwb3J0IGRlZmF1bHQgVHJlZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNwbGF5LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/splaytree/dist/splay.esm.js\n");

/***/ })

};
;