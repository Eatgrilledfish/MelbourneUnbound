/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/geojson-equality";
exports.ids = ["vendor-chunks/geojson-equality"];
exports.modules = {

/***/ "(ssr)/./node_modules/geojson-equality/index.js":
/*!************************************************!*\
  !*** ./node_modules/geojson-equality/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("//index.js\nvar deepEqual = __webpack_require__(/*! deep-equal */ \"(ssr)/./node_modules/deep-equal/index.js\");\n\nvar Equality = function(opt) {\n  this.precision = opt && opt.precision ? opt.precision : 17;\n  this.direction = opt && opt.direction ? opt.direction : false;\n  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;\n  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;\n};\n\nEquality.prototype.compare = function(g1,g2) {\n  if (g1.type !== g2.type || !sameLength(g1,g2)) return false;\n\n  switch(g1.type) {\n  case 'Point':\n    return this.compareCoord(g1.coordinates, g2.coordinates);\n    break;\n  case 'LineString':\n    return this.compareLine(g1.coordinates, g2.coordinates,0,false);\n    break;\n  case 'Polygon':\n    return this.comparePolygon(g1,g2);\n    break;\n  case 'Feature':\n    return this.compareFeature(g1, g2);\n  default:\n    if (g1.type.indexOf('Multi') === 0) {\n      var context = this;\n      var g1s = explode(g1);\n      var g2s = explode(g2);\n      return g1s.every(function(g1part) {\n        return this.some(function(g2part) {\n          return context.compare(g1part,g2part);\n        });\n      },g2s);\n    }\n  }\n  return false;\n};\n\nfunction explode(g) {\n  return g.coordinates.map(function(part) {\n    return {\n      type: g.type.replace('Multi', ''),\n      coordinates: part}\n  });\n}\n//compare length of coordinates/array\nfunction sameLength(g1,g2) {\n   return g1.hasOwnProperty('coordinates') ?\n    g1.coordinates.length === g2.coordinates.length\n    : g1.length === g2.length;\n}\n\n// compare the two coordinates [x,y]\nEquality.prototype.compareCoord = function(c1,c2) {\n  if (c1.length !== c2.length) {\n    return false;\n  }\n\n  for (var i=0; i < c1.length; i++) {\n    if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nEquality.prototype.compareLine = function(path1,path2,ind,isPoly) {\n  if (!sameLength(path1,path2)) return false;\n  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);\n  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);\n  if (isPoly && !this.compareCoord(p1[0],p2[0])) {\n    // fix start index of both to same point\n    p2 = this.fixStartIndex(p2,p1);\n    if(!p2) return;\n  }\n  // for linestring ind =0 and for polygon ind =1\n  var sameDirection = this.compareCoord(p1[ind],p2[ind]);\n  if (this.direction || sameDirection\n  ) {\n    return this.comparePath(p1, p2);\n  } else {\n    if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])\n    ) {\n      return this.comparePath(p1.slice().reverse(), p2);\n    }\n    return false;\n  }\n};\nEquality.prototype.fixStartIndex = function(sourcePath,targetPath) {\n  //make sourcePath first point same as of targetPath\n  var correctPath,ind = -1;\n  for (var i=0; i< sourcePath.length; i++) {\n    if(this.compareCoord(sourcePath[i],targetPath[0])) {\n      ind = i;\n      break;\n    }\n  }\n  if (ind >= 0) {\n    correctPath = [].concat(\n      sourcePath.slice(ind,sourcePath.length),\n      sourcePath.slice(1,ind+1));\n  }\n  return correctPath;\n};\nEquality.prototype.comparePath = function (p1,p2) {\n  var cont = this;\n  return p1.every(function(c,i) {\n    return cont.compareCoord(c,this[i]);\n  },p2);\n};\n\nEquality.prototype.comparePolygon = function(g1,g2) {\n  if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {\n    var holes1 = g1.coordinates.slice(1,g1.coordinates.length);\n    var holes2 = g2.coordinates.slice(1,g2.coordinates.length);\n    var cont = this;\n    return holes1.every(function(h1) {\n      return this.some(function(h2) {\n        return cont.compareLine(h1,h2,1,true);\n      });\n    },holes2);\n  } else {\n    return false;\n  }\n};\n\nEquality.prototype.compareFeature = function(g1,g2) {\n  if (\n    g1.id !== g2.id ||\n    !this.objectComparator(g1.properties, g2.properties) ||\n    !this.compareBBox(g1,g2)\n  ) {\n    return false;\n  }\n  return this.compare(g1.geometry, g2.geometry);\n};\n\nEquality.prototype.compareBBox = function(g1,g2) {\n  if (\n    (!g1.bbox && !g2.bbox) || \n    (\n      g1.bbox && g2.bbox &&\n      this.compareCoord(g1.bbox, g2.bbox)\n    )\n  )  {\n    return true;\n  }\n  return false;\n};\nEquality.prototype.removePseudo = function(path) {\n  //TODO to be implement\n  return path;\n};\n\nfunction objectComparator(obj1, obj2) {\n  return deepEqual(obj1, obj2, {strict: true});\n}\n\nmodule.exports = Equality;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ2VvanNvbi1lcXVhbGl0eS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDREQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3Qzs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2dlb2pzb24tZXF1YWxpdHkvaW5kZXguanM/ZGE0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL2luZGV4LmpzXG52YXIgZGVlcEVxdWFsID0gcmVxdWlyZSgnZGVlcC1lcXVhbCcpO1xuXG52YXIgRXF1YWxpdHkgPSBmdW5jdGlvbihvcHQpIHtcbiAgdGhpcy5wcmVjaXNpb24gPSBvcHQgJiYgb3B0LnByZWNpc2lvbiA/IG9wdC5wcmVjaXNpb24gOiAxNztcbiAgdGhpcy5kaXJlY3Rpb24gPSBvcHQgJiYgb3B0LmRpcmVjdGlvbiA/IG9wdC5kaXJlY3Rpb24gOiBmYWxzZTtcbiAgdGhpcy5wc2V1ZG9Ob2RlID0gb3B0ICYmIG9wdC5wc2V1ZG9Ob2RlID8gb3B0LnBzZXVkb05vZGUgOiBmYWxzZTtcbiAgdGhpcy5vYmplY3RDb21wYXJhdG9yID0gb3B0ICYmIG9wdC5vYmplY3RDb21wYXJhdG9yID8gb3B0Lm9iamVjdENvbXBhcmF0b3IgOiBvYmplY3RDb21wYXJhdG9yO1xufTtcblxuRXF1YWxpdHkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihnMSxnMikge1xuICBpZiAoZzEudHlwZSAhPT0gZzIudHlwZSB8fCAhc2FtZUxlbmd0aChnMSxnMikpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2goZzEudHlwZSkge1xuICBjYXNlICdQb2ludCc6XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZUNvb3JkKGcxLmNvb3JkaW5hdGVzLCBnMi5jb29yZGluYXRlcyk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVMaW5lKGcxLmNvb3JkaW5hdGVzLCBnMi5jb29yZGluYXRlcywwLGZhbHNlKTtcbiAgICBicmVhaztcbiAgY2FzZSAnUG9seWdvbic6XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVBvbHlnb24oZzEsZzIpO1xuICAgIGJyZWFrO1xuICBjYXNlICdGZWF0dXJlJzpcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlRmVhdHVyZShnMSwgZzIpO1xuICBkZWZhdWx0OlxuICAgIGlmIChnMS50eXBlLmluZGV4T2YoJ011bHRpJykgPT09IDApIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIHZhciBnMXMgPSBleHBsb2RlKGcxKTtcbiAgICAgIHZhciBnMnMgPSBleHBsb2RlKGcyKTtcbiAgICAgIHJldHVybiBnMXMuZXZlcnkoZnVuY3Rpb24oZzFwYXJ0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24oZzJwYXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29tcGFyZShnMXBhcnQsZzJwYXJ0KTtcbiAgICAgICAgfSk7XG4gICAgICB9LGcycyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGV4cGxvZGUoZykge1xuICByZXR1cm4gZy5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBnLnR5cGUucmVwbGFjZSgnTXVsdGknLCAnJyksXG4gICAgICBjb29yZGluYXRlczogcGFydH1cbiAgfSk7XG59XG4vL2NvbXBhcmUgbGVuZ3RoIG9mIGNvb3JkaW5hdGVzL2FycmF5XG5mdW5jdGlvbiBzYW1lTGVuZ3RoKGcxLGcyKSB7XG4gICByZXR1cm4gZzEuaGFzT3duUHJvcGVydHkoJ2Nvb3JkaW5hdGVzJykgP1xuICAgIGcxLmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gZzIuY29vcmRpbmF0ZXMubGVuZ3RoXG4gICAgOiBnMS5sZW5ndGggPT09IGcyLmxlbmd0aDtcbn1cblxuLy8gY29tcGFyZSB0aGUgdHdvIGNvb3JkaW5hdGVzIFt4LHldXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZUNvb3JkID0gZnVuY3Rpb24oYzEsYzIpIHtcbiAgaWYgKGMxLmxlbmd0aCAhPT0gYzIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaT0wOyBpIDwgYzEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYzFbaV0udG9GaXhlZCh0aGlzLnByZWNpc2lvbikgIT09IGMyW2ldLnRvRml4ZWQodGhpcy5wcmVjaXNpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuRXF1YWxpdHkucHJvdG90eXBlLmNvbXBhcmVMaW5lID0gZnVuY3Rpb24ocGF0aDEscGF0aDIsaW5kLGlzUG9seSkge1xuICBpZiAoIXNhbWVMZW5ndGgocGF0aDEscGF0aDIpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwMSA9IHRoaXMucHNldWRvTm9kZSA/IHBhdGgxIDogdGhpcy5yZW1vdmVQc2V1ZG8ocGF0aDEpO1xuICB2YXIgcDIgPSB0aGlzLnBzZXVkb05vZGUgPyBwYXRoMiA6IHRoaXMucmVtb3ZlUHNldWRvKHBhdGgyKTtcbiAgaWYgKGlzUG9seSAmJiAhdGhpcy5jb21wYXJlQ29vcmQocDFbMF0scDJbMF0pKSB7XG4gICAgLy8gZml4IHN0YXJ0IGluZGV4IG9mIGJvdGggdG8gc2FtZSBwb2ludFxuICAgIHAyID0gdGhpcy5maXhTdGFydEluZGV4KHAyLHAxKTtcbiAgICBpZighcDIpIHJldHVybjtcbiAgfVxuICAvLyBmb3IgbGluZXN0cmluZyBpbmQgPTAgYW5kIGZvciBwb2x5Z29uIGluZCA9MVxuICB2YXIgc2FtZURpcmVjdGlvbiA9IHRoaXMuY29tcGFyZUNvb3JkKHAxW2luZF0scDJbaW5kXSk7XG4gIGlmICh0aGlzLmRpcmVjdGlvbiB8fCBzYW1lRGlyZWN0aW9uXG4gICkge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmVQYXRoKHAxLCBwMik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuY29tcGFyZUNvb3JkKHAxW2luZF0scDJbcDIubGVuZ3RoIC0gKDEraW5kKV0pXG4gICAgKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlUGF0aChwMS5zbGljZSgpLnJldmVyc2UoKSwgcDIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5FcXVhbGl0eS5wcm90b3R5cGUuZml4U3RhcnRJbmRleCA9IGZ1bmN0aW9uKHNvdXJjZVBhdGgsdGFyZ2V0UGF0aCkge1xuICAvL21ha2Ugc291cmNlUGF0aCBmaXJzdCBwb2ludCBzYW1lIGFzIG9mIHRhcmdldFBhdGhcbiAgdmFyIGNvcnJlY3RQYXRoLGluZCA9IC0xO1xuICBmb3IgKHZhciBpPTA7IGk8IHNvdXJjZVBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBpZih0aGlzLmNvbXBhcmVDb29yZChzb3VyY2VQYXRoW2ldLHRhcmdldFBhdGhbMF0pKSB7XG4gICAgICBpbmQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChpbmQgPj0gMCkge1xuICAgIGNvcnJlY3RQYXRoID0gW10uY29uY2F0KFxuICAgICAgc291cmNlUGF0aC5zbGljZShpbmQsc291cmNlUGF0aC5sZW5ndGgpLFxuICAgICAgc291cmNlUGF0aC5zbGljZSgxLGluZCsxKSk7XG4gIH1cbiAgcmV0dXJuIGNvcnJlY3RQYXRoO1xufTtcbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlUGF0aCA9IGZ1bmN0aW9uIChwMSxwMikge1xuICB2YXIgY29udCA9IHRoaXM7XG4gIHJldHVybiBwMS5ldmVyeShmdW5jdGlvbihjLGkpIHtcbiAgICByZXR1cm4gY29udC5jb21wYXJlQ29vcmQoYyx0aGlzW2ldKTtcbiAgfSxwMik7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZVBvbHlnb24gPSBmdW5jdGlvbihnMSxnMikge1xuICBpZiAodGhpcy5jb21wYXJlTGluZShnMS5jb29yZGluYXRlc1swXSxnMi5jb29yZGluYXRlc1swXSwxLHRydWUpKSB7XG4gICAgdmFyIGhvbGVzMSA9IGcxLmNvb3JkaW5hdGVzLnNsaWNlKDEsZzEuY29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICB2YXIgaG9sZXMyID0gZzIuY29vcmRpbmF0ZXMuc2xpY2UoMSxnMi5jb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHZhciBjb250ID0gdGhpcztcbiAgICByZXR1cm4gaG9sZXMxLmV2ZXJ5KGZ1bmN0aW9uKGgxKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uKGgyKSB7XG4gICAgICAgIHJldHVybiBjb250LmNvbXBhcmVMaW5lKGgxLGgyLDEsdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9LGhvbGVzMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZUZlYXR1cmUgPSBmdW5jdGlvbihnMSxnMikge1xuICBpZiAoXG4gICAgZzEuaWQgIT09IGcyLmlkIHx8XG4gICAgIXRoaXMub2JqZWN0Q29tcGFyYXRvcihnMS5wcm9wZXJ0aWVzLCBnMi5wcm9wZXJ0aWVzKSB8fFxuICAgICF0aGlzLmNvbXBhcmVCQm94KGcxLGcyKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY29tcGFyZShnMS5nZW9tZXRyeSwgZzIuZ2VvbWV0cnkpO1xufTtcblxuRXF1YWxpdHkucHJvdG90eXBlLmNvbXBhcmVCQm94ID0gZnVuY3Rpb24oZzEsZzIpIHtcbiAgaWYgKFxuICAgICghZzEuYmJveCAmJiAhZzIuYmJveCkgfHwgXG4gICAgKFxuICAgICAgZzEuYmJveCAmJiBnMi5iYm94ICYmXG4gICAgICB0aGlzLmNvbXBhcmVDb29yZChnMS5iYm94LCBnMi5iYm94KVxuICAgIClcbiAgKSAge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5FcXVhbGl0eS5wcm90b3R5cGUucmVtb3ZlUHNldWRvID0gZnVuY3Rpb24ocGF0aCkge1xuICAvL1RPRE8gdG8gYmUgaW1wbGVtZW50XG4gIHJldHVybiBwYXRoO1xufTtcblxuZnVuY3Rpb24gb2JqZWN0Q29tcGFyYXRvcihvYmoxLCBvYmoyKSB7XG4gIHJldHVybiBkZWVwRXF1YWwob2JqMSwgb2JqMiwge3N0cmljdDogdHJ1ZX0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVxdWFsaXR5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/geojson-equality/index.js\n");

/***/ })

};
;