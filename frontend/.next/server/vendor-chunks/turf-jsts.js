"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/turf-jsts";
exports.ids = ["vendor-chunks/turf-jsts"];
exports.modules = {

/***/ "(ssr)/./node_modules/turf-jsts/jsts.mjs":
/*!*****************************************!*\
  !*** ./node_modules/turf-jsts/jsts.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferOp: () => (/* binding */ BufferOp),\n/* harmony export */   GeoJSONReader: () => (/* binding */ GeoJSONReader),\n/* harmony export */   GeoJSONWriter: () => (/* binding */ GeoJSONWriter),\n/* harmony export */   OverlayOp: () => (/* binding */ OverlayOp),\n/* harmony export */   UnionOp: () => (/* binding */ UnionOp)\n/* harmony export */ });\n/* Polyfill service v3.13.0\n * For detailed credits and licence information see http://github.com/financial-times/polyfill-service\n *\n * - Array.prototype.fill, License: CC0 */\n\nif (!('fill' in Array.prototype)) {\n  Object.defineProperty(Array.prototype, 'fill', {\n    configurable: true,\n    value: function fill (value) {\n      if (this === undefined || this === null) {\n        throw new TypeError(this + ' is not an object')\n      }\n\n      var arrayLike = Object(this);\n\n      var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;\n\n      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;\n\n      relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);\n\n      var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;\n\n      relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);\n\n      while (relativeStart < relativeEnd) {\n        arrayLike[relativeStart] = value;\n\n        ++relativeStart;\n      }\n\n      return arrayLike\n    },\n    writable: true\n  });\n}\n\n/**\n * Polyfill for IE support\n */\nNumber.isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value)\n};\n\nNumber.isInteger = Number.isInteger || function (val) {\n  return typeof val === 'number' &&\n  isFinite(val) &&\n  Math.floor(val) === val\n};\n\nNumber.parseFloat = Number.parseFloat || parseFloat;\n\nNumber.isNaN = Number.isNaN || function (value) {\n  return value !== value // eslint-disable-line\n};\n\n/**\n * Polyfill for IE support\n */\nMath.trunc = Math.trunc || function (x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x)\n};\n\nvar NumberUtil = function NumberUtil () {};\n\nNumberUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNumberUtil.prototype.getClass = function getClass () {\n  return NumberUtil\n};\nNumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance (x1, x2, tolerance) {\n  return Math.abs(x1 - x2) <= tolerance\n};\n\nvar IllegalArgumentException = (function (Error) {\n\tfunction IllegalArgumentException (message) {\n\t\tError.call(this, message);\n\t\tthis.name = 'IllegalArgumentException';\n\t\tthis.message = message;\n\t\tthis.stack = (new Error()).stack;\n\t}\n\n\tif ( Error ) IllegalArgumentException.__proto__ = Error;\n\tIllegalArgumentException.prototype = Object.create( Error && Error.prototype );\n\tIllegalArgumentException.prototype.constructor = IllegalArgumentException;\n\n\treturn IllegalArgumentException;\n}(Error));\n\nvar Double = function Double () {};\n\nvar staticAccessors$1 = { MAX_VALUE: { configurable: true } };\n\nDouble.isNaN = function isNaN (n) { return Number.isNaN(n) };\nDouble.doubleToLongBits = function doubleToLongBits (n) { return n };\nDouble.longBitsToDouble = function longBitsToDouble (n) { return n };\nDouble.isInfinite = function isInfinite (n) { return !Number.isFinite(n) };\nstaticAccessors$1.MAX_VALUE.get = function () { return Number.MAX_VALUE };\n\nObject.defineProperties( Double, staticAccessors$1 );\n\nvar Comparable = function Comparable () {};\n\nvar Clonable = function Clonable () {};\n\nvar Comparator = function Comparator () {};\n\nfunction Serializable () {}\n\n// import Assert from '../util/Assert'\n\nvar Coordinate = function Coordinate () {\n  this.x = null;\n  this.y = null;\n  this.z = null;\n  if (arguments.length === 0) {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = Coordinate.NULL_ORDINATE;\n  } else if (arguments.length === 1) {\n    var c = arguments[0];\n    this.x = c.x;\n    this.y = c.y;\n    this.z = c.z;\n  } else if (arguments.length === 2) {\n    this.x = arguments[0];\n    this.y = arguments[1];\n    this.z = Coordinate.NULL_ORDINATE;\n  } else if (arguments.length === 3) {\n    this.x = arguments[0];\n    this.y = arguments[1];\n    this.z = arguments[2];\n  }\n};\n\nvar staticAccessors = { DimensionalComparator: { configurable: true },serialVersionUID: { configurable: true },NULL_ORDINATE: { configurable: true },X: { configurable: true },Y: { configurable: true },Z: { configurable: true } };\nCoordinate.prototype.setOrdinate = function setOrdinate (ordinateIndex, value) {\n  switch (ordinateIndex) {\n    case Coordinate.X:\n      this.x = value;\n      break\n    case Coordinate.Y:\n      this.y = value;\n      break\n    case Coordinate.Z:\n      this.z = value;\n      break\n    default:\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n  }\n};\nCoordinate.prototype.equals2D = function equals2D () {\n  if (arguments.length === 1) {\n    var other = arguments[0];\n    if (this.x !== other.x) {\n      return false\n    }\n    if (this.y !== other.y) {\n      return false\n    }\n    return true\n  } else if (arguments.length === 2) {\n    var c = arguments[0];\n    var tolerance = arguments[1];\n    if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n      return false\n    }\n    if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n      return false\n    }\n    return true\n  }\n};\nCoordinate.prototype.getOrdinate = function getOrdinate (ordinateIndex) {\n  switch (ordinateIndex) {\n    case Coordinate.X:\n      return this.x\n    case Coordinate.Y:\n      return this.y\n    case Coordinate.Z:\n      return this.z\n    default:\n  }\n  throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n};\nCoordinate.prototype.equals3D = function equals3D (other) {\n  return this.x === other.x &&\n         this.y === other.y &&\n         ((this.z === other.z || Double.isNaN(this.z)) &&\n         Double.isNaN(other.z))\n};\nCoordinate.prototype.equals = function equals (other) {\n  if (!(other instanceof Coordinate)) {\n    return false\n  }\n  return this.equals2D(other)\n};\nCoordinate.prototype.equalInZ = function equalInZ (c, tolerance) {\n  return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance)\n};\nCoordinate.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  if (this.x < other.x) { return -1 }\n  if (this.x > other.x) { return 1 }\n  if (this.y < other.y) { return -1 }\n  if (this.y > other.y) { return 1 }\n  return 0\n};\nCoordinate.prototype.clone = function clone () {\n  // try {\n  // var coord = null\n  // return coord\n  // } catch (e) {\n  // if (e instanceof CloneNotSupportedException) {\n  //   Assert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\")\n  //   return null\n  // } else throw e\n  // } finally {}\n};\nCoordinate.prototype.copy = function copy () {\n  return new Coordinate(this)\n};\nCoordinate.prototype.toString = function toString () {\n  return '(' + this.x + ', ' + this.y + ', ' + this.z + ')'\n};\nCoordinate.prototype.distance3D = function distance3D (c) {\n  var dx = this.x - c.x;\n  var dy = this.y - c.y;\n  var dz = this.z - c.z;\n  return Math.sqrt(dx * dx + dy * dy + dz * dz)\n};\nCoordinate.prototype.distance = function distance (c) {\n  var dx = this.x - c.x;\n  var dy = this.y - c.y;\n  return Math.sqrt(dx * dx + dy * dy)\n};\nCoordinate.prototype.hashCode = function hashCode () {\n  var result = 17;\n  result = 37 * result + Coordinate.hashCode(this.x);\n  result = 37 * result + Coordinate.hashCode(this.y);\n  return result\n};\nCoordinate.prototype.setCoordinate = function setCoordinate (other) {\n  this.x = other.x;\n  this.y = other.y;\n  this.z = other.z;\n};\nCoordinate.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Clonable, Serializable]\n};\nCoordinate.prototype.getClass = function getClass () {\n  return Coordinate\n};\nCoordinate.hashCode = function hashCode () {\n  if (arguments.length === 1) {\n    var x = arguments[0];\n    var f = Double.doubleToLongBits(x);\n    return Math.trunc((f ^ f) >>> 32)\n  }\n};\nstaticAccessors.DimensionalComparator.get = function () { return DimensionalComparator };\nstaticAccessors.serialVersionUID.get = function () { return 6683108902428366910 };\nstaticAccessors.NULL_ORDINATE.get = function () { return Double.NaN };\nstaticAccessors.X.get = function () { return 0 };\nstaticAccessors.Y.get = function () { return 1 };\nstaticAccessors.Z.get = function () { return 2 };\n\nObject.defineProperties( Coordinate, staticAccessors );\n\nvar DimensionalComparator = function DimensionalComparator (dimensionsToTest) {\n  this._dimensionsToTest = 2;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var dimensionsToTest$1 = arguments[0];\n    if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) { throw new IllegalArgumentException('only 2 or 3 dimensions may be specified') }\n    this._dimensionsToTest = dimensionsToTest$1;\n  }\n};\nDimensionalComparator.prototype.compare = function compare (o1, o2) {\n  var c1 = o1;\n  var c2 = o2;\n  var compX = DimensionalComparator.compare(c1.x, c2.x);\n  if (compX !== 0) { return compX }\n  var compY = DimensionalComparator.compare(c1.y, c2.y);\n  if (compY !== 0) { return compY }\n  if (this._dimensionsToTest <= 2) { return 0 }\n  var compZ = DimensionalComparator.compare(c1.z, c2.z);\n  return compZ\n};\nDimensionalComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nDimensionalComparator.prototype.getClass = function getClass () {\n  return DimensionalComparator\n};\nDimensionalComparator.compare = function compare (a, b) {\n  if (a < b) { return -1 }\n  if (a > b) { return 1 }\n  if (Double.isNaN(a)) {\n    if (Double.isNaN(b)) { return 0 }\n    return -1\n  }\n  if (Double.isNaN(b)) { return 1 }\n  return 0\n};\n\n// import hasInterface from '../../../../hasInterface'\n// import CoordinateSequence from './CoordinateSequence'\n\nvar CoordinateSequenceFactory = function CoordinateSequenceFactory () {};\n\nCoordinateSequenceFactory.prototype.create = function create () {\n  // if (arguments.length === 1) {\n  // if (arguments[0] instanceof Array) {\n  //   let coordinates = arguments[0]\n  // } else if (hasInterface(arguments[0], CoordinateSequence)) {\n  //   let coordSeq = arguments[0]\n  // }\n  // } else if (arguments.length === 2) {\n  // let size = arguments[0]\n  // let dimension = arguments[1]\n  // }\n};\nCoordinateSequenceFactory.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequenceFactory.prototype.getClass = function getClass () {\n  return CoordinateSequenceFactory\n};\n\nvar Location = function Location () {};\n\nvar staticAccessors$4 = { INTERIOR: { configurable: true },BOUNDARY: { configurable: true },EXTERIOR: { configurable: true },NONE: { configurable: true } };\n\nLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLocation.prototype.getClass = function getClass () {\n  return Location\n};\nLocation.toLocationSymbol = function toLocationSymbol (locationValue) {\n  switch (locationValue) {\n    case Location.EXTERIOR:\n      return 'e'\n    case Location.BOUNDARY:\n      return 'b'\n    case Location.INTERIOR:\n      return 'i'\n    case Location.NONE:\n      return '-'\n    default:\n  }\n  throw new IllegalArgumentException('Unknown location value: ' + locationValue)\n};\nstaticAccessors$4.INTERIOR.get = function () { return 0 };\nstaticAccessors$4.BOUNDARY.get = function () { return 1 };\nstaticAccessors$4.EXTERIOR.get = function () { return 2 };\nstaticAccessors$4.NONE.get = function () { return -1 };\n\nObject.defineProperties( Location, staticAccessors$4 );\n\nvar hasInterface = function (o, i) {\n  return o.interfaces_ && o.interfaces_().indexOf(i) > -1\n};\n\nvar MathUtil = function MathUtil () {};\n\nvar staticAccessors$5 = { LOG_10: { configurable: true } };\n\nMathUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMathUtil.prototype.getClass = function getClass () {\n  return MathUtil\n};\nMathUtil.log10 = function log10 (x) {\n  var ln = Math.log(x);\n  if (Double.isInfinite(ln)) { return ln }\n  if (Double.isNaN(ln)) { return ln }\n  return ln / MathUtil.LOG_10\n};\nMathUtil.min = function min (v1, v2, v3, v4) {\n  var min = v1;\n  if (v2 < min) { min = v2; }\n  if (v3 < min) { min = v3; }\n  if (v4 < min) { min = v4; }\n  return min\n};\nMathUtil.clamp = function clamp () {\n  if (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number')) {\n    var x = arguments[0];\n    var min = arguments[1];\n    var max = arguments[2];\n    if (x < min) { return min }\n    if (x > max) { return max }\n    return x\n  } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n    var x$1 = arguments[0];\n    var min$1 = arguments[1];\n    var max$1 = arguments[2];\n    if (x$1 < min$1) { return min$1 }\n    if (x$1 > max$1) { return max$1 }\n    return x$1\n  }\n};\nMathUtil.wrap = function wrap (index, max) {\n  if (index < 0) {\n    return max - -index % max\n  }\n  return index % max\n};\nMathUtil.max = function max () {\n  if (arguments.length === 3) {\n    var v1 = arguments[0];\n    var v2 = arguments[1];\n    var v3 = arguments[2];\n    var max = v1;\n    if (v2 > max) { max = v2; }\n    if (v3 > max) { max = v3; }\n    return max\n  } else if (arguments.length === 4) {\n    var v1$1 = arguments[0];\n    var v2$1 = arguments[1];\n    var v3$1 = arguments[2];\n    var v4 = arguments[3];\n    var max$1 = v1$1;\n    if (v2$1 > max$1) { max$1 = v2$1; }\n    if (v3$1 > max$1) { max$1 = v3$1; }\n    if (v4 > max$1) { max$1 = v4; }\n    return max$1\n  }\n};\nMathUtil.average = function average (x1, x2) {\n  return (x1 + x2) / 2.0\n};\nstaticAccessors$5.LOG_10.get = function () { return Math.log(10) };\n\nObject.defineProperties( MathUtil, staticAccessors$5 );\n\nvar StringBuffer = function StringBuffer (str) {\n  this.str = str;\n};\nStringBuffer.prototype.append = function append (e) {\n  this.str += e;\n};\n\nStringBuffer.prototype.setCharAt = function setCharAt (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n};\n\nStringBuffer.prototype.toString = function toString (e) {\n  return this.str\n};\n\nvar Integer = function Integer (value) {\n  this.value = value;\n};\nInteger.prototype.intValue = function intValue () {\n  return this.value\n};\nInteger.prototype.compareTo = function compareTo (o) {\n  if (this.value < o) { return -1 }\n  if (this.value > o) { return 1 }\n  return 0\n};\nInteger.isNaN = function isNaN (n) { return Number.isNaN(n) };\n\nvar Character = function Character () {};\n\nCharacter.isWhitespace = function isWhitespace (c) { return ((c <= 32 && c >= 0) || c === 127) };\nCharacter.toUpperCase = function toUpperCase (c) { return c.toUpperCase() };\n\nvar DD = function DD () {\n  this._hi = 0.0;\n  this._lo = 0.0;\n  if (arguments.length === 0) {\n    this.init(0.0);\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'number') {\n      var x = arguments[0];\n      this.init(x);\n    } else if (arguments[0] instanceof DD) {\n      var dd = arguments[0];\n      this.init(dd);\n    } else if (typeof arguments[0] === 'string') {\n      var str = arguments[0];\n      DD.call(this, DD.parse(str));\n    }\n  } else if (arguments.length === 2) {\n    var hi = arguments[0];\n    var lo = arguments[1];\n    this.init(hi, lo);\n  }\n};\n\nvar staticAccessors$7 = { PI: { configurable: true },TWO_PI: { configurable: true },PI_2: { configurable: true },E: { configurable: true },NaN: { configurable: true },EPS: { configurable: true },SPLIT: { configurable: true },MAX_PRINT_DIGITS: { configurable: true },TEN: { configurable: true },ONE: { configurable: true },SCI_NOT_EXPONENT_CHAR: { configurable: true },SCI_NOT_ZERO: { configurable: true } };\nDD.prototype.le = function le (y) {\n  return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo\n};\nDD.prototype.extractSignificantDigits = function extractSignificantDigits (insertDecimalPoint, magnitude) {\n  var y = this.abs();\n  var mag = DD.magnitude(y._hi);\n  var scale = DD.TEN.pow(mag);\n  y = y.divide(scale);\n  if (y.gt(DD.TEN)) {\n    y = y.divide(DD.TEN);\n    mag += 1;\n  } else if (y.lt(DD.ONE)) {\n    y = y.multiply(DD.TEN);\n    mag -= 1;\n  }\n  var decimalPointPos = mag + 1;\n  var buf = new StringBuffer();\n  var numDigits = DD.MAX_PRINT_DIGITS - 1;\n  for (var i = 0; i <= numDigits; i++) {\n    if (insertDecimalPoint && i === decimalPointPos) {\n      buf.append('.');\n    }\n    var digit = Math.trunc(y._hi);\n    if (digit < 0) {\n      break\n    }\n    var rebiasBy10 = false;\n    var digitChar = 0;\n    if (digit > 9) {\n      rebiasBy10 = true;\n      digitChar = '9';\n    } else {\n      digitChar = '0' + digit;\n    }\n    buf.append(digitChar);\n    y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n    if (rebiasBy10) { y.selfAdd(DD.TEN); }\n    var continueExtractingDigits = true;\n    var remMag = DD.magnitude(y._hi);\n    if (remMag < 0 && Math.abs(remMag) >= numDigits - i) { continueExtractingDigits = false; }\n    if (!continueExtractingDigits) { break }\n  }\n  magnitude[0] = mag;\n  return buf.toString()\n};\nDD.prototype.sqr = function sqr () {\n  return this.multiply(this)\n};\nDD.prototype.doubleValue = function doubleValue () {\n  return this._hi + this._lo\n};\nDD.prototype.subtract = function subtract () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    return this.add(y.negate())\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    return this.add(-y$1)\n  }\n};\nDD.prototype.equals = function equals () {\n  if (arguments.length === 1) {\n    var y = arguments[0];\n    return this._hi === y._hi && this._lo === y._lo\n  }\n};\nDD.prototype.isZero = function isZero () {\n  return this._hi === 0.0 && this._lo === 0.0\n};\nDD.prototype.selfSubtract = function selfSubtract () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    if (this.isNaN()) { return this }\n    return this.selfAdd(-y._hi, -y._lo)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (this.isNaN()) { return this }\n    return this.selfAdd(-y$1, 0.0)\n  }\n};\nDD.prototype.getSpecialNumberString = function getSpecialNumberString () {\n  if (this.isZero()) { return '0.0' }\n  if (this.isNaN()) { return 'NaN ' }\n  return null\n};\nDD.prototype.min = function min (x) {\n  if (this.le(x)) {\n    return this\n  } else {\n    return x\n  }\n};\nDD.prototype.selfDivide = function selfDivide () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfDivide(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      return this.selfDivide(y$1, 0.0)\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var hc = null;\n    var tc = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    var U = null;\n    var u = null;\n    C = this._hi / yhi;\n    c = DD.SPLIT * C;\n    hc = c - C;\n    u = DD.SPLIT * yhi;\n    hc = c - hc;\n    tc = C - hc;\n    hy = u - yhi;\n    U = C * yhi;\n    hy = u - hy;\n    ty = yhi - hy;\n    u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n    c = (this._hi - U - u + this._lo - C * ylo) / yhi;\n    u = C + c;\n    this._hi = u;\n    this._lo = C - u + c;\n    return this\n  }\n};\nDD.prototype.dump = function dump () {\n  return 'DD<' + this._hi + ', ' + this._lo + '>'\n};\nDD.prototype.divide = function divide () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    var hc = null;\n    var tc = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    var U = null;\n    var u = null;\n    C = this._hi / y._hi;\n    c = DD.SPLIT * C;\n    hc = c - C;\n    u = DD.SPLIT * y._hi;\n    hc = c - hc;\n    tc = C - hc;\n    hy = u - y._hi;\n    U = C * y._hi;\n    hy = u - hy;\n    ty = y._hi - hy;\n    u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n    c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n    u = C + c;\n    var zhi = u;\n    var zlo = C - u + c;\n    return new DD(zhi, zlo)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (Double.isNaN(y$1)) { return DD.createNaN() }\n    return DD.copy(this).selfDivide(y$1, 0.0)\n  }\n};\nDD.prototype.ge = function ge (y) {\n  return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo\n};\nDD.prototype.pow = function pow (exp) {\n  if (exp === 0.0) { return DD.valueOf(1.0) }\n  var r = new DD(this);\n  var s = DD.valueOf(1.0);\n  var n = Math.abs(exp);\n  if (n > 1) {\n    while (n > 0) {\n      if (n % 2 === 1) {\n        s.selfMultiply(r);\n      }\n      n /= 2;\n      if (n > 0) { r = r.sqr(); }\n    }\n  } else {\n    s = r;\n  }\n  if (exp < 0) { return s.reciprocal() }\n  return s\n};\nDD.prototype.ceil = function ceil () {\n  if (this.isNaN()) { return DD.NaN }\n  var fhi = Math.ceil(this._hi);\n  var flo = 0.0;\n  if (fhi === this._hi) {\n    flo = Math.ceil(this._lo);\n  }\n  return new DD(fhi, flo)\n};\nDD.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  if (this._hi < other._hi) { return -1 }\n  if (this._hi > other._hi) { return 1 }\n  if (this._lo < other._lo) { return -1 }\n  if (this._lo > other._lo) { return 1 }\n  return 0\n};\nDD.prototype.rint = function rint () {\n  if (this.isNaN()) { return this }\n  var plus5 = this.add(0.5);\n  return plus5.floor()\n};\nDD.prototype.setValue = function setValue () {\n  if (arguments[0] instanceof DD) {\n    var value = arguments[0];\n    this.init(value);\n    return this\n  } else if (typeof arguments[0] === 'number') {\n    var value$1 = arguments[0];\n    this.init(value$1);\n    return this\n  }\n};\nDD.prototype.max = function max (x) {\n  if (this.ge(x)) {\n    return this\n  } else {\n    return x\n  }\n};\nDD.prototype.sqrt = function sqrt () {\n  if (this.isZero()) { return DD.valueOf(0.0) }\n  if (this.isNegative()) {\n    return DD.NaN\n  }\n  var x = 1.0 / Math.sqrt(this._hi);\n  var ax = this._hi * x;\n  var axdd = DD.valueOf(ax);\n  var diffSq = this.subtract(axdd.sqr());\n  var d2 = diffSq._hi * (x * 0.5);\n  return axdd.add(d2)\n};\nDD.prototype.selfAdd = function selfAdd () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfAdd(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      var H = null;\n      var h = null;\n      var S = null;\n      var s = null;\n      var e = null;\n      var f = null;\n      S = this._hi + y$1;\n      e = S - this._hi;\n      s = S - e;\n      s = y$1 - e + (this._hi - s);\n      f = s + this._lo;\n      H = S + f;\n      h = f + (S - H);\n      this._hi = H + h;\n      this._lo = h + (H - this._hi);\n      return this\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var H$1 = null;\n    var h$1 = null;\n    var T = null;\n    var t = null;\n    var S$1 = null;\n    var s$1 = null;\n    var e$1 = null;\n    var f$1 = null;\n    S$1 = this._hi + yhi;\n    T = this._lo + ylo;\n    e$1 = S$1 - this._hi;\n    f$1 = T - this._lo;\n    s$1 = S$1 - e$1;\n    t = T - f$1;\n    s$1 = yhi - e$1 + (this._hi - s$1);\n    t = ylo - f$1 + (this._lo - t);\n    e$1 = s$1 + T;\n    H$1 = S$1 + e$1;\n    h$1 = e$1 + (S$1 - H$1);\n    e$1 = t + h$1;\n    var zhi = H$1 + e$1;\n    var zlo = e$1 + (H$1 - zhi);\n    this._hi = zhi;\n    this._lo = zlo;\n    return this\n  }\n};\nDD.prototype.selfMultiply = function selfMultiply () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfMultiply(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      return this.selfMultiply(y$1, 0.0)\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var hx = null;\n    var tx = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    C = DD.SPLIT * this._hi;\n    hx = C - this._hi;\n    c = DD.SPLIT * yhi;\n    hx = C - hx;\n    tx = this._hi - hx;\n    hy = c - yhi;\n    C = this._hi * yhi;\n    hy = c - hy;\n    ty = yhi - hy;\n    c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n    var zhi = C + c;\n    hx = C - zhi;\n    var zlo = c + hx;\n    this._hi = zhi;\n    this._lo = zlo;\n    return this\n  }\n};\nDD.prototype.selfSqr = function selfSqr () {\n  return this.selfMultiply(this)\n};\nDD.prototype.floor = function floor () {\n  if (this.isNaN()) { return DD.NaN }\n  var fhi = Math.floor(this._hi);\n  var flo = 0.0;\n  if (fhi === this._hi) {\n    flo = Math.floor(this._lo);\n  }\n  return new DD(fhi, flo)\n};\nDD.prototype.negate = function negate () {\n  if (this.isNaN()) { return this }\n  return new DD(-this._hi, -this._lo)\n};\nDD.prototype.clone = function clone () {\n  // try {\n  // return null\n  // } catch (ex) {\n  // if (ex instanceof CloneNotSupportedException) {\n  //   return null\n  // } else throw ex\n  // } finally {}\n};\nDD.prototype.multiply = function multiply () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    if (y.isNaN()) { return DD.createNaN() }\n    return DD.copy(this).selfMultiply(y)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (Double.isNaN(y$1)) { return DD.createNaN() }\n    return DD.copy(this).selfMultiply(y$1, 0.0)\n  }\n};\nDD.prototype.isNaN = function isNaN () {\n  return Double.isNaN(this._hi)\n};\nDD.prototype.intValue = function intValue () {\n  return Math.trunc(this._hi)\n};\nDD.prototype.toString = function toString () {\n  var mag = DD.magnitude(this._hi);\n  if (mag >= -3 && mag <= 20) { return this.toStandardNotation() }\n  return this.toSciNotation()\n};\nDD.prototype.toStandardNotation = function toStandardNotation () {\n  var specialStr = this.getSpecialNumberString();\n  if (specialStr !== null) { return specialStr }\n  var magnitude = new Array(1).fill(null);\n  var sigDigits = this.extractSignificantDigits(true, magnitude);\n  var decimalPointPos = magnitude[0] + 1;\n  var num = sigDigits;\n  if (sigDigits.charAt(0) === '.') {\n    num = '0' + sigDigits;\n  } else if (decimalPointPos < 0) {\n    num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n  } else if (sigDigits.indexOf('.') === -1) {\n    var numZeroes = decimalPointPos - sigDigits.length;\n    var zeroes = DD.stringOfChar('0', numZeroes);\n    num = sigDigits + zeroes + '.0';\n  }\n  if (this.isNegative()) { return '-' + num }\n  return num\n};\nDD.prototype.reciprocal = function reciprocal () {\n  var hc = null;\n  var tc = null;\n  var hy = null;\n  var ty = null;\n  var C = null;\n  var c = null;\n  var U = null;\n  var u = null;\n  C = 1.0 / this._hi;\n  c = DD.SPLIT * C;\n  hc = c - C;\n  u = DD.SPLIT * this._hi;\n  hc = c - hc;\n  tc = C - hc;\n  hy = u - this._hi;\n  U = C * this._hi;\n  hy = u - hy;\n  ty = this._hi - hy;\n  u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  c = (1.0 - U - u - C * this._lo) / this._hi;\n  var zhi = C + c;\n  var zlo = C - zhi + c;\n  return new DD(zhi, zlo)\n};\nDD.prototype.toSciNotation = function toSciNotation () {\n  if (this.isZero()) { return DD.SCI_NOT_ZERO }\n  var specialStr = this.getSpecialNumberString();\n  if (specialStr !== null) { return specialStr }\n  var magnitude = new Array(1).fill(null);\n  var digits = this.extractSignificantDigits(false, magnitude);\n  var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n  if (digits.charAt(0) === '0') {\n    throw new Error('Found leading zero: ' + digits)\n  }\n  var trailingDigits = '';\n  if (digits.length > 1) { trailingDigits = digits.substring(1); }\n  var digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;\n  if (this.isNegative()) { return '-' + digitsWithDecimal + expStr }\n  return digitsWithDecimal + expStr\n};\nDD.prototype.abs = function abs () {\n  if (this.isNaN()) { return DD.NaN }\n  if (this.isNegative()) { return this.negate() }\n  return new DD(this)\n};\nDD.prototype.isPositive = function isPositive () {\n  return (this._hi > 0.0 || this._hi === 0.0) && this._lo > 0.0\n};\nDD.prototype.lt = function lt (y) {\n  return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo\n};\nDD.prototype.add = function add () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    return DD.copy(this).selfAdd(y)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    return DD.copy(this).selfAdd(y$1)\n  }\n};\nDD.prototype.init = function init () {\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'number') {\n      var x = arguments[0];\n      this._hi = x;\n      this._lo = 0.0;\n    } else if (arguments[0] instanceof DD) {\n      var dd = arguments[0];\n      this._hi = dd._hi;\n      this._lo = dd._lo;\n    }\n  } else if (arguments.length === 2) {\n    var hi = arguments[0];\n    var lo = arguments[1];\n    this._hi = hi;\n    this._lo = lo;\n  }\n};\nDD.prototype.gt = function gt (y) {\n  return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo\n};\nDD.prototype.isNegative = function isNegative () {\n  return (this._hi < 0.0 || this._hi === 0.0) && this._lo < 0.0\n};\nDD.prototype.trunc = function trunc () {\n  if (this.isNaN()) { return DD.NaN }\n  if (this.isPositive()) { return this.floor(); } else { return this.ceil() }\n};\nDD.prototype.signum = function signum () {\n  if (this._hi > 0) { return 1 }\n  if (this._hi < 0) { return -1 }\n  if (this._lo > 0) { return 1 }\n  if (this._lo < 0) { return -1 }\n  return 0\n};\nDD.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable, Comparable, Clonable]\n};\nDD.prototype.getClass = function getClass () {\n  return DD\n};\nDD.sqr = function sqr (x) {\n  return DD.valueOf(x).selfMultiply(x)\n};\nDD.valueOf = function valueOf () {\n  if (typeof arguments[0] === 'string') {\n    var str = arguments[0];\n    return DD.parse(str)\n  } else if (typeof arguments[0] === 'number') {\n    var x = arguments[0];\n    return new DD(x)\n  }\n};\nDD.sqrt = function sqrt (x) {\n  return DD.valueOf(x).sqrt()\n};\nDD.parse = function parse (str) {\n  var i = 0;\n  var strlen = str.length;\n  while (Character.isWhitespace(str.charAt(i))) { i++; }\n  var isNegative = false;\n  if (i < strlen) {\n    var signCh = str.charAt(i);\n    if (signCh === '-' || signCh === '+') {\n      i++;\n      if (signCh === '-') { isNegative = true; }\n    }\n  }\n  var val = new DD();\n  var numDigits = 0;\n  var numBeforeDec = 0;\n  var exp = 0;\n  while (true) {\n    if (i >= strlen) { break }\n    var ch = str.charAt(i);\n    i++;\n    if (Character.isDigit(ch)) {\n      var d = ch - '0';\n      val.selfMultiply(DD.TEN);\n      val.selfAdd(d);\n      numDigits++;\n      continue\n    }\n    if (ch === '.') {\n      numBeforeDec = numDigits;\n      continue\n    }\n    if (ch === 'e' || ch === 'E') {\n      var expStr = str.substring(i);\n      try {\n        exp = Integer.parseInt(expStr);\n      } catch (ex) {\n        if (ex instanceof Error) {\n          throw new Error('Invalid exponent ' + expStr + ' in string ' + str)\n        } else { throw ex }\n      } finally {}\n      break\n    }\n    throw new Error(\"Unexpected character '\" + ch + \"' at position \" + i + ' in string ' + str)\n  }\n  var val2 = val;\n  var numDecPlaces = numDigits - numBeforeDec - exp;\n  if (numDecPlaces === 0) {\n    val2 = val;\n  } else if (numDecPlaces > 0) {\n    var scale = DD.TEN.pow(numDecPlaces);\n    val2 = val.divide(scale);\n  } else if (numDecPlaces < 0) {\n    var scale$1 = DD.TEN.pow(-numDecPlaces);\n    val2 = val.multiply(scale$1);\n  }\n  if (isNegative) {\n    return val2.negate()\n  }\n  return val2\n};\nDD.createNaN = function createNaN () {\n  return new DD(Double.NaN, Double.NaN)\n};\nDD.copy = function copy (dd) {\n  return new DD(dd)\n};\nDD.magnitude = function magnitude (x) {\n  var xAbs = Math.abs(x);\n  var xLog10 = Math.log(xAbs) / Math.log(10);\n  var xMag = Math.trunc(Math.floor(xLog10));\n  var xApprox = Math.pow(10, xMag);\n  if (xApprox * 10 <= xAbs) { xMag += 1; }\n  return xMag\n};\nDD.stringOfChar = function stringOfChar (ch, len) {\n  var buf = new StringBuffer();\n  for (var i = 0; i < len; i++) {\n    buf.append(ch);\n  }\n  return buf.toString()\n};\nstaticAccessors$7.PI.get = function () { return new DD(3.141592653589793116e+00, 1.224646799147353207e-16) };\nstaticAccessors$7.TWO_PI.get = function () { return new DD(6.283185307179586232e+00, 2.449293598294706414e-16) };\nstaticAccessors$7.PI_2.get = function () { return new DD(1.570796326794896558e+00, 6.123233995736766036e-17) };\nstaticAccessors$7.E.get = function () { return new DD(2.718281828459045091e+00, 1.445646891729250158e-16) };\nstaticAccessors$7.NaN.get = function () { return new DD(Double.NaN, Double.NaN) };\nstaticAccessors$7.EPS.get = function () { return 1.23259516440783e-32 };\nstaticAccessors$7.SPLIT.get = function () { return 134217729.0 };\nstaticAccessors$7.MAX_PRINT_DIGITS.get = function () { return 32 };\nstaticAccessors$7.TEN.get = function () { return DD.valueOf(10.0) };\nstaticAccessors$7.ONE.get = function () { return DD.valueOf(1.0) };\nstaticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function () { return 'E' };\nstaticAccessors$7.SCI_NOT_ZERO.get = function () { return '0.0E0' };\n\nObject.defineProperties( DD, staticAccessors$7 );\n\nvar CGAlgorithmsDD = function CGAlgorithmsDD () {};\n\nvar staticAccessors$6 = { DP_SAFE_EPSILON: { configurable: true } };\n\nCGAlgorithmsDD.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCGAlgorithmsDD.prototype.getClass = function getClass () {\n  return CGAlgorithmsDD\n};\nCGAlgorithmsDD.orientationIndex = function orientationIndex (p1, p2, q) {\n  var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n  if (index <= 1) { return index }\n  var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n  var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n  var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n  var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n  return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum()\n};\nCGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2 (x1, y1, x2, y2) {\n  var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n  return det.signum()\n};\nCGAlgorithmsDD.intersection = function intersection (p1, p2, q1, q2) {\n  var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n  var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n  var denom = denom1.subtract(denom2);\n  var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  var numx = numx1.subtract(numx2);\n  var fracP = numx.selfDivide(denom).doubleValue();\n  var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n  var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  var numy = numy1.subtract(numy2);\n  var fracQ = numy.selfDivide(denom).doubleValue();\n  var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n  return new Coordinate(x, y)\n};\nCGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter (pa, pb, pc) {\n  var detsum = null;\n  var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n  var detright = (pa.y - pc.y) * (pb.x - pc.x);\n  var det = detleft - detright;\n  if (detleft > 0.0) {\n    if (detright <= 0.0) {\n      return CGAlgorithmsDD.signum(det)\n    } else {\n      detsum = detleft + detright;\n    }\n  } else if (detleft < 0.0) {\n    if (detright >= 0.0) {\n      return CGAlgorithmsDD.signum(det)\n    } else {\n      detsum = -detleft - detright;\n    }\n  } else {\n    return CGAlgorithmsDD.signum(det)\n  }\n  var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n  if (det >= errbound || -det >= errbound) {\n    return CGAlgorithmsDD.signum(det)\n  }\n  return 2\n};\nCGAlgorithmsDD.signum = function signum (x) {\n  if (x > 0) { return 1 }\n  if (x < 0) { return -1 }\n  return 0\n};\nstaticAccessors$6.DP_SAFE_EPSILON.get = function () { return 1e-15 };\n\nObject.defineProperties( CGAlgorithmsDD, staticAccessors$6 );\n\nvar CoordinateSequence = function CoordinateSequence () {};\n\nvar staticAccessors$8 = { X: { configurable: true },Y: { configurable: true },Z: { configurable: true },M: { configurable: true } };\n\nstaticAccessors$8.X.get = function () { return 0 };\nstaticAccessors$8.Y.get = function () { return 1 };\nstaticAccessors$8.Z.get = function () { return 2 };\nstaticAccessors$8.M.get = function () { return 3 };\nCoordinateSequence.prototype.setOrdinate = function setOrdinate (index, ordinateIndex, value) {};\nCoordinateSequence.prototype.size = function size () {};\nCoordinateSequence.prototype.getOrdinate = function getOrdinate (index, ordinateIndex) {};\nCoordinateSequence.prototype.getCoordinate = function getCoordinate () {};\nCoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy (i) {};\nCoordinateSequence.prototype.getDimension = function getDimension () {};\nCoordinateSequence.prototype.getX = function getX (index) {};\nCoordinateSequence.prototype.clone = function clone () {};\nCoordinateSequence.prototype.expandEnvelope = function expandEnvelope (env) {};\nCoordinateSequence.prototype.copy = function copy () {};\nCoordinateSequence.prototype.getY = function getY (index) {};\nCoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray () {};\nCoordinateSequence.prototype.interfaces_ = function interfaces_ () {\n  return [Clonable]\n};\nCoordinateSequence.prototype.getClass = function getClass () {\n  return CoordinateSequence\n};\n\nObject.defineProperties( CoordinateSequence, staticAccessors$8 );\n\nvar Exception = function Exception () {};\n\nvar NotRepresentableException = (function (Exception$$1) {\n  function NotRepresentableException () {\n    Exception$$1.call(this, 'Projective point not representable on the Cartesian plane.');\n  }\n\n  if ( Exception$$1 ) NotRepresentableException.__proto__ = Exception$$1;\n  NotRepresentableException.prototype = Object.create( Exception$$1 && Exception$$1.prototype );\n  NotRepresentableException.prototype.constructor = NotRepresentableException;\n  NotRepresentableException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  NotRepresentableException.prototype.getClass = function getClass () {\n    return NotRepresentableException\n  };\n\n  return NotRepresentableException;\n}(Exception));\n\nvar System = function System () {};\n\nSystem.arraycopy = function arraycopy (src, srcPos, dest, destPos, len) {\n  var c = 0;\n  for (var i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i];\n    c++;\n  }\n};\n\nSystem.getProperty = function getProperty (name) {\n  return {\n    'line.separator': '\\n'\n  }[name]\n};\n\nvar HCoordinate = function HCoordinate () {\n  this.x = null;\n  this.y = null;\n  this.w = null;\n  if (arguments.length === 0) {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.w = 1.0;\n  } else if (arguments.length === 1) {\n    var p = arguments[0];\n    this.x = p.x;\n    this.y = p.y;\n    this.w = 1.0;\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      var _x = arguments[0];\n      var _y = arguments[1];\n      this.x = _x;\n      this.y = _y;\n      this.w = 1.0;\n    } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n      var p1 = arguments[0];\n      var p2 = arguments[1];\n      this.x = p1.y * p2.w - p2.y * p1.w;\n      this.y = p2.x * p1.w - p1.x * p2.w;\n      this.w = p1.x * p2.y - p2.x * p1.y;\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      var p1$1 = arguments[0];\n      var p2$1 = arguments[1];\n      this.x = p1$1.y - p2$1.y;\n      this.y = p2$1.x - p1$1.x;\n      this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;\n    }\n  } else if (arguments.length === 3) {\n    var _x$1 = arguments[0];\n    var _y$1 = arguments[1];\n    var _w = arguments[2];\n    this.x = _x$1;\n    this.y = _y$1;\n    this.w = _w;\n  } else if (arguments.length === 4) {\n    var p1$2 = arguments[0];\n    var p2$2 = arguments[1];\n    var q1 = arguments[2];\n    var q2 = arguments[3];\n    var px = p1$2.y - p2$2.y;\n    var py = p2$2.x - p1$2.x;\n    var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;\n    var qx = q1.y - q2.y;\n    var qy = q2.x - q1.x;\n    var qw = q1.x * q2.y - q2.x * q1.y;\n    this.x = py * qw - qy * pw;\n    this.y = qx * pw - px * qw;\n    this.w = px * qy - qx * py;\n  }\n};\nHCoordinate.prototype.getY = function getY () {\n  var a = this.y / this.w;\n  if (Double.isNaN(a) || Double.isInfinite(a)) {\n    throw new NotRepresentableException()\n  }\n  return a\n};\nHCoordinate.prototype.getX = function getX () {\n  var a = this.x / this.w;\n  if (Double.isNaN(a) || Double.isInfinite(a)) {\n    throw new NotRepresentableException()\n  }\n  return a\n};\nHCoordinate.prototype.getCoordinate = function getCoordinate () {\n  var p = new Coordinate();\n  p.x = this.getX();\n  p.y = this.getY();\n  return p\n};\nHCoordinate.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nHCoordinate.prototype.getClass = function getClass () {\n  return HCoordinate\n};\nHCoordinate.intersection = function intersection (p1, p2, q1, q2) {\n  var px = p1.y - p2.y;\n  var py = p2.x - p1.x;\n  var pw = p1.x * p2.y - p2.x * p1.y;\n  var qx = q1.y - q2.y;\n  var qy = q2.x - q1.x;\n  var qw = q1.x * q2.y - q2.x * q1.y;\n  var x = py * qw - qy * pw;\n  var y = qx * pw - px * qw;\n  var w = px * qy - qx * py;\n  var xInt = x / w;\n  var yInt = y / w;\n  if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {\n    throw new NotRepresentableException()\n  }\n  return new Coordinate(xInt, yInt)\n};\n\nvar Envelope = function Envelope () {\n  this._minx = null;\n  this._maxx = null;\n  this._miny = null;\n  this._maxy = null;\n  if (arguments.length === 0) {\n    this.init();\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.init(p.x, p.x, p.y, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var env = arguments[0];\n      this.init(env);\n    }\n  } else if (arguments.length === 2) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    this.init(p1.x, p2.x, p1.y, p2.y);\n  } else if (arguments.length === 4) {\n    var x1 = arguments[0];\n    var x2 = arguments[1];\n    var y1 = arguments[2];\n    var y2 = arguments[3];\n    this.init(x1, x2, y1, y2);\n  }\n};\n\nvar staticAccessors$9 = { serialVersionUID: { configurable: true } };\nEnvelope.prototype.getArea = function getArea () {\n  return this.getWidth() * this.getHeight()\n};\nEnvelope.prototype.equals = function equals (other) {\n  if (!(other instanceof Envelope)) {\n    return false\n  }\n  var otherEnvelope = other;\n  if (this.isNull()) {\n    return otherEnvelope.isNull()\n  }\n  return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY()\n};\nEnvelope.prototype.intersection = function intersection (env) {\n  if (this.isNull() || env.isNull() || !this.intersects(env)) { return new Envelope() }\n  var intMinX = this._minx > env._minx ? this._minx : env._minx;\n  var intMinY = this._miny > env._miny ? this._miny : env._miny;\n  var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n  var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n  return new Envelope(intMinX, intMaxX, intMinY, intMaxY)\n};\nEnvelope.prototype.isNull = function isNull () {\n  return this._maxx < this._minx\n};\nEnvelope.prototype.getMaxX = function getMaxX () {\n  return this._maxx\n};\nEnvelope.prototype.covers = function covers () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.covers(p.x, p.y)\n    } else if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (this.isNull() || other.isNull()) {\n        return false\n      }\n      return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) { return false }\n    return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy\n  }\n};\nEnvelope.prototype.intersects = function intersects () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (this.isNull() || other.isNull()) {\n        return false\n      }\n      return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny)\n    } else if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.intersects(p.x, p.y)\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) { return false }\n    return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny)\n  }\n};\nEnvelope.prototype.getMinY = function getMinY () {\n  return this._miny\n};\nEnvelope.prototype.getMinX = function getMinX () {\n  return this._minx\n};\nEnvelope.prototype.expandToInclude = function expandToInclude () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.expandToInclude(p.x, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (other.isNull()) {\n        return null\n      }\n      if (this.isNull()) {\n        this._minx = other.getMinX();\n        this._maxx = other.getMaxX();\n        this._miny = other.getMinY();\n        this._maxy = other.getMaxY();\n      } else {\n        if (other._minx < this._minx) {\n          this._minx = other._minx;\n        }\n        if (other._maxx > this._maxx) {\n          this._maxx = other._maxx;\n        }\n        if (other._miny < this._miny) {\n          this._miny = other._miny;\n        }\n        if (other._maxy > this._maxy) {\n          this._maxy = other._maxy;\n        }\n      }\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) {\n      this._minx = x;\n      this._maxx = x;\n      this._miny = y;\n      this._maxy = y;\n    } else {\n      if (x < this._minx) {\n        this._minx = x;\n      }\n      if (x > this._maxx) {\n        this._maxx = x;\n      }\n      if (y < this._miny) {\n        this._miny = y;\n      }\n      if (y > this._maxy) {\n        this._maxy = y;\n      }\n    }\n  }\n};\nEnvelope.prototype.minExtent = function minExtent () {\n  if (this.isNull()) { return 0.0 }\n  var w = this.getWidth();\n  var h = this.getHeight();\n  if (w < h) { return w }\n  return h\n};\nEnvelope.prototype.getWidth = function getWidth () {\n  if (this.isNull()) {\n    return 0\n  }\n  return this._maxx - this._minx\n};\nEnvelope.prototype.compareTo = function compareTo (o) {\n  var env = o;\n  if (this.isNull()) {\n    if (env.isNull()) { return 0 }\n    return -1\n  } else {\n    if (env.isNull()) { return 1 }\n  }\n  if (this._minx < env._minx) { return -1 }\n  if (this._minx > env._minx) { return 1 }\n  if (this._miny < env._miny) { return -1 }\n  if (this._miny > env._miny) { return 1 }\n  if (this._maxx < env._maxx) { return -1 }\n  if (this._maxx > env._maxx) { return 1 }\n  if (this._maxy < env._maxy) { return -1 }\n  if (this._maxy > env._maxy) { return 1 }\n  return 0\n};\nEnvelope.prototype.translate = function translate (transX, transY) {\n  if (this.isNull()) {\n    return null\n  }\n  this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n};\nEnvelope.prototype.toString = function toString () {\n  return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'\n};\nEnvelope.prototype.setToNull = function setToNull () {\n  this._minx = 0;\n  this._maxx = -1;\n  this._miny = 0;\n  this._maxy = -1;\n};\nEnvelope.prototype.getHeight = function getHeight () {\n  if (this.isNull()) {\n    return 0\n  }\n  return this._maxy - this._miny\n};\nEnvelope.prototype.maxExtent = function maxExtent () {\n  if (this.isNull()) { return 0.0 }\n  var w = this.getWidth();\n  var h = this.getHeight();\n  if (w > h) { return w }\n  return h\n};\nEnvelope.prototype.expandBy = function expandBy () {\n  if (arguments.length === 1) {\n    var distance = arguments[0];\n    this.expandBy(distance, distance);\n  } else if (arguments.length === 2) {\n    var deltaX = arguments[0];\n    var deltaY = arguments[1];\n    if (this.isNull()) { return null }\n    this._minx -= deltaX;\n    this._maxx += deltaX;\n    this._miny -= deltaY;\n    this._maxy += deltaY;\n    if (this._minx > this._maxx || this._miny > this._maxy) { this.setToNull(); }\n  }\n};\nEnvelope.prototype.contains = function contains () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      return this.covers(other)\n    } else if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.covers(p)\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    return this.covers(x, y)\n  }\n};\nEnvelope.prototype.centre = function centre () {\n  if (this.isNull()) { return null }\n  return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0)\n};\nEnvelope.prototype.init = function init () {\n  if (arguments.length === 0) {\n    this.setToNull();\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.init(p.x, p.x, p.y, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var env = arguments[0];\n      this._minx = env._minx;\n      this._maxx = env._maxx;\n      this._miny = env._miny;\n      this._maxy = env._maxy;\n    }\n  } else if (arguments.length === 2) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    this.init(p1.x, p2.x, p1.y, p2.y);\n  } else if (arguments.length === 4) {\n    var x1 = arguments[0];\n    var x2 = arguments[1];\n    var y1 = arguments[2];\n    var y2 = arguments[3];\n    if (x1 < x2) {\n      this._minx = x1;\n      this._maxx = x2;\n    } else {\n      this._minx = x2;\n      this._maxx = x1;\n    }\n    if (y1 < y2) {\n      this._miny = y1;\n      this._maxy = y2;\n    } else {\n      this._miny = y2;\n      this._maxy = y1;\n    }\n  }\n};\nEnvelope.prototype.getMaxY = function getMaxY () {\n  return this._maxy\n};\nEnvelope.prototype.distance = function distance (env) {\n  if (this.intersects(env)) { return 0 }\n  var dx = 0.0;\n  if (this._maxx < env._minx) { dx = env._minx - this._maxx; } else if (this._minx > env._maxx) { dx = this._minx - env._maxx; }\n  var dy = 0.0;\n  if (this._maxy < env._miny) { dy = env._miny - this._maxy; } else if (this._miny > env._maxy) { dy = this._miny - env._maxy; }\n  if (dx === 0.0) { return dy }\n  if (dy === 0.0) { return dx }\n  return Math.sqrt(dx * dx + dy * dy)\n};\nEnvelope.prototype.hashCode = function hashCode () {\n  var result = 17;\n  result = 37 * result + Coordinate.hashCode(this._minx);\n  result = 37 * result + Coordinate.hashCode(this._maxx);\n  result = 37 * result + Coordinate.hashCode(this._miny);\n  result = 37 * result + Coordinate.hashCode(this._maxy);\n  return result\n};\nEnvelope.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Serializable]\n};\nEnvelope.prototype.getClass = function getClass () {\n  return Envelope\n};\nEnvelope.intersects = function intersects () {\n  if (arguments.length === 3) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    var q = arguments[2];\n    if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {\n      return true\n    }\n    return false\n  } else if (arguments.length === 4) {\n    var p1$1 = arguments[0];\n    var p2$1 = arguments[1];\n    var q1 = arguments[2];\n    var q2 = arguments[3];\n    var minq = Math.min(q1.x, q2.x);\n    var maxq = Math.max(q1.x, q2.x);\n    var minp = Math.min(p1$1.x, p2$1.x);\n    var maxp = Math.max(p1$1.x, p2$1.x);\n    if (minp > maxq) { return false }\n    if (maxp < minq) { return false }\n    minq = Math.min(q1.y, q2.y);\n    maxq = Math.max(q1.y, q2.y);\n    minp = Math.min(p1$1.y, p2$1.y);\n    maxp = Math.max(p1$1.y, p2$1.y);\n    if (minp > maxq) { return false }\n    if (maxp < minq) { return false }\n    return true\n  }\n};\nstaticAccessors$9.serialVersionUID.get = function () { return 5873921885273102420 };\n\nObject.defineProperties( Envelope, staticAccessors$9 );\n\nvar regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n};\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/** Create a new parser for WKT\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of WKTParser.\n * @constructor\n * @private\n */\nvar WKTParser = function WKTParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n};\n/**\n * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n * and GEOMETRYCOLLECTION.\n *\n * @param {String} wkt A WKT string.\n * @return {Geometry} A geometry instance.\n * @private\n */\nWKTParser.prototype.read = function read (wkt) {\n  var geometry, type, str;\n  wkt = wkt.replace(/[\\n\\r]/g, ' ');\n  var matches = regExes.typeStr.exec(wkt);\n  if (wkt.search('EMPTY') !== -1) {\n    matches = regExes.emptyTypeStr.exec(wkt);\n    matches[2] = undefined;\n  }\n  if (matches) {\n    type = matches[1].toLowerCase();\n    str = matches[2];\n    if (parse$1[type]) {\n      geometry = parse$1[type].apply(this, [str]);\n    }\n  }\n\n  if (geometry === undefined) { throw new Error('Could not parse WKT ' + wkt) }\n\n  return geometry\n};\n\n/**\n * Serialize a geometry into a WKT string.\n *\n * @param {Geometry} geometry A feature or array of features.\n * @return {String} The WKT string representation of the input geometries.\n * @private\n */\nWKTParser.prototype.write = function write (geometry) {\n  return this.extractGeometry(geometry)\n};\n\n/**\n * Entry point to construct the WKT for a single Geometry object.\n *\n * @param {Geometry} geometry\n * @return {String} A WKT string of representing the geometry.\n * @private\n */\nWKTParser.prototype.extractGeometry = function extractGeometry (geometry) {\n  var type = geometry.getGeometryType().toLowerCase();\n  if (!extract$1[type]) {\n    return null\n  }\n  var wktType = type.toUpperCase();\n  var data;\n  if (geometry.isEmpty()) {\n    data = wktType + ' EMPTY';\n  } else {\n    data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';\n  }\n  return data\n};\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nvar extract$1 = {\n  coordinate: function coordinate (coordinate$1) {\n    return coordinate$1.x + ' ' + coordinate$1.y\n  },\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point: function point (point$1) {\n    return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0])\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint: function multipoint (multipoint$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multipoint$1._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.point.apply(this$1, [multipoint$1._geometries[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring: function linestring (linestring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = linestring$1._points._coordinates.length; i < len; ++i) {\n      array.push(extract$1.coordinate.apply(this$1, [linestring$1._points._coordinates[i]]));\n    }\n    return array.join(',')\n  },\n\n  linearring: function linearring (linearring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = linearring$1._points._coordinates.length; i < len; ++i) {\n      array.push(extract$1.coordinate.apply(this$1, [linearring$1._points._coordinates[i]]));\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring: function multilinestring (multilinestring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multilinestring$1._geometries.length; i < len; ++i) {\n      array.push('(' +\n        extract$1.linestring.apply(this$1, [multilinestring$1._geometries[i]]) +\n        ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon: function polygon (polygon$1) {\n    var this$1 = this;\n\n    var array = [];\n    array.push('(' + extract$1.linestring.apply(this, [polygon$1._shell]) + ')');\n    for (var i = 0, len = polygon$1._holes.length; i < len; ++i) {\n      array.push('(' + extract$1.linestring.apply(this$1, [polygon$1._holes[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon: function multipolygon (multipolygon$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multipolygon$1._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.polygon.apply(this$1, [multipolygon$1._geometries[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection: function geometrycollection (collection) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = collection._geometries.length; i < len; ++i) {\n      array.push(this$1.extractGeometry(collection._geometries[i]));\n    }\n    return array.join(',')\n  }\n};\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nvar parse$1 = {\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point: function point (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPoint()\n    }\n\n    var coords = str.trim().split(regExes.spaces);\n    return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]),\n      Number.parseFloat(coords[1])))\n  },\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint: function multipoint (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPoint()\n    }\n\n    var point;\n    var points = str.trim().split(',');\n    var components = [];\n    for (var i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.point.apply(this$1, [point]));\n    }\n    return this.geometryFactory.createMultiPoint(components)\n  },\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring: function linestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString()\n    }\n\n    var points = str.trim().split(',');\n    var components = [];\n    var coords;\n    for (var i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces);\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    }\n    return this.geometryFactory.createLineString(components)\n  },\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring: function linearring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing()\n    }\n\n    var points = str.trim().split(',');\n    var components = [];\n    var coords;\n    for (var i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces);\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    }\n    return this.geometryFactory.createLinearRing(components)\n  },\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring: function multilinestring (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString()\n    }\n\n    var line;\n    var lines = str.trim().split(regExes.parenComma);\n    var components = [];\n    for (var i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.linestring.apply(this$1, [line]));\n    }\n    return this.geometryFactory.createMultiLineString(components)\n  },\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon: function polygon (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon()\n    }\n\n    var ring, linestring, linearring;\n    var rings = str.trim().split(regExes.parenComma);\n    var shell;\n    var holes = [];\n    for (var i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1');\n      linestring = parse$1.linestring.apply(this$1, [ring]);\n      linearring = this$1.geometryFactory.createLinearRing(linestring._points);\n      if (i === 0) {\n        shell = linearring;\n      } else {\n        holes.push(linearring);\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon: function multipolygon (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon()\n    }\n\n    var polygon;\n    var polygons = str.trim().split(regExes.doubleParenComma);\n    var components = [];\n    for (var i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.polygon.apply(this$1, [polygon]));\n    }\n    return this.geometryFactory.createMultiPolygon(components)\n  },\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection: function geometrycollection (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection()\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1');\n    var wktArray = str.trim().split('|');\n    var components = [];\n    for (var i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this$1.read(wktArray[i]));\n    }\n    return this.geometryFactory.createGeometryCollection(components)\n  }\n};\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\n\n/**\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar WKTWriter = function WKTWriter (geometryFactory) {\n  this.parser = new WKTParser(geometryFactory);\n};\n\n/**\n * Converts a <code>Geometry</code> to its Well-known Text representation.\n *\n * @param {Geometry} geometry a <code>Geometry</code> to process.\n * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n *       Features Specification).\n * @memberof WKTWriter\n */\nWKTWriter.prototype.write = function write (geometry) {\n  return this.parser.write(geometry)\n};\n/**\n * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n * {@link Coordinate}s.\n *\n * @param p0 the first coordinate.\n * @param p1 the second coordinate.\n *\n * @return the WKT.\n * @private\n */\nWKTWriter.toLineString = function toLineString (p0, p1) {\n  if (arguments.length !== 2) {\n    throw new Error('Not implemented')\n  }\n  return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n};\n\nvar RuntimeException = (function (Error) {\n  function RuntimeException (message) {\n    Error.call(this, message);\n    this.name = 'RuntimeException';\n    this.message = message;\n    this.stack = (new Error()).stack;\n  }\n\n  if ( Error ) RuntimeException.__proto__ = Error;\n  RuntimeException.prototype = Object.create( Error && Error.prototype );\n  RuntimeException.prototype.constructor = RuntimeException;\n\n  return RuntimeException;\n}(Error));\n\nvar AssertionFailedException = (function (RuntimeException$$1) {\n  function AssertionFailedException () {\n    RuntimeException$$1.call(this);\n    if (arguments.length === 0) {\n      RuntimeException$$1.call(this);\n    } else if (arguments.length === 1) {\n      var message = arguments[0];\n      RuntimeException$$1.call(this, message);\n    }\n  }\n\n  if ( RuntimeException$$1 ) AssertionFailedException.__proto__ = RuntimeException$$1;\n  AssertionFailedException.prototype = Object.create( RuntimeException$$1 && RuntimeException$$1.prototype );\n  AssertionFailedException.prototype.constructor = AssertionFailedException;\n  AssertionFailedException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  AssertionFailedException.prototype.getClass = function getClass () {\n    return AssertionFailedException\n  };\n\n  return AssertionFailedException;\n}(RuntimeException));\n\nvar Assert = function Assert () {};\n\nAssert.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nAssert.prototype.getClass = function getClass () {\n  return Assert\n};\nAssert.shouldNeverReachHere = function shouldNeverReachHere () {\n  if (arguments.length === 0) {\n    Assert.shouldNeverReachHere(null);\n  } else if (arguments.length === 1) {\n    var message = arguments[0];\n    throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''))\n  }\n};\nAssert.isTrue = function isTrue () {\n  var assertion;\n  var message;\n  if (arguments.length === 1) {\n    assertion = arguments[0];\n    Assert.isTrue(assertion, null);\n  } else if (arguments.length === 2) {\n    assertion = arguments[0];\n    message = arguments[1];\n    if (!assertion) {\n      if (message === null) {\n        throw new AssertionFailedException()\n      } else {\n        throw new AssertionFailedException(message)\n      }\n    }\n  }\n};\nAssert.equals = function equals () {\n  var expectedValue;\n  var actualValue;\n  var message;\n  if (arguments.length === 2) {\n    expectedValue = arguments[0];\n    actualValue = arguments[1];\n    Assert.equals(expectedValue, actualValue, null);\n  } else if (arguments.length === 3) {\n    expectedValue = arguments[0];\n    actualValue = arguments[1];\n    message = arguments[2];\n    if (!actualValue.equals(expectedValue)) {\n      throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''))\n    }\n  }\n};\n\nvar LineIntersector = function LineIntersector () {\n  this._result = null;\n  this._inputLines = Array(2).fill().map(function () { return Array(2); });\n  this._intPt = new Array(2).fill(null);\n  this._intLineIndex = null;\n  this._isProper = null;\n  this._pa = null;\n  this._pb = null;\n  this._precisionModel = null;\n  this._intPt[0] = new Coordinate();\n  this._intPt[1] = new Coordinate();\n  this._pa = this._intPt[0];\n  this._pb = this._intPt[1];\n  this._result = 0;\n};\n\nvar staticAccessors$10 = { DONT_INTERSECT: { configurable: true },DO_INTERSECT: { configurable: true },COLLINEAR: { configurable: true },NO_INTERSECTION: { configurable: true },POINT_INTERSECTION: { configurable: true },COLLINEAR_INTERSECTION: { configurable: true } };\nLineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment (segmentIndex, intIndex) {\n  this.computeIntLineIndex();\n  return this._intLineIndex[segmentIndex][intIndex]\n};\nLineIntersector.prototype.getTopologySummary = function getTopologySummary () {\n  var catBuf = new StringBuffer();\n  if (this.isEndPoint()) { catBuf.append(' endpoint'); }\n  if (this._isProper) { catBuf.append(' proper'); }\n  if (this.isCollinear()) { catBuf.append(' collinear'); }\n  return catBuf.toString()\n};\nLineIntersector.prototype.computeIntersection = function computeIntersection (p1, p2, p3, p4) {\n  this._inputLines[0][0] = p1;\n  this._inputLines[0][1] = p2;\n  this._inputLines[1][0] = p3;\n  this._inputLines[1][1] = p4;\n  this._result = this.computeIntersect(p1, p2, p3, p4);\n};\nLineIntersector.prototype.getIntersectionNum = function getIntersectionNum () {\n  return this._result\n};\nLineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex () {\n  if (arguments.length === 0) {\n    if (this._intLineIndex === null) {\n      this._intLineIndex = Array(2).fill().map(function () { return Array(2); });\n      this.computeIntLineIndex(0);\n      this.computeIntLineIndex(1);\n    }\n  } else if (arguments.length === 1) {\n    var segmentIndex = arguments[0];\n    var dist0 = this.getEdgeDistance(segmentIndex, 0);\n    var dist1 = this.getEdgeDistance(segmentIndex, 1);\n    if (dist0 > dist1) {\n      this._intLineIndex[segmentIndex][0] = 0;\n      this._intLineIndex[segmentIndex][1] = 1;\n    } else {\n      this._intLineIndex[segmentIndex][0] = 1;\n      this._intLineIndex[segmentIndex][1] = 0;\n    }\n  }\n};\nLineIntersector.prototype.isProper = function isProper () {\n  return this.hasIntersection() && this._isProper\n};\nLineIntersector.prototype.setPrecisionModel = function setPrecisionModel (precisionModel) {\n  this._precisionModel = precisionModel;\n};\nLineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isInteriorIntersection(0)) { return true }\n    if (this.isInteriorIntersection(1)) { return true }\n    return false\n  } else if (arguments.length === 1) {\n    var inputLineIndex = arguments[0];\n    for (var i = 0; i < this._result; i++) {\n      if (!(this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][0]) || this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][1]))) {\n        return true\n      }\n    }\n    return false\n  }\n};\nLineIntersector.prototype.getIntersection = function getIntersection (intIndex) {\n  return this._intPt[intIndex]\n};\nLineIntersector.prototype.isEndPoint = function isEndPoint () {\n  return this.hasIntersection() && !this._isProper\n};\nLineIntersector.prototype.hasIntersection = function hasIntersection () {\n  return this._result !== LineIntersector.NO_INTERSECTION\n};\nLineIntersector.prototype.getEdgeDistance = function getEdgeDistance (segmentIndex, intIndex) {\n  var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n  return dist\n};\nLineIntersector.prototype.isCollinear = function isCollinear () {\n  return this._result === LineIntersector.COLLINEAR_INTERSECTION\n};\nLineIntersector.prototype.toString = function toString () {\n  return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()\n};\nLineIntersector.prototype.getEndpoint = function getEndpoint (segmentIndex, ptIndex) {\n  return this._inputLines[segmentIndex][ptIndex]\n};\nLineIntersector.prototype.isIntersection = function isIntersection (pt) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._result; i++) {\n    if (this$1._intPt[i].equals2D(pt)) {\n      return true\n    }\n  }\n  return false\n};\nLineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment (segmentIndex, intIndex) {\n  this.computeIntLineIndex();\n  return this._intPt[this._intLineIndex[segmentIndex][intIndex]]\n};\nLineIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineIntersector.prototype.getClass = function getClass () {\n  return LineIntersector\n};\nLineIntersector.computeEdgeDistance = function computeEdgeDistance (p, p0, p1) {\n  var dx = Math.abs(p1.x - p0.x);\n  var dy = Math.abs(p1.y - p0.y);\n  var dist = -1.0;\n  if (p.equals(p0)) {\n    dist = 0.0;\n  } else if (p.equals(p1)) {\n    if (dx > dy) { dist = dx; } else { dist = dy; }\n  } else {\n    var pdx = Math.abs(p.x - p0.x);\n    var pdy = Math.abs(p.y - p0.y);\n    if (dx > dy) { dist = pdx; } else { dist = pdy; }\n    if (dist === 0.0 && !p.equals(p0)) {\n      dist = Math.max(pdx, pdy);\n    }\n  }\n  Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');\n  return dist\n};\nLineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance (p, p1, p2) {\n  var dx = p.x - p1.x;\n  var dy = p.y - p1.y;\n  var dist = Math.sqrt(dx * dx + dy * dy);\n  Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');\n  return dist\n};\nstaticAccessors$10.DONT_INTERSECT.get = function () { return 0 };\nstaticAccessors$10.DO_INTERSECT.get = function () { return 1 };\nstaticAccessors$10.COLLINEAR.get = function () { return 2 };\nstaticAccessors$10.NO_INTERSECTION.get = function () { return 0 };\nstaticAccessors$10.POINT_INTERSECTION.get = function () { return 1 };\nstaticAccessors$10.COLLINEAR_INTERSECTION.get = function () { return 2 };\n\nObject.defineProperties( LineIntersector, staticAccessors$10 );\n\nvar RobustLineIntersector = (function (LineIntersector$$1) {\n  function RobustLineIntersector () {\n    LineIntersector$$1.apply(this, arguments);\n  }\n\n  if ( LineIntersector$$1 ) RobustLineIntersector.__proto__ = LineIntersector$$1;\n  RobustLineIntersector.prototype = Object.create( LineIntersector$$1 && LineIntersector$$1.prototype );\n  RobustLineIntersector.prototype.constructor = RobustLineIntersector;\n\n  RobustLineIntersector.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes (intPt) {\n    var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n    var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n    return env0.contains(intPt) && env1.contains(intPt)\n  };\n  RobustLineIntersector.prototype.computeIntersection = function computeIntersection () {\n    if (arguments.length === 3) {\n      var p = arguments[0];\n      var p1 = arguments[1];\n      var p2 = arguments[2];\n      this._isProper = false;\n      if (Envelope.intersects(p1, p2, p)) {\n        if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {\n          this._isProper = true;\n          if (p.equals(p1) || p.equals(p2)) {\n            this._isProper = false;\n          }\n          this._result = LineIntersector$$1.POINT_INTERSECTION;\n          return null\n        }\n      }\n      this._result = LineIntersector$$1.NO_INTERSECTION;\n    } else { return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments) }\n  };\n  RobustLineIntersector.prototype.normalizeToMinimum = function normalizeToMinimum (n1, n2, n3, n4, normPt) {\n    normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n    normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n    n1.x -= normPt.x;\n    n1.y -= normPt.y;\n    n2.x -= normPt.x;\n    n2.y -= normPt.y;\n    n3.x -= normPt.x;\n    n3.y -= normPt.y;\n    n4.x -= normPt.x;\n    n4.y -= normPt.y;\n  };\n  RobustLineIntersector.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection (p1, p2, q1, q2) {\n    var intPt = null;\n    try {\n      intPt = HCoordinate.intersection(p1, p2, q1, q2);\n    } catch (e) {\n      if (e instanceof NotRepresentableException) {\n        intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n      } else { throw e }\n    } finally {}\n    return intPt\n  };\n  RobustLineIntersector.prototype.intersection = function intersection (p1, p2, q1, q2) {\n    var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n    if (!this.isInSegmentEnvelopes(intPt)) {\n      intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n    }\n    if (this._precisionModel !== null) {\n      this._precisionModel.makePrecise(intPt);\n    }\n    return intPt\n  };\n  RobustLineIntersector.prototype.smallestInAbsValue = function smallestInAbsValue (x1, x2, x3, x4) {\n    var x = x1;\n    var xabs = Math.abs(x);\n    if (Math.abs(x2) < xabs) {\n      x = x2;\n      xabs = Math.abs(x2);\n    }\n    if (Math.abs(x3) < xabs) {\n      x = x3;\n      xabs = Math.abs(x3);\n    }\n    if (Math.abs(x4) < xabs) {\n      x = x4;\n    }\n    return x\n  };\n  RobustLineIntersector.prototype.checkDD = function checkDD (p1, p2, q1, q2, intPt) {\n    var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n    var isIn = this.isInSegmentEnvelopes(intPtDD);\n    System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);\n    if (intPt.distance(intPtDD) > 0.0001) {\n      System.out.println('Distance = ' + intPt.distance(intPtDD));\n    }\n  };\n  RobustLineIntersector.prototype.intersectionWithNormalization = function intersectionWithNormalization (p1, p2, q1, q2) {\n    var n1 = new Coordinate(p1);\n    var n2 = new Coordinate(p2);\n    var n3 = new Coordinate(q1);\n    var n4 = new Coordinate(q2);\n    var normPt = new Coordinate();\n    this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n    var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n    intPt.x += normPt.x;\n    intPt.y += normPt.y;\n    return intPt\n  };\n  RobustLineIntersector.prototype.computeCollinearIntersection = function computeCollinearIntersection (p1, p2, q1, q2) {\n    var p1q1p2 = Envelope.intersects(p1, p2, q1);\n    var p1q2p2 = Envelope.intersects(p1, p2, q2);\n    var q1p1q2 = Envelope.intersects(q1, q2, p1);\n    var q1p2q2 = Envelope.intersects(q1, q2, p2);\n    if (p1q1p2 && p1q2p2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = q2;\n      return LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (q1p1q2 && q1p2q2) {\n      this._intPt[0] = p1;\n      this._intPt[1] = p2;\n      return LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p1q2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = p1;\n      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p2q2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = p2;\n      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p1q2) {\n      this._intPt[0] = q2;\n      this._intPt[1] = p1;\n      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p2q2) {\n      this._intPt[0] = q2;\n      this._intPt[1] = p2;\n      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    return LineIntersector$$1.NO_INTERSECTION\n  };\n  RobustLineIntersector.prototype.normalizeToEnvCentre = function normalizeToEnvCentre (n00, n01, n10, n11, normPt) {\n    var minX0 = n00.x < n01.x ? n00.x : n01.x;\n    var minY0 = n00.y < n01.y ? n00.y : n01.y;\n    var maxX0 = n00.x > n01.x ? n00.x : n01.x;\n    var maxY0 = n00.y > n01.y ? n00.y : n01.y;\n    var minX1 = n10.x < n11.x ? n10.x : n11.x;\n    var minY1 = n10.y < n11.y ? n10.y : n11.y;\n    var maxX1 = n10.x > n11.x ? n10.x : n11.x;\n    var maxY1 = n10.y > n11.y ? n10.y : n11.y;\n    var intMinX = minX0 > minX1 ? minX0 : minX1;\n    var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n    var intMinY = minY0 > minY1 ? minY0 : minY1;\n    var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n    var intMidX = (intMinX + intMaxX) / 2.0;\n    var intMidY = (intMinY + intMaxY) / 2.0;\n    normPt.x = intMidX;\n    normPt.y = intMidY;\n    n00.x -= normPt.x;\n    n00.y -= normPt.y;\n    n01.x -= normPt.x;\n    n01.y -= normPt.y;\n    n10.x -= normPt.x;\n    n10.y -= normPt.y;\n    n11.x -= normPt.x;\n    n11.y -= normPt.y;\n  };\n  RobustLineIntersector.prototype.computeIntersect = function computeIntersect (p1, p2, q1, q2) {\n    this._isProper = false;\n    if (!Envelope.intersects(p1, p2, q1, q2)) { return LineIntersector$$1.NO_INTERSECTION }\n    var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);\n    var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);\n    if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {\n      return LineIntersector$$1.NO_INTERSECTION\n    }\n    var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);\n    var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);\n    if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {\n      return LineIntersector$$1.NO_INTERSECTION\n    }\n    var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n    if (collinear) {\n      return this.computeCollinearIntersection(p1, p2, q1, q2)\n    }\n    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n      this._isProper = false;\n      if (p1.equals2D(q1) || p1.equals2D(q2)) {\n        this._intPt[0] = p1;\n      } else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n        this._intPt[0] = p2;\n      } else if (Pq1 === 0) {\n        this._intPt[0] = new Coordinate(q1);\n      } else if (Pq2 === 0) {\n        this._intPt[0] = new Coordinate(q2);\n      } else if (Qp1 === 0) {\n        this._intPt[0] = new Coordinate(p1);\n      } else if (Qp2 === 0) {\n        this._intPt[0] = new Coordinate(p2);\n      }\n    } else {\n      this._isProper = true;\n      this._intPt[0] = this.intersection(p1, p2, q1, q2);\n    }\n    return LineIntersector$$1.POINT_INTERSECTION\n  };\n  RobustLineIntersector.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  RobustLineIntersector.prototype.getClass = function getClass () {\n    return RobustLineIntersector\n  };\n  RobustLineIntersector.nearestEndpoint = function nearestEndpoint (p1, p2, q1, q2) {\n    var nearestPt = p1;\n    var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);\n    var dist = CGAlgorithms.distancePointLine(p2, q1, q2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = p2;\n    }\n    dist = CGAlgorithms.distancePointLine(q1, p1, p2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = q1;\n    }\n    dist = CGAlgorithms.distancePointLine(q2, p1, p2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = q2;\n    }\n    return nearestPt\n  };\n\n  return RobustLineIntersector;\n}(LineIntersector));\n\nvar RobustDeterminant = function RobustDeterminant () {};\n\nRobustDeterminant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRobustDeterminant.prototype.getClass = function getClass () {\n  return RobustDeterminant\n};\nRobustDeterminant.orientationIndex = function orientationIndex (p1, p2, q) {\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dx2 = q.x - p2.x;\n  var dy2 = q.y - p2.y;\n  return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2)\n};\nRobustDeterminant.signOfDet2x2 = function signOfDet2x2 (x1, y1, x2, y2) {\n  var sign = null;\n  var swap = null;\n  var k = null;\n  sign = 1;\n  if (x1 === 0.0 || y2 === 0.0) {\n    if (y1 === 0.0 || x2 === 0.0) {\n      return 0\n    } else if (y1 > 0) {\n      if (x2 > 0) {\n        return -sign\n      } else {\n        return sign\n      }\n    } else {\n      if (x2 > 0) {\n        return sign\n      } else {\n        return -sign\n      }\n    }\n  }\n  if (y1 === 0.0 || x2 === 0.0) {\n    if (y2 > 0) {\n      if (x1 > 0) {\n        return sign\n      } else {\n        return -sign\n      }\n    } else {\n      if (x1 > 0) {\n        return -sign\n      } else {\n        return sign\n      }\n    }\n  }\n  if (y1 > 0.0) {\n    if (y2 > 0.0) {\n      if (y1 <= y2) {\n        \n      } else {\n        sign = -sign;\n        swap = x1;\n        x1 = x2;\n        x2 = swap;\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n      }\n    } else {\n      if (y1 <= -y2) {\n        sign = -sign;\n        x2 = -x2;\n        y2 = -y2;\n      } else {\n        swap = x1;\n        x1 = -x2;\n        x2 = swap;\n        swap = y1;\n        y1 = -y2;\n        y2 = swap;\n      }\n    }\n  } else {\n    if (y2 > 0.0) {\n      if (-y1 <= y2) {\n        sign = -sign;\n        x1 = -x1;\n        y1 = -y1;\n      } else {\n        swap = -x1;\n        x1 = x2;\n        x2 = swap;\n        swap = -y1;\n        y1 = y2;\n        y2 = swap;\n      }\n    } else {\n      if (y1 >= y2) {\n        x1 = -x1;\n        y1 = -y1;\n        x2 = -x2;\n        y2 = -y2;\n      } else {\n        sign = -sign;\n        swap = -x1;\n        x1 = -x2;\n        x2 = swap;\n        swap = -y1;\n        y1 = -y2;\n        y2 = swap;\n      }\n    }\n  }\n  if (x1 > 0.0) {\n    if (x2 > 0.0) {\n      if (x1 <= x2) {\n        \n      } else {\n        return sign\n      }\n    } else {\n      return sign\n    }\n  } else {\n    if (x2 > 0.0) {\n      return -sign\n    } else {\n      if (x1 >= x2) {\n        sign = -sign;\n        x1 = -x1;\n        x2 = -x2;\n      } else {\n        return -sign\n      }\n    }\n  }\n  while (true) {\n    k = Math.floor(x2 / x1);\n    x2 = x2 - k * x1;\n    y2 = y2 - k * y1;\n    if (y2 < 0.0) {\n      return -sign\n    }\n    if (y2 > y1) {\n      return sign\n    }\n    if (x1 > x2 + x2) {\n      if (y1 < y2 + y2) {\n        return sign\n      }\n    } else {\n      if (y1 > y2 + y2) {\n        return -sign\n      } else {\n        x2 = x1 - x2;\n        y2 = y1 - y2;\n        sign = -sign;\n      }\n    }\n    if (y2 === 0.0) {\n      if (x2 === 0.0) {\n        return 0\n      } else {\n        return -sign\n      }\n    }\n    if (x2 === 0.0) {\n      return sign\n    }\n    k = Math.floor(x1 / x2);\n    x1 = x1 - k * x2;\n    y1 = y1 - k * y2;\n    if (y1 < 0.0) {\n      return sign\n    }\n    if (y1 > y2) {\n      return -sign\n    }\n    if (x2 > x1 + x1) {\n      if (y2 < y1 + y1) {\n        return -sign\n      }\n    } else {\n      if (y2 > y1 + y1) {\n        return sign\n      } else {\n        x1 = x2 - x1;\n        y1 = y2 - y1;\n        sign = -sign;\n      }\n    }\n    if (y1 === 0.0) {\n      if (x1 === 0.0) {\n        return 0\n      } else {\n        return sign\n      }\n    }\n    if (x1 === 0.0) {\n      return -sign\n    }\n  }\n};\n\nvar RayCrossingCounter = function RayCrossingCounter () {\n  this._p = null;\n  this._crossingCount = 0;\n  this._isPointOnSegment = false;\n  var p = arguments[0];\n  this._p = p;\n};\nRayCrossingCounter.prototype.countSegment = function countSegment (p1, p2) {\n  if (p1.x < this._p.x && p2.x < this._p.x) { return null }\n  if (this._p.x === p2.x && this._p.y === p2.y) {\n    this._isPointOnSegment = true;\n    return null\n  }\n  if (p1.y === this._p.y && p2.y === this._p.y) {\n    var minx = p1.x;\n    var maxx = p2.x;\n    if (minx > maxx) {\n      minx = p2.x;\n      maxx = p1.x;\n    }\n    if (this._p.x >= minx && this._p.x <= maxx) {\n      this._isPointOnSegment = true;\n    }\n    return null\n  }\n  if ((p1.y > this._p.y && p2.y <= this._p.y) || (p2.y > this._p.y && p1.y <= this._p.y)) {\n    var x1 = p1.x - this._p.x;\n    var y1 = p1.y - this._p.y;\n    var x2 = p2.x - this._p.x;\n    var y2 = p2.y - this._p.y;\n    var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);\n    if (xIntSign === 0.0) {\n      this._isPointOnSegment = true;\n      return null\n    }\n    if (y2 < y1) { xIntSign = -xIntSign; }\n    if (xIntSign > 0.0) {\n      this._crossingCount++;\n    }\n  }\n};\nRayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon () {\n  return this.getLocation() !== Location.EXTERIOR\n};\nRayCrossingCounter.prototype.getLocation = function getLocation () {\n  if (this._isPointOnSegment) { return Location.BOUNDARY }\n  if (this._crossingCount % 2 === 1) {\n    return Location.INTERIOR\n  }\n  return Location.EXTERIOR\n};\nRayCrossingCounter.prototype.isOnSegment = function isOnSegment () {\n  return this._isPointOnSegment\n};\nRayCrossingCounter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRayCrossingCounter.prototype.getClass = function getClass () {\n  return RayCrossingCounter\n};\nRayCrossingCounter.locatePointInRing = function locatePointInRing () {\n  if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n    var p = arguments[0];\n    var ring = arguments[1];\n    var counter = new RayCrossingCounter(p);\n    var p1 = new Coordinate();\n    var p2 = new Coordinate();\n    for (var i = 1; i < ring.size(); i++) {\n      ring.getCoordinate(i, p1);\n      ring.getCoordinate(i - 1, p2);\n      counter.countSegment(p1, p2);\n      if (counter.isOnSegment()) { return counter.getLocation() }\n    }\n    return counter.getLocation()\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n    var p$1 = arguments[0];\n    var ring$1 = arguments[1];\n    var counter$1 = new RayCrossingCounter(p$1);\n    for (var i$1 = 1; i$1 < ring$1.length; i$1++) {\n      var p1$1 = ring$1[i$1];\n      var p2$1 = ring$1[i$1 - 1];\n      counter$1.countSegment(p1$1, p2$1);\n      if (counter$1.isOnSegment()) { return counter$1.getLocation() }\n    }\n    return counter$1.getLocation()\n  }\n};\n\nvar CGAlgorithms = function CGAlgorithms () {};\n\nvar staticAccessors$3 = { CLOCKWISE: { configurable: true },RIGHT: { configurable: true },COUNTERCLOCKWISE: { configurable: true },LEFT: { configurable: true },COLLINEAR: { configurable: true },STRAIGHT: { configurable: true } };\n\nCGAlgorithms.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCGAlgorithms.prototype.getClass = function getClass () {\n  return CGAlgorithms\n};\nCGAlgorithms.orientationIndex = function orientationIndex (p1, p2, q) {\n  return CGAlgorithmsDD.orientationIndex(p1, p2, q)\n};\nCGAlgorithms.signedArea = function signedArea () {\n  if (arguments[0] instanceof Array) {\n    var ring = arguments[0];\n    if (ring.length < 3) { return 0.0 }\n    var sum = 0.0;\n    var x0 = ring[0].x;\n    for (var i = 1; i < ring.length - 1; i++) {\n      var x = ring[i].x - x0;\n      var y1 = ring[i + 1].y;\n      var y2 = ring[i - 1].y;\n      sum += x * (y2 - y1);\n    }\n    return sum / 2.0\n  } else if (hasInterface(arguments[0], CoordinateSequence)) {\n    var ring$1 = arguments[0];\n    var n = ring$1.size();\n    if (n < 3) { return 0.0 }\n    var p0 = new Coordinate();\n    var p1 = new Coordinate();\n    var p2 = new Coordinate();\n    ring$1.getCoordinate(0, p1);\n    ring$1.getCoordinate(1, p2);\n    var x0$1 = p1.x;\n    p2.x -= x0$1;\n    var sum$1 = 0.0;\n    for (var i$1 = 1; i$1 < n - 1; i$1++) {\n      p0.y = p1.y;\n      p1.x = p2.x;\n      p1.y = p2.y;\n      ring$1.getCoordinate(i$1 + 1, p2);\n      p2.x -= x0$1;\n      sum$1 += p1.x * (p0.y - p2.y);\n    }\n    return sum$1 / 2.0\n  }\n};\nCGAlgorithms.distanceLineLine = function distanceLineLine (A, B, C, D) {\n  if (A.equals(B)) { return CGAlgorithms.distancePointLine(A, C, D) }\n  if (C.equals(D)) { return CGAlgorithms.distancePointLine(D, A, B) }\n  var noIntersection = false;\n  if (!Envelope.intersects(A, B, C, D)) {\n    noIntersection = true;\n  } else {\n    var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n    if (denom === 0) {\n      noIntersection = true;\n    } else {\n      var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n      var sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n      var s = sNum / denom;\n      var r = rNumb / denom;\n      if (r < 0 || r > 1 || s < 0 || s > 1) {\n        noIntersection = true;\n      }\n    }\n  }\n  if (noIntersection) {\n    return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B))\n  }\n  return 0.0\n};\nCGAlgorithms.isPointInRing = function isPointInRing (p, ring) {\n  return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR\n};\nCGAlgorithms.computeLength = function computeLength (pts) {\n  var n = pts.size();\n  if (n <= 1) { return 0.0 }\n  var len = 0.0;\n  var p = new Coordinate();\n  pts.getCoordinate(0, p);\n  var x0 = p.x;\n  var y0 = p.y;\n  for (var i = 1; i < n; i++) {\n    pts.getCoordinate(i, p);\n    var x1 = p.x;\n    var y1 = p.y;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    len += Math.sqrt(dx * dx + dy * dy);\n    x0 = x1;\n    y0 = y1;\n  }\n  return len\n};\nCGAlgorithms.isCCW = function isCCW (ring) {\n  var nPts = ring.length - 1;\n  if (nPts < 3) { throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined') }\n  var hiPt = ring[0];\n  var hiIndex = 0;\n  for (var i = 1; i <= nPts; i++) {\n    var p = ring[i];\n    if (p.y > hiPt.y) {\n      hiPt = p;\n      hiIndex = i;\n    }\n  }\n  var iPrev = hiIndex;\n  do {\n    iPrev = iPrev - 1;\n    if (iPrev < 0) { iPrev = nPts; }\n  } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex)\n  var iNext = hiIndex;\n  do {\n    iNext = (iNext + 1) % nPts;\n  } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex)\n  var prev = ring[iPrev];\n  var next = ring[iNext];\n  if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) { return false }\n  var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n  var isCCW = false;\n  if (disc === 0) {\n    isCCW = prev.x > next.x;\n  } else {\n    isCCW = disc > 0;\n  }\n  return isCCW\n};\nCGAlgorithms.locatePointInRing = function locatePointInRing (p, ring) {\n  return RayCrossingCounter.locatePointInRing(p, ring)\n};\nCGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular (p, A, B) {\n  var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  return Math.abs(s) * Math.sqrt(len2)\n};\nCGAlgorithms.computeOrientation = function computeOrientation (p1, p2, q) {\n  return CGAlgorithms.orientationIndex(p1, p2, q)\n};\nCGAlgorithms.distancePointLine = function distancePointLine () {\n  if (arguments.length === 2) {\n    var p = arguments[0];\n    var line = arguments[1];\n    if (line.length === 0) { throw new IllegalArgumentException('Line array must contain at least one vertex') }\n    var minDistance = p.distance(line[0]);\n    for (var i = 0; i < line.length - 1; i++) {\n      var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n      if (dist < minDistance) {\n        minDistance = dist;\n      }\n    }\n    return minDistance\n  } else if (arguments.length === 3) {\n    var p$1 = arguments[0];\n    var A = arguments[1];\n    var B = arguments[2];\n    if (A.x === B.x && A.y === B.y) { return p$1.distance(A) }\n    var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n    var r = ((p$1.x - A.x) * (B.x - A.x) + (p$1.y - A.y) * (B.y - A.y)) / len2;\n    if (r <= 0.0) { return p$1.distance(A) }\n    if (r >= 1.0) { return p$1.distance(B) }\n    var s = ((A.y - p$1.y) * (B.x - A.x) - (A.x - p$1.x) * (B.y - A.y)) / len2;\n    return Math.abs(s) * Math.sqrt(len2)\n  }\n};\nCGAlgorithms.isOnLine = function isOnLine (p, pt) {\n  var lineIntersector = new RobustLineIntersector();\n  for (var i = 1; i < pt.length; i++) {\n    var p0 = pt[i - 1];\n    var p1 = pt[i];\n    lineIntersector.computeIntersection(p, p0, p1);\n    if (lineIntersector.hasIntersection()) {\n      return true\n    }\n  }\n  return false\n};\nstaticAccessors$3.CLOCKWISE.get = function () { return -1 };\nstaticAccessors$3.RIGHT.get = function () { return CGAlgorithms.CLOCKWISE };\nstaticAccessors$3.COUNTERCLOCKWISE.get = function () { return 1 };\nstaticAccessors$3.LEFT.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };\nstaticAccessors$3.COLLINEAR.get = function () { return 0 };\nstaticAccessors$3.STRAIGHT.get = function () { return CGAlgorithms.COLLINEAR };\n\nObject.defineProperties( CGAlgorithms, staticAccessors$3 );\n\nvar GeometryComponentFilter = function GeometryComponentFilter () {};\n\nGeometryComponentFilter.prototype.filter = function filter (geom) {};\nGeometryComponentFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryComponentFilter.prototype.getClass = function getClass () {\n  return GeometryComponentFilter\n};\n\nvar Geometry = function Geometry () {\n  var factory = arguments[0];\n\n  this._envelope = null;\n  this._factory = null;\n  this._SRID = null;\n  this._userData = null;\n  this._factory = factory;\n  this._SRID = factory.getSRID();\n};\n\nvar staticAccessors$11 = { serialVersionUID: { configurable: true },SORTINDEX_POINT: { configurable: true },SORTINDEX_MULTIPOINT: { configurable: true },SORTINDEX_LINESTRING: { configurable: true },SORTINDEX_LINEARRING: { configurable: true },SORTINDEX_MULTILINESTRING: { configurable: true },SORTINDEX_POLYGON: { configurable: true },SORTINDEX_MULTIPOLYGON: { configurable: true },SORTINDEX_GEOMETRYCOLLECTION: { configurable: true },geometryChangedFilter: { configurable: true } };\nGeometry.prototype.isGeometryCollection = function isGeometryCollection () {\n  return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION\n};\nGeometry.prototype.getFactory = function getFactory () {\n  return this._factory\n};\nGeometry.prototype.getGeometryN = function getGeometryN (n) {\n  return this\n};\nGeometry.prototype.getArea = function getArea () {\n  return 0.0\n};\nGeometry.prototype.isRectangle = function isRectangle () {\n  return false\n};\nGeometry.prototype.equals = function equals () {\n  if (arguments[0] instanceof Geometry) {\n    var g$1 = arguments[0];\n    if (g$1 === null) { return false }\n    return this.equalsTopo(g$1)\n  } else if (arguments[0] instanceof Object) {\n    var o = arguments[0];\n    if (!(o instanceof Geometry)) { return false }\n    var g = o;\n    return this.equalsExact(g)\n  }\n};\nGeometry.prototype.equalsExact = function equalsExact (other) {\n  return this === other || this.equalsExact(other, 0)\n};\nGeometry.prototype.geometryChanged = function geometryChanged () {\n  this.apply(Geometry.geometryChangedFilter);\n};\nGeometry.prototype.geometryChangedAction = function geometryChangedAction () {\n  this._envelope = null;\n};\nGeometry.prototype.equalsNorm = function equalsNorm (g) {\n  if (g === null) { return false }\n  return this.norm().equalsExact(g.norm())\n};\nGeometry.prototype.getLength = function getLength () {\n  return 0.0\n};\nGeometry.prototype.getNumGeometries = function getNumGeometries () {\n  return 1\n};\nGeometry.prototype.compareTo = function compareTo () {\n  if (arguments.length === 1) {\n    var o = arguments[0];\n    var other = o;\n    if (this.getSortIndex() !== other.getSortIndex()) {\n      return this.getSortIndex() - other.getSortIndex()\n    }\n    if (this.isEmpty() && other.isEmpty()) {\n      return 0\n    }\n    if (this.isEmpty()) {\n      return -1\n    }\n    if (other.isEmpty()) {\n      return 1\n    }\n    return this.compareToSameClass(o)\n  } else if (arguments.length === 2) {\n    var other$1 = arguments[0];\n    var comp = arguments[1];\n    if (this.getSortIndex() !== other$1.getSortIndex()) {\n      return this.getSortIndex() - other$1.getSortIndex()\n    }\n    if (this.isEmpty() && other$1.isEmpty()) {\n      return 0\n    }\n    if (this.isEmpty()) {\n      return -1\n    }\n    if (other$1.isEmpty()) {\n      return 1\n    }\n    return this.compareToSameClass(other$1, comp)\n  }\n};\nGeometry.prototype.getUserData = function getUserData () {\n  return this._userData\n};\nGeometry.prototype.getSRID = function getSRID () {\n  return this._SRID\n};\nGeometry.prototype.getEnvelope = function getEnvelope () {\n  return this.getFactory().toGeometry(this.getEnvelopeInternal())\n};\nGeometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection (g) {\n  if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {\n    throw new IllegalArgumentException('This method does not support GeometryCollection arguments')\n  }\n};\nGeometry.prototype.equal = function equal (a, b, tolerance) {\n  if (tolerance === 0) {\n    return a.equals(b)\n  }\n  return a.distance(b) <= tolerance\n};\nGeometry.prototype.norm = function norm () {\n  var copy = this.copy();\n  copy.normalize();\n  return copy\n};\nGeometry.prototype.getPrecisionModel = function getPrecisionModel () {\n  return this._factory.getPrecisionModel()\n};\nGeometry.prototype.getEnvelopeInternal = function getEnvelopeInternal () {\n  if (this._envelope === null) {\n    this._envelope = this.computeEnvelopeInternal();\n  }\n  return new Envelope(this._envelope)\n};\nGeometry.prototype.setSRID = function setSRID (SRID) {\n  this._SRID = SRID;\n};\nGeometry.prototype.setUserData = function setUserData (userData) {\n  this._userData = userData;\n};\nGeometry.prototype.compare = function compare (a, b) {\n  var i = a.iterator();\n  var j = b.iterator();\n  while (i.hasNext() && j.hasNext()) {\n    var aElement = i.next();\n    var bElement = j.next();\n    var comparison = aElement.compareTo(bElement);\n    if (comparison !== 0) {\n      return comparison\n    }\n  }\n  if (i.hasNext()) {\n    return 1\n  }\n  if (j.hasNext()) {\n    return -1\n  }\n  return 0\n};\nGeometry.prototype.hashCode = function hashCode () {\n  return this.getEnvelopeInternal().hashCode()\n};\nGeometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived () {\n  if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {\n    return true\n  }\n  return false\n};\nGeometry.prototype.interfaces_ = function interfaces_ () {\n  return [Clonable, Comparable, Serializable]\n};\nGeometry.prototype.getClass = function getClass () {\n  return Geometry\n};\nGeometry.hasNonEmptyElements = function hasNonEmptyElements (geometries) {\n  for (var i = 0; i < geometries.length; i++) {\n    if (!geometries[i].isEmpty()) {\n      return true\n    }\n  }\n  return false\n};\nGeometry.hasNullElements = function hasNullElements (array) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === null) {\n      return true\n    }\n  }\n  return false\n};\nstaticAccessors$11.serialVersionUID.get = function () { return 8763622679187376702 };\nstaticAccessors$11.SORTINDEX_POINT.get = function () { return 0 };\nstaticAccessors$11.SORTINDEX_MULTIPOINT.get = function () { return 1 };\nstaticAccessors$11.SORTINDEX_LINESTRING.get = function () { return 2 };\nstaticAccessors$11.SORTINDEX_LINEARRING.get = function () { return 3 };\nstaticAccessors$11.SORTINDEX_MULTILINESTRING.get = function () { return 4 };\nstaticAccessors$11.SORTINDEX_POLYGON.get = function () { return 5 };\nstaticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function () { return 6 };\nstaticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function () { return 7 };\nstaticAccessors$11.geometryChangedFilter.get = function () { return geometryChangedFilter };\n\nObject.defineProperties( Geometry, staticAccessors$11 );\n\nvar geometryChangedFilter = function geometryChangedFilter () {};\n\ngeometryChangedFilter.interfaces_ = function interfaces_ () {\n  return [GeometryComponentFilter]\n};\ngeometryChangedFilter.filter = function filter (geom) {\n  geom.geometryChangedAction();\n};\n\nvar CoordinateFilter = function CoordinateFilter () {};\n\nCoordinateFilter.prototype.filter = function filter (coord) {};\nCoordinateFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateFilter.prototype.getClass = function getClass () {\n  return CoordinateFilter\n};\n\nvar BoundaryNodeRule = function BoundaryNodeRule () {};\n\nvar staticAccessors$12 = { Mod2BoundaryNodeRule: { configurable: true },EndPointBoundaryNodeRule: { configurable: true },MultiValentEndPointBoundaryNodeRule: { configurable: true },MonoValentEndPointBoundaryNodeRule: { configurable: true },MOD2_BOUNDARY_RULE: { configurable: true },ENDPOINT_BOUNDARY_RULE: { configurable: true },MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true },MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true },OGC_SFS_BOUNDARY_RULE: { configurable: true } };\n\nBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {};\nBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundaryNodeRule.prototype.getClass = function getClass () {\n  return BoundaryNodeRule\n};\nstaticAccessors$12.Mod2BoundaryNodeRule.get = function () { return Mod2BoundaryNodeRule };\nstaticAccessors$12.EndPointBoundaryNodeRule.get = function () { return EndPointBoundaryNodeRule };\nstaticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function () { return MultiValentEndPointBoundaryNodeRule };\nstaticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function () { return MonoValentEndPointBoundaryNodeRule };\nstaticAccessors$12.MOD2_BOUNDARY_RULE.get = function () { return new Mod2BoundaryNodeRule() };\nstaticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function () { return new EndPointBoundaryNodeRule() };\nstaticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MultiValentEndPointBoundaryNodeRule() };\nstaticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MonoValentEndPointBoundaryNodeRule() };\nstaticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function () { return BoundaryNodeRule.MOD2_BOUNDARY_RULE };\n\nObject.defineProperties( BoundaryNodeRule, staticAccessors$12 );\n\nvar Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule () {};\n\nMod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount % 2 === 1\n};\nMod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMod2BoundaryNodeRule.prototype.getClass = function getClass () {\n  return Mod2BoundaryNodeRule\n};\n\nvar EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule () {};\n\nEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount > 0\n};\nEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return EndPointBoundaryNodeRule\n};\n\nvar MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule () {};\n\nMultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount > 1\n};\nMultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return MultiValentEndPointBoundaryNodeRule\n};\n\nvar MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule () {};\n\nMonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount === 1\n};\nMonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return MonoValentEndPointBoundaryNodeRule\n};\n\n// import Iterator from './Iterator'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nvar Collection = function Collection () {};\n\nCollection.prototype.add = function add () {};\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function addAll () {};\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function isEmpty () {};\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function iterator () {};\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function size () {};\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function toArray () {};\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function remove () {};\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction IndexOutOfBoundsException (message) {\n  this.message = message || '';\n}\nIndexOutOfBoundsException.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nvar Iterator = function Iterator () {};\n\nIterator.prototype.hasNext = function hasNext () {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function next () {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function remove () {};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nvar List = (function (Collection$$1) {\n  function List () {\n    Collection$$1.apply(this, arguments);\n  }\n\n  if ( Collection$$1 ) List.__proto__ = Collection$$1;\n  List.prototype = Object.create( Collection$$1 && Collection$$1.prototype );\n  List.prototype.constructor = List;\n\n  List.prototype.get = function get () { };\n\n  /**\n   * Replaces the element at the specified position in this list with the\n   * specified element (optional operation).\n   * @param {number} index\n   * @param {Object} e\n   * @return {Object}\n   */\n  List.prototype.set = function set () { };\n\n  /**\n   * Returns true if this collection contains no elements.\n   * @return {boolean}\n   */\n  List.prototype.isEmpty = function isEmpty () { };\n\n  return List;\n}(Collection));\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction NoSuchElementException (message) {\n  this.message = message || '';\n}\nNoSuchElementException.prototype = new Error();\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n\n// import OperationNotSupported from './OperationNotSupported'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nvar ArrayList = (function (List$$1) {\n  function ArrayList () {\n    List$$1.call(this);\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n\n  if ( List$$1 ) ArrayList.__proto__ = List$$1;\n  ArrayList.prototype = Object.create( List$$1 && List$$1.prototype );\n  ArrayList.prototype.constructor = ArrayList;\n\n  ArrayList.prototype.ensureCapacity = function ensureCapacity () {};\n  ArrayList.prototype.interfaces_ = function interfaces_ () { return [List$$1, Collection] };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.add = function add (e) {\n    if (arguments.length === 1) {\n      this.array_.push(e);\n    } else {\n      this.array_.splice(arguments[0], arguments[1]);\n    }\n    return true\n  };\n\n  ArrayList.prototype.clear = function clear () {\n    this.array_ = [];\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.addAll = function addAll (c) {\n    var this$1 = this;\n\n    for (var i = c.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    return true\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.set = function set (index, element) {\n    var oldElement = this.array_[index];\n    this.array_[index] = element;\n    return oldElement\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.iterator = function iterator () {\n    return new Iterator_(this)\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.get = function get (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException()\n    }\n\n    return this.array_[index]\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.isEmpty = function isEmpty () {\n    return this.array_.length === 0\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.size = function size () {\n    return this.array_.length\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.toArray = function toArray () {\n    var this$1 = this;\n\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this$1.array_[i]);\n    }\n\n    return array\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.remove = function remove (o) {\n    var this$1 = this;\n\n    var found = false;\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      if (this$1.array_[i] === o) {\n        this$1.array_.splice(i, 1);\n        found = true;\n        break\n      }\n    }\n\n    return found\n  };\n\n  return ArrayList;\n}(List));\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = (function (Iterator$$1) {\n  function Iterator_ (arrayList) {\n    Iterator$$1.call(this);\n    /**\n     * @type {ArrayList}\n     * @private\n    */\n    this.arrayList_ = arrayList;\n    /**\n     * @type {number}\n     * @private\n    */\n    this.position_ = 0;\n  }\n\n  if ( Iterator$$1 ) Iterator_.__proto__ = Iterator$$1;\n  Iterator_.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  Iterator_.prototype.constructor = Iterator_;\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.next = function next () {\n    if (this.position_ === this.arrayList_.size()) {\n      throw new NoSuchElementException()\n    }\n    return this.arrayList_.get(this.position_++)\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.hasNext = function hasNext () {\n    if (this.position_ < this.arrayList_.size()) {\n      return true\n    } else {\n      return false\n    }\n  };\n\n  /**\n   * TODO: should be in ListIterator\n   * @override\n   */\n  Iterator_.prototype.set = function set (element) {\n    return this.arrayList_.set(this.position_ - 1, element)\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.remove = function remove () {\n    this.arrayList_.remove(this.arrayList_.get(this.position_));\n  };\n\n  return Iterator_;\n}(Iterator));\n\nvar CoordinateList = (function (ArrayList$$1) {\n  function CoordinateList () {\n    ArrayList$$1.call(this);\n    if (arguments.length === 0) {\n    } else if (arguments.length === 1) {\n      var coord = arguments[0];\n      this.ensureCapacity(coord.length);\n      this.add(coord, true);\n    } else if (arguments.length === 2) {\n      var coord$1 = arguments[0];\n      var allowRepeated = arguments[1];\n      this.ensureCapacity(coord$1.length);\n      this.add(coord$1, allowRepeated);\n    }\n  }\n\n  if ( ArrayList$$1 ) CoordinateList.__proto__ = ArrayList$$1;\n  CoordinateList.prototype = Object.create( ArrayList$$1 && ArrayList$$1.prototype );\n  CoordinateList.prototype.constructor = CoordinateList;\n\n  var staticAccessors = { coordArrayType: { configurable: true } };\n  staticAccessors.coordArrayType.get = function () { return new Array(0).fill(null) };\n  CoordinateList.prototype.getCoordinate = function getCoordinate (i) {\n    return this.get(i)\n  };\n  CoordinateList.prototype.addAll = function addAll () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var coll = arguments[0];\n      var allowRepeated = arguments[1];\n      var isChanged = false;\n      for (var i = coll.iterator(); i.hasNext();) {\n        this$1.add(i.next(), allowRepeated);\n        isChanged = true;\n      }\n      return isChanged\n    } else { return ArrayList$$1.prototype.addAll.apply(this, arguments) }\n  };\n  CoordinateList.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var clone = ArrayList$$1.prototype.clone.call(this);\n    for (var i = 0; i < this.size(); i++) {\n      clone.add(i, this$1.get(i).copy());\n    }\n    return clone\n  };\n  CoordinateList.prototype.toCoordinateArray = function toCoordinateArray () {\n    return this.toArray(CoordinateList.coordArrayType)\n  };\n  CoordinateList.prototype.add = function add () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var coord = arguments[0];\n      ArrayList$$1.prototype.add.call(this, coord);\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {\n        var coord$1 = arguments[0];\n        var allowRepeated = arguments[1];\n        this.add(coord$1, allowRepeated, true);\n        return true\n      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {\n        var coord$2 = arguments[0];\n        var allowRepeated$1 = arguments[1];\n        if (!allowRepeated$1) {\n          if (this.size() >= 1) {\n            var last = this.get(this.size() - 1);\n            if (last.equals2D(coord$2)) { return null }\n          }\n        }\n        ArrayList$$1.prototype.add.call(this, coord$2);\n      } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {\n        var obj = arguments[0];\n        var allowRepeated$2 = arguments[1];\n        this.add(obj, allowRepeated$2);\n        return true\n      }\n    } else if (arguments.length === 3) {\n      if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Array && typeof arguments[1] === 'boolean')) {\n        var coord$3 = arguments[0];\n        var allowRepeated$3 = arguments[1];\n        var direction = arguments[2];\n        if (direction) {\n          for (var i$1 = 0; i$1 < coord$3.length; i$1++) {\n            this$1.add(coord$3[i$1], allowRepeated$3);\n          }\n        } else {\n          for (var i$2 = coord$3.length - 1; i$2 >= 0; i$2--) {\n            this$1.add(coord$3[i$2], allowRepeated$3);\n          }\n        }\n        return true\n      } else if (typeof arguments[2] === 'boolean' && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n        var i$3 = arguments[0];\n        var coord$4 = arguments[1];\n        var allowRepeated$4 = arguments[2];\n        if (!allowRepeated$4) {\n          var size = this.size();\n          if (size > 0) {\n            if (i$3 > 0) {\n              var prev = this.get(i$3 - 1);\n              if (prev.equals2D(coord$4)) { return null }\n            }\n            if (i$3 < size) {\n              var next = this.get(i$3);\n              if (next.equals2D(coord$4)) { return null }\n            }\n          }\n        }\n        ArrayList$$1.prototype.add.call(this, i$3, coord$4);\n      }\n    } else if (arguments.length === 4) {\n      var coord$5 = arguments[0];\n      var allowRepeated$5 = arguments[1];\n      var start = arguments[2];\n      var end = arguments[3];\n      var inc = 1;\n      if (start > end) { inc = -1; }\n      for (var i = start; i !== end; i += inc) {\n        this$1.add(coord$5[i], allowRepeated$5);\n      }\n      return true\n    }\n  };\n  CoordinateList.prototype.closeRing = function closeRing () {\n    if (this.size() > 0) { this.add(new Coordinate(this.get(0)), false); }\n  };\n  CoordinateList.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  CoordinateList.prototype.getClass = function getClass () {\n    return CoordinateList\n  };\n\n  Object.defineProperties( CoordinateList, staticAccessors );\n\n  return CoordinateList;\n}(ArrayList));\n\nvar CoordinateArrays = function CoordinateArrays () {};\n\nvar staticAccessors$13 = { ForwardComparator: { configurable: true },BidirectionalComparator: { configurable: true },coordArrayType: { configurable: true } };\n\nstaticAccessors$13.ForwardComparator.get = function () { return ForwardComparator };\nstaticAccessors$13.BidirectionalComparator.get = function () { return BidirectionalComparator };\nstaticAccessors$13.coordArrayType.get = function () { return new Array(0).fill(null) };\n\nCoordinateArrays.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateArrays.prototype.getClass = function getClass () {\n  return CoordinateArrays\n};\nCoordinateArrays.isRing = function isRing (pts) {\n  if (pts.length < 4) { return false }\n  if (!pts[0].equals2D(pts[pts.length - 1])) { return false }\n  return true\n};\nCoordinateArrays.ptNotInList = function ptNotInList (testPts, pts) {\n  for (var i = 0; i < testPts.length; i++) {\n    var testPt = testPts[i];\n    if (CoordinateArrays.indexOf(testPt, pts) < 0) { return testPt }\n  }\n  return null\n};\nCoordinateArrays.scroll = function scroll (coordinates, firstCoordinate) {\n  var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n  if (i < 0) { return null }\n  var newCoordinates = new Array(coordinates.length).fill(null);\n  System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n  System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n  System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n};\nCoordinateArrays.equals = function equals () {\n  if (arguments.length === 2) {\n    var coord1 = arguments[0];\n    var coord2 = arguments[1];\n    if (coord1 === coord2) { return true }\n    if (coord1 === null || coord2 === null) { return false }\n    if (coord1.length !== coord2.length) { return false }\n    for (var i = 0; i < coord1.length; i++) {\n      if (!coord1[i].equals(coord2[i])) { return false }\n    }\n    return true\n  } else if (arguments.length === 3) {\n    var coord1$1 = arguments[0];\n    var coord2$1 = arguments[1];\n    var coordinateComparator = arguments[2];\n    if (coord1$1 === coord2$1) { return true }\n    if (coord1$1 === null || coord2$1 === null) { return false }\n    if (coord1$1.length !== coord2$1.length) { return false }\n    for (var i$1 = 0; i$1 < coord1$1.length; i$1++) {\n      if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) { return false }\n    }\n    return true\n  }\n};\nCoordinateArrays.intersection = function intersection (coordinates, env) {\n  var coordList = new CoordinateList();\n  for (var i = 0; i < coordinates.length; i++) {\n    if (env.intersects(coordinates[i])) { coordList.add(coordinates[i], true); }\n  }\n  return coordList.toCoordinateArray()\n};\nCoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints (coord) {\n  for (var i = 1; i < coord.length; i++) {\n    if (coord[i - 1].equals(coord[i])) {\n      return true\n    }\n  }\n  return false\n};\nCoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints (coord) {\n  if (!CoordinateArrays.hasRepeatedPoints(coord)) { return coord }\n  var coordList = new CoordinateList(coord, false);\n  return coordList.toCoordinateArray()\n};\nCoordinateArrays.reverse = function reverse (coord) {\n  var last = coord.length - 1;\n  var mid = Math.trunc(last / 2);\n  for (var i = 0; i <= mid; i++) {\n    var tmp = coord[i];\n    coord[i] = coord[last - i];\n    coord[last - i] = tmp;\n  }\n};\nCoordinateArrays.removeNull = function removeNull (coord) {\n  var nonNull = 0;\n  for (var i = 0; i < coord.length; i++) {\n    if (coord[i] !== null) { nonNull++; }\n  }\n  var newCoord = new Array(nonNull).fill(null);\n  if (nonNull === 0) { return newCoord }\n  var j = 0;\n  for (var i$1 = 0; i$1 < coord.length; i$1++) {\n    if (coord[i$1] !== null) { newCoord[j++] = coord[i$1]; }\n  }\n  return newCoord\n};\nCoordinateArrays.copyDeep = function copyDeep () {\n  if (arguments.length === 1) {\n    var coordinates = arguments[0];\n    var copy = new Array(coordinates.length).fill(null);\n    for (var i = 0; i < coordinates.length; i++) {\n      copy[i] = new Coordinate(coordinates[i]);\n    }\n    return copy\n  } else if (arguments.length === 5) {\n    var src = arguments[0];\n    var srcStart = arguments[1];\n    var dest = arguments[2];\n    var destStart = arguments[3];\n    var length = arguments[4];\n    for (var i$1 = 0; i$1 < length; i$1++) {\n      dest[destStart + i$1] = new Coordinate(src[srcStart + i$1]);\n    }\n  }\n};\nCoordinateArrays.isEqualReversed = function isEqualReversed (pts1, pts2) {\n  for (var i = 0; i < pts1.length; i++) {\n    var p1 = pts1[i];\n    var p2 = pts2[pts1.length - i - 1];\n    if (p1.compareTo(p2) !== 0) { return false }\n  }\n  return true\n};\nCoordinateArrays.envelope = function envelope (coordinates) {\n  var env = new Envelope();\n  for (var i = 0; i < coordinates.length; i++) {\n    env.expandToInclude(coordinates[i]);\n  }\n  return env\n};\nCoordinateArrays.toCoordinateArray = function toCoordinateArray (coordList) {\n  return coordList.toArray(CoordinateArrays.coordArrayType)\n};\nCoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing (n, c) {\n  return c.length >= n ? c : []\n};\nCoordinateArrays.indexOf = function indexOf (coordinate, coordinates) {\n  for (var i = 0; i < coordinates.length; i++) {\n    if (coordinate.equals(coordinates[i])) {\n      return i\n    }\n  }\n  return -1\n};\nCoordinateArrays.increasingDirection = function increasingDirection (pts) {\n  for (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n    var j = pts.length - 1 - i;\n    var comp = pts[i].compareTo(pts[j]);\n    if (comp !== 0) { return comp }\n  }\n  return 1\n};\nCoordinateArrays.compare = function compare (pts1, pts2) {\n  var i = 0;\n  while (i < pts1.length && i < pts2.length) {\n    var compare = pts1[i].compareTo(pts2[i]);\n    if (compare !== 0) { return compare }\n    i++;\n  }\n  if (i < pts2.length) { return -1 }\n  if (i < pts1.length) { return 1 }\n  return 0\n};\nCoordinateArrays.minCoordinate = function minCoordinate (coordinates) {\n  var minCoord = null;\n  for (var i = 0; i < coordinates.length; i++) {\n    if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n      minCoord = coordinates[i];\n    }\n  }\n  return minCoord\n};\nCoordinateArrays.extract = function extract (pts, start, end) {\n  start = MathUtil.clamp(start, 0, pts.length);\n  end = MathUtil.clamp(end, -1, pts.length);\n  var npts = end - start + 1;\n  if (end < 0) { npts = 0; }\n  if (start >= pts.length) { npts = 0; }\n  if (end < start) { npts = 0; }\n  var extractPts = new Array(npts).fill(null);\n  if (npts === 0) { return extractPts }\n  var iPts = 0;\n  for (var i = start; i <= end; i++) {\n    extractPts[iPts++] = pts[i];\n  }\n  return extractPts\n};\n\nObject.defineProperties( CoordinateArrays, staticAccessors$13 );\n\nvar ForwardComparator = function ForwardComparator () {};\n\nForwardComparator.prototype.compare = function compare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  return CoordinateArrays.compare(pts1, pts2)\n};\nForwardComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nForwardComparator.prototype.getClass = function getClass () {\n  return ForwardComparator\n};\n\nvar BidirectionalComparator = function BidirectionalComparator () {};\n\nBidirectionalComparator.prototype.compare = function compare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  if (pts1.length < pts2.length) { return -1 }\n  if (pts1.length > pts2.length) { return 1 }\n  if (pts1.length === 0) { return 0 }\n  var forwardComp = CoordinateArrays.compare(pts1, pts2);\n  var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n  if (isEqualRev) { return 0 }\n  return forwardComp\n};\nBidirectionalComparator.prototype.OLDcompare = function OLDcompare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  if (pts1.length < pts2.length) { return -1 }\n  if (pts1.length > pts2.length) { return 1 }\n  if (pts1.length === 0) { return 0 }\n  var dir1 = CoordinateArrays.increasingDirection(pts1);\n  var dir2 = CoordinateArrays.increasingDirection(pts2);\n  var i1 = dir1 > 0 ? 0 : pts1.length - 1;\n  var i2 = dir2 > 0 ? 0 : pts1.length - 1;\n  for (var i = 0; i < pts1.length; i++) {\n    var comparePt = pts1[i1].compareTo(pts2[i2]);\n    if (comparePt !== 0) { return comparePt }\n    i1 += dir1;\n    i2 += dir2;\n  }\n  return 0\n};\nBidirectionalComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nBidirectionalComparator.prototype.getClass = function getClass () {\n  return BidirectionalComparator\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nvar Map$1 = function Map () {};\n\nMap$1.prototype.get = function get () {};\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap$1.prototype.put = function put () {};\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap$1.prototype.size = function size () {};\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap$1.prototype.values = function values () {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap$1.prototype.entrySet = function entrySet () {};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nvar SortedMap = (function (Map) {\n\tfunction SortedMap () {\n\t\tMap.apply(this, arguments);\n\t}if ( Map ) SortedMap.__proto__ = Map;\n\tSortedMap.prototype = Object.create( Map && Map.prototype );\n\tSortedMap.prototype.constructor = SortedMap;\n\n\t\n\n\treturn SortedMap;\n}(Map$1));\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction OperationNotSupported (message) {\n  this.message = message || '';\n}\nOperationNotSupported.prototype = new Error();\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nfunction Set() {}\nSet.prototype = new Collection();\n\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet.prototype.contains = function() {};\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nvar HashSet = (function (Set$$1) {\n  function HashSet () {\n    Set$$1.call(this);\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n\n  if ( Set$$1 ) HashSet.__proto__ = Set$$1;\n  HashSet.prototype = Object.create( Set$$1 && Set$$1.prototype );\n  HashSet.prototype.constructor = HashSet;\n\n  /**\n   * @override\n   */\n  HashSet.prototype.contains = function contains (o) {\n    var this$1 = this;\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this$1.array_[i];\n      if (e === o) {\n        return true\n      }\n    }\n    return false\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.add = function add (o) {\n    if (this.contains(o)) {\n      return false\n    }\n\n    this.array_.push(o);\n\n    return true\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.addAll = function addAll (c) {\n    var this$1 = this;\n\n    for (var i = c.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    return true\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.remove = function remove (o) {\n    // throw new javascript.util.OperationNotSupported()\n    throw new Error()\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.size = function size () {\n    return this.array_.length\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.isEmpty = function isEmpty () {\n    return this.array_.length === 0\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.toArray = function toArray () {\n    var this$1 = this;\n\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this$1.array_[i]);\n    }\n\n    return array\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.iterator = function iterator () {\n    return new Iterator_$1(this)\n  };\n\n  return HashSet;\n}(Set));\n\n/**\n   * @extends {Iterator}\n   * @param {HashSet} hashSet\n   * @constructor\n   * @private\n   */\nvar Iterator_$1 = (function (Iterator$$1) {\n  function Iterator_ (hashSet) {\n    Iterator$$1.call(this);\n    /**\n     * @type {HashSet}\n     * @private\n     */\n    this.hashSet_ = hashSet;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.position_ = 0;\n  }\n\n  if ( Iterator$$1 ) Iterator_.__proto__ = Iterator$$1;\n  Iterator_.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  Iterator_.prototype.constructor = Iterator_;\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.next = function next () {\n    if (this.position_ === this.hashSet_.size()) {\n      throw new NoSuchElementException()\n    }\n    return this.hashSet_.array_[this.position_++]\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.hasNext = function hasNext () {\n    if (this.position_ < this.hashSet_.size()) {\n      return true\n    } else {\n      return false\n    }\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.remove = function remove () {\n    throw new OperationNotSupported()\n  };\n\n  return Iterator_;\n}(Iterator));\n\nvar BLACK = 0;\nvar RED = 1;\nfunction colorOf (p) { return (p === null ? BLACK : p.color) }\nfunction parentOf (p) { return (p === null ? null : p.parent) }\nfunction setColor (p, c) { if (p !== null) { p.color = c; } }\nfunction leftOf (p) { return (p === null ? null : p.left) }\nfunction rightOf (p) { return (p === null ? null : p.right) }\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nfunction TreeMap () {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n}\nTreeMap.prototype = new SortedMap();\n\n/**\n * @override\n */\nTreeMap.prototype.get = function (key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) { p = p.left; }\n    else if (cmp > 0) { p = p.right; }\n    else { return p.value }\n  }\n  return null\n};\n\n/**\n * @override\n */\nTreeMap.prototype.put = function (key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue: function getValue () { return this.value },\n      getKey: function getKey () { return this.key }\n    };\n    this.size_ = 1;\n    return null\n  }\n  var t = this.root_;\n  var parent;\n  var cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue\n    }\n  } while (t !== null)\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue: function getValue () { return this.value },\n    getKey: function getKey () { return this.key }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null\n};\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function (x) {\n  var this$1 = this;\n\n  x.color = RED;\n  while (x != null && x !== this.root_ && x.parent.color === RED) {\n    if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) === RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x === rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this$1.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this$1.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y$1 = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y$1) === RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y$1, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x === leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this$1.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this$1.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n/**\n * @override\n */\nTreeMap.prototype.values = function () {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList\n};\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function () {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet\n};\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function (p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null) { r.left.parent = p; }\n    r.parent = p.parent;\n    if (p.parent === null) { this.root_ = r; } else if (p.parent.left === p) { p.parent.left = r; } else { p.parent.right = r; }\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function (p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) { l.right.parent = p; }\n    l.parent = p.parent;\n    if (p.parent === null) { this.root_ = l; } else if (p.parent.right === p) { p.parent.right = l; } else { p.parent.left = l; }\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function () {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p\n};\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function (t) {\n  if (t === null) { return null } else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p\n  } else {\n    var p$1 = t.parent;\n    var ch = t;\n    while (p$1 !== null && ch === p$1.right) {\n      ch = p$1;\n      p$1 = p$1.parent;\n    }\n    return p$1\n  }\n};\n\n/**\n * @override\n */\nTreeMap.prototype.size = function () {\n  return this.size_\n};\n\nvar Lineal = function Lineal () {};\n\nLineal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineal.prototype.getClass = function getClass () {\n  return Lineal\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nfunction SortedSet () {}\nSortedSet.prototype = new Set();\n\n// import Iterator from './Iterator'\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nfunction TreeSet () {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n}\nTreeSet.prototype = new SortedSet();\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function (o) {\n  var this$1 = this;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this$1.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true\n    }\n  }\n  return false\n};\n\n/**\n * @override\n */\nTreeSet.prototype.add = function (o) {\n  var this$1 = this;\n\n  if (this.contains(o)) {\n    return false\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this$1.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this$1.array_.splice(i, 0, o);\n      return true\n    }\n  }\n\n  this.array_.push(o);\n\n  return true\n};\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function (c) {\n  var this$1 = this;\n\n  for (var i = c.iterator(); i.hasNext();) {\n    this$1.add(i.next());\n  }\n  return true\n};\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function (e) {\n  throw new OperationNotSupported()\n};\n\n/**\n * @override\n */\nTreeSet.prototype.size = function () {\n  return this.array_.length\n};\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function () {\n  return this.array_.length === 0\n};\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function () {\n  var this$1 = this;\n\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this$1.array_[i]);\n  }\n\n  return array\n};\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function () {\n  return new Iterator_$2(this)\n};\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_$2 = function (treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.next = function () {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException()\n  }\n  return this.treeSet_.array_[this.position_++]\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.hasNext = function () {\n  if (this.position_ < this.treeSet_.size()) {\n    return true\n  } else {\n    return false\n  }\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.remove = function () {\n  throw new OperationNotSupported()\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nvar Arrays = function Arrays () {};\n\nArrays.sort = function sort () {\n  var a = arguments[0];\n  var i;\n  var t;\n  var comparator;\n  var compare;\n  if (arguments.length === 1) {\n    compare = function (a, b) {\n      return a.compareTo(b)\n    };\n    a.sort(compare);\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function (a, b) {\n      return comparator['compare'](a, b)\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function (a, b) {\n      return comparator['compare'](a, b)\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n  }\n};\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function asList (array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList\n};\n\nvar Dimension = function Dimension () {};\n\nvar staticAccessors$14 = { P: { configurable: true },L: { configurable: true },A: { configurable: true },FALSE: { configurable: true },TRUE: { configurable: true },DONTCARE: { configurable: true },SYM_FALSE: { configurable: true },SYM_TRUE: { configurable: true },SYM_DONTCARE: { configurable: true },SYM_P: { configurable: true },SYM_L: { configurable: true },SYM_A: { configurable: true } };\n\nstaticAccessors$14.P.get = function () { return 0 };\nstaticAccessors$14.L.get = function () { return 1 };\nstaticAccessors$14.A.get = function () { return 2 };\nstaticAccessors$14.FALSE.get = function () { return -1 };\nstaticAccessors$14.TRUE.get = function () { return -2 };\nstaticAccessors$14.DONTCARE.get = function () { return -3 };\nstaticAccessors$14.SYM_FALSE.get = function () { return 'F' };\nstaticAccessors$14.SYM_TRUE.get = function () { return 'T' };\nstaticAccessors$14.SYM_DONTCARE.get = function () { return '*' };\nstaticAccessors$14.SYM_P.get = function () { return '0' };\nstaticAccessors$14.SYM_L.get = function () { return '1' };\nstaticAccessors$14.SYM_A.get = function () { return '2' };\n\nDimension.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDimension.prototype.getClass = function getClass () {\n  return Dimension\n};\nDimension.toDimensionSymbol = function toDimensionSymbol (dimensionValue) {\n  switch (dimensionValue) {\n    case Dimension.FALSE:\n      return Dimension.SYM_FALSE\n    case Dimension.TRUE:\n      return Dimension.SYM_TRUE\n    case Dimension.DONTCARE:\n      return Dimension.SYM_DONTCARE\n    case Dimension.P:\n      return Dimension.SYM_P\n    case Dimension.L:\n      return Dimension.SYM_L\n    case Dimension.A:\n      return Dimension.SYM_A\n    default:\n  }\n  throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue)\n};\nDimension.toDimensionValue = function toDimensionValue (dimensionSymbol) {\n  switch (Character.toUpperCase(dimensionSymbol)) {\n    case Dimension.SYM_FALSE:\n      return Dimension.FALSE\n    case Dimension.SYM_TRUE:\n      return Dimension.TRUE\n    case Dimension.SYM_DONTCARE:\n      return Dimension.DONTCARE\n    case Dimension.SYM_P:\n      return Dimension.P\n    case Dimension.SYM_L:\n      return Dimension.L\n    case Dimension.SYM_A:\n      return Dimension.A\n    default:\n  }\n  throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol)\n};\n\nObject.defineProperties( Dimension, staticAccessors$14 );\n\nvar GeometryFilter = function GeometryFilter () {};\n\nGeometryFilter.prototype.filter = function filter (geom) {};\nGeometryFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryFilter.prototype.getClass = function getClass () {\n  return GeometryFilter\n};\n\nvar CoordinateSequenceFilter = function CoordinateSequenceFilter () {};\n\nCoordinateSequenceFilter.prototype.filter = function filter (seq, i) {};\nCoordinateSequenceFilter.prototype.isDone = function isDone () {};\nCoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged () {};\nCoordinateSequenceFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequenceFilter.prototype.getClass = function getClass () {\n  return CoordinateSequenceFilter\n};\n\nvar GeometryCollection = (function (Geometry$$1) {\n  function GeometryCollection (geometries, factory) {\n    Geometry$$1.call(this, factory);\n    this._geometries = geometries || [];\n\n    if (Geometry$$1.hasNullElements(this._geometries)) {\n      throw new IllegalArgumentException('geometries must not contain null elements')\n    }\n  }\n\n  if ( Geometry$$1 ) GeometryCollection.__proto__ = Geometry$$1;\n  GeometryCollection.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  GeometryCollection.prototype.constructor = GeometryCollection;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  GeometryCollection.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    var this$1 = this;\n\n    var envelope = new Envelope();\n    for (var i = 0; i < this._geometries.length; i++) {\n      envelope.expandToInclude(this$1._geometries[i].getEnvelopeInternal());\n    }\n    return envelope\n  };\n  GeometryCollection.prototype.getGeometryN = function getGeometryN (n) {\n    return this._geometries[n]\n  };\n  GeometryCollection.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION\n  };\n  GeometryCollection.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n    var coordinates = new Array(this.getNumPoints()).fill(null);\n    var k = -1;\n    for (var i = 0; i < this._geometries.length; i++) {\n      var childCoordinates = this$1._geometries[i].getCoordinates();\n      for (var j = 0; j < childCoordinates.length; j++) {\n        k++;\n        coordinates[k] = childCoordinates[j];\n      }\n    }\n    return coordinates\n  };\n  GeometryCollection.prototype.getArea = function getArea () {\n    var this$1 = this;\n\n    var area = 0.0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      area += this$1._geometries[i].getArea();\n    }\n    return area\n  };\n  GeometryCollection.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherCollection = other;\n      if (this._geometries.length !== otherCollection._geometries.length) {\n        return false\n      }\n      for (var i = 0; i < this._geometries.length; i++) {\n        if (!this$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  GeometryCollection.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    for (var i = 0; i < this._geometries.length; i++) {\n      this$1._geometries[i].normalize();\n    }\n    Arrays.sort(this._geometries);\n  };\n  GeometryCollection.prototype.getCoordinate = function getCoordinate () {\n    if (this.isEmpty()) { return null }\n    return this._geometries[0].getCoordinate()\n  };\n  GeometryCollection.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    var this$1 = this;\n\n    var dimension = Dimension.FALSE;\n    for (var i = 0; i < this._geometries.length; i++) {\n      dimension = Math.max(dimension, this$1._geometries[i].getBoundaryDimension());\n    }\n    return dimension\n  };\n  GeometryCollection.prototype.getDimension = function getDimension () {\n    var this$1 = this;\n\n    var dimension = Dimension.FALSE;\n    for (var i = 0; i < this._geometries.length; i++) {\n      dimension = Math.max(dimension, this$1._geometries[i].getDimension());\n    }\n    return dimension\n  };\n  GeometryCollection.prototype.getLength = function getLength () {\n    var this$1 = this;\n\n    var sum = 0.0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      sum += this$1._geometries[i].getLength();\n    }\n    return sum\n  };\n  GeometryCollection.prototype.getNumPoints = function getNumPoints () {\n    var this$1 = this;\n\n    var numPoints = 0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      numPoints += this$1._geometries[i].getNumPoints();\n    }\n    return numPoints\n  };\n  GeometryCollection.prototype.getNumGeometries = function getNumGeometries () {\n    return this._geometries.length\n  };\n  GeometryCollection.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var n = this._geometries.length;\n    var revGeoms = new Array(n).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revGeoms[i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createGeometryCollection(revGeoms)\n  };\n  GeometryCollection.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var theseElements = new TreeSet(Arrays.asList(this._geometries));\n      var otherElements = new TreeSet(Arrays.asList(o._geometries));\n      return this.compare(theseElements, otherElements)\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var gc = o$1;\n      var n1 = this.getNumGeometries();\n      var n2 = gc.getNumGeometries();\n      var i = 0;\n      while (i < n1 && i < n2) {\n        var thisGeom = this$1.getGeometryN(i);\n        var otherGeom = gc.getGeometryN(i);\n        var holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n        if (holeComp !== 0) { return holeComp }\n        i++;\n      }\n      if (i < n1) { return 1 }\n      if (i < n2) { return -1 }\n      return 0\n    }\n  };\n  GeometryCollection.prototype.apply = function apply () {\n    var this$1 = this;\n\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      for (var i = 0; i < this._geometries.length; i++) {\n        this$1._geometries[i].apply(filter);\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this._geometries.length === 0) { return null }\n      for (var i$1 = 0; i$1 < this._geometries.length; i$1++) {\n        this$1._geometries[i$1].apply(filter$1);\n        if (filter$1.isDone()) {\n          break\n        }\n      }\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n      for (var i$2 = 0; i$2 < this._geometries.length; i$2++) {\n        this$1._geometries[i$2].apply(filter$2);\n      }\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n      for (var i$3 = 0; i$3 < this._geometries.length; i$3++) {\n        this$1._geometries[i$3].apply(filter$3);\n      }\n    }\n  };\n  GeometryCollection.prototype.getBoundary = function getBoundary () {\n    this.checkNotGeometryCollection(this);\n    Assert.shouldNeverReachHere();\n    return null\n  };\n  GeometryCollection.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var gc = Geometry$$1.prototype.clone.call(this);\n    gc._geometries = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      gc._geometries[i] = this$1._geometries[i].clone();\n    }\n    return gc\n  };\n  GeometryCollection.prototype.getGeometryType = function getGeometryType () {\n    return 'GeometryCollection'\n  };\n  GeometryCollection.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var geometries = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < geometries.length; i++) {\n      geometries[i] = this$1._geometries[i].copy();\n    }\n    return new GeometryCollection(geometries, this._factory)\n  };\n  GeometryCollection.prototype.isEmpty = function isEmpty () {\n    var this$1 = this;\n\n    for (var i = 0; i < this._geometries.length; i++) {\n      if (!this$1._geometries[i].isEmpty()) {\n        return false\n      }\n    }\n    return true\n  };\n  GeometryCollection.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  GeometryCollection.prototype.getClass = function getClass () {\n    return GeometryCollection\n  };\n  staticAccessors.serialVersionUID.get = function () { return -5694727726395021467 };\n\n  Object.defineProperties( GeometryCollection, staticAccessors );\n\n  return GeometryCollection;\n}(Geometry));\n\nvar MultiLineString = (function (GeometryCollection$$1) {\n  function MultiLineString () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiLineString.__proto__ = GeometryCollection$$1;\n  MultiLineString.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiLineString.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTILINESTRING\n  };\n  MultiLineString.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiLineString.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    if (this.isClosed()) {\n      return Dimension.FALSE\n    }\n    return 0\n  };\n  MultiLineString.prototype.isClosed = function isClosed () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return false\n    }\n    for (var i = 0; i < this._geometries.length; i++) {\n      if (!this$1._geometries[i].isClosed()) {\n        return false\n      }\n    }\n    return true\n  };\n  MultiLineString.prototype.getDimension = function getDimension () {\n    return 1\n  };\n  MultiLineString.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var nLines = this._geometries.length;\n    var revLines = new Array(nLines).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revLines[nLines - 1 - i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createMultiLineString(revLines)\n  };\n  MultiLineString.prototype.getBoundary = function getBoundary () {\n    return new BoundaryOp(this).getBoundary()\n  };\n  MultiLineString.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiLineString'\n  };\n  MultiLineString.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var lineStrings = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < lineStrings.length; i++) {\n      lineStrings[i] = this$1._geometries[i].copy();\n    }\n    return new MultiLineString(lineStrings, this._factory)\n  };\n  MultiLineString.prototype.interfaces_ = function interfaces_ () {\n    return [Lineal]\n  };\n  MultiLineString.prototype.getClass = function getClass () {\n    return MultiLineString\n  };\n  staticAccessors.serialVersionUID.get = function () { return 8166665132445433741 };\n\n  Object.defineProperties( MultiLineString, staticAccessors );\n\n  return MultiLineString;\n}(GeometryCollection));\n\nvar BoundaryOp = function BoundaryOp () {\n  this._geom = null;\n  this._geomFact = null;\n  this._bnRule = null;\n  this._endpointMap = null;\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n    this._geom = geom;\n    this._geomFact = geom.getFactory();\n    this._bnRule = bnRule;\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var bnRule$1 = arguments[1];\n    this._geom = geom$1;\n    this._geomFact = geom$1.getFactory();\n    this._bnRule = bnRule$1;\n  }\n};\nBoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString (mLine) {\n  if (this._geom.isEmpty()) {\n    return this.getEmptyMultiPoint()\n  }\n  var bdyPts = this.computeBoundaryCoordinates(mLine);\n  if (bdyPts.length === 1) {\n    return this._geomFact.createPoint(bdyPts[0])\n  }\n  return this._geomFact.createMultiPointFromCoords(bdyPts)\n};\nBoundaryOp.prototype.getBoundary = function getBoundary () {\n  if (this._geom instanceof LineString) { return this.boundaryLineString(this._geom) }\n  if (this._geom instanceof MultiLineString) { return this.boundaryMultiLineString(this._geom) }\n  return this._geom.getBoundary()\n};\nBoundaryOp.prototype.boundaryLineString = function boundaryLineString (line) {\n  if (this._geom.isEmpty()) {\n    return this.getEmptyMultiPoint()\n  }\n  if (line.isClosed()) {\n    var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n    if (closedEndpointOnBoundary) {\n      return line.getStartPoint()\n    } else {\n      return this._geomFact.createMultiPoint()\n    }\n  }\n  return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()])\n};\nBoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint () {\n  return this._geomFact.createMultiPoint()\n};\nBoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates (mLine) {\n    var this$1 = this;\n\n  var bdyPts = new ArrayList();\n  this._endpointMap = new TreeMap();\n  for (var i = 0; i < mLine.getNumGeometries(); i++) {\n    var line = mLine.getGeometryN(i);\n    if (line.getNumPoints() === 0) { continue }\n    this$1.addEndpoint(line.getCoordinateN(0));\n    this$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n  }\n  for (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {\n    var entry = it.next();\n    var counter = entry.getValue();\n    var valence = counter.count;\n    if (this$1._bnRule.isInBoundary(valence)) {\n      bdyPts.add(entry.getKey());\n    }\n  }\n  return CoordinateArrays.toCoordinateArray(bdyPts)\n};\nBoundaryOp.prototype.addEndpoint = function addEndpoint (pt) {\n  var counter = this._endpointMap.get(pt);\n  if (counter === null) {\n    counter = new Counter();\n    this._endpointMap.put(pt, counter);\n  }\n  counter.count++;\n};\nBoundaryOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundaryOp.prototype.getClass = function getClass () {\n  return BoundaryOp\n};\nBoundaryOp.getBoundary = function getBoundary () {\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    var bop = new BoundaryOp(g);\n    return bop.getBoundary()\n  } else if (arguments.length === 2) {\n    var g$1 = arguments[0];\n    var bnRule = arguments[1];\n    var bop$1 = new BoundaryOp(g$1, bnRule);\n    return bop$1.getBoundary()\n  }\n};\n\nvar Counter = function Counter () {\n  this.count = null;\n};\nCounter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCounter.prototype.getClass = function getClass () {\n  return Counter\n};\n\n// boundary\n\nfunction PrintStream () {}\n\nfunction StringReader () {}\n\nvar DecimalFormat = function DecimalFormat () {};\n\nfunction ByteArrayOutputStream () {}\n\nfunction IOException () {}\n\nfunction LineNumberReader () {}\n\nvar StringUtil = function StringUtil () {};\n\nvar staticAccessors$15 = { NEWLINE: { configurable: true },SIMPLE_ORDINATE_FORMAT: { configurable: true } };\n\nStringUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nStringUtil.prototype.getClass = function getClass () {\n  return StringUtil\n};\nStringUtil.chars = function chars (c, n) {\n  var ch = new Array(n).fill(null);\n  for (var i = 0; i < n; i++) {\n    ch[i] = c;\n  }\n  return String(ch)\n};\nStringUtil.getStackTrace = function getStackTrace () {\n  if (arguments.length === 1) {\n    var t = arguments[0];\n    var os = new ByteArrayOutputStream();\n    var ps = new PrintStream(os);\n    t.printStackTrace(ps);\n    return os.toString()\n  } else if (arguments.length === 2) {\n    var t$1 = arguments[0];\n    var depth = arguments[1];\n    var stackTrace = '';\n    var stringReader = new StringReader(StringUtil.getStackTrace(t$1));\n    var lineNumberReader = new LineNumberReader(stringReader);\n    for (var i = 0; i < depth; i++) {\n      try {\n        stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n      } catch (e) {\n        if (e instanceof IOException) {\n          Assert.shouldNeverReachHere();\n        } else { throw e }\n      } finally {}\n    }\n    return stackTrace\n  }\n};\nStringUtil.split = function split (s, separator) {\n  var separatorlen = separator.length;\n  var tokenList = new ArrayList();\n  var tmpString = '' + s;\n  var pos = tmpString.indexOf(separator);\n  while (pos >= 0) {\n    var token = tmpString.substring(0, pos);\n    tokenList.add(token);\n    tmpString = tmpString.substring(pos + separatorlen);\n    pos = tmpString.indexOf(separator);\n  }\n  if (tmpString.length > 0) { tokenList.add(tmpString); }\n  var res = new Array(tokenList.size()).fill(null);\n  for (var i = 0; i < res.length; i++) {\n    res[i] = tokenList.get(i);\n  }\n  return res\n};\nStringUtil.toString = function toString () {\n  if (arguments.length === 1) {\n    var d = arguments[0];\n    return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d)\n  }\n};\nStringUtil.spaces = function spaces (n) {\n  return StringUtil.chars(' ', n)\n};\nstaticAccessors$15.NEWLINE.get = function () { return System.getProperty('line.separator') };\nstaticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function () { return new DecimalFormat('0.#') };\n\nObject.defineProperties( StringUtil, staticAccessors$15 );\n\nvar CoordinateSequences = function CoordinateSequences () {};\n\nCoordinateSequences.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequences.prototype.getClass = function getClass () {\n  return CoordinateSequences\n};\nCoordinateSequences.copyCoord = function copyCoord (src, srcPos, dest, destPos) {\n  var minDim = Math.min(src.getDimension(), dest.getDimension());\n  for (var dim = 0; dim < minDim; dim++) {\n    dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n  }\n};\nCoordinateSequences.isRing = function isRing (seq) {\n  var n = seq.size();\n  if (n === 0) { return true }\n  if (n <= 3) { return false }\n  return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)\n};\nCoordinateSequences.isEqual = function isEqual (cs1, cs2) {\n  var cs1Size = cs1.size();\n  var cs2Size = cs2.size();\n  if (cs1Size !== cs2Size) { return false }\n  var dim = Math.min(cs1.getDimension(), cs2.getDimension());\n  for (var i = 0; i < cs1Size; i++) {\n    for (var d = 0; d < dim; d++) {\n      var v1 = cs1.getOrdinate(i, d);\n      var v2 = cs2.getOrdinate(i, d);\n      if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) { continue }\n      if (Double.isNaN(v1) && Double.isNaN(v2)) { continue }\n      return false\n    }\n  }\n  return true\n};\nCoordinateSequences.extend = function extend (fact, seq, size) {\n  var newseq = fact.create(size, seq.getDimension());\n  var n = seq.size();\n  CoordinateSequences.copy(seq, 0, newseq, 0, n);\n  if (n > 0) {\n    for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, n - 1, newseq, i, 1); }\n  }\n  return newseq\n};\nCoordinateSequences.reverse = function reverse (seq) {\n  var last = seq.size() - 1;\n  var mid = Math.trunc(last / 2);\n  for (var i = 0; i <= mid; i++) {\n    CoordinateSequences.swap(seq, i, last - i);\n  }\n};\nCoordinateSequences.swap = function swap (seq, i, j) {\n  if (i === j) { return null }\n  for (var dim = 0; dim < seq.getDimension(); dim++) {\n    var tmp = seq.getOrdinate(i, dim);\n    seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n    seq.setOrdinate(j, dim, tmp);\n  }\n};\nCoordinateSequences.copy = function copy (src, srcPos, dest, destPos, length) {\n  for (var i = 0; i < length; i++) {\n    CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n  }\n};\nCoordinateSequences.toString = function toString () {\n  if (arguments.length === 1) {\n    var cs = arguments[0];\n    var size = cs.size();\n    if (size === 0) { return '()' }\n    var dim = cs.getDimension();\n    var buf = new StringBuffer();\n    buf.append('(');\n    for (var i = 0; i < size; i++) {\n      if (i > 0) { buf.append(' '); }\n      for (var d = 0; d < dim; d++) {\n        if (d > 0) { buf.append(','); }\n        buf.append(StringUtil.toString(cs.getOrdinate(i, d)));\n      }\n    }\n    buf.append(')');\n    return buf.toString()\n  }\n};\nCoordinateSequences.ensureValidRing = function ensureValidRing (fact, seq) {\n  var n = seq.size();\n  if (n === 0) { return seq }\n  if (n <= 3) { return CoordinateSequences.createClosedRing(fact, seq, 4) }\n  var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n  if (isClosed) { return seq }\n  return CoordinateSequences.createClosedRing(fact, seq, n + 1)\n};\nCoordinateSequences.createClosedRing = function createClosedRing (fact, seq, size) {\n  var newseq = fact.create(size, seq.getDimension());\n  var n = seq.size();\n  CoordinateSequences.copy(seq, 0, newseq, 0, n);\n  for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, 0, newseq, i, 1); }\n  return newseq\n};\n\nvar LineString = (function (Geometry$$1) {\n  function LineString (points, factory) {\n    Geometry$$1.call(this, factory);\n    this._points = null;\n    this.init(points);\n  }\n\n  if ( Geometry$$1 ) LineString.__proto__ = Geometry$$1;\n  LineString.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  LineString.prototype.constructor = LineString;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  LineString.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    if (this.isEmpty()) {\n      return new Envelope()\n    }\n    return this._points.expandEnvelope(new Envelope())\n  };\n  LineString.prototype.isRing = function isRing () {\n    return this.isClosed() && this.isSimple()\n  };\n  LineString.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_LINESTRING\n  };\n  LineString.prototype.getCoordinates = function getCoordinates () {\n    return this._points.toCoordinateArray()\n  };\n  LineString.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherLineString = other;\n      if (this._points.size() !== otherLineString._points.size()) {\n        return false\n      }\n      for (var i = 0; i < this._points.size(); i++) {\n        if (!this$1.equal(this$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  LineString.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n      var j = this$1._points.size() - 1 - i;\n      if (!this$1._points.getCoordinate(i).equals(this$1._points.getCoordinate(j))) {\n        if (this$1._points.getCoordinate(i).compareTo(this$1._points.getCoordinate(j)) > 0) {\n          CoordinateSequences.reverse(this$1._points);\n        }\n        return null\n      }\n    }\n  };\n  LineString.prototype.getCoordinate = function getCoordinate () {\n    if (this.isEmpty()) { return null }\n    return this._points.getCoordinate(0)\n  };\n  LineString.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    if (this.isClosed()) {\n      return Dimension.FALSE\n    }\n    return 0\n  };\n  LineString.prototype.isClosed = function isClosed () {\n    if (this.isEmpty()) {\n      return false\n    }\n    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))\n  };\n  LineString.prototype.getEndPoint = function getEndPoint () {\n    if (this.isEmpty()) {\n      return null\n    }\n    return this.getPointN(this.getNumPoints() - 1)\n  };\n  LineString.prototype.getDimension = function getDimension () {\n    return 1\n  };\n  LineString.prototype.getLength = function getLength () {\n    return CGAlgorithms.computeLength(this._points)\n  };\n  LineString.prototype.getNumPoints = function getNumPoints () {\n    return this._points.size()\n  };\n  LineString.prototype.reverse = function reverse () {\n    var seq = this._points.copy();\n    CoordinateSequences.reverse(seq);\n    var revLine = this.getFactory().createLineString(seq);\n    return revLine\n  };\n  LineString.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var line = o;\n      var i = 0;\n      var j = 0;\n      while (i < this._points.size() && j < line._points.size()) {\n        var comparison = this$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n        if (comparison !== 0) {\n          return comparison\n        }\n        i++;\n        j++;\n      }\n      if (i < this._points.size()) {\n        return 1\n      }\n      if (j < line._points.size()) {\n        return -1\n      }\n      return 0\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var line$1 = o$1;\n      return comp.compare(this._points, line$1._points)\n    }\n  };\n  LineString.prototype.apply = function apply () {\n    var this$1 = this;\n\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      for (var i = 0; i < this._points.size(); i++) {\n        filter.filter(this$1._points.getCoordinate(i));\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this._points.size() === 0) { return null }\n      for (var i$1 = 0; i$1 < this._points.size(); i$1++) {\n        filter$1.filter(this$1._points, i$1);\n        if (filter$1.isDone()) { break }\n      }\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n    }\n  };\n  LineString.prototype.getBoundary = function getBoundary () {\n    return new BoundaryOp(this).getBoundary()\n  };\n  LineString.prototype.isEquivalentClass = function isEquivalentClass (other) {\n    return other instanceof LineString\n  };\n  LineString.prototype.clone = function clone () {\n    var ls = Geometry$$1.prototype.clone.call(this);\n    ls._points = this._points.clone();\n    return ls\n  };\n  LineString.prototype.getCoordinateN = function getCoordinateN (n) {\n    return this._points.getCoordinate(n)\n  };\n  LineString.prototype.getGeometryType = function getGeometryType () {\n    return 'LineString'\n  };\n  LineString.prototype.copy = function copy () {\n    return new LineString(this._points.copy(), this._factory)\n  };\n  LineString.prototype.getCoordinateSequence = function getCoordinateSequence () {\n    return this._points\n  };\n  LineString.prototype.isEmpty = function isEmpty () {\n    return this._points.size() === 0\n  };\n  LineString.prototype.init = function init (points) {\n    if (points === null) {\n      points = this.getFactory().getCoordinateSequenceFactory().create([]);\n    }\n    if (points.size() === 1) {\n      throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)')\n    }\n    this._points = points;\n  };\n  LineString.prototype.isCoordinate = function isCoordinate (pt) {\n    var this$1 = this;\n\n    for (var i = 0; i < this._points.size(); i++) {\n      if (this$1._points.getCoordinate(i).equals(pt)) {\n        return true\n      }\n    }\n    return false\n  };\n  LineString.prototype.getStartPoint = function getStartPoint () {\n    if (this.isEmpty()) {\n      return null\n    }\n    return this.getPointN(0)\n  };\n  LineString.prototype.getPointN = function getPointN (n) {\n    return this.getFactory().createPoint(this._points.getCoordinate(n))\n  };\n  LineString.prototype.interfaces_ = function interfaces_ () {\n    return [Lineal]\n  };\n  LineString.prototype.getClass = function getClass () {\n    return LineString\n  };\n  staticAccessors.serialVersionUID.get = function () { return 3110669828065365560 };\n\n  Object.defineProperties( LineString, staticAccessors );\n\n  return LineString;\n}(Geometry));\n\nvar Puntal = function Puntal () {};\n\nPuntal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPuntal.prototype.getClass = function getClass () {\n  return Puntal\n};\n\nvar Point = (function (Geometry$$1) {\n  function Point (coordinates, factory) {\n    Geometry$$1.call(this, factory);\n    this._coordinates = coordinates || null;\n    this.init(this._coordinates);\n  }\n\n  if ( Geometry$$1 ) Point.__proto__ = Geometry$$1;\n  Point.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  Point.prototype.constructor = Point;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  Point.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    if (this.isEmpty()) {\n      return new Envelope()\n    }\n    var env = new Envelope();\n    env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n    return env\n  };\n  Point.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_POINT\n  };\n  Point.prototype.getCoordinates = function getCoordinates () {\n    return this.isEmpty() ? [] : [this.getCoordinate()]\n  };\n  Point.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      if (this.isEmpty() && other.isEmpty()) {\n        return true\n      }\n      if (this.isEmpty() !== other.isEmpty()) {\n        return false\n      }\n      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance)\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  Point.prototype.normalize = function normalize () {};\n  Point.prototype.getCoordinate = function getCoordinate () {\n    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null\n  };\n  Point.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  Point.prototype.getDimension = function getDimension () {\n    return 0\n  };\n  Point.prototype.getNumPoints = function getNumPoints () {\n    return this.isEmpty() ? 0 : 1\n  };\n  Point.prototype.reverse = function reverse () {\n    return this.copy()\n  };\n  Point.prototype.getX = function getX () {\n    if (this.getCoordinate() === null) {\n      throw new Error('getX called on empty Point')\n    }\n    return this.getCoordinate().x\n  };\n  Point.prototype.compareToSameClass = function compareToSameClass () {\n    if (arguments.length === 1) {\n      var other = arguments[0];\n      var point$1 = other;\n      return this.getCoordinate().compareTo(point$1.getCoordinate())\n    } else if (arguments.length === 2) {\n      var other$1 = arguments[0];\n      var comp = arguments[1];\n      var point = other$1;\n      return comp.compare(this._coordinates, point._coordinates)\n    }\n  };\n  Point.prototype.apply = function apply () {\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      if (this.isEmpty()) {\n        return null\n      }\n      filter.filter(this.getCoordinate());\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this.isEmpty()) { return null }\n      filter$1.filter(this._coordinates, 0);\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n    }\n  };\n  Point.prototype.getBoundary = function getBoundary () {\n    return this.getFactory().createGeometryCollection(null)\n  };\n  Point.prototype.clone = function clone () {\n    var p = Geometry$$1.prototype.clone.call(this);\n    p._coordinates = this._coordinates.clone();\n    return p\n  };\n  Point.prototype.getGeometryType = function getGeometryType () {\n    return 'Point'\n  };\n  Point.prototype.copy = function copy () {\n    return new Point(this._coordinates.copy(), this._factory)\n  };\n  Point.prototype.getCoordinateSequence = function getCoordinateSequence () {\n    return this._coordinates\n  };\n  Point.prototype.getY = function getY () {\n    if (this.getCoordinate() === null) {\n      throw new Error('getY called on empty Point')\n    }\n    return this.getCoordinate().y\n  };\n  Point.prototype.isEmpty = function isEmpty () {\n    return this._coordinates.size() === 0\n  };\n  Point.prototype.init = function init (coordinates) {\n    if (coordinates === null) {\n      coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n    }\n    Assert.isTrue(coordinates.size() <= 1);\n    this._coordinates = coordinates;\n  };\n  Point.prototype.isSimple = function isSimple () {\n    return true\n  };\n  Point.prototype.interfaces_ = function interfaces_ () {\n    return [Puntal]\n  };\n  Point.prototype.getClass = function getClass () {\n    return Point\n  };\n  staticAccessors.serialVersionUID.get = function () { return 4902022702746614570 };\n\n  Object.defineProperties( Point, staticAccessors );\n\n  return Point;\n}(Geometry));\n\nvar Polygonal = function Polygonal () {};\n\nPolygonal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPolygonal.prototype.getClass = function getClass () {\n  return Polygonal\n};\n\nvar Polygon = (function (Geometry$$1) {\n  function Polygon (shell, holes, factory) {\n    Geometry$$1.call(this, factory);\n    this._shell = null;\n    this._holes = null;\n    if (shell === null) {\n      shell = this.getFactory().createLinearRing();\n    }\n    if (holes === null) {\n      holes = [];\n    }\n    if (Geometry$$1.hasNullElements(holes)) {\n      throw new IllegalArgumentException('holes must not contain null elements')\n    }\n    if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {\n      throw new IllegalArgumentException('shell is empty but holes are not')\n    }\n    this._shell = shell;\n    this._holes = holes;\n  }\n\n  if ( Geometry$$1 ) Polygon.__proto__ = Geometry$$1;\n  Polygon.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  Polygon.prototype.constructor = Polygon;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  Polygon.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    return this._shell.getEnvelopeInternal()\n  };\n  Polygon.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_POLYGON\n  };\n  Polygon.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return []\n    }\n    var coordinates = new Array(this.getNumPoints()).fill(null);\n    var k = -1;\n    var shellCoordinates = this._shell.getCoordinates();\n    for (var x = 0; x < shellCoordinates.length; x++) {\n      k++;\n      coordinates[k] = shellCoordinates[x];\n    }\n    for (var i = 0; i < this._holes.length; i++) {\n      var childCoordinates = this$1._holes[i].getCoordinates();\n      for (var j = 0; j < childCoordinates.length; j++) {\n        k++;\n        coordinates[k] = childCoordinates[j];\n      }\n    }\n    return coordinates\n  };\n  Polygon.prototype.getArea = function getArea () {\n    var this$1 = this;\n\n    var area = 0.0;\n    area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));\n    for (var i = 0; i < this._holes.length; i++) {\n      area -= Math.abs(CGAlgorithms.signedArea(this$1._holes[i].getCoordinateSequence()));\n    }\n    return area\n  };\n  Polygon.prototype.isRectangle = function isRectangle () {\n    if (this.getNumInteriorRing() !== 0) { return false }\n    if (this._shell === null) { return false }\n    if (this._shell.getNumPoints() !== 5) { return false }\n    var seq = this._shell.getCoordinateSequence();\n    var env = this.getEnvelopeInternal();\n    for (var i = 0; i < 5; i++) {\n      var x = seq.getX(i);\n      if (!(x === env.getMinX() || x === env.getMaxX())) { return false }\n      var y = seq.getY(i);\n      if (!(y === env.getMinY() || y === env.getMaxY())) { return false }\n    }\n    var prevX = seq.getX(0);\n    var prevY = seq.getY(0);\n    for (var i$1 = 1; i$1 <= 4; i$1++) {\n      var x$1 = seq.getX(i$1);\n      var y$1 = seq.getY(i$1);\n      var xChanged = x$1 !== prevX;\n      var yChanged = y$1 !== prevY;\n      if (xChanged === yChanged) { return false }\n      prevX = x$1;\n      prevY = y$1;\n    }\n    return true\n  };\n  Polygon.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherPolygon = other;\n      var thisShell = this._shell;\n      var otherPolygonShell = otherPolygon._shell;\n      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n        return false\n      }\n      if (this._holes.length !== otherPolygon._holes.length) {\n        return false\n      }\n      for (var i = 0; i < this._holes.length; i++) {\n        if (!this$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  Polygon.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    if (arguments.length === 0) {\n      this.normalize(this._shell, true);\n      for (var i = 0; i < this._holes.length; i++) {\n        this$1.normalize(this$1._holes[i], false);\n      }\n      Arrays.sort(this._holes);\n    } else if (arguments.length === 2) {\n      var ring = arguments[0];\n      var clockwise = arguments[1];\n      if (ring.isEmpty()) {\n        return null\n      }\n      var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n      System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n      var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n      CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n      System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n      ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n      if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {\n        CoordinateArrays.reverse(ring.getCoordinates());\n      }\n    }\n  };\n  Polygon.prototype.getCoordinate = function getCoordinate () {\n    return this._shell.getCoordinate()\n  };\n  Polygon.prototype.getNumInteriorRing = function getNumInteriorRing () {\n    return this._holes.length\n  };\n  Polygon.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return 1\n  };\n  Polygon.prototype.getDimension = function getDimension () {\n    return 2\n  };\n  Polygon.prototype.getLength = function getLength () {\n    var this$1 = this;\n\n    var len = 0.0;\n    len += this._shell.getLength();\n    for (var i = 0; i < this._holes.length; i++) {\n      len += this$1._holes[i].getLength();\n    }\n    return len\n  };\n  Polygon.prototype.getNumPoints = function getNumPoints () {\n    var this$1 = this;\n\n    var numPoints = this._shell.getNumPoints();\n    for (var i = 0; i < this._holes.length; i++) {\n      numPoints += this$1._holes[i].getNumPoints();\n    }\n    return numPoints\n  };\n  Polygon.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var poly = this.copy();\n    poly._shell = this._shell.copy().reverse();\n    poly._holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < this._holes.length; i++) {\n      poly._holes[i] = this$1._holes[i].copy().reverse();\n    }\n    return poly\n  };\n  Polygon.prototype.convexHull = function convexHull () {\n    return this.getExteriorRing().convexHull()\n  };\n  Polygon.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var thisShell = this._shell;\n      var otherShell = o._shell;\n      return thisShell.compareToSameClass(otherShell)\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var poly = o$1;\n      var thisShell$1 = this._shell;\n      var otherShell$1 = poly._shell;\n      var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);\n      if (shellComp !== 0) { return shellComp }\n      var nHole1 = this.getNumInteriorRing();\n      var nHole2 = poly.getNumInteriorRing();\n      var i = 0;\n      while (i < nHole1 && i < nHole2) {\n        var thisHole = this$1.getInteriorRingN(i);\n        var otherHole = poly.getInteriorRingN(i);\n        var holeComp = thisHole.compareToSameClass(otherHole, comp);\n        if (holeComp !== 0) { return holeComp }\n        i++;\n      }\n      if (i < nHole1) { return 1 }\n      if (i < nHole2) { return -1 }\n      return 0\n    }\n  };\n  Polygon.prototype.apply = function apply (filter) {\n    var this$1 = this;\n\n    if (hasInterface(filter, CoordinateFilter)) {\n      this._shell.apply(filter);\n      for (var i$1 = 0; i$1 < this._holes.length; i$1++) {\n        this$1._holes[i$1].apply(filter);\n      }\n    } else if (hasInterface(filter, CoordinateSequenceFilter)) {\n      this._shell.apply(filter);\n      if (!filter.isDone()) {\n        for (var i$2 = 0; i$2 < this._holes.length; i$2++) {\n          this$1._holes[i$2].apply(filter);\n          if (filter.isDone()) { break }\n        }\n      }\n      if (filter.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(filter, GeometryFilter)) {\n      filter.filter(this);\n    } else if (hasInterface(filter, GeometryComponentFilter)) {\n      filter.filter(this);\n      this._shell.apply(filter);\n      for (var i = 0; i < this._holes.length; i++) {\n        this$1._holes[i].apply(filter);\n      }\n    }\n  };\n  Polygon.prototype.getBoundary = function getBoundary () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return this.getFactory().createMultiLineString()\n    }\n    var rings = new Array(this._holes.length + 1).fill(null);\n    rings[0] = this._shell;\n    for (var i = 0; i < this._holes.length; i++) {\n      rings[i + 1] = this$1._holes[i];\n    }\n    if (rings.length <= 1) { return this.getFactory().createLinearRing(rings[0].getCoordinateSequence()) }\n    return this.getFactory().createMultiLineString(rings)\n  };\n  Polygon.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var poly = Geometry$$1.prototype.clone.call(this);\n    poly._shell = this._shell.clone();\n    poly._holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < this._holes.length; i++) {\n      poly._holes[i] = this$1._holes[i].clone();\n    }\n    return poly\n  };\n  Polygon.prototype.getGeometryType = function getGeometryType () {\n    return 'Polygon'\n  };\n  Polygon.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var shell = this._shell.copy();\n    var holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < holes.length; i++) {\n      holes[i] = this$1._holes[i].copy();\n    }\n    return new Polygon(shell, holes, this._factory)\n  };\n  Polygon.prototype.getExteriorRing = function getExteriorRing () {\n    return this._shell\n  };\n  Polygon.prototype.isEmpty = function isEmpty () {\n    return this._shell.isEmpty()\n  };\n  Polygon.prototype.getInteriorRingN = function getInteriorRingN (n) {\n    return this._holes[n]\n  };\n  Polygon.prototype.interfaces_ = function interfaces_ () {\n    return [Polygonal]\n  };\n  Polygon.prototype.getClass = function getClass () {\n    return Polygon\n  };\n  staticAccessors.serialVersionUID.get = function () { return -3494792200821764533 };\n\n  Object.defineProperties( Polygon, staticAccessors );\n\n  return Polygon;\n}(Geometry));\n\nvar MultiPoint = (function (GeometryCollection$$1) {\n  function MultiPoint () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiPoint.__proto__ = GeometryCollection$$1;\n  MultiPoint.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiPoint.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTIPOINT\n  };\n  MultiPoint.prototype.isValid = function isValid () {\n    return true\n  };\n  MultiPoint.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiPoint.prototype.getCoordinate = function getCoordinate () {\n    if (arguments.length === 1) {\n      var n = arguments[0];\n      return this._geometries[n].getCoordinate()\n    } else { return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments) }\n  };\n  MultiPoint.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  MultiPoint.prototype.getDimension = function getDimension () {\n    return 0\n  };\n  MultiPoint.prototype.getBoundary = function getBoundary () {\n    return this.getFactory().createGeometryCollection(null)\n  };\n  MultiPoint.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiPoint'\n  };\n  MultiPoint.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var points = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < points.length; i++) {\n      points[i] = this$1._geometries[i].copy();\n    }\n    return new MultiPoint(points, this._factory)\n  };\n  MultiPoint.prototype.interfaces_ = function interfaces_ () {\n    return [Puntal]\n  };\n  MultiPoint.prototype.getClass = function getClass () {\n    return MultiPoint\n  };\n  staticAccessors.serialVersionUID.get = function () { return -8048474874175355449 };\n\n  Object.defineProperties( MultiPoint, staticAccessors );\n\n  return MultiPoint;\n}(GeometryCollection));\n\nvar LinearRing = (function (LineString$$1) {\n  function LinearRing (points, factory) {\n    if (points instanceof Coordinate && factory instanceof GeometryFactory) {\n      points = factory.getCoordinateSequenceFactory().create(points);\n    }\n    LineString$$1.call(this, points, factory);\n    this.validateConstruction();\n  }\n\n  if ( LineString$$1 ) LinearRing.__proto__ = LineString$$1;\n  LinearRing.prototype = Object.create( LineString$$1 && LineString$$1.prototype );\n  LinearRing.prototype.constructor = LinearRing;\n\n  var staticAccessors = { MINIMUM_VALID_SIZE: { configurable: true },serialVersionUID: { configurable: true } };\n  LinearRing.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_LINEARRING\n  };\n  LinearRing.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  LinearRing.prototype.isClosed = function isClosed () {\n    if (this.isEmpty()) {\n      return true\n    }\n    return LineString$$1.prototype.isClosed.call(this)\n  };\n  LinearRing.prototype.reverse = function reverse () {\n    var seq = this._points.copy();\n    CoordinateSequences.reverse(seq);\n    var rev = this.getFactory().createLinearRing(seq);\n    return rev\n  };\n  LinearRing.prototype.validateConstruction = function validateConstruction () {\n    if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {\n      throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring')\n    }\n    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n      throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)')\n    }\n  };\n  LinearRing.prototype.getGeometryType = function getGeometryType () {\n    return 'LinearRing'\n  };\n  LinearRing.prototype.copy = function copy () {\n    return new LinearRing(this._points.copy(), this._factory)\n  };\n  LinearRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  LinearRing.prototype.getClass = function getClass () {\n    return LinearRing\n  };\n  staticAccessors.MINIMUM_VALID_SIZE.get = function () { return 4 };\n  staticAccessors.serialVersionUID.get = function () { return -4261142084085851829 };\n\n  Object.defineProperties( LinearRing, staticAccessors );\n\n  return LinearRing;\n}(LineString));\n\nvar MultiPolygon = (function (GeometryCollection$$1) {\n  function MultiPolygon () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiPolygon.__proto__ = GeometryCollection$$1;\n  MultiPolygon.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiPolygon.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTIPOLYGON\n  };\n  MultiPolygon.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiPolygon.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return 1\n  };\n  MultiPolygon.prototype.getDimension = function getDimension () {\n    return 2\n  };\n  MultiPolygon.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var n = this._geometries.length;\n    var revGeoms = new Array(n).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revGeoms[i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createMultiPolygon(revGeoms)\n  };\n  MultiPolygon.prototype.getBoundary = function getBoundary () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return this.getFactory().createMultiLineString()\n    }\n    var allRings = new ArrayList();\n    for (var i = 0; i < this._geometries.length; i++) {\n      var polygon = this$1._geometries[i];\n      var rings = polygon.getBoundary();\n      for (var j = 0; j < rings.getNumGeometries(); j++) {\n        allRings.add(rings.getGeometryN(j));\n      }\n    }\n    var allRingsArray = new Array(allRings.size()).fill(null);\n    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray))\n  };\n  MultiPolygon.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiPolygon'\n  };\n  MultiPolygon.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var polygons = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < polygons.length; i++) {\n      polygons[i] = this$1._geometries[i].copy();\n    }\n    return new MultiPolygon(polygons, this._factory)\n  };\n  MultiPolygon.prototype.interfaces_ = function interfaces_ () {\n    return [Polygonal]\n  };\n  MultiPolygon.prototype.getClass = function getClass () {\n    return MultiPolygon\n  };\n  staticAccessors.serialVersionUID.get = function () { return -551033529766975875 };\n\n  Object.defineProperties( MultiPolygon, staticAccessors );\n\n  return MultiPolygon;\n}(GeometryCollection));\n\nvar GeometryEditor = function GeometryEditor (factory) {\n  this._factory = factory || null;\n  this._isUserDataCopied = false;\n};\n\nvar staticAccessors$16 = { NoOpGeometryOperation: { configurable: true },CoordinateOperation: { configurable: true },CoordinateSequenceOperation: { configurable: true } };\nGeometryEditor.prototype.setCopyUserData = function setCopyUserData (isUserDataCopied) {\n  this._isUserDataCopied = isUserDataCopied;\n};\nGeometryEditor.prototype.edit = function edit (geometry, operation) {\n  if (geometry === null) { return null }\n  var result = this.editInternal(geometry, operation);\n  if (this._isUserDataCopied) {\n    result.setUserData(geometry.getUserData());\n  }\n  return result\n};\nGeometryEditor.prototype.editInternal = function editInternal (geometry, operation) {\n  if (this._factory === null) { this._factory = geometry.getFactory(); }\n  if (geometry instanceof GeometryCollection) {\n    return this.editGeometryCollection(geometry, operation)\n  }\n  if (geometry instanceof Polygon) {\n    return this.editPolygon(geometry, operation)\n  }\n  if (geometry instanceof Point) {\n    return operation.edit(geometry, this._factory)\n  }\n  if (geometry instanceof LineString) {\n    return operation.edit(geometry, this._factory)\n  }\n  Assert.shouldNeverReachHere('Unsupported Geometry class: ' + geometry.getClass().getName());\n  return null\n};\nGeometryEditor.prototype.editGeometryCollection = function editGeometryCollection (collection, operation) {\n    var this$1 = this;\n\n  var collectionForType = operation.edit(collection, this._factory);\n  var geometries = new ArrayList();\n  for (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n    var geometry = this$1.edit(collectionForType.getGeometryN(i), operation);\n    if (geometry === null || geometry.isEmpty()) {\n      continue\n    }\n    geometries.add(geometry);\n  }\n  if (collectionForType.getClass() === MultiPoint) {\n    return this._factory.createMultiPoint(geometries.toArray([]))\n  }\n  if (collectionForType.getClass() === MultiLineString) {\n    return this._factory.createMultiLineString(geometries.toArray([]))\n  }\n  if (collectionForType.getClass() === MultiPolygon) {\n    return this._factory.createMultiPolygon(geometries.toArray([]))\n  }\n  return this._factory.createGeometryCollection(geometries.toArray([]))\n};\nGeometryEditor.prototype.editPolygon = function editPolygon (polygon, operation) {\n    var this$1 = this;\n\n  var newPolygon = operation.edit(polygon, this._factory);\n  if (newPolygon === null) { newPolygon = this._factory.createPolygon(null); }\n  if (newPolygon.isEmpty()) {\n    return newPolygon\n  }\n  var shell = this.edit(newPolygon.getExteriorRing(), operation);\n  if (shell === null || shell.isEmpty()) {\n    return this._factory.createPolygon()\n  }\n  var holes = new ArrayList();\n  for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n    var hole = this$1.edit(newPolygon.getInteriorRingN(i), operation);\n    if (hole === null || hole.isEmpty()) {\n      continue\n    }\n    holes.add(hole);\n  }\n  return this._factory.createPolygon(shell, holes.toArray([]))\n};\nGeometryEditor.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryEditor.prototype.getClass = function getClass () {\n  return GeometryEditor\n};\nGeometryEditor.GeometryEditorOperation = function GeometryEditorOperation () {};\nstaticAccessors$16.NoOpGeometryOperation.get = function () { return NoOpGeometryOperation };\nstaticAccessors$16.CoordinateOperation.get = function () { return CoordinateOperation };\nstaticAccessors$16.CoordinateSequenceOperation.get = function () { return CoordinateSequenceOperation };\n\nObject.defineProperties( GeometryEditor, staticAccessors$16 );\n\nvar NoOpGeometryOperation = function NoOpGeometryOperation () {};\n\nNoOpGeometryOperation.prototype.edit = function edit (geometry, factory) {\n  return geometry\n};\nNoOpGeometryOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nNoOpGeometryOperation.prototype.getClass = function getClass () {\n  return NoOpGeometryOperation\n};\n\nvar CoordinateOperation = function CoordinateOperation () {};\n\nCoordinateOperation.prototype.edit = function edit (geometry, factory) {\n  var coords = this.editCoordinates(geometry.getCoordinates(), geometry);\n  if (coords === null) { return geometry }\n  if (geometry instanceof LinearRing) {\n    return factory.createLinearRing(coords)\n  }\n  if (geometry instanceof LineString) {\n    return factory.createLineString(coords)\n  }\n  if (geometry instanceof Point) {\n    if (coords.length > 0) {\n      return factory.createPoint(coords[0])\n    } else {\n      return factory.createPoint()\n    }\n  }\n  return geometry\n};\nCoordinateOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nCoordinateOperation.prototype.getClass = function getClass () {\n  return CoordinateOperation\n};\n\nvar CoordinateSequenceOperation = function CoordinateSequenceOperation () {};\n\nCoordinateSequenceOperation.prototype.edit = function edit (geometry, factory) {\n  if (geometry instanceof LinearRing) {\n    return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  if (geometry instanceof LineString) {\n    return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  if (geometry instanceof Point) {\n    return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  return geometry\n};\nCoordinateSequenceOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nCoordinateSequenceOperation.prototype.getClass = function getClass () {\n  return CoordinateSequenceOperation\n};\n\nvar CoordinateArraySequence = function CoordinateArraySequence () {\n  var this$1 = this;\n\n  this._dimension = 3;\n  this._coordinates = null;\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      this._coordinates = arguments[0];\n      this._dimension = 3;\n    } else if (Number.isInteger(arguments[0])) {\n      var size = arguments[0];\n      this._coordinates = new Array(size).fill(null);\n      for (var i = 0; i < size; i++) {\n        this$1._coordinates[i] = new Coordinate();\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordSeq = arguments[0];\n      if (coordSeq === null) {\n        this._coordinates = new Array(0).fill(null);\n        return null\n      }\n      this._dimension = coordSeq.getDimension();\n      this._coordinates = new Array(coordSeq.size()).fill(null);\n      for (var i$1 = 0; i$1 < this._coordinates.length; i$1++) {\n        this$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);\n      }\n    }\n  } else if (arguments.length === 2) {\n    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n      var coordinates = arguments[0];\n      var dimension = arguments[1];\n      this._coordinates = coordinates;\n      this._dimension = dimension;\n      if (coordinates === null) { this._coordinates = new Array(0).fill(null); }\n    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var size$1 = arguments[0];\n      var dimension$1 = arguments[1];\n      this._coordinates = new Array(size$1).fill(null);\n      this._dimension = dimension$1;\n      for (var i$2 = 0; i$2 < size$1; i$2++) {\n        this$1._coordinates[i$2] = new Coordinate();\n      }\n    }\n  }\n};\n\nvar staticAccessors$18 = { serialVersionUID: { configurable: true } };\nCoordinateArraySequence.prototype.setOrdinate = function setOrdinate (index, ordinateIndex, value) {\n  switch (ordinateIndex) {\n    case CoordinateSequence.X:\n      this._coordinates[index].x = value;\n      break\n    case CoordinateSequence.Y:\n      this._coordinates[index].y = value;\n      break\n    case CoordinateSequence.Z:\n      this._coordinates[index].z = value;\n      break\n    default:\n      throw new IllegalArgumentException('invalid ordinateIndex')\n  }\n};\nCoordinateArraySequence.prototype.size = function size () {\n  return this._coordinates.length\n};\nCoordinateArraySequence.prototype.getOrdinate = function getOrdinate (index, ordinateIndex) {\n  switch (ordinateIndex) {\n    case CoordinateSequence.X:\n      return this._coordinates[index].x\n    case CoordinateSequence.Y:\n      return this._coordinates[index].y\n    case CoordinateSequence.Z:\n      return this._coordinates[index].z\n    default:\n  }\n  return Double.NaN\n};\nCoordinateArraySequence.prototype.getCoordinate = function getCoordinate () {\n  if (arguments.length === 1) {\n    var i = arguments[0];\n    return this._coordinates[i]\n  } else if (arguments.length === 2) {\n    var index = arguments[0];\n    var coord = arguments[1];\n    coord.x = this._coordinates[index].x;\n    coord.y = this._coordinates[index].y;\n    coord.z = this._coordinates[index].z;\n  }\n};\nCoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy (i) {\n  return new Coordinate(this._coordinates[i])\n};\nCoordinateArraySequence.prototype.getDimension = function getDimension () {\n  return this._dimension\n};\nCoordinateArraySequence.prototype.getX = function getX (index) {\n  return this._coordinates[index].x\n};\nCoordinateArraySequence.prototype.clone = function clone () {\n    var this$1 = this;\n\n  var cloneCoordinates = new Array(this.size()).fill(null);\n  for (var i = 0; i < this._coordinates.length; i++) {\n    cloneCoordinates[i] = this$1._coordinates[i].clone();\n  }\n  return new CoordinateArraySequence(cloneCoordinates, this._dimension)\n};\nCoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope (env) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._coordinates.length; i++) {\n    env.expandToInclude(this$1._coordinates[i]);\n  }\n  return env\n};\nCoordinateArraySequence.prototype.copy = function copy () {\n    var this$1 = this;\n\n  var cloneCoordinates = new Array(this.size()).fill(null);\n  for (var i = 0; i < this._coordinates.length; i++) {\n    cloneCoordinates[i] = this$1._coordinates[i].copy();\n  }\n  return new CoordinateArraySequence(cloneCoordinates, this._dimension)\n};\nCoordinateArraySequence.prototype.toString = function toString () {\n    var this$1 = this;\n\n  if (this._coordinates.length > 0) {\n    var strBuf = new StringBuffer(17 * this._coordinates.length);\n    strBuf.append('(');\n    strBuf.append(this._coordinates[0]);\n    for (var i = 1; i < this._coordinates.length; i++) {\n      strBuf.append(', ');\n      strBuf.append(this$1._coordinates[i]);\n    }\n    strBuf.append(')');\n    return strBuf.toString()\n  } else {\n    return '()'\n  }\n};\nCoordinateArraySequence.prototype.getY = function getY (index) {\n  return this._coordinates[index].y\n};\nCoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray () {\n  return this._coordinates\n};\nCoordinateArraySequence.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequence, Serializable]\n};\nCoordinateArraySequence.prototype.getClass = function getClass () {\n  return CoordinateArraySequence\n};\nstaticAccessors$18.serialVersionUID.get = function () { return -915438501601840650 };\n\nObject.defineProperties( CoordinateArraySequence, staticAccessors$18 );\n\nvar CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory () {};\n\nvar staticAccessors$17 = { serialVersionUID: { configurable: true },instanceObject: { configurable: true } };\n\nCoordinateArraySequenceFactory.prototype.readResolve = function readResolve () {\n  return CoordinateArraySequenceFactory.instance()\n};\nCoordinateArraySequenceFactory.prototype.create = function create () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return new CoordinateArraySequence(coordinates)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordSeq = arguments[0];\n      return new CoordinateArraySequence(coordSeq)\n    }\n  } else if (arguments.length === 2) {\n    var size = arguments[0];\n    var dimension = arguments[1];\n    if (dimension > 3) { dimension = 3; }\n    if (dimension < 2) { return new CoordinateArraySequence(size) }\n    return new CoordinateArraySequence(size, dimension)\n  }\n};\nCoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFactory, Serializable]\n};\nCoordinateArraySequenceFactory.prototype.getClass = function getClass () {\n  return CoordinateArraySequenceFactory\n};\nCoordinateArraySequenceFactory.instance = function instance () {\n  return CoordinateArraySequenceFactory.instanceObject\n};\n\nstaticAccessors$17.serialVersionUID.get = function () { return -4099577099607551657 };\nstaticAccessors$17.instanceObject.get = function () { return new CoordinateArraySequenceFactory() };\n\nObject.defineProperties( CoordinateArraySequenceFactory, staticAccessors$17 );\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nvar HashMap = (function (MapInterface) {\n  function HashMap () {\n    MapInterface.call(this);\n    this.map_ = new Map();\n  }\n\n  if ( MapInterface ) HashMap.__proto__ = MapInterface;\n  HashMap.prototype = Object.create( MapInterface && MapInterface.prototype );\n  HashMap.prototype.constructor = HashMap;\n  /**\n   * @override\n   */\n  HashMap.prototype.get = function get (key) {\n    return this.map_.get(key) || null\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.put = function put (key, value) {\n    this.map_.set(key, value);\n    return value\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.values = function values () {\n    var arrayList = new ArrayList();\n    var it = this.map_.values();\n    var o = it.next();\n    while (!o.done) {\n      arrayList.add(o.value);\n      o = it.next();\n    }\n    return arrayList\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.entrySet = function entrySet () {\n    var hashSet = new HashSet();\n    this.map_.entries().forEach(function (entry) { return hashSet.add(entry); });\n    return hashSet\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.size = function size () {\n    return this.map_.size()\n  };\n\n  return HashMap;\n}(Map$1));\n\nvar PrecisionModel = function PrecisionModel () {\n  this._modelType = null;\n  this._scale = null;\n  if (arguments.length === 0) {\n    this._modelType = PrecisionModel.FLOATING;\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Type) {\n      var modelType = arguments[0];\n      this._modelType = modelType;\n      if (modelType === PrecisionModel.FIXED) {\n        this.setScale(1.0);\n      }\n    } else if (typeof arguments[0] === 'number') {\n      var scale = arguments[0];\n      this._modelType = PrecisionModel.FIXED;\n      this.setScale(scale);\n    } else if (arguments[0] instanceof PrecisionModel) {\n      var pm = arguments[0];\n      this._modelType = pm._modelType;\n      this._scale = pm._scale;\n    }\n  }\n};\n\nvar staticAccessors$19 = { serialVersionUID: { configurable: true },maximumPreciseValue: { configurable: true } };\nPrecisionModel.prototype.equals = function equals (other) {\n  if (!(other instanceof PrecisionModel)) {\n    return false\n  }\n  var otherPrecisionModel = other;\n  return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale\n};\nPrecisionModel.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  var sigDigits = this.getMaximumSignificantDigits();\n  var otherSigDigits = other.getMaximumSignificantDigits();\n  return new Integer(sigDigits).compareTo(new Integer(otherSigDigits))\n};\nPrecisionModel.prototype.getScale = function getScale () {\n  return this._scale\n};\nPrecisionModel.prototype.isFloating = function isFloating () {\n  return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE\n};\nPrecisionModel.prototype.getType = function getType () {\n  return this._modelType\n};\nPrecisionModel.prototype.toString = function toString () {\n  var description = 'UNKNOWN';\n  if (this._modelType === PrecisionModel.FLOATING) {\n    description = 'Floating';\n  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n    description = 'Floating-Single';\n  } else if (this._modelType === PrecisionModel.FIXED) {\n    description = 'Fixed (Scale=' + this.getScale() + ')';\n  }\n  return description\n};\nPrecisionModel.prototype.makePrecise = function makePrecise () {\n  if (typeof arguments[0] === 'number') {\n    var val = arguments[0];\n    if (Double.isNaN(val)) { return val }\n    if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n      var floatSingleVal = val;\n      return floatSingleVal\n    }\n    if (this._modelType === PrecisionModel.FIXED) {\n      return Math.round(val * this._scale) / this._scale\n    }\n    return val\n  } else if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    if (this._modelType === PrecisionModel.FLOATING) { return null }\n    coord.x = this.makePrecise(coord.x);\n    coord.y = this.makePrecise(coord.y);\n  }\n};\nPrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits () {\n  var maxSigDigits = 16;\n  if (this._modelType === PrecisionModel.FLOATING) {\n    maxSigDigits = 16;\n  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n    maxSigDigits = 6;\n  } else if (this._modelType === PrecisionModel.FIXED) {\n    maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n  }\n  return maxSigDigits\n};\nPrecisionModel.prototype.setScale = function setScale (scale) {\n  this._scale = Math.abs(scale);\n};\nPrecisionModel.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable, Comparable]\n};\nPrecisionModel.prototype.getClass = function getClass () {\n  return PrecisionModel\n};\nPrecisionModel.mostPrecise = function mostPrecise (pm1, pm2) {\n  if (pm1.compareTo(pm2) >= 0) { return pm1 }\n  return pm2\n};\nstaticAccessors$19.serialVersionUID.get = function () { return 7777263578777803835 };\nstaticAccessors$19.maximumPreciseValue.get = function () { return 9007199254740992.0 };\n\nObject.defineProperties( PrecisionModel, staticAccessors$19 );\n\nvar Type = function Type (name) {\n  this._name = name || null;\n  Type.nameToTypeMap.put(name, this);\n};\n\nvar staticAccessors$1$1 = { serialVersionUID: { configurable: true },nameToTypeMap: { configurable: true } };\nType.prototype.readResolve = function readResolve () {\n  return Type.nameToTypeMap.get(this._name)\n};\nType.prototype.toString = function toString () {\n  return this._name\n};\nType.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nType.prototype.getClass = function getClass () {\n  return Type\n};\nstaticAccessors$1$1.serialVersionUID.get = function () { return -5528602631731589822 };\nstaticAccessors$1$1.nameToTypeMap.get = function () { return new HashMap() };\n\nObject.defineProperties( Type, staticAccessors$1$1 );\n\nPrecisionModel.Type = Type;\nPrecisionModel.FIXED = new Type('FIXED');\nPrecisionModel.FLOATING = new Type('FLOATING');\nPrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');\n\nvar GeometryFactory = function GeometryFactory () {\n  this._precisionModel = new PrecisionModel();\n  this._SRID = 0;\n  this._coordinateSequenceFactory = GeometryFactory.getDefaultCoordinateSequenceFactory();\n\n  if (arguments.length === 0) {\n  } else if (arguments.length === 1) {\n    if (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n      this._coordinateSequenceFactory = arguments[0];\n    } else if (arguments[0] instanceof PrecisionModel) {\n      this._precisionModel = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    this._precisionModel = arguments[0];\n    this._SRID = arguments[1];\n  } else if (arguments.length === 3) {\n    this._precisionModel = arguments[0];\n    this._SRID = arguments[1];\n    this._coordinateSequenceFactory = arguments[2];\n  }\n};\n\nvar staticAccessors$2 = { serialVersionUID: { configurable: true } };\nGeometryFactory.prototype.toGeometry = function toGeometry (envelope) {\n  if (envelope.isNull()) {\n    return this.createPoint(null)\n  }\n  if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n    return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()))\n  }\n  if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n    return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())])\n  }\n  return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null)\n};\nGeometryFactory.prototype.createLineString = function createLineString (coordinates) {\n  if (!coordinates) { return new LineString(this.getCoordinateSequenceFactory().create([]), this) }\n  else if (coordinates instanceof Array) { return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this) }\n  else if (hasInterface(coordinates, CoordinateSequence)) { return new LineString(coordinates, this) }\n};\nGeometryFactory.prototype.createMultiLineString = function createMultiLineString () {\n  if (arguments.length === 0) {\n    return new MultiLineString(null, this)\n  } else if (arguments.length === 1) {\n    var lineStrings = arguments[0];\n    return new MultiLineString(lineStrings, this)\n  }\n};\nGeometryFactory.prototype.buildGeometry = function buildGeometry (geomList) {\n  var geomClass = null;\n  var isHeterogeneous = false;\n  var hasGeometryCollection = false;\n  for (var i = geomList.iterator(); i.hasNext();) {\n    var geom = i.next();\n    var partClass = geom.getClass();\n    if (geomClass === null) {\n      geomClass = partClass;\n    }\n    if (partClass !== geomClass) {\n      isHeterogeneous = true;\n    }\n    if (geom.isGeometryCollectionOrDerived()) { hasGeometryCollection = true; }\n  }\n  if (geomClass === null) {\n    return this.createGeometryCollection()\n  }\n  if (isHeterogeneous || hasGeometryCollection) {\n    return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList))\n  }\n  var geom0 = geomList.iterator().next();\n  var isCollection = geomList.size() > 1;\n  if (isCollection) {\n    if (geom0 instanceof Polygon) {\n      return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList))\n    } else if (geom0 instanceof LineString) {\n      return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList))\n    } else if (geom0 instanceof Point) {\n      return this.createMultiPoint(GeometryFactory.toPointArray(geomList))\n    }\n    Assert.shouldNeverReachHere('Unhandled class: ' + geom0.getClass().getName());\n  }\n  return geom0\n};\nGeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords (coordinates) {\n  return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n};\nGeometryFactory.prototype.createPoint = function createPoint () {\n  if (arguments.length === 0) {\n    return this.createPoint(this.getCoordinateSequenceFactory().create([]))\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var coordinate = arguments[0];\n      return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates = arguments[0];\n      return new Point(coordinates, this)\n    }\n  }\n};\nGeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory () {\n  return this._coordinateSequenceFactory\n};\nGeometryFactory.prototype.createPolygon = function createPolygon () {\n  if (arguments.length === 0) {\n    return new Polygon(null, null, this)\n  } else if (arguments.length === 1) {\n    if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates = arguments[0];\n      return this.createPolygon(this.createLinearRing(coordinates))\n    } else if (arguments[0] instanceof Array) {\n      var coordinates$1 = arguments[0];\n      return this.createPolygon(this.createLinearRing(coordinates$1))\n    } else if (arguments[0] instanceof LinearRing) {\n      var shell = arguments[0];\n      return this.createPolygon(shell, null)\n    }\n  } else if (arguments.length === 2) {\n    var shell$1 = arguments[0];\n    var holes = arguments[1];\n    return new Polygon(shell$1, holes, this)\n  }\n};\nGeometryFactory.prototype.getSRID = function getSRID () {\n  return this._SRID\n};\nGeometryFactory.prototype.createGeometryCollection = function createGeometryCollection () {\n  if (arguments.length === 0) {\n    return new GeometryCollection(null, this)\n  } else if (arguments.length === 1) {\n    var geometries = arguments[0];\n    return new GeometryCollection(geometries, this)\n  }\n};\nGeometryFactory.prototype.createGeometry = function createGeometry (g) {\n  var editor = new GeometryEditor(this);\n  return editor.edit(g, {\n    edit: function () {\n      if (arguments.length === 2) {\n        var coordSeq = arguments[0];\n        // const geometry = arguments[1]\n        return this._coordinateSequenceFactory.create(coordSeq)\n      }\n    }\n  })\n};\nGeometryFactory.prototype.getPrecisionModel = function getPrecisionModel () {\n  return this._precisionModel\n};\nGeometryFactory.prototype.createLinearRing = function createLinearRing () {\n  if (arguments.length === 0) {\n    return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates$1 = arguments[0];\n      return new LinearRing(coordinates$1, this)\n    }\n  }\n};\nGeometryFactory.prototype.createMultiPolygon = function createMultiPolygon () {\n  if (arguments.length === 0) {\n    return new MultiPolygon(null, this)\n  } else if (arguments.length === 1) {\n    var polygons = arguments[0];\n    return new MultiPolygon(polygons, this)\n  }\n};\nGeometryFactory.prototype.createMultiPoint = function createMultiPoint () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    return new MultiPoint(null, this)\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var point = arguments[0];\n      return new MultiPoint(point, this)\n    } else if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates$1 = arguments[0];\n      if (coordinates$1 === null) {\n        return this.createMultiPoint(new Array(0).fill(null))\n      }\n      var points = new Array(coordinates$1.size()).fill(null);\n      for (var i = 0; i < coordinates$1.size(); i++) {\n        var ptSeq = this$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());\n        CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);\n        points[i] = this$1.createPoint(ptSeq);\n      }\n      return this.createMultiPoint(points)\n    }\n  }\n};\nGeometryFactory.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nGeometryFactory.prototype.getClass = function getClass () {\n  return GeometryFactory\n};\nGeometryFactory.toMultiPolygonArray = function toMultiPolygonArray (multiPolygons) {\n  var multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n  return multiPolygons.toArray(multiPolygonArray)\n};\nGeometryFactory.toGeometryArray = function toGeometryArray (geometries) {\n  if (geometries === null) { return null }\n  var geometryArray = new Array(geometries.size()).fill(null);\n  return geometries.toArray(geometryArray)\n};\nGeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory () {\n  return CoordinateArraySequenceFactory.instance()\n};\nGeometryFactory.toMultiLineStringArray = function toMultiLineStringArray (multiLineStrings) {\n  var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n  return multiLineStrings.toArray(multiLineStringArray)\n};\nGeometryFactory.toLineStringArray = function toLineStringArray (lineStrings) {\n  var lineStringArray = new Array(lineStrings.size()).fill(null);\n  return lineStrings.toArray(lineStringArray)\n};\nGeometryFactory.toMultiPointArray = function toMultiPointArray (multiPoints) {\n  var multiPointArray = new Array(multiPoints.size()).fill(null);\n  return multiPoints.toArray(multiPointArray)\n};\nGeometryFactory.toLinearRingArray = function toLinearRingArray (linearRings) {\n  var linearRingArray = new Array(linearRings.size()).fill(null);\n  return linearRings.toArray(linearRingArray)\n};\nGeometryFactory.toPointArray = function toPointArray (points) {\n  var pointArray = new Array(points.size()).fill(null);\n  return points.toArray(pointArray)\n};\nGeometryFactory.toPolygonArray = function toPolygonArray (polygons) {\n  var polygonArray = new Array(polygons.size()).fill(null);\n  return polygons.toArray(polygonArray)\n};\nGeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord (coord, exemplar) {\n  exemplar.getPrecisionModel().makePrecise(coord);\n  return exemplar.getFactory().createPoint(coord)\n};\nstaticAccessors$2.serialVersionUID.get = function () { return -6820524753094095635 };\n\nObject.defineProperties( GeometryFactory, staticAccessors$2 );\n\nvar geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nvar GeoJSONParser = function GeoJSONParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n};\n/**\n * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n *\n * @param {}\n *        A GeoJSON object.\n * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n * @private\n */\nGeoJSONParser.prototype.read = function read (json) {\n  var obj;\n  if (typeof json === 'string') {\n    obj = JSON.parse(json);\n  } else {\n    obj = json;\n  }\n\n  var type = obj.type;\n\n  if (!parse[type]) {\n    throw new Error('Unknown GeoJSON type: ' + obj.type)\n  }\n\n  if (geometryTypes.indexOf(type) !== -1) {\n    return parse[type].apply(this, [obj.coordinates])\n  } else if (type === 'GeometryCollection') {\n    return parse[type].apply(this, [obj.geometries])\n  }\n\n  // feature or feature collection\n  return parse[type].apply(this, [obj])\n};\n\n/**\n * Serialize a Geometry object into GeoJSON\n *\n * @param {Geometry}\n *        geometry A Geometry or array of Geometries.\n * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n * @private\n */\nGeoJSONParser.prototype.write = function write (geometry) {\n  var type = geometry.getGeometryType();\n\n  if (!extract[type]) {\n    throw new Error('Geometry is not supported')\n  }\n\n  return extract[type].apply(this, [geometry])\n};\n\nvar parse = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function (obj) {\n    var feature = {};\n\n    // copy features\n    for (var key in obj) {\n      feature[key] = obj[key];\n    }\n\n    // parse geometry\n    if (obj.geometry) {\n      var type = obj.geometry.type;\n      if (!parse[type]) {\n        throw new Error('Unknown GeoJSON type: ' + obj.type)\n      }\n      feature.geometry = this.read(obj.geometry);\n    }\n\n    // bbox\n    if (obj.bbox) {\n      feature.bbox = parse.bbox.apply(this, [obj.bbox]);\n    }\n\n    return feature\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function (obj) {\n    var this$1 = this;\n\n    var featureCollection = {};\n\n    if (obj.features) {\n      featureCollection.features = [];\n\n      for (var i = 0; i < obj.features.length; ++i) {\n        featureCollection.features.push(this$1.read(obj.features[i]));\n      }\n    }\n\n    if (obj.bbox) {\n      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);\n    }\n\n    return featureCollection\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function (array) {\n    var coordinates = [];\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i];\n      coordinates.push(new Coordinate(sub[0], sub[1]));\n    }\n    return coordinates\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function (array) {\n    return this.geometryFactory.createLinearRing([\n      new Coordinate(array[0], array[1]),\n      new Coordinate(array[2], array[1]),\n      new Coordinate(array[2], array[3]),\n      new Coordinate(array[0], array[3]),\n      new Coordinate(array[0], array[1])\n    ])\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function (array) {\n    var coordinate = new Coordinate(array[0], array[1]);\n    return this.geometryFactory.createPoint(coordinate)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function (array) {\n    var this$1 = this;\n\n    var points = [];\n    for (var i = 0; i < array.length; ++i) {\n      points.push(parse.Point.apply(this$1, [array[i]]));\n    }\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function (array) {\n    var coordinates = parse.coordinates.apply(this, [array]);\n    return this.geometryFactory.createLineString(coordinates)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function (array) {\n    var this$1 = this;\n\n    var lineStrings = [];\n    for (var i = 0; i < array.length; ++i) {\n      lineStrings.push(parse.LineString.apply(this$1, [array[i]]));\n    }\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function (array) {\n    var this$1 = this;\n\n    var shellCoordinates = parse.coordinates.apply(this, [array[0]]);\n    var shell = this.geometryFactory.createLinearRing(shellCoordinates);\n    var holes = [];\n    for (var i = 1; i < array.length; ++i) {\n      var hole = array[i];\n      var coordinates = parse.coordinates.apply(this$1, [hole]);\n      var linearRing = this$1.geometryFactory.createLinearRing(coordinates);\n      holes.push(linearRing);\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function (array) {\n    var this$1 = this;\n\n    var polygons = [];\n    for (var i = 0; i < array.length; ++i) {\n      var polygon = array[i];\n      polygons.push(parse.Polygon.apply(this$1, [polygon]));\n    }\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function (array) {\n    var this$1 = this;\n\n    var geometries = [];\n    for (var i = 0; i < array.length; ++i) {\n      var geometry = array[i];\n      geometries.push(this$1.read(geometry));\n    }\n    return this.geometryFactory.createGeometryCollection(geometries)\n  }\n};\n\nvar extract = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function (coordinate) {\n    return [coordinate.x, coordinate.y]\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function (point) {\n    var array = extract.coordinate.apply(this, [point.getCoordinate()]);\n    return {\n      type: 'Point',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function (multipoint) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multipoint._geometries.length; ++i) {\n      var point = multipoint._geometries[i];\n      var geoJson = extract.Point.apply(this$1, [point]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function (linestring) {\n    var this$1 = this;\n\n    var array = [];\n    var coordinates = linestring.getCoordinates();\n    for (var i = 0; i < coordinates.length; ++i) {\n      var coordinate = coordinates[i];\n      array.push(extract.coordinate.apply(this$1, [coordinate]));\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function (multilinestring) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multilinestring._geometries.length; ++i) {\n      var linestring = multilinestring._geometries[i];\n      var geoJson = extract.LineString.apply(this$1, [linestring]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function (polygon) {\n    var this$1 = this;\n\n    var array = [];\n    var shellGeoJson = extract.LineString.apply(this, [polygon._shell]);\n    array.push(shellGeoJson.coordinates);\n    for (var i = 0; i < polygon._holes.length; ++i) {\n      var hole = polygon._holes[i];\n      var holeGeoJson = extract.LineString.apply(this$1, [hole]);\n      array.push(holeGeoJson.coordinates);\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function (multipolygon) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multipolygon._geometries.length; ++i) {\n      var polygon = multipolygon._geometries[i];\n      var geoJson = extract.Polygon.apply(this$1, [polygon]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function (collection) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < collection._geometries.length; ++i) {\n      var geometry = collection._geometries[i];\n      var type = geometry.getGeometryType();\n      array.push(extract[type].apply(this$1, [geometry]));\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    }\n  }\n};\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\n\n/**\n * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n * to allow it to create <code>Geometry</code> objects of the appropriate\n * implementation. In particular, the <code>GeometryFactory</code> determines\n * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar GeoJSONReader = function GeoJSONReader (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n  this.precisionModel = this.geometryFactory.getPrecisionModel();\n  this.parser = new GeoJSONParser(this.geometryFactory);\n};\n/**\n * Reads a GeoJSON representation of a {@link Geometry}\n *\n * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n *\n * @param {Object|String} geoJson a GeoJSON Object or String.\n * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n * @memberof GeoJSONReader\n */\nGeoJSONReader.prototype.read = function read (geoJson) {\n  var geometry = this.parser.read(geoJson);\n\n  if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n    this.reducePrecision(geometry);\n  }\n\n  return geometry\n};\n\n// NOTE: this is a hack\nGeoJSONReader.prototype.reducePrecision = function reducePrecision (geometry) {\n    var this$1 = this;\n\n  var i, len;\n\n  if (geometry.coordinate) {\n    this.precisionModel.makePrecise(geometry.coordinate);\n  } else if (geometry.points) {\n    for (i = 0, len = geometry.points.length; i < len; i++) {\n      this$1.precisionModel.makePrecise(geometry.points[i]);\n    }\n  } else if (geometry.geometries) {\n    for (i = 0, len = geometry.geometries.length; i < len; i++) {\n      this$1.reducePrecision(geometry.geometries[i]);\n    }\n  }\n};\n\n/**\n * @module GeoJSONWriter\n */\n\n/**\n * Writes the GeoJSON representation of a {@link Geometry}. The\n * The GeoJSON format is defined <A\n * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n */\n\n/**\n * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar GeoJSONWriter = function GeoJSONWriter () {\n  this.parser = new GeoJSONParser(this.geometryFactory);\n};\n/**\n * Converts a <code>Geometry</code> to its GeoJSON representation.\n *\n * @param {Geometry}\n *        geometry a <code>Geometry</code> to process.\n * @return {Object} The GeoJSON representation of the Geometry.\n * @memberof GeoJSONWriter\n */\nGeoJSONWriter.prototype.write = function write (geometry) {\n  return this.parser.write(geometry)\n};\n\n/* eslint-disable no-undef */\n\n// io\n\nvar Position = function Position () {};\n\nvar staticAccessors$20 = { ON: { configurable: true },LEFT: { configurable: true },RIGHT: { configurable: true } };\n\nPosition.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPosition.prototype.getClass = function getClass () {\n  return Position\n};\nPosition.opposite = function opposite (position) {\n  if (position === Position.LEFT) { return Position.RIGHT }\n  if (position === Position.RIGHT) { return Position.LEFT }\n  return position\n};\nstaticAccessors$20.ON.get = function () { return 0 };\nstaticAccessors$20.LEFT.get = function () { return 1 };\nstaticAccessors$20.RIGHT.get = function () { return 2 };\n\nObject.defineProperties( Position, staticAccessors$20 );\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction EmptyStackException (message) {\n  this.message = message || '';\n}\nEmptyStackException.prototype = new Error();\n\n/**\n * @type {string}\n */\nEmptyStackException.prototype.name = 'EmptyStackException';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n *\n * @extends {List}\n * @constructor\n * @private\n */\nfunction Stack () {\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.array_ = [];\n}\nStack.prototype = new List();\n\n/**\n * @override\n */\nStack.prototype.add = function (e) {\n  this.array_.push(e);\n  return true\n};\n\n/**\n * @override\n */\nStack.prototype.get = function (index) {\n  if (index < 0 || index >= this.size()) {\n    throw new Error()\n  }\n\n  return this.array_[index]\n};\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.push = function (e) {\n  this.array_.push(e);\n  return e\n};\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.pop = function (e) {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException()\n  }\n\n  return this.array_.pop()\n};\n\n/**\n * Looks at the object at the top of this stack without removing it from the\n * stack.\n * @return {Object}\n */\nStack.prototype.peek = function () {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException()\n  }\n\n  return this.array_[this.array_.length - 1]\n};\n\n/**\n * Tests if this stack is empty.\n * @return {boolean} true if and only if this stack contains no items; false\n *         otherwise.\n */\nStack.prototype.empty = function () {\n  if (this.array_.length === 0) {\n    return true\n  } else {\n    return false\n  }\n};\n\n/**\n * @return {boolean}\n */\nStack.prototype.isEmpty = function () {\n  return this.empty()\n};\n\n/**\n * Returns the 1-based position where an object is on this stack. If the object\n * o occurs as an item in this stack, this method returns the distance from the\n * top of the stack of the occurrence nearest the top of the stack; the topmost\n * item on the stack is considered to be at distance 1. The equals method is\n * used to compare o to the items in this stack.\n *\n * NOTE: does not currently actually use equals. (=== is used)\n *\n * @param {Object} o\n * @return {number} the 1-based position from the top of the stack where the\n *         object is located; the return value -1 indicates that the object is\n *         not on the stack.\n */\nStack.prototype.search = function (o) {\n  return this.array_.indexOf(o)\n};\n\n/**\n * @return {number}\n * @export\n */\nStack.prototype.size = function () {\n  return this.array_.length\n};\n\n/**\n * @return {Array}\n */\nStack.prototype.toArray = function () {\n  var this$1 = this;\n\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this$1.array_[i]);\n  }\n\n  return array\n};\n\nvar RightmostEdgeFinder = function RightmostEdgeFinder () {\n  this._minIndex = -1;\n  this._minCoord = null;\n  this._minDe = null;\n  this._orientedDe = null;\n};\nRightmostEdgeFinder.prototype.getCoordinate = function getCoordinate () {\n  return this._minCoord\n};\nRightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide (de, index) {\n  var side = this.getRightmostSideOfSegment(de, index);\n  if (side < 0) { side = this.getRightmostSideOfSegment(de, index - 1); }\n  if (side < 0) {\n    this._minCoord = null;\n    this.checkForRightmostCoordinate(de);\n  }\n  return side\n};\nRightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex () {\n  var pts = this._minDe.getEdge().getCoordinates();\n  Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');\n  var pPrev = pts[this._minIndex - 1];\n  var pNext = pts[this._minIndex + 1];\n  var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);\n  var usePrev = false;\n  if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {\n    usePrev = true;\n  } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {\n    usePrev = true;\n  }\n  if (usePrev) {\n    this._minIndex = this._minIndex - 1;\n  }\n};\nRightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment (de, i) {\n  var e = de.getEdge();\n  var coord = e.getCoordinates();\n  if (i < 0 || i + 1 >= coord.length) { return -1 }\n  if (coord[i].y === coord[i + 1].y) { return -1 }\n  var pos = Position.LEFT;\n  if (coord[i].y < coord[i + 1].y) { pos = Position.RIGHT; }\n  return pos\n};\nRightmostEdgeFinder.prototype.getEdge = function getEdge () {\n  return this._orientedDe\n};\nRightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate (de) {\n    var this$1 = this;\n\n  var coord = de.getEdge().getCoordinates();\n  for (var i = 0; i < coord.length - 1; i++) {\n    if (this$1._minCoord === null || coord[i].x > this$1._minCoord.x) {\n      this$1._minDe = de;\n      this$1._minIndex = i;\n      this$1._minCoord = coord[i];\n    }\n  }\n};\nRightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode () {\n  var node = this._minDe.getNode();\n  var star = node.getEdges();\n  this._minDe = star.getRightmostEdge();\n  if (!this._minDe.isForward()) {\n    this._minDe = this._minDe.getSym();\n    this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n  }\n};\nRightmostEdgeFinder.prototype.findEdge = function findEdge (dirEdgeList) {\n    var this$1 = this;\n\n  for (var i = dirEdgeList.iterator(); i.hasNext();) {\n    var de = i.next();\n    if (!de.isForward()) { continue }\n    this$1.checkForRightmostCoordinate(de);\n  }\n  Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');\n  if (this._minIndex === 0) {\n    this.findRightmostEdgeAtNode();\n  } else {\n    this.findRightmostEdgeAtVertex();\n  }\n  this._orientedDe = this._minDe;\n  var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n  if (rightmostSide === Position.LEFT) {\n    this._orientedDe = this._minDe.getSym();\n  }\n};\nRightmostEdgeFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRightmostEdgeFinder.prototype.getClass = function getClass () {\n  return RightmostEdgeFinder\n};\n\nvar TopologyException = (function (RuntimeException$$1) {\n  function TopologyException (msg, pt) {\n    RuntimeException$$1.call(this, TopologyException.msgWithCoord(msg, pt));\n    this.pt = pt ? new Coordinate(pt) : null;\n    this.name = 'TopologyException';\n  }\n\n  if ( RuntimeException$$1 ) TopologyException.__proto__ = RuntimeException$$1;\n  TopologyException.prototype = Object.create( RuntimeException$$1 && RuntimeException$$1.prototype );\n  TopologyException.prototype.constructor = TopologyException;\n  TopologyException.prototype.getCoordinate = function getCoordinate () {\n    return this.pt\n  };\n  TopologyException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  TopologyException.prototype.getClass = function getClass () {\n    return TopologyException\n  };\n  TopologyException.msgWithCoord = function msgWithCoord (msg, pt) {\n    if (!pt) { return msg + ' [ ' + pt + ' ]' }\n    return msg\n  };\n\n  return TopologyException;\n}(RuntimeException));\n\nvar LinkedList = function LinkedList () {\n  this.array_ = [];\n};\nLinkedList.prototype.addLast = function addLast (e) {\n  this.array_.push(e);\n};\nLinkedList.prototype.removeFirst = function removeFirst () {\n  return this.array_.shift()\n};\nLinkedList.prototype.isEmpty = function isEmpty () {\n  return this.array_.length === 0\n};\n\nvar BufferSubgraph = function BufferSubgraph () {\n  this._finder = null;\n  this._dirEdgeList = new ArrayList();\n  this._nodes = new ArrayList();\n  this._rightMostCoord = null;\n  this._env = null;\n  this._finder = new RightmostEdgeFinder();\n};\nBufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges () {\n  for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n    var de = it.next();\n    de.setVisited(false);\n  }\n};\nBufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate () {\n  return this._rightMostCoord\n};\nBufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth (n) {\n    var this$1 = this;\n\n  var startEdge = null;\n  for (var i = n.getEdges().iterator(); i.hasNext();) {\n    var de = i.next();\n    if (de.isVisited() || de.getSym().isVisited()) {\n      startEdge = de;\n      break\n    }\n  }\n  if (startEdge === null) { throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate()) }\n  n.getEdges().computeDepths(startEdge);\n  for (var i$1 = n.getEdges().iterator(); i$1.hasNext();) {\n    var de$1 = i$1.next();\n    de$1.setVisited(true);\n    this$1.copySymDepths(de$1);\n  }\n};\nBufferSubgraph.prototype.computeDepth = function computeDepth (outsideDepth) {\n  this.clearVisitedEdges();\n  var de = this._finder.getEdge();\n  // const n = de.getNode()\n  // const label = de.getLabel()\n  de.setEdgeDepths(Position.RIGHT, outsideDepth);\n  this.copySymDepths(de);\n  this.computeDepths(de);\n};\nBufferSubgraph.prototype.create = function create (node) {\n  this.addReachable(node);\n  this._finder.findEdge(this._dirEdgeList);\n  this._rightMostCoord = this._finder.getCoordinate();\n};\nBufferSubgraph.prototype.findResultEdges = function findResultEdges () {\n  for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n    var de = it.next();\n    if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n      de.setInResult(true);\n    }\n  }\n};\nBufferSubgraph.prototype.computeDepths = function computeDepths (startEdge) {\n    var this$1 = this;\n\n  var nodesVisited = new HashSet();\n  var nodeQueue = new LinkedList();\n  var startNode = startEdge.getNode();\n  nodeQueue.addLast(startNode);\n  nodesVisited.add(startNode);\n  startEdge.setVisited(true);\n  while (!nodeQueue.isEmpty()) {\n    var n = nodeQueue.removeFirst();\n    nodesVisited.add(n);\n    this$1.computeNodeDepth(n);\n    for (var i = n.getEdges().iterator(); i.hasNext();) {\n      var de = i.next();\n      var sym = de.getSym();\n      if (sym.isVisited()) { continue }\n      var adjNode = sym.getNode();\n      if (!nodesVisited.contains(adjNode)) {\n        nodeQueue.addLast(adjNode);\n        nodesVisited.add(adjNode);\n      }\n    }\n  }\n};\nBufferSubgraph.prototype.compareTo = function compareTo (o) {\n  var graph = o;\n  if (this._rightMostCoord.x < graph._rightMostCoord.x) {\n    return -1\n  }\n  if (this._rightMostCoord.x > graph._rightMostCoord.x) {\n    return 1\n  }\n  return 0\n};\nBufferSubgraph.prototype.getEnvelope = function getEnvelope () {\n  if (this._env === null) {\n    var edgeEnv = new Envelope();\n    for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n      var dirEdge = it.next();\n      var pts = dirEdge.getEdge().getCoordinates();\n      for (var i = 0; i < pts.length - 1; i++) {\n        edgeEnv.expandToInclude(pts[i]);\n      }\n    }\n    this._env = edgeEnv;\n  }\n  return this._env\n};\nBufferSubgraph.prototype.addReachable = function addReachable (startNode) {\n    var this$1 = this;\n\n  var nodeStack = new Stack();\n  nodeStack.add(startNode);\n  while (!nodeStack.empty()) {\n    var node = nodeStack.pop();\n    this$1.add(node, nodeStack);\n  }\n};\nBufferSubgraph.prototype.copySymDepths = function copySymDepths (de) {\n  var sym = de.getSym();\n  sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n  sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n};\nBufferSubgraph.prototype.add = function add (node, nodeStack) {\n    var this$1 = this;\n\n  node.setVisited(true);\n  this._nodes.add(node);\n  for (var i = node.getEdges().iterator(); i.hasNext();) {\n    var de = i.next();\n    this$1._dirEdgeList.add(de);\n    var sym = de.getSym();\n    var symNode = sym.getNode();\n    if (!symNode.isVisited()) { nodeStack.push(symNode); }\n  }\n};\nBufferSubgraph.prototype.getNodes = function getNodes () {\n  return this._nodes\n};\nBufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges () {\n  return this._dirEdgeList\n};\nBufferSubgraph.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nBufferSubgraph.prototype.getClass = function getClass () {\n  return BufferSubgraph\n};\n\nvar TopologyLocation = function TopologyLocation () {\n  var this$1 = this;\n\n  this.location = null;\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var location = arguments[0];\n      this.init(location.length);\n    } else if (Number.isInteger(arguments[0])) {\n      var on = arguments[0];\n      this.init(1);\n      this.location[Position.ON] = on;\n    } else if (arguments[0] instanceof TopologyLocation) {\n      var gl = arguments[0];\n      this.init(gl.location.length);\n      if (gl !== null) {\n        for (var i = 0; i < this.location.length; i++) {\n          this$1.location[i] = gl.location[i];\n        }\n      }\n    }\n  } else if (arguments.length === 3) {\n    var on$1 = arguments[0];\n    var left = arguments[1];\n    var right = arguments[2];\n    this.init(3);\n    this.location[Position.ON] = on$1;\n    this.location[Position.LEFT] = left;\n    this.location[Position.RIGHT] = right;\n  }\n};\nTopologyLocation.prototype.setAllLocations = function setAllLocations (locValue) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    this$1.location[i] = locValue;\n  }\n};\nTopologyLocation.prototype.isNull = function isNull () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] !== Location.NONE) { return false }\n  }\n  return true\n};\nTopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull (locValue) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE) { this$1.location[i] = locValue; }\n  }\n};\nTopologyLocation.prototype.isLine = function isLine () {\n  return this.location.length === 1\n};\nTopologyLocation.prototype.merge = function merge (gl) {\n    var this$1 = this;\n\n  if (gl.location.length > this.location.length) {\n    var newLoc = new Array(3).fill(null);\n    newLoc[Position.ON] = this.location[Position.ON];\n    newLoc[Position.LEFT] = Location.NONE;\n    newLoc[Position.RIGHT] = Location.NONE;\n    this.location = newLoc;\n  }\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE && i < gl.location.length) { this$1.location[i] = gl.location[i]; }\n  }\n};\nTopologyLocation.prototype.getLocations = function getLocations () {\n  return this.location\n};\nTopologyLocation.prototype.flip = function flip () {\n  if (this.location.length <= 1) { return null }\n  var temp = this.location[Position.LEFT];\n  this.location[Position.LEFT] = this.location[Position.RIGHT];\n  this.location[Position.RIGHT] = temp;\n};\nTopologyLocation.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position.LEFT])); }\n  buf.append(Location.toLocationSymbol(this.location[Position.ON]));\n  if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position.RIGHT])); }\n  return buf.toString()\n};\nTopologyLocation.prototype.setLocations = function setLocations (on, left, right) {\n  this.location[Position.ON] = on;\n  this.location[Position.LEFT] = left;\n  this.location[Position.RIGHT] = right;\n};\nTopologyLocation.prototype.get = function get (posIndex) {\n  if (posIndex < this.location.length) { return this.location[posIndex] }\n  return Location.NONE\n};\nTopologyLocation.prototype.isArea = function isArea () {\n  return this.location.length > 1\n};\nTopologyLocation.prototype.isAnyNull = function isAnyNull () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE) { return true }\n  }\n  return false\n};\nTopologyLocation.prototype.setLocation = function setLocation () {\n  if (arguments.length === 1) {\n    var locValue = arguments[0];\n    this.setLocation(Position.ON, locValue);\n  } else if (arguments.length === 2) {\n    var locIndex = arguments[0];\n    var locValue$1 = arguments[1];\n    this.location[locIndex] = locValue$1;\n  }\n};\nTopologyLocation.prototype.init = function init (size) {\n  this.location = new Array(size).fill(null);\n  this.setAllLocations(Location.NONE);\n};\nTopologyLocation.prototype.isEqualOnSide = function isEqualOnSide (le, locIndex) {\n  return this.location[locIndex] === le.location[locIndex]\n};\nTopologyLocation.prototype.allPositionsEqual = function allPositionsEqual (loc) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] !== loc) { return false }\n  }\n  return true\n};\nTopologyLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nTopologyLocation.prototype.getClass = function getClass () {\n  return TopologyLocation\n};\n\nvar Label = function Label () {\n  this.elt = new Array(2).fill(null);\n  if (arguments.length === 1) {\n    if (Number.isInteger(arguments[0])) {\n      var onLoc = arguments[0];\n      this.elt[0] = new TopologyLocation(onLoc);\n      this.elt[1] = new TopologyLocation(onLoc);\n    } else if (arguments[0] instanceof Label) {\n      var lbl = arguments[0];\n      this.elt[0] = new TopologyLocation(lbl.elt[0]);\n      this.elt[1] = new TopologyLocation(lbl.elt[1]);\n    }\n  } else if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var onLoc$1 = arguments[1];\n    this.elt[0] = new TopologyLocation(Location.NONE);\n    this.elt[1] = new TopologyLocation(Location.NONE);\n    this.elt[geomIndex].setLocation(onLoc$1);\n  } else if (arguments.length === 3) {\n    var onLoc$2 = arguments[0];\n    var leftLoc = arguments[1];\n    var rightLoc = arguments[2];\n    this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);\n    this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);\n  } else if (arguments.length === 4) {\n    var geomIndex$1 = arguments[0];\n    var onLoc$3 = arguments[1];\n    var leftLoc$1 = arguments[2];\n    var rightLoc$1 = arguments[3];\n    this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n    this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n    this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);\n  }\n};\nLabel.prototype.getGeometryCount = function getGeometryCount () {\n  var count = 0;\n  if (!this.elt[0].isNull()) { count++; }\n  if (!this.elt[1].isNull()) { count++; }\n  return count\n};\nLabel.prototype.setAllLocations = function setAllLocations (geomIndex, location) {\n  this.elt[geomIndex].setAllLocations(location);\n};\nLabel.prototype.isNull = function isNull (geomIndex) {\n  return this.elt[geomIndex].isNull()\n};\nLabel.prototype.setAllLocationsIfNull = function setAllLocationsIfNull () {\n  if (arguments.length === 1) {\n    var location = arguments[0];\n    this.setAllLocationsIfNull(0, location);\n    this.setAllLocationsIfNull(1, location);\n  } else if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var location$1 = arguments[1];\n    this.elt[geomIndex].setAllLocationsIfNull(location$1);\n  }\n};\nLabel.prototype.isLine = function isLine (geomIndex) {\n  return this.elt[geomIndex].isLine()\n};\nLabel.prototype.merge = function merge (lbl) {\n    var this$1 = this;\n\n  for (var i = 0; i < 2; i++) {\n    if (this$1.elt[i] === null && lbl.elt[i] !== null) {\n      this$1.elt[i] = new TopologyLocation(lbl.elt[i]);\n    } else {\n      this$1.elt[i].merge(lbl.elt[i]);\n    }\n  }\n};\nLabel.prototype.flip = function flip () {\n  this.elt[0].flip();\n  this.elt[1].flip();\n};\nLabel.prototype.getLocation = function getLocation () {\n  if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this.elt[geomIndex].get(Position.ON)\n  } else if (arguments.length === 2) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    return this.elt[geomIndex$1].get(posIndex)\n  }\n};\nLabel.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  if (this.elt[0] !== null) {\n    buf.append('A:');\n    buf.append(this.elt[0].toString());\n  }\n  if (this.elt[1] !== null) {\n    buf.append(' B:');\n    buf.append(this.elt[1].toString());\n  }\n  return buf.toString()\n};\nLabel.prototype.isArea = function isArea () {\n  if (arguments.length === 0) {\n    return this.elt[0].isArea() || this.elt[1].isArea()\n  } else if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this.elt[geomIndex].isArea()\n  }\n};\nLabel.prototype.isAnyNull = function isAnyNull (geomIndex) {\n  return this.elt[geomIndex].isAnyNull()\n};\nLabel.prototype.setLocation = function setLocation () {\n  if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var location = arguments[1];\n    this.elt[geomIndex].setLocation(Position.ON, location);\n  } else if (arguments.length === 3) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    var location$1 = arguments[2];\n    this.elt[geomIndex$1].setLocation(posIndex, location$1);\n  }\n};\nLabel.prototype.isEqualOnSide = function isEqualOnSide (lbl, side) {\n  return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)\n};\nLabel.prototype.allPositionsEqual = function allPositionsEqual (geomIndex, loc) {\n  return this.elt[geomIndex].allPositionsEqual(loc)\n};\nLabel.prototype.toLine = function toLine (geomIndex) {\n  if (this.elt[geomIndex].isArea()) { this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]); }\n};\nLabel.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLabel.prototype.getClass = function getClass () {\n  return Label\n};\nLabel.toLineLabel = function toLineLabel (label) {\n  var lineLabel = new Label(Location.NONE);\n  for (var i = 0; i < 2; i++) {\n    lineLabel.setLocation(i, label.getLocation(i));\n  }\n  return lineLabel\n};\n\nvar EdgeRing = function EdgeRing () {\n  this._startDe = null;\n  this._maxNodeDegree = -1;\n  this._edges = new ArrayList();\n  this._pts = new ArrayList();\n  this._label = new Label(Location.NONE);\n  this._ring = null;\n  this._isHole = null;\n  this._shell = null;\n  this._holes = new ArrayList();\n  this._geometryFactory = null;\n  var start = arguments[0];\n  var geometryFactory = arguments[1];\n  this._geometryFactory = geometryFactory;\n  this.computePoints(start);\n  this.computeRing();\n};\nEdgeRing.prototype.computeRing = function computeRing () {\n    var this$1 = this;\n\n  if (this._ring !== null) { return null }\n  var coord = new Array(this._pts.size()).fill(null);\n  for (var i = 0; i < this._pts.size(); i++) {\n    coord[i] = this$1._pts.get(i);\n  }\n  this._ring = this._geometryFactory.createLinearRing(coord);\n  this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());\n};\nEdgeRing.prototype.isIsolated = function isIsolated () {\n  return this._label.getGeometryCount() === 1\n};\nEdgeRing.prototype.computePoints = function computePoints (start) {\n    var this$1 = this;\n\n  this._startDe = start;\n  var de = start;\n  var isFirstEdge = true;\n  do {\n    if (de === null) { throw new TopologyException('Found null DirectedEdge') }\n    if (de.getEdgeRing() === this$1) { throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate()) }\n    this$1._edges.add(de);\n    var label = de.getLabel();\n    Assert.isTrue(label.isArea());\n    this$1.mergeLabel(label);\n    this$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n    isFirstEdge = false;\n    this$1.setEdgeRing(de, this$1);\n    de = this$1.getNext(de);\n  } while (de !== this._startDe)\n};\nEdgeRing.prototype.getLinearRing = function getLinearRing () {\n  return this._ring\n};\nEdgeRing.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts.get(i)\n};\nEdgeRing.prototype.computeMaxNodeDegree = function computeMaxNodeDegree () {\n    var this$1 = this;\n\n  this._maxNodeDegree = 0;\n  var de = this._startDe;\n  do {\n    var node = de.getNode();\n    var degree = node.getEdges().getOutgoingDegree(this$1);\n    if (degree > this$1._maxNodeDegree) { this$1._maxNodeDegree = degree; }\n    de = this$1.getNext(de);\n  } while (de !== this._startDe)\n  this._maxNodeDegree *= 2;\n};\nEdgeRing.prototype.addPoints = function addPoints (edge, isForward, isFirstEdge) {\n    var this$1 = this;\n\n  var edgePts = edge.getCoordinates();\n  if (isForward) {\n    var startIndex = 1;\n    if (isFirstEdge) { startIndex = 0; }\n    for (var i = startIndex; i < edgePts.length; i++) {\n      this$1._pts.add(edgePts[i]);\n    }\n  } else {\n    var startIndex$1 = edgePts.length - 2;\n    if (isFirstEdge) { startIndex$1 = edgePts.length - 1; }\n    for (var i$1 = startIndex$1; i$1 >= 0; i$1--) {\n      this$1._pts.add(edgePts[i$1]);\n    }\n  }\n};\nEdgeRing.prototype.isHole = function isHole () {\n  return this._isHole\n};\nEdgeRing.prototype.setInResult = function setInResult () {\n  var de = this._startDe;\n  do {\n    de.getEdge().setInResult(true);\n    de = de.getNext();\n  } while (de !== this._startDe)\n};\nEdgeRing.prototype.containsPoint = function containsPoint (p) {\n  var shell = this.getLinearRing();\n  var env = shell.getEnvelopeInternal();\n  if (!env.contains(p)) { return false }\n  if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) { return false }\n  for (var i = this._holes.iterator(); i.hasNext();) {\n    var hole = i.next();\n    if (hole.containsPoint(p)) { return false }\n  }\n  return true\n};\nEdgeRing.prototype.addHole = function addHole (ring) {\n  this._holes.add(ring);\n};\nEdgeRing.prototype.isShell = function isShell () {\n  return this._shell === null\n};\nEdgeRing.prototype.getLabel = function getLabel () {\n  return this._label\n};\nEdgeRing.prototype.getEdges = function getEdges () {\n  return this._edges\n};\nEdgeRing.prototype.getMaxNodeDegree = function getMaxNodeDegree () {\n  if (this._maxNodeDegree < 0) { this.computeMaxNodeDegree(); }\n  return this._maxNodeDegree\n};\nEdgeRing.prototype.getShell = function getShell () {\n  return this._shell\n};\nEdgeRing.prototype.mergeLabel = function mergeLabel () {\n  if (arguments.length === 1) {\n    var deLabel = arguments[0];\n    this.mergeLabel(deLabel, 0);\n    this.mergeLabel(deLabel, 1);\n  } else if (arguments.length === 2) {\n    var deLabel$1 = arguments[0];\n    var geomIndex = arguments[1];\n    var loc = deLabel$1.getLocation(geomIndex, Position.RIGHT);\n    if (loc === Location.NONE) { return null }\n    if (this._label.getLocation(geomIndex) === Location.NONE) {\n      this._label.setLocation(geomIndex, loc);\n      return null\n    }\n  }\n};\nEdgeRing.prototype.setShell = function setShell (shell) {\n  this._shell = shell;\n  if (shell !== null) { shell.addHole(this); }\n};\nEdgeRing.prototype.toPolygon = function toPolygon (geometryFactory) {\n    var this$1 = this;\n\n  var holeLR = new Array(this._holes.size()).fill(null);\n  for (var i = 0; i < this._holes.size(); i++) {\n    holeLR[i] = this$1._holes.get(i).getLinearRing();\n  }\n  var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n  return poly\n};\nEdgeRing.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeRing.prototype.getClass = function getClass () {\n  return EdgeRing\n};\n\nvar MinimalEdgeRing = (function (EdgeRing$$1) {\n  function MinimalEdgeRing () {\n    var start = arguments[0];\n    var geometryFactory = arguments[1];\n    EdgeRing$$1.call(this, start, geometryFactory);\n  }\n\n  if ( EdgeRing$$1 ) MinimalEdgeRing.__proto__ = EdgeRing$$1;\n  MinimalEdgeRing.prototype = Object.create( EdgeRing$$1 && EdgeRing$$1.prototype );\n  MinimalEdgeRing.prototype.constructor = MinimalEdgeRing;\n  MinimalEdgeRing.prototype.setEdgeRing = function setEdgeRing (de, er) {\n    de.setMinEdgeRing(er);\n  };\n  MinimalEdgeRing.prototype.getNext = function getNext (de) {\n    return de.getNextMin()\n  };\n  MinimalEdgeRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MinimalEdgeRing.prototype.getClass = function getClass () {\n    return MinimalEdgeRing\n  };\n\n  return MinimalEdgeRing;\n}(EdgeRing));\n\nvar MaximalEdgeRing = (function (EdgeRing$$1) {\n  function MaximalEdgeRing () {\n    var start = arguments[0];\n    var geometryFactory = arguments[1];\n    EdgeRing$$1.call(this, start, geometryFactory);\n  }\n\n  if ( EdgeRing$$1 ) MaximalEdgeRing.__proto__ = EdgeRing$$1;\n  MaximalEdgeRing.prototype = Object.create( EdgeRing$$1 && EdgeRing$$1.prototype );\n  MaximalEdgeRing.prototype.constructor = MaximalEdgeRing;\n  MaximalEdgeRing.prototype.buildMinimalRings = function buildMinimalRings () {\n    var this$1 = this;\n\n    var minEdgeRings = new ArrayList();\n    var de = this._startDe;\n    do {\n      if (de.getMinEdgeRing() === null) {\n        var minEr = new MinimalEdgeRing(de, this$1._geometryFactory);\n        minEdgeRings.add(minEr);\n      }\n      de = de.getNext();\n    } while (de !== this._startDe)\n    return minEdgeRings\n  };\n  MaximalEdgeRing.prototype.setEdgeRing = function setEdgeRing (de, er) {\n    de.setEdgeRing(er);\n  };\n  MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings () {\n    var this$1 = this;\n\n    var de = this._startDe;\n    do {\n      var node = de.getNode();\n      node.getEdges().linkMinimalDirectedEdges(this$1);\n      de = de.getNext();\n    } while (de !== this._startDe)\n  };\n  MaximalEdgeRing.prototype.getNext = function getNext (de) {\n    return de.getNext()\n  };\n  MaximalEdgeRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MaximalEdgeRing.prototype.getClass = function getClass () {\n    return MaximalEdgeRing\n  };\n\n  return MaximalEdgeRing;\n}(EdgeRing));\n\nvar GraphComponent = function GraphComponent () {\n  this._label = null;\n  this._isInResult = false;\n  this._isCovered = false;\n  this._isCoveredSet = false;\n  this._isVisited = false;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var label = arguments[0];\n    this._label = label;\n  }\n};\nGraphComponent.prototype.setVisited = function setVisited (isVisited) {\n  this._isVisited = isVisited;\n};\nGraphComponent.prototype.setInResult = function setInResult (isInResult) {\n  this._isInResult = isInResult;\n};\nGraphComponent.prototype.isCovered = function isCovered () {\n  return this._isCovered\n};\nGraphComponent.prototype.isCoveredSet = function isCoveredSet () {\n  return this._isCoveredSet\n};\nGraphComponent.prototype.setLabel = function setLabel (label) {\n  this._label = label;\n};\nGraphComponent.prototype.getLabel = function getLabel () {\n  return this._label\n};\nGraphComponent.prototype.setCovered = function setCovered (isCovered) {\n  this._isCovered = isCovered;\n  this._isCoveredSet = true;\n};\nGraphComponent.prototype.updateIM = function updateIM (im) {\n  Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');\n  this.computeIM(im);\n};\nGraphComponent.prototype.isInResult = function isInResult () {\n  return this._isInResult\n};\nGraphComponent.prototype.isVisited = function isVisited () {\n  return this._isVisited\n};\nGraphComponent.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGraphComponent.prototype.getClass = function getClass () {\n  return GraphComponent\n};\n\nvar Node = (function (GraphComponent$$1) {\n  function Node () {\n    GraphComponent$$1.call(this);\n    this._coord = null;\n    this._edges = null;\n    var coord = arguments[0];\n    var edges = arguments[1];\n    this._coord = coord;\n    this._edges = edges;\n    this._label = new Label(0, Location.NONE);\n  }\n\n  if ( GraphComponent$$1 ) Node.__proto__ = GraphComponent$$1;\n  Node.prototype = Object.create( GraphComponent$$1 && GraphComponent$$1.prototype );\n  Node.prototype.constructor = Node;\n  Node.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult () {\n    for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {\n      var de = it.next();\n      if (de.getEdge().isInResult()) { return true }\n    }\n    return false\n  };\n  Node.prototype.isIsolated = function isIsolated () {\n    return this._label.getGeometryCount() === 1\n  };\n  Node.prototype.getCoordinate = function getCoordinate () {\n    return this._coord\n  };\n  Node.prototype.print = function print (out) {\n    out.println('node ' + this._coord + ' lbl: ' + this._label);\n  };\n  Node.prototype.computeIM = function computeIM (im) {};\n  Node.prototype.computeMergedLocation = function computeMergedLocation (label2, eltIndex) {\n    var loc = Location.NONE;\n    loc = this._label.getLocation(eltIndex);\n    if (!label2.isNull(eltIndex)) {\n      var nLoc = label2.getLocation(eltIndex);\n      if (loc !== Location.BOUNDARY) { loc = nLoc; }\n    }\n    return loc\n  };\n  Node.prototype.setLabel = function setLabel () {\n    if (arguments.length === 2) {\n      var argIndex = arguments[0];\n      var onLocation = arguments[1];\n      if (this._label === null) {\n        this._label = new Label(argIndex, onLocation);\n      } else { this._label.setLocation(argIndex, onLocation); }\n    } else { return GraphComponent$$1.prototype.setLabel.apply(this, arguments) }\n  };\n  Node.prototype.getEdges = function getEdges () {\n    return this._edges\n  };\n  Node.prototype.mergeLabel = function mergeLabel () {\n    var this$1 = this;\n\n    if (arguments[0] instanceof Node) {\n      var n = arguments[0];\n      this.mergeLabel(n._label);\n    } else if (arguments[0] instanceof Label) {\n      var label2 = arguments[0];\n      for (var i = 0; i < 2; i++) {\n        var loc = this$1.computeMergedLocation(label2, i);\n        var thisLoc = this$1._label.getLocation(i);\n        if (thisLoc === Location.NONE) { this$1._label.setLocation(i, loc); }\n      }\n    }\n  };\n  Node.prototype.add = function add (e) {\n    this._edges.insert(e);\n    e.setNode(this);\n  };\n  Node.prototype.setLabelBoundary = function setLabelBoundary (argIndex) {\n    if (this._label === null) { return null }\n    var loc = Location.NONE;\n    if (this._label !== null) { loc = this._label.getLocation(argIndex); }\n    var newLoc = null;\n    switch (loc) {\n      case Location.BOUNDARY:\n        newLoc = Location.INTERIOR;\n        break\n      case Location.INTERIOR:\n        newLoc = Location.BOUNDARY;\n        break\n      default:\n        newLoc = Location.BOUNDARY;\n        break\n    }\n    this._label.setLocation(argIndex, newLoc);\n  };\n  Node.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  Node.prototype.getClass = function getClass () {\n    return Node\n  };\n\n  return Node;\n}(GraphComponent));\n\nvar NodeMap = function NodeMap () {\n  this.nodeMap = new TreeMap();\n  this.nodeFact = null;\n  var nodeFact = arguments[0];\n  this.nodeFact = nodeFact;\n};\nNodeMap.prototype.find = function find (coord) {\n  return this.nodeMap.get(coord)\n};\nNodeMap.prototype.addNode = function addNode () {\n  if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    var node = this.nodeMap.get(coord);\n    if (node === null) {\n      node = this.nodeFact.createNode(coord);\n      this.nodeMap.put(coord, node);\n    }\n    return node\n  } else if (arguments[0] instanceof Node) {\n    var n = arguments[0];\n    var node$1 = this.nodeMap.get(n.getCoordinate());\n    if (node$1 === null) {\n      this.nodeMap.put(n.getCoordinate(), n);\n      return n\n    }\n    node$1.mergeLabel(n);\n    return node$1\n  }\n};\nNodeMap.prototype.print = function print (out) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var n = it.next();\n    n.print(out);\n  }\n};\nNodeMap.prototype.iterator = function iterator () {\n  return this.nodeMap.values().iterator()\n};\nNodeMap.prototype.values = function values () {\n  return this.nodeMap.values()\n};\nNodeMap.prototype.getBoundaryNodes = function getBoundaryNodes (geomIndex) {\n  var bdyNodes = new ArrayList();\n  for (var i = this.iterator(); i.hasNext();) {\n    var node = i.next();\n    if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) { bdyNodes.add(node); }\n  }\n  return bdyNodes\n};\nNodeMap.prototype.add = function add (e) {\n  var p = e.getCoordinate();\n  var n = this.addNode(p);\n  n.add(e);\n};\nNodeMap.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodeMap.prototype.getClass = function getClass () {\n  return NodeMap\n};\n\nvar Quadrant = function Quadrant () {};\n\nvar staticAccessors$21 = { NE: { configurable: true },NW: { configurable: true },SW: { configurable: true },SE: { configurable: true } };\n\nQuadrant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nQuadrant.prototype.getClass = function getClass () {\n  return Quadrant\n};\nQuadrant.isNorthern = function isNorthern (quad) {\n  return quad === Quadrant.NE || quad === Quadrant.NW\n};\nQuadrant.isOpposite = function isOpposite (quad1, quad2) {\n  if (quad1 === quad2) { return false }\n  var diff = (quad1 - quad2 + 4) % 4;\n  if (diff === 2) { return true }\n  return false\n};\nQuadrant.commonHalfPlane = function commonHalfPlane (quad1, quad2) {\n  if (quad1 === quad2) { return quad1 }\n  var diff = (quad1 - quad2 + 4) % 4;\n  if (diff === 2) { return -1 }\n  var min = quad1 < quad2 ? quad1 : quad2;\n  var max = quad1 > quad2 ? quad1 : quad2;\n  if (min === 0 && max === 3) { return 3 }\n  return min\n};\nQuadrant.isInHalfPlane = function isInHalfPlane (quad, halfPlane) {\n  if (halfPlane === Quadrant.SE) {\n    return quad === Quadrant.SE || quad === Quadrant.SW\n  }\n  return quad === halfPlane || quad === halfPlane + 1\n};\nQuadrant.quadrant = function quadrant () {\n  if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n    var dx = arguments[0];\n    var dy = arguments[1];\n    if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )') }\n    if (dx >= 0.0) {\n      if (dy >= 0.0) { return Quadrant.NE; } else { return Quadrant.SE }\n    } else {\n      if (dy >= 0.0) { return Quadrant.NW; } else { return Quadrant.SW }\n    }\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (p1.x === p0.x && p1.y === p0.y) { throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0) }\n    if (p1.x >= p0.x) {\n      if (p1.y >= p0.y) { return Quadrant.NE; } else { return Quadrant.SE }\n    } else {\n      if (p1.y >= p0.y) { return Quadrant.NW; } else { return Quadrant.SW }\n    }\n  }\n};\nstaticAccessors$21.NE.get = function () { return 0 };\nstaticAccessors$21.NW.get = function () { return 1 };\nstaticAccessors$21.SW.get = function () { return 2 };\nstaticAccessors$21.SE.get = function () { return 3 };\n\nObject.defineProperties( Quadrant, staticAccessors$21 );\n\nvar EdgeEnd = function EdgeEnd () {\n  this._edge = null;\n  this._label = null;\n  this._node = null;\n  this._p0 = null;\n  this._p1 = null;\n  this._dx = null;\n  this._dy = null;\n  this._quadrant = null;\n  if (arguments.length === 1) {\n    var edge = arguments[0];\n    this._edge = edge;\n  } else if (arguments.length === 3) {\n    var edge$1 = arguments[0];\n    var p0 = arguments[1];\n    var p1 = arguments[2];\n    var label = null;\n    this._edge = edge$1;\n    this.init(p0, p1);\n    this._label = label;\n  } else if (arguments.length === 4) {\n    var edge$2 = arguments[0];\n    var p0$1 = arguments[1];\n    var p1$1 = arguments[2];\n    var label$1 = arguments[3];\n    this._edge = edge$2;\n    this.init(p0$1, p1$1);\n    this._label = label$1;\n  }\n};\nEdgeEnd.prototype.compareDirection = function compareDirection (e) {\n  if (this._dx === e._dx && this._dy === e._dy) { return 0 }\n  if (this._quadrant > e._quadrant) { return 1 }\n  if (this._quadrant < e._quadrant) { return -1 }\n  return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1)\n};\nEdgeEnd.prototype.getDy = function getDy () {\n  return this._dy\n};\nEdgeEnd.prototype.getCoordinate = function getCoordinate () {\n  return this._p0\n};\nEdgeEnd.prototype.setNode = function setNode (node) {\n  this._node = node;\n};\nEdgeEnd.prototype.print = function print (out) {\n  var angle = Math.atan2(this._dy, this._dx);\n  var className = this.getClass().getName();\n  var lastDotPos = className.lastIndexOf('.');\n  var name = className.substring(lastDotPos + 1);\n  out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);\n};\nEdgeEnd.prototype.compareTo = function compareTo (obj) {\n  var e = obj;\n  return this.compareDirection(e)\n};\nEdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate () {\n  return this._p1\n};\nEdgeEnd.prototype.getDx = function getDx () {\n  return this._dx\n};\nEdgeEnd.prototype.getLabel = function getLabel () {\n  return this._label\n};\nEdgeEnd.prototype.getEdge = function getEdge () {\n  return this._edge\n};\nEdgeEnd.prototype.getQuadrant = function getQuadrant () {\n  return this._quadrant\n};\nEdgeEnd.prototype.getNode = function getNode () {\n  return this._node\n};\nEdgeEnd.prototype.toString = function toString () {\n  var angle = Math.atan2(this._dy, this._dx);\n  var className = this.getClass().getName();\n  var lastDotPos = className.lastIndexOf('.');\n  var name = className.substring(lastDotPos + 1);\n  return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label\n};\nEdgeEnd.prototype.computeLabel = function computeLabel (boundaryNodeRule) {};\nEdgeEnd.prototype.init = function init (p0, p1) {\n  this._p0 = p0;\n  this._p1 = p1;\n  this._dx = p1.x - p0.x;\n  this._dy = p1.y - p0.y;\n  this._quadrant = Quadrant.quadrant(this._dx, this._dy);\n  Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');\n};\nEdgeEnd.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nEdgeEnd.prototype.getClass = function getClass () {\n  return EdgeEnd\n};\n\nvar DirectedEdge = (function (EdgeEnd$$1) {\n  function DirectedEdge () {\n    var edge = arguments[0];\n    var isForward = arguments[1];\n    EdgeEnd$$1.call(this, edge);\n    this._isForward = null;\n    this._isInResult = false;\n    this._isVisited = false;\n    this._sym = null;\n    this._next = null;\n    this._nextMin = null;\n    this._edgeRing = null;\n    this._minEdgeRing = null;\n    this._depth = [0, -999, -999];\n    this._isForward = isForward;\n    if (isForward) {\n      this.init(edge.getCoordinate(0), edge.getCoordinate(1));\n    } else {\n      var n = edge.getNumPoints() - 1;\n      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n    }\n    this.computeDirectedLabel();\n  }\n\n  if ( EdgeEnd$$1 ) DirectedEdge.__proto__ = EdgeEnd$$1;\n  DirectedEdge.prototype = Object.create( EdgeEnd$$1 && EdgeEnd$$1.prototype );\n  DirectedEdge.prototype.constructor = DirectedEdge;\n  DirectedEdge.prototype.getNextMin = function getNextMin () {\n    return this._nextMin\n  };\n  DirectedEdge.prototype.getDepth = function getDepth (position) {\n    return this._depth[position]\n  };\n  DirectedEdge.prototype.setVisited = function setVisited (isVisited) {\n    this._isVisited = isVisited;\n  };\n  DirectedEdge.prototype.computeDirectedLabel = function computeDirectedLabel () {\n    this._label = new Label(this._edge.getLabel());\n    if (!this._isForward) { this._label.flip(); }\n  };\n  DirectedEdge.prototype.getNext = function getNext () {\n    return this._next\n  };\n  DirectedEdge.prototype.setDepth = function setDepth (position, depthVal) {\n    if (this._depth[position] !== -999) {\n      if (this._depth[position] !== depthVal) { throw new TopologyException('assigned depths do not match', this.getCoordinate()) }\n    }\n    this._depth[position] = depthVal;\n  };\n  DirectedEdge.prototype.isInteriorAreaEdge = function isInteriorAreaEdge () {\n    var this$1 = this;\n\n    var isInteriorAreaEdge = true;\n    for (var i = 0; i < 2; i++) {\n      if (!(this$1._label.isArea(i) && this$1._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this$1._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n        isInteriorAreaEdge = false;\n      }\n    }\n    return isInteriorAreaEdge\n  };\n  DirectedEdge.prototype.setNextMin = function setNextMin (nextMin) {\n    this._nextMin = nextMin;\n  };\n  DirectedEdge.prototype.print = function print (out) {\n    EdgeEnd$$1.prototype.print.call(this, out);\n    out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT]);\n    out.print(' (' + this.getDepthDelta() + ')');\n    if (this._isInResult) { out.print(' inResult'); }\n  };\n  DirectedEdge.prototype.setMinEdgeRing = function setMinEdgeRing (minEdgeRing) {\n    this._minEdgeRing = minEdgeRing;\n  };\n  DirectedEdge.prototype.isLineEdge = function isLineEdge () {\n    var isLine = this._label.isLine(0) || this._label.isLine(1);\n    var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n    var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n    return isLine && isExteriorIfArea0 && isExteriorIfArea1\n  };\n  DirectedEdge.prototype.setEdgeRing = function setEdgeRing (edgeRing) {\n    this._edgeRing = edgeRing;\n  };\n  DirectedEdge.prototype.getMinEdgeRing = function getMinEdgeRing () {\n    return this._minEdgeRing\n  };\n  DirectedEdge.prototype.getDepthDelta = function getDepthDelta () {\n    var depthDelta = this._edge.getDepthDelta();\n    if (!this._isForward) { depthDelta = -depthDelta; }\n    return depthDelta\n  };\n  DirectedEdge.prototype.setInResult = function setInResult (isInResult) {\n    this._isInResult = isInResult;\n  };\n  DirectedEdge.prototype.getSym = function getSym () {\n    return this._sym\n  };\n  DirectedEdge.prototype.isForward = function isForward () {\n    return this._isForward\n  };\n  DirectedEdge.prototype.getEdge = function getEdge () {\n    return this._edge\n  };\n  DirectedEdge.prototype.printEdge = function printEdge (out) {\n    this.print(out);\n    out.print(' ');\n    if (this._isForward) { this._edge.print(out); } else { this._edge.printReverse(out); }\n  };\n  DirectedEdge.prototype.setSym = function setSym (de) {\n    this._sym = de;\n  };\n  DirectedEdge.prototype.setVisitedEdge = function setVisitedEdge (isVisited) {\n    this.setVisited(isVisited);\n    this._sym.setVisited(isVisited);\n  };\n  DirectedEdge.prototype.setEdgeDepths = function setEdgeDepths (position, depth) {\n    var depthDelta = this.getEdge().getDepthDelta();\n    if (!this._isForward) { depthDelta = -depthDelta; }\n    var directionFactor = 1;\n    if (position === Position.LEFT) { directionFactor = -1; }\n    var oppositePos = Position.opposite(position);\n    var delta = depthDelta * directionFactor;\n    var oppositeDepth = depth + delta;\n    this.setDepth(position, depth);\n    this.setDepth(oppositePos, oppositeDepth);\n  };\n  DirectedEdge.prototype.getEdgeRing = function getEdgeRing () {\n    return this._edgeRing\n  };\n  DirectedEdge.prototype.isInResult = function isInResult () {\n    return this._isInResult\n  };\n  DirectedEdge.prototype.setNext = function setNext (next) {\n    this._next = next;\n  };\n  DirectedEdge.prototype.isVisited = function isVisited () {\n    return this._isVisited\n  };\n  DirectedEdge.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  DirectedEdge.prototype.getClass = function getClass () {\n    return DirectedEdge\n  };\n  DirectedEdge.depthFactor = function depthFactor (currLocation, nextLocation) {\n    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) { return 1; } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) { return -1 }\n    return 0\n  };\n\n  return DirectedEdge;\n}(EdgeEnd));\n\nvar NodeFactory = function NodeFactory () {};\n\nNodeFactory.prototype.createNode = function createNode (coord) {\n  return new Node(coord, null)\n};\nNodeFactory.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodeFactory.prototype.getClass = function getClass () {\n  return NodeFactory\n};\n\nvar PlanarGraph = function PlanarGraph () {\n  this._edges = new ArrayList();\n  this._nodes = null;\n  this._edgeEndList = new ArrayList();\n  if (arguments.length === 0) {\n    this._nodes = new NodeMap(new NodeFactory());\n  } else if (arguments.length === 1) {\n    var nodeFact = arguments[0];\n    this._nodes = new NodeMap(nodeFact);\n  }\n};\nPlanarGraph.prototype.printEdges = function printEdges (out) {\n    var this$1 = this;\n\n  out.println('Edges:');\n  for (var i = 0; i < this._edges.size(); i++) {\n    out.println('edge ' + i + ':');\n    var e = this$1._edges.get(i);\n    e.print(out);\n    e.eiList.print(out);\n  }\n};\nPlanarGraph.prototype.find = function find (coord) {\n  return this._nodes.find(coord)\n};\nPlanarGraph.prototype.addNode = function addNode () {\n  if (arguments[0] instanceof Node) {\n    var node = arguments[0];\n    return this._nodes.addNode(node)\n  } else if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    return this._nodes.addNode(coord)\n  }\n};\nPlanarGraph.prototype.getNodeIterator = function getNodeIterator () {\n  return this._nodes.iterator()\n};\nPlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges () {\n  for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkResultDirectedEdges();\n  }\n};\nPlanarGraph.prototype.debugPrintln = function debugPrintln (o) {\n  System.out.println(o);\n};\nPlanarGraph.prototype.isBoundaryNode = function isBoundaryNode (geomIndex, coord) {\n  var node = this._nodes.find(coord);\n  if (node === null) { return false }\n  var label = node.getLabel();\n  if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) { return true }\n  return false\n};\nPlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges () {\n  for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkAllDirectedEdges();\n  }\n};\nPlanarGraph.prototype.matchInSameDirection = function matchInSameDirection (p0, p1, ep0, ep1) {\n  if (!p0.equals(ep0)) { return false }\n  if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) { return true }\n  return false\n};\nPlanarGraph.prototype.getEdgeEnds = function getEdgeEnds () {\n  return this._edgeEndList\n};\nPlanarGraph.prototype.debugPrint = function debugPrint (o) {\n  System.out.print(o);\n};\nPlanarGraph.prototype.getEdgeIterator = function getEdgeIterator () {\n  return this._edges.iterator()\n};\nPlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection (p0, p1) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    var e = this$1._edges.get(i);\n    var eCoord = e.getCoordinates();\n    if (this$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) { return e }\n    if (this$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) { return e }\n  }\n  return null\n};\nPlanarGraph.prototype.insertEdge = function insertEdge (e) {\n  this._edges.add(e);\n};\nPlanarGraph.prototype.findEdgeEnd = function findEdgeEnd (e) {\n  for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {\n    var ee = i.next();\n    if (ee.getEdge() === e) { return ee }\n  }\n  return null\n};\nPlanarGraph.prototype.addEdges = function addEdges (edgesToAdd) {\n    var this$1 = this;\n\n  for (var it = edgesToAdd.iterator(); it.hasNext();) {\n    var e = it.next();\n    this$1._edges.add(e);\n    var de1 = new DirectedEdge(e, true);\n    var de2 = new DirectedEdge(e, false);\n    de1.setSym(de2);\n    de2.setSym(de1);\n    this$1.add(de1);\n    this$1.add(de2);\n  }\n};\nPlanarGraph.prototype.add = function add (e) {\n  this._nodes.add(e);\n  this._edgeEndList.add(e);\n};\nPlanarGraph.prototype.getNodes = function getNodes () {\n  return this._nodes.values()\n};\nPlanarGraph.prototype.findEdge = function findEdge (p0, p1) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    var e = this$1._edges.get(i);\n    var eCoord = e.getCoordinates();\n    if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) { return e }\n  }\n  return null\n};\nPlanarGraph.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPlanarGraph.prototype.getClass = function getClass () {\n  return PlanarGraph\n};\nPlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges (nodes) {\n  for (var nodeit = nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkResultDirectedEdges();\n  }\n};\n\nvar PolygonBuilder = function PolygonBuilder () {\n  this._geometryFactory = null;\n  this._shellList = new ArrayList();\n  var geometryFactory = arguments[0];\n  this._geometryFactory = geometryFactory;\n};\nPolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles (edgeRings, shellList, freeHoleList) {\n  for (var it = edgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.isHole()) {\n      freeHoleList.add(er);\n    } else {\n      shellList.add(er);\n    }\n  }\n};\nPolygonBuilder.prototype.computePolygons = function computePolygons (shellList) {\n    var this$1 = this;\n\n  var resultPolyList = new ArrayList();\n  for (var it = shellList.iterator(); it.hasNext();) {\n    var er = it.next();\n    var poly = er.toPolygon(this$1._geometryFactory);\n    resultPolyList.add(poly);\n  }\n  return resultPolyList\n};\nPolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles (shellList, freeHoleList) {\n    var this$1 = this;\n\n  for (var it = freeHoleList.iterator(); it.hasNext();) {\n    var hole = it.next();\n    if (hole.getShell() === null) {\n      var shell = this$1.findEdgeRingContaining(hole, shellList);\n      if (shell === null) { throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0)) }\n      hole.setShell(shell);\n    }\n  }\n};\nPolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings (maxEdgeRings, shellList, freeHoleList) {\n    var this$1 = this;\n\n  var edgeRings = new ArrayList();\n  for (var it = maxEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.getMaxNodeDegree() > 2) {\n      er.linkDirectedEdgesForMinimalEdgeRings();\n      var minEdgeRings = er.buildMinimalRings();\n      var shell = this$1.findShell(minEdgeRings);\n      if (shell !== null) {\n        this$1.placePolygonHoles(shell, minEdgeRings);\n        shellList.add(shell);\n      } else {\n        freeHoleList.addAll(minEdgeRings);\n      }\n    } else {\n      edgeRings.add(er);\n    }\n  }\n  return edgeRings\n};\nPolygonBuilder.prototype.containsPoint = function containsPoint (p) {\n  for (var it = this._shellList.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.containsPoint(p)) { return true }\n  }\n  return false\n};\nPolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings (dirEdges) {\n    var this$1 = this;\n\n  var maxEdgeRings = new ArrayList();\n  for (var it = dirEdges.iterator(); it.hasNext();) {\n    var de = it.next();\n    if (de.isInResult() && de.getLabel().isArea()) {\n      if (de.getEdgeRing() === null) {\n        var er = new MaximalEdgeRing(de, this$1._geometryFactory);\n        maxEdgeRings.add(er);\n        er.setInResult();\n      }\n    }\n  }\n  return maxEdgeRings\n};\nPolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles (shell, minEdgeRings) {\n  for (var it = minEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.isHole()) {\n      er.setShell(shell);\n    }\n  }\n};\nPolygonBuilder.prototype.getPolygons = function getPolygons () {\n  var resultPolyList = this.computePolygons(this._shellList);\n  return resultPolyList\n};\nPolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining (testEr, shellList) {\n  var testRing = testEr.getLinearRing();\n  var testEnv = testRing.getEnvelopeInternal();\n  var testPt = testRing.getCoordinateN(0);\n  var minShell = null;\n  var minEnv = null;\n  for (var it = shellList.iterator(); it.hasNext();) {\n    var tryShell = it.next();\n    var tryRing = tryShell.getLinearRing();\n    var tryEnv = tryRing.getEnvelopeInternal();\n    if (minShell !== null) { minEnv = minShell.getLinearRing().getEnvelopeInternal(); }\n    var isContained = false;\n    if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) { isContained = true; }\n    if (isContained) {\n      if (minShell === null || minEnv.contains(tryEnv)) {\n        minShell = tryShell;\n      }\n    }\n  }\n  return minShell\n};\nPolygonBuilder.prototype.findShell = function findShell (minEdgeRings) {\n  var shellCount = 0;\n  var shell = null;\n  for (var it = minEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (!er.isHole()) {\n      shell = er;\n      shellCount++;\n    }\n  }\n  Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');\n  return shell\n};\nPolygonBuilder.prototype.add = function add () {\n  if (arguments.length === 1) {\n    var graph = arguments[0];\n    this.add(graph.getEdgeEnds(), graph.getNodes());\n  } else if (arguments.length === 2) {\n    var dirEdges = arguments[0];\n    var nodes = arguments[1];\n    PlanarGraph.linkResultDirectedEdges(nodes);\n    var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n    var freeHoleList = new ArrayList();\n    var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n    this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n    this.placeFreeHoles(this._shellList, freeHoleList);\n  }\n};\nPolygonBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPolygonBuilder.prototype.getClass = function getClass () {\n  return PolygonBuilder\n};\n\nvar Boundable = function Boundable () {};\n\nBoundable.prototype.getBounds = function getBounds () {};\nBoundable.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundable.prototype.getClass = function getClass () {\n  return Boundable\n};\n\nvar ItemBoundable = function ItemBoundable () {\n  this._bounds = null;\n  this._item = null;\n  var bounds = arguments[0];\n  var item = arguments[1];\n  this._bounds = bounds;\n  this._item = item;\n};\nItemBoundable.prototype.getItem = function getItem () {\n  return this._item\n};\nItemBoundable.prototype.getBounds = function getBounds () {\n  return this._bounds\n};\nItemBoundable.prototype.interfaces_ = function interfaces_ () {\n  return [Boundable, Serializable]\n};\nItemBoundable.prototype.getClass = function getClass () {\n  return ItemBoundable\n};\n\nvar PriorityQueue = function PriorityQueue () {\n  this._size = null;\n  this._items = null;\n  this._size = 0;\n  this._items = new ArrayList();\n  this._items.add(null);\n};\nPriorityQueue.prototype.poll = function poll () {\n  if (this.isEmpty()) { return null }\n  var minItem = this._items.get(1);\n  this._items.set(1, this._items.get(this._size));\n  this._size -= 1;\n  this.reorder(1);\n  return minItem\n};\nPriorityQueue.prototype.size = function size () {\n  return this._size\n};\nPriorityQueue.prototype.reorder = function reorder (hole) {\n    var this$1 = this;\n\n  var child = null;\n  var tmp = this._items.get(hole);\n  for (; hole * 2 <= this._size; hole = child) {\n    child = hole * 2;\n    if (child !== this$1._size && this$1._items.get(child + 1).compareTo(this$1._items.get(child)) < 0) { child++; }\n    if (this$1._items.get(child).compareTo(tmp) < 0) { this$1._items.set(hole, this$1._items.get(child)); } else { break }\n  }\n  this._items.set(hole, tmp);\n};\nPriorityQueue.prototype.clear = function clear () {\n  this._size = 0;\n  this._items.clear();\n};\nPriorityQueue.prototype.isEmpty = function isEmpty () {\n  return this._size === 0\n};\nPriorityQueue.prototype.add = function add (x) {\n    var this$1 = this;\n\n  this._items.add(null);\n  this._size += 1;\n  var hole = this._size;\n  this._items.set(0, x);\n  for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n    this$1._items.set(hole, this$1._items.get(Math.trunc(hole / 2)));\n  }\n  this._items.set(hole, x);\n};\nPriorityQueue.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPriorityQueue.prototype.getClass = function getClass () {\n  return PriorityQueue\n};\n\nvar ItemVisitor = function ItemVisitor () {};\n\nItemVisitor.prototype.visitItem = function visitItem (item) {};\nItemVisitor.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nItemVisitor.prototype.getClass = function getClass () {\n  return ItemVisitor\n};\n\nvar SpatialIndex = function SpatialIndex () {};\n\nSpatialIndex.prototype.insert = function insert (itemEnv, item) {};\nSpatialIndex.prototype.remove = function remove (itemEnv, item) {};\nSpatialIndex.prototype.query = function query () {\n  // if (arguments.length === 1) {\n  // const searchEnv = arguments[0]\n  // } else if (arguments.length === 2) {\n  // const searchEnv = arguments[0]\n  // const visitor = arguments[1]\n  // }\n};\nSpatialIndex.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSpatialIndex.prototype.getClass = function getClass () {\n  return SpatialIndex\n};\n\nvar AbstractNode = function AbstractNode () {\n  this._childBoundables = new ArrayList();\n  this._bounds = null;\n  this._level = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var level = arguments[0];\n    this._level = level;\n  }\n};\n\nvar staticAccessors$22 = { serialVersionUID: { configurable: true } };\nAbstractNode.prototype.getLevel = function getLevel () {\n  return this._level\n};\nAbstractNode.prototype.size = function size () {\n  return this._childBoundables.size()\n};\nAbstractNode.prototype.getChildBoundables = function getChildBoundables () {\n  return this._childBoundables\n};\nAbstractNode.prototype.addChildBoundable = function addChildBoundable (childBoundable) {\n  Assert.isTrue(this._bounds === null);\n  this._childBoundables.add(childBoundable);\n};\nAbstractNode.prototype.isEmpty = function isEmpty () {\n  return this._childBoundables.isEmpty()\n};\nAbstractNode.prototype.getBounds = function getBounds () {\n  if (this._bounds === null) {\n    this._bounds = this.computeBounds();\n  }\n  return this._bounds\n};\nAbstractNode.prototype.interfaces_ = function interfaces_ () {\n  return [Boundable, Serializable]\n};\nAbstractNode.prototype.getClass = function getClass () {\n  return AbstractNode\n};\nstaticAccessors$22.serialVersionUID.get = function () { return 6493722185909573708 };\n\nObject.defineProperties( AbstractNode, staticAccessors$22 );\n\nvar Collections = function Collections () {};\n\nCollections.reverseOrder = function reverseOrder () {\n  return {\n    compare: function compare (a, b) {\n      return b.compareTo(a)\n    }\n  }\n};\nCollections.min = function min (l) {\n  Collections.sort(l);\n  return l.get(0)\n};\nCollections.sort = function sort (l, c) {\n  var a = l.toArray();\n  if (c) {\n    Arrays.sort(a, c);\n  } else {\n    Arrays.sort(a);\n  }\n  var i = l.iterator();\n  for (var pos = 0, alen = a.length; pos < alen; pos++) {\n    i.next();\n    i.set(a[pos]);\n  }\n};\nCollections.singletonList = function singletonList (o) {\n  var arrayList = new ArrayList();\n  arrayList.add(o);\n  return arrayList\n};\n\nvar BoundablePair = function BoundablePair () {\n  this._boundable1 = null;\n  this._boundable2 = null;\n  this._distance = null;\n  this._itemDistance = null;\n  var boundable1 = arguments[0];\n  var boundable2 = arguments[1];\n  var itemDistance = arguments[2];\n  this._boundable1 = boundable1;\n  this._boundable2 = boundable2;\n  this._itemDistance = itemDistance;\n  this._distance = this.distance();\n};\nBoundablePair.prototype.expandToQueue = function expandToQueue (priQ, minDistance) {\n  var isComp1 = BoundablePair.isComposite(this._boundable1);\n  var isComp2 = BoundablePair.isComposite(this._boundable2);\n  if (isComp1 && isComp2) {\n    if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n      this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n      return null\n    } else {\n      this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n      return null\n    }\n  } else if (isComp1) {\n    this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n    return null\n  } else if (isComp2) {\n    this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n    return null\n  }\n  throw new IllegalArgumentException('neither boundable is composite')\n};\nBoundablePair.prototype.isLeaves = function isLeaves () {\n  return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))\n};\nBoundablePair.prototype.compareTo = function compareTo (o) {\n  var nd = o;\n  if (this._distance < nd._distance) { return -1 }\n  if (this._distance > nd._distance) { return 1 }\n  return 0\n};\nBoundablePair.prototype.expand = function expand (bndComposite, bndOther, priQ, minDistance) {\n    var this$1 = this;\n\n  var children = bndComposite.getChildBoundables();\n  for (var i = children.iterator(); i.hasNext();) {\n    var child = i.next();\n    var bp = new BoundablePair(child, bndOther, this$1._itemDistance);\n    if (bp.getDistance() < minDistance) {\n      priQ.add(bp);\n    }\n  }\n};\nBoundablePair.prototype.getBoundable = function getBoundable (i) {\n  if (i === 0) { return this._boundable1 }\n  return this._boundable2\n};\nBoundablePair.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nBoundablePair.prototype.distance = function distance () {\n  if (this.isLeaves()) {\n    return this._itemDistance.distance(this._boundable1, this._boundable2)\n  }\n  return this._boundable1.getBounds().distance(this._boundable2.getBounds())\n};\nBoundablePair.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nBoundablePair.prototype.getClass = function getClass () {\n  return BoundablePair\n};\nBoundablePair.area = function area (b) {\n  return b.getBounds().getArea()\n};\nBoundablePair.isComposite = function isComposite (item) {\n  return item instanceof AbstractNode\n};\n\nvar AbstractSTRtree = function AbstractSTRtree () {\n  this._root = null;\n  this._built = false;\n  this._itemBoundables = new ArrayList();\n  this._nodeCapacity = null;\n  if (arguments.length === 0) {\n    var nodeCapacity = AbstractSTRtree.DEFAULT_NODE_CAPACITY;\n    this._nodeCapacity = nodeCapacity;\n  } else if (arguments.length === 1) {\n    var nodeCapacity$1 = arguments[0];\n    Assert.isTrue(nodeCapacity$1 > 1, 'Node capacity must be greater than 1');\n    this._nodeCapacity = nodeCapacity$1;\n  }\n};\n\nvar staticAccessors$23 = { IntersectsOp: { configurable: true },serialVersionUID: { configurable: true },DEFAULT_NODE_CAPACITY: { configurable: true } };\nAbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity () {\n  return this._nodeCapacity\n};\nAbstractSTRtree.prototype.lastNode = function lastNode (nodes) {\n  return nodes.get(nodes.size() - 1)\n};\nAbstractSTRtree.prototype.size = function size () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isEmpty()) {\n      return 0\n    }\n    this.build();\n    return this.size(this._root)\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var size = 0;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        size += this$1.size(childBoundable);\n      } else if (childBoundable instanceof ItemBoundable) {\n        size += 1;\n      }\n    }\n    return size\n  }\n};\nAbstractSTRtree.prototype.removeItem = function removeItem (node, item) {\n  var childToRemove = null;\n  for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n    var childBoundable = i.next();\n    if (childBoundable instanceof ItemBoundable) {\n      if (childBoundable.getItem() === item) { childToRemove = childBoundable; }\n    }\n  }\n  if (childToRemove !== null) {\n    node.getChildBoundables().remove(childToRemove);\n    return true\n  }\n  return false\n};\nAbstractSTRtree.prototype.itemsTree = function itemsTree () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    this.build();\n    var valuesTree = this.itemsTree(this._root);\n    if (valuesTree === null) { return new ArrayList() }\n    return valuesTree\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var valuesTreeForNode = new ArrayList();\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        var valuesTreeForChild = this$1.itemsTree(childBoundable);\n        if (valuesTreeForChild !== null) { valuesTreeForNode.add(valuesTreeForChild); }\n      } else if (childBoundable instanceof ItemBoundable) {\n        valuesTreeForNode.add(childBoundable.getItem());\n      } else {\n        Assert.shouldNeverReachHere();\n      }\n    }\n    if (valuesTreeForNode.size() <= 0) { return null }\n    return valuesTreeForNode\n  }\n};\nAbstractSTRtree.prototype.insert = function insert (bounds, item) {\n  Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');\n  this._itemBoundables.add(new ItemBoundable(bounds, item));\n};\nAbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var level = arguments[0];\n    var boundables = new ArrayList();\n    this.boundablesAtLevel(level, this._root, boundables);\n    return boundables\n  } else if (arguments.length === 3) {\n    var level$1 = arguments[0];\n    var top = arguments[1];\n    var boundables$1 = arguments[2];\n    Assert.isTrue(level$1 > -2);\n    if (top.getLevel() === level$1) {\n      boundables$1.add(top);\n      return null\n    }\n    for (var i = top.getChildBoundables().iterator(); i.hasNext();) {\n      var boundable = i.next();\n      if (boundable instanceof AbstractNode) {\n        this$1.boundablesAtLevel(level$1, boundable, boundables$1);\n      } else {\n        Assert.isTrue(boundable instanceof ItemBoundable);\n        if (level$1 === -1) {\n          boundables$1.add(boundable);\n        }\n      }\n    }\n    return null\n  }\n};\nAbstractSTRtree.prototype.query = function query () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var searchBounds = arguments[0];\n    this.build();\n    var matches = new ArrayList();\n    if (this.isEmpty()) {\n      return matches\n    }\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n      this.query(searchBounds, this._root, matches);\n    }\n    return matches\n  } else if (arguments.length === 2) {\n    var searchBounds$1 = arguments[0];\n    var visitor = arguments[1];\n    this.build();\n    if (this.isEmpty()) {\n      return null\n    }\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {\n      this.query(searchBounds$1, this._root, visitor);\n    }\n  } else if (arguments.length === 3) {\n    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      var searchBounds$2 = arguments[0];\n      var node = arguments[1];\n      var visitor$1 = arguments[2];\n      var childBoundables = node.getChildBoundables();\n      for (var i = 0; i < childBoundables.size(); i++) {\n        var childBoundable = childBoundables.get(i);\n        if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {\n          continue\n        }\n        if (childBoundable instanceof AbstractNode) {\n          this$1.query(searchBounds$2, childBoundable, visitor$1);\n        } else if (childBoundable instanceof ItemBoundable) {\n          visitor$1.visitItem(childBoundable.getItem());\n        } else {\n          Assert.shouldNeverReachHere();\n        }\n      }\n    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      var searchBounds$3 = arguments[0];\n      var node$1 = arguments[1];\n      var matches$1 = arguments[2];\n      var childBoundables$1 = node$1.getChildBoundables();\n      for (var i$1 = 0; i$1 < childBoundables$1.size(); i$1++) {\n        var childBoundable$1 = childBoundables$1.get(i$1);\n        if (!this$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {\n          continue\n        }\n        if (childBoundable$1 instanceof AbstractNode) {\n          this$1.query(searchBounds$3, childBoundable$1, matches$1);\n        } else if (childBoundable$1 instanceof ItemBoundable) {\n          matches$1.add(childBoundable$1.getItem());\n        } else {\n          Assert.shouldNeverReachHere();\n        }\n      }\n    }\n  }\n};\nAbstractSTRtree.prototype.build = function build () {\n  if (this._built) { return null }\n  this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n  this._itemBoundables = null;\n  this._built = true;\n};\nAbstractSTRtree.prototype.getRoot = function getRoot () {\n  this.build();\n  return this._root\n};\nAbstractSTRtree.prototype.remove = function remove () {\n    var this$1 = this;\n\n  if (arguments.length === 2) {\n    var searchBounds = arguments[0];\n    var item = arguments[1];\n    this.build();\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n      return this.remove(searchBounds, this._root, item)\n    }\n    return false\n  } else if (arguments.length === 3) {\n    var searchBounds$1 = arguments[0];\n    var node = arguments[1];\n    var item$1 = arguments[2];\n    var found = this.removeItem(node, item$1);\n    if (found) { return true }\n    var childToPrune = null;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {\n        continue\n      }\n      if (childBoundable instanceof AbstractNode) {\n        found = this$1.remove(searchBounds$1, childBoundable, item$1);\n        if (found) {\n          childToPrune = childBoundable;\n          break\n        }\n      }\n    }\n    if (childToPrune !== null) {\n      if (childToPrune.getChildBoundables().isEmpty()) {\n        node.getChildBoundables().remove(childToPrune);\n      }\n    }\n    return found\n  }\n};\nAbstractSTRtree.prototype.createHigherLevels = function createHigherLevels (boundablesOfALevel, level) {\n  Assert.isTrue(!boundablesOfALevel.isEmpty());\n  var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n  if (parentBoundables.size() === 1) {\n    return parentBoundables.get(0)\n  }\n  return this.createHigherLevels(parentBoundables, level + 1)\n};\nAbstractSTRtree.prototype.depth = function depth () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isEmpty()) {\n      return 0\n    }\n    this.build();\n    return this.depth(this._root)\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var maxChildDepth = 0;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        var childDepth = this$1.depth(childBoundable);\n        if (childDepth > maxChildDepth) { maxChildDepth = childDepth; }\n      }\n    }\n    return maxChildDepth + 1\n  }\n};\nAbstractSTRtree.prototype.createParentBoundables = function createParentBoundables (childBoundables, newLevel) {\n    var this$1 = this;\n\n  Assert.isTrue(!childBoundables.isEmpty());\n  var parentBoundables = new ArrayList();\n  parentBoundables.add(this.createNode(newLevel));\n  var sortedChildBoundables = new ArrayList(childBoundables);\n  Collections.sort(sortedChildBoundables, this.getComparator());\n  for (var i = sortedChildBoundables.iterator(); i.hasNext();) {\n    var childBoundable = i.next();\n    if (this$1.lastNode(parentBoundables).getChildBoundables().size() === this$1.getNodeCapacity()) {\n      parentBoundables.add(this$1.createNode(newLevel));\n    }\n    this$1.lastNode(parentBoundables).addChildBoundable(childBoundable);\n  }\n  return parentBoundables\n};\nAbstractSTRtree.prototype.isEmpty = function isEmpty () {\n  if (!this._built) { return this._itemBoundables.isEmpty() }\n  return this._root.isEmpty()\n};\nAbstractSTRtree.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nAbstractSTRtree.prototype.getClass = function getClass () {\n  return AbstractSTRtree\n};\nAbstractSTRtree.compareDoubles = function compareDoubles (a, b) {\n  return a > b ? 1 : a < b ? -1 : 0\n};\nstaticAccessors$23.IntersectsOp.get = function () { return IntersectsOp };\nstaticAccessors$23.serialVersionUID.get = function () { return -3886435814360241337 };\nstaticAccessors$23.DEFAULT_NODE_CAPACITY.get = function () { return 10 };\n\nObject.defineProperties( AbstractSTRtree, staticAccessors$23 );\n\nvar IntersectsOp = function IntersectsOp () {};\n\nvar ItemDistance = function ItemDistance () {};\n\nItemDistance.prototype.distance = function distance (item1, item2) {};\nItemDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nItemDistance.prototype.getClass = function getClass () {\n  return ItemDistance\n};\n\nvar STRtree = (function (AbstractSTRtree$$1) {\n  function STRtree (nodeCapacity) {\n    nodeCapacity = nodeCapacity || STRtree.DEFAULT_NODE_CAPACITY;\n    AbstractSTRtree$$1.call(this, nodeCapacity);\n  }\n\n  if ( AbstractSTRtree$$1 ) STRtree.__proto__ = AbstractSTRtree$$1;\n  STRtree.prototype = Object.create( AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype );\n  STRtree.prototype.constructor = STRtree;\n\n  var staticAccessors = { STRtreeNode: { configurable: true },serialVersionUID: { configurable: true },xComparator: { configurable: true },yComparator: { configurable: true },intersectsOp: { configurable: true },DEFAULT_NODE_CAPACITY: { configurable: true } };\n  STRtree.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices (verticalSlices, newLevel) {\n    var this$1 = this;\n\n    Assert.isTrue(verticalSlices.length > 0);\n    var parentBoundables = new ArrayList();\n    for (var i = 0; i < verticalSlices.length; i++) {\n      parentBoundables.addAll(this$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n    }\n    return parentBoundables\n  };\n  STRtree.prototype.createNode = function createNode (level) {\n    return new STRtreeNode(level)\n  };\n  STRtree.prototype.size = function size () {\n    if (arguments.length === 0) {\n      return AbstractSTRtree$$1.prototype.size.call(this)\n    } else { return AbstractSTRtree$$1.prototype.size.apply(this, arguments) }\n  };\n  STRtree.prototype.insert = function insert () {\n    if (arguments.length === 2) {\n      var itemEnv = arguments[0];\n      var item = arguments[1];\n      if (itemEnv.isNull()) {\n        return null\n      }\n      AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);\n    } else { return AbstractSTRtree$$1.prototype.insert.apply(this, arguments) }\n  };\n  STRtree.prototype.getIntersectsOp = function getIntersectsOp () {\n    return STRtree.intersectsOp\n  };\n  STRtree.prototype.verticalSlices = function verticalSlices (childBoundables, sliceCount) {\n    var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n    var slices = new Array(sliceCount).fill(null);\n    var i = childBoundables.iterator();\n    for (var j = 0; j < sliceCount; j++) {\n      slices[j] = new ArrayList();\n      var boundablesAddedToSlice = 0;\n      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n        var childBoundable = i.next();\n        slices[j].add(childBoundable);\n        boundablesAddedToSlice++;\n      }\n    }\n    return slices\n  };\n  STRtree.prototype.query = function query () {\n    if (arguments.length === 1) {\n      var searchEnv = arguments[0];\n      return AbstractSTRtree$$1.prototype.query.call(this, searchEnv)\n    } else if (arguments.length === 2) {\n      var searchEnv$1 = arguments[0];\n      var visitor = arguments[1];\n      AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);\n    } else if (arguments.length === 3) {\n      if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n        var searchBounds = arguments[0];\n        var node = arguments[1];\n        var visitor$1 = arguments[2];\n        AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);\n      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n        var searchBounds$1 = arguments[0];\n        var node$1 = arguments[1];\n        var matches = arguments[2];\n        AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);\n      }\n    }\n  };\n  STRtree.prototype.getComparator = function getComparator () {\n    return STRtree.yComparator\n  };\n  STRtree.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice (childBoundables, newLevel) {\n    return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel)\n  };\n  STRtree.prototype.remove = function remove () {\n    if (arguments.length === 2) {\n      var itemEnv = arguments[0];\n      var item = arguments[1];\n      return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item)\n    } else { return AbstractSTRtree$$1.prototype.remove.apply(this, arguments) }\n  };\n  STRtree.prototype.depth = function depth () {\n    if (arguments.length === 0) {\n      return AbstractSTRtree$$1.prototype.depth.call(this)\n    } else { return AbstractSTRtree$$1.prototype.depth.apply(this, arguments) }\n  };\n  STRtree.prototype.createParentBoundables = function createParentBoundables (childBoundables, newLevel) {\n    Assert.isTrue(!childBoundables.isEmpty());\n    var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n    var sortedChildBoundables = new ArrayList(childBoundables);\n    Collections.sort(sortedChildBoundables, STRtree.xComparator);\n    var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)\n  };\n  STRtree.prototype.nearestNeighbour = function nearestNeighbour () {\n    if (arguments.length === 1) {\n      if (hasInterface(arguments[0], ItemDistance)) {\n        var itemDist = arguments[0];\n        var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n        return this.nearestNeighbour(bp)\n      } else if (arguments[0] instanceof BoundablePair) {\n        var initBndPair = arguments[0];\n        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY)\n      }\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n        var tree = arguments[0];\n        var itemDist$1 = arguments[1];\n        var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);\n        return this.nearestNeighbour(bp$1)\n      } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number') {\n        var initBndPair$1 = arguments[0];\n        var maxDistance = arguments[1];\n        var distanceLowerBound = maxDistance;\n        var minPair = null;\n        var priQ = new PriorityQueue();\n        priQ.add(initBndPair$1);\n        while (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n          var bndPair = priQ.poll();\n          var currentDistance = bndPair.getDistance();\n          if (currentDistance >= distanceLowerBound) { break }\n          if (bndPair.isLeaves()) {\n            distanceLowerBound = currentDistance;\n            minPair = bndPair;\n          } else {\n            bndPair.expandToQueue(priQ, distanceLowerBound);\n          }\n        }\n        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]\n      }\n    } else if (arguments.length === 3) {\n      var env = arguments[0];\n      var item = arguments[1];\n      var itemDist$2 = arguments[2];\n      var bnd = new ItemBoundable(env, item);\n      var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);\n      return this.nearestNeighbour(bp$2)[0]\n    }\n  };\n  STRtree.prototype.interfaces_ = function interfaces_ () {\n    return [SpatialIndex, Serializable]\n  };\n  STRtree.prototype.getClass = function getClass () {\n    return STRtree\n  };\n  STRtree.centreX = function centreX (e) {\n    return STRtree.avg(e.getMinX(), e.getMaxX())\n  };\n  STRtree.avg = function avg (a, b) {\n    return (a + b) / 2\n  };\n  STRtree.centreY = function centreY (e) {\n    return STRtree.avg(e.getMinY(), e.getMaxY())\n  };\n  staticAccessors.STRtreeNode.get = function () { return STRtreeNode };\n  staticAccessors.serialVersionUID.get = function () { return 259274702368956900 };\n  staticAccessors.xComparator.get = function () {\n    return {\n      interfaces_: function () {\n        return [Comparator]\n      },\n      compare: function (o1, o2) {\n        return AbstractSTRtree$$1.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))\n      }\n    }\n  };\n  staticAccessors.yComparator.get = function () {\n    return {\n      interfaces_: function () {\n        return [Comparator]\n      },\n      compare: function (o1, o2) {\n        return AbstractSTRtree$$1.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))\n      }\n    }\n  };\n  staticAccessors.intersectsOp.get = function () {\n    return {\n      interfaces_: function () {\n        return [AbstractSTRtree$$1.IntersectsOp]\n      },\n      intersects: function (aBounds, bBounds) {\n        return aBounds.intersects(bBounds)\n      }\n    }\n  };\n  staticAccessors.DEFAULT_NODE_CAPACITY.get = function () { return 10 };\n\n  Object.defineProperties( STRtree, staticAccessors );\n\n  return STRtree;\n}(AbstractSTRtree));\n\nvar STRtreeNode = (function (AbstractNode$$1) {\n  function STRtreeNode () {\n    var level = arguments[0];\n    AbstractNode$$1.call(this, level);\n  }\n\n  if ( AbstractNode$$1 ) STRtreeNode.__proto__ = AbstractNode$$1;\n  STRtreeNode.prototype = Object.create( AbstractNode$$1 && AbstractNode$$1.prototype );\n  STRtreeNode.prototype.constructor = STRtreeNode;\n  STRtreeNode.prototype.computeBounds = function computeBounds () {\n    var bounds = null;\n    for (var i = this.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (bounds === null) {\n        bounds = new Envelope(childBoundable.getBounds());\n      } else {\n        bounds.expandToInclude(childBoundable.getBounds());\n      }\n    }\n    return bounds\n  };\n  STRtreeNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  STRtreeNode.prototype.getClass = function getClass () {\n    return STRtreeNode\n  };\n\n  return STRtreeNode;\n}(AbstractNode));\n\nvar SegmentPointComparator = function SegmentPointComparator () {};\n\nSegmentPointComparator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentPointComparator.prototype.getClass = function getClass () {\n  return SegmentPointComparator\n};\nSegmentPointComparator.relativeSign = function relativeSign (x0, x1) {\n  if (x0 < x1) { return -1 }\n  if (x0 > x1) { return 1 }\n  return 0\n};\nSegmentPointComparator.compare = function compare (octant, p0, p1) {\n  if (p0.equals2D(p1)) { return 0 }\n  var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n  var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n  switch (octant) {\n    case 0:\n      return SegmentPointComparator.compareValue(xSign, ySign)\n    case 1:\n      return SegmentPointComparator.compareValue(ySign, xSign)\n    case 2:\n      return SegmentPointComparator.compareValue(ySign, -xSign)\n    case 3:\n      return SegmentPointComparator.compareValue(-xSign, ySign)\n    case 4:\n      return SegmentPointComparator.compareValue(-xSign, -ySign)\n    case 5:\n      return SegmentPointComparator.compareValue(-ySign, -xSign)\n    case 6:\n      return SegmentPointComparator.compareValue(-ySign, xSign)\n    case 7:\n      return SegmentPointComparator.compareValue(xSign, -ySign)\n    default:\n  }\n  Assert.shouldNeverReachHere('invalid octant value');\n  return 0\n};\nSegmentPointComparator.compareValue = function compareValue (compareSign0, compareSign1) {\n  if (compareSign0 < 0) { return -1 }\n  if (compareSign0 > 0) { return 1 }\n  if (compareSign1 < 0) { return -1 }\n  if (compareSign1 > 0) { return 1 }\n  return 0\n};\n\nvar SegmentNode = function SegmentNode () {\n  this._segString = null;\n  this.coord = null;\n  this.segmentIndex = null;\n  this._segmentOctant = null;\n  this._isInterior = null;\n  var segString = arguments[0];\n  var coord = arguments[1];\n  var segmentIndex = arguments[2];\n  var segmentOctant = arguments[3];\n  this._segString = segString;\n  this.coord = new Coordinate(coord);\n  this.segmentIndex = segmentIndex;\n  this._segmentOctant = segmentOctant;\n  this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n};\nSegmentNode.prototype.getCoordinate = function getCoordinate () {\n  return this.coord\n};\nSegmentNode.prototype.print = function print (out) {\n  out.print(this.coord);\n  out.print(' seg # = ' + this.segmentIndex);\n};\nSegmentNode.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  if (this.segmentIndex < other.segmentIndex) { return -1 }\n  if (this.segmentIndex > other.segmentIndex) { return 1 }\n  if (this.coord.equals2D(other.coord)) { return 0 }\n  return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)\n};\nSegmentNode.prototype.isEndPoint = function isEndPoint (maxSegmentIndex) {\n  if (this.segmentIndex === 0 && !this._isInterior) { return true }\n  if (this.segmentIndex === maxSegmentIndex) { return true }\n  return false\n};\nSegmentNode.prototype.isInterior = function isInterior () {\n  return this._isInterior\n};\nSegmentNode.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nSegmentNode.prototype.getClass = function getClass () {\n  return SegmentNode\n};\n\n// import Iterator from '../../../../java/util/Iterator'\nvar SegmentNodeList = function SegmentNodeList () {\n  this._nodeMap = new TreeMap();\n  this._edge = null;\n  var edge = arguments[0];\n  this._edge = edge;\n};\nSegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates () {\n    var this$1 = this;\n\n  var coordList = new CoordinateList();\n  this.addEndpoints();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    this$1.addEdgeCoordinates(eiPrev, ei, coordList);\n    eiPrev = ei;\n  }\n  return coordList.toCoordinateArray()\n};\nSegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes () {\n    var this$1 = this;\n\n  var collapsedVertexIndexes = new ArrayList();\n  this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n  this.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n  for (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {\n    var vertexIndex = it.next().intValue();\n    this$1.add(this$1._edge.getCoordinate(vertexIndex), vertexIndex);\n  }\n};\nSegmentNodeList.prototype.print = function print (out) {\n  out.println('Intersections:');\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    ei.print(out);\n  }\n};\nSegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices (collapsedVertexIndexes) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edge.size() - 2; i++) {\n    var p0 = this$1._edge.getCoordinate(i);\n    // const p1 = this._edge.getCoordinate(i + 1)\n    var p2 = this$1._edge.getCoordinate(i + 2);\n    if (p0.equals2D(p2)) {\n      collapsedVertexIndexes.add(new Integer(i + 1));\n    }\n  }\n};\nSegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates (ei0, ei1, coordList) {\n    var this$1 = this;\n\n  // let npts = ei1.segmentIndex - ei0.segmentIndex + 2\n  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  // if (!useIntPt1) {\n  // npts--\n  // }\n  // const ipt = 0\n  coordList.add(new Coordinate(ei0.coord), false);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    coordList.add(this$1._edge.getCoordinate(i));\n  }\n  if (useIntPt1) {\n    coordList.add(new Coordinate(ei1.coord));\n  }\n};\nSegmentNodeList.prototype.iterator = function iterator () {\n  return this._nodeMap.values().iterator()\n};\nSegmentNodeList.prototype.addSplitEdges = function addSplitEdges (edgeList) {\n    var this$1 = this;\n\n  this.addEndpoints();\n  this.addCollapsedNodes();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var newEdge = this$1.createSplitEdge(eiPrev, ei);\n    edgeList.add(newEdge);\n    eiPrev = ei;\n  }\n};\nSegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex (ei0, ei1, collapsedVertexIndex) {\n  if (!ei0.coord.equals2D(ei1.coord)) { return false }\n  var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n  if (!ei1.isInterior()) {\n    numVerticesBetween--;\n  }\n  if (numVerticesBetween === 1) {\n    collapsedVertexIndex[0] = ei0.segmentIndex + 1;\n    return true\n  }\n  return false\n};\nSegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes (collapsedVertexIndexes) {\n    var this$1 = this;\n\n  var collapsedVertexIndex = new Array(1).fill(null);\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var isCollapsed = this$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n    if (isCollapsed) { collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0])); }\n    eiPrev = ei;\n  }\n};\nSegmentNodeList.prototype.getEdge = function getEdge () {\n  return this._edge\n};\nSegmentNodeList.prototype.addEndpoints = function addEndpoints () {\n  var maxSegIndex = this._edge.size() - 1;\n  this.add(this._edge.getCoordinate(0), 0);\n  this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n};\nSegmentNodeList.prototype.createSplitEdge = function createSplitEdge (ei0, ei1) {\n    var this$1 = this;\n\n  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  if (!useIntPt1) {\n    npts--;\n  }\n  var pts = new Array(npts).fill(null);\n  var ipt = 0;\n  pts[ipt++] = new Coordinate(ei0.coord);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    pts[ipt++] = this$1._edge.getCoordinate(i);\n  }\n  if (useIntPt1) { pts[ipt] = new Coordinate(ei1.coord); }\n  return new NodedSegmentString(pts, this._edge.getData())\n};\nSegmentNodeList.prototype.add = function add (intPt, segmentIndex) {\n  var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n  var ei = this._nodeMap.get(eiNew);\n  if (ei !== null) {\n    Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');\n    return ei\n  }\n  this._nodeMap.put(eiNew, eiNew);\n  return eiNew\n};\nSegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness (splitEdges) {\n  var edgePts = this._edge.getCoordinates();\n  var split0 = splitEdges.get(0);\n  var pt0 = split0.getCoordinate(0);\n  if (!pt0.equals2D(edgePts[0])) { throw new RuntimeException('bad split edge start point at ' + pt0) }\n  var splitn = splitEdges.get(splitEdges.size() - 1);\n  var splitnPts = splitn.getCoordinates();\n  var ptn = splitnPts[splitnPts.length - 1];\n  if (!ptn.equals2D(edgePts[edgePts.length - 1])) { throw new RuntimeException('bad split edge end point at ' + ptn) }\n};\nSegmentNodeList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentNodeList.prototype.getClass = function getClass () {\n  return SegmentNodeList\n};\n\n\n\n// class NodeVertexIterator {\n//   constructor () {\n//     this._nodeList = null\n//     this._edge = null\n//     this._nodeIt = null\n//     this._currNode = null\n//     this._nextNode = null\n//     this._currSegIndex = 0\n//     let nodeList = arguments[0]\n//     this._nodeList = nodeList\n//     this._edge = nodeList.getEdge()\n//     this._nodeIt = nodeList.iterator()\n//     this.readNextNode()\n//   }\n//   next () {\n//     if (this._currNode === null) {\n//       this._currNode = this._nextNode\n//       this._currSegIndex = this._currNode.segmentIndex\n//       this.readNextNode()\n//       return this._currNode\n//     }\n//     if (this._nextNode === null) return null\n//     if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n//       this._currNode = this._nextNode\n//       this._currSegIndex = this._currNode.segmentIndex\n//       this.readNextNode()\n//       return this._currNode\n//     }\n//     if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}\n//     return null\n//   }\n//   remove () {\n//     // throw new UnsupportedOperationException(this.getClass().getName())\n//   }\n//   hasNext () {\n//     if (this._nextNode === null) return false\n//     return true\n//   }\n//   readNextNode () {\n//     if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null\n//   }\n//   interfaces_ () {\n//     return [Iterator]\n//   }\n//   getClass () {\n//     return NodeVertexIterator\n//   }\n// }\n\nvar Octant = function Octant () {};\n\nOctant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOctant.prototype.getClass = function getClass () {\n  return Octant\n};\nOctant.octant = function octant () {\n  if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n    var dx = arguments[0];\n    var dy = arguments[1];\n    if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )') }\n    var adx = Math.abs(dx);\n    var ady = Math.abs(dy);\n    if (dx >= 0) {\n      if (dy >= 0) {\n        if (adx >= ady) { return 0; } else { return 1 }\n      } else {\n        if (adx >= ady) { return 7; } else { return 6 }\n      }\n    } else {\n      if (dy >= 0) {\n        if (adx >= ady) { return 3; } else { return 2 }\n      } else {\n        if (adx >= ady) { return 4; } else { return 5 }\n      }\n    }\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    var dx$1 = p1.x - p0.x;\n    var dy$1 = p1.y - p0.y;\n    if (dx$1 === 0.0 && dy$1 === 0.0) { throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0) }\n    return Octant.octant(dx$1, dy$1)\n  }\n};\n\nvar SegmentString = function SegmentString () {};\n\nSegmentString.prototype.getCoordinates = function getCoordinates () {};\nSegmentString.prototype.size = function size () {};\nSegmentString.prototype.getCoordinate = function getCoordinate (i) {};\nSegmentString.prototype.isClosed = function isClosed () {};\nSegmentString.prototype.setData = function setData (data) {};\nSegmentString.prototype.getData = function getData () {};\nSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentString.prototype.getClass = function getClass () {\n  return SegmentString\n};\n\nvar NodableSegmentString = function NodableSegmentString () {};\n\nNodableSegmentString.prototype.addIntersection = function addIntersection (intPt, segmentIndex) {};\nNodableSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentString]\n};\nNodableSegmentString.prototype.getClass = function getClass () {\n  return NodableSegmentString\n};\n\nvar NodedSegmentString = function NodedSegmentString () {\n  this._nodeList = new SegmentNodeList(this);\n  this._pts = null;\n  this._data = null;\n  var pts = arguments[0];\n  var data = arguments[1];\n  this._pts = pts;\n  this._data = data;\n};\nNodedSegmentString.prototype.getCoordinates = function getCoordinates () {\n  return this._pts\n};\nNodedSegmentString.prototype.size = function size () {\n  return this._pts.length\n};\nNodedSegmentString.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts[i]\n};\nNodedSegmentString.prototype.isClosed = function isClosed () {\n  return this._pts[0].equals(this._pts[this._pts.length - 1])\n};\nNodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant (index) {\n  if (index === this._pts.length - 1) { return -1 }\n  return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))\n};\nNodedSegmentString.prototype.setData = function setData (data) {\n  this._data = data;\n};\nNodedSegmentString.prototype.safeOctant = function safeOctant (p0, p1) {\n  if (p0.equals2D(p1)) { return 0 }\n  return Octant.octant(p0, p1)\n};\nNodedSegmentString.prototype.getData = function getData () {\n  return this._data\n};\nNodedSegmentString.prototype.addIntersection = function addIntersection () {\n  if (arguments.length === 2) {\n    var intPt$1 = arguments[0];\n    var segmentIndex = arguments[1];\n    this.addIntersectionNode(intPt$1, segmentIndex);\n  } else if (arguments.length === 4) {\n    var li = arguments[0];\n    var segmentIndex$1 = arguments[1];\n    // const geomIndex = arguments[2]\n    var intIndex = arguments[3];\n    var intPt = new Coordinate(li.getIntersection(intIndex));\n    this.addIntersection(intPt, segmentIndex$1);\n  }\n};\nNodedSegmentString.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))\n};\nNodedSegmentString.prototype.getNodeList = function getNodeList () {\n  return this._nodeList\n};\nNodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode (intPt, segmentIndex) {\n  var normalizedSegmentIndex = segmentIndex;\n  var nextSegIndex = normalizedSegmentIndex + 1;\n  if (nextSegIndex < this._pts.length) {\n    var nextPt = this._pts[nextSegIndex];\n    if (intPt.equals2D(nextPt)) {\n      normalizedSegmentIndex = nextSegIndex;\n    }\n  }\n  var ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n  return ei\n};\nNodedSegmentString.prototype.addIntersections = function addIntersections (li, segmentIndex, geomIndex) {\n    var this$1 = this;\n\n  for (var i = 0; i < li.getIntersectionNum(); i++) {\n    this$1.addIntersection(li, segmentIndex, geomIndex, i);\n  }\n};\nNodedSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [NodableSegmentString]\n};\nNodedSegmentString.prototype.getClass = function getClass () {\n  return NodedSegmentString\n};\nNodedSegmentString.getNodedSubstrings = function getNodedSubstrings () {\n  if (arguments.length === 1) {\n    var segStrings = arguments[0];\n    var resultEdgelist = new ArrayList();\n    NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n    return resultEdgelist\n  } else if (arguments.length === 2) {\n    var segStrings$1 = arguments[0];\n    var resultEdgelist$1 = arguments[1];\n    for (var i = segStrings$1.iterator(); i.hasNext();) {\n      var ss = i.next();\n      ss.getNodeList().addSplitEdges(resultEdgelist$1);\n    }\n  }\n};\n\nvar LineSegment = function LineSegment () {\n  this.p0 = null;\n  this.p1 = null;\n  if (arguments.length === 0) {\n    this.p0 = new Coordinate();\n    this.p1 = new Coordinate();\n  } else if (arguments.length === 1) {\n    var ls = arguments[0];\n    this.p0 = new Coordinate(ls.p0);\n    this.p1 = new Coordinate(ls.p1);\n  } else if (arguments.length === 2) {\n    this.p0 = arguments[0];\n    this.p1 = arguments[1];\n  } else if (arguments.length === 4) {\n    var x0 = arguments[0];\n    var y0 = arguments[1];\n    var x1 = arguments[2];\n    var y1 = arguments[3];\n    this.p0 = new Coordinate(x0, y0);\n    this.p1 = new Coordinate(x1, y1);\n  }\n};\n\nvar staticAccessors$24 = { serialVersionUID: { configurable: true } };\nLineSegment.prototype.minX = function minX () {\n  return Math.min(this.p0.x, this.p1.x)\n};\nLineSegment.prototype.orientationIndex = function orientationIndex () {\n  if (arguments[0] instanceof LineSegment) {\n    var seg = arguments[0];\n    var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);\n    var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);\n    if (orient0 >= 0 && orient1 >= 0) { return Math.max(orient0, orient1) }\n    if (orient0 <= 0 && orient1 <= 0) { return Math.max(orient0, orient1) }\n    return 0\n  } else if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    return CGAlgorithms.orientationIndex(this.p0, this.p1, p)\n  }\n};\nLineSegment.prototype.toGeometry = function toGeometry (geomFactory) {\n  return geomFactory.createLineString([this.p0, this.p1])\n};\nLineSegment.prototype.isVertical = function isVertical () {\n  return this.p0.x === this.p1.x\n};\nLineSegment.prototype.equals = function equals (o) {\n  if (!(o instanceof LineSegment)) {\n    return false\n  }\n  var other = o;\n  return this.p0.equals(other.p0) && this.p1.equals(other.p1)\n};\nLineSegment.prototype.intersection = function intersection (line) {\n  var li = new RobustLineIntersector();\n  li.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n  if (li.hasIntersection()) { return li.getIntersection(0) }\n  return null\n};\nLineSegment.prototype.project = function project () {\n  if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    if (p.equals(this.p0) || p.equals(this.p1)) { return new Coordinate(p) }\n    var r = this.projectionFactor(p);\n    var coord = new Coordinate();\n    coord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n    coord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n    return coord\n  } else if (arguments[0] instanceof LineSegment) {\n    var seg = arguments[0];\n    var pf0 = this.projectionFactor(seg.p0);\n    var pf1 = this.projectionFactor(seg.p1);\n    if (pf0 >= 1.0 && pf1 >= 1.0) { return null }\n    if (pf0 <= 0.0 && pf1 <= 0.0) { return null }\n    var newp0 = this.project(seg.p0);\n    if (pf0 < 0.0) { newp0 = this.p0; }\n    if (pf0 > 1.0) { newp0 = this.p1; }\n    var newp1 = this.project(seg.p1);\n    if (pf1 < 0.0) { newp1 = this.p0; }\n    if (pf1 > 1.0) { newp1 = this.p1; }\n    return new LineSegment(newp0, newp1)\n  }\n};\nLineSegment.prototype.normalize = function normalize () {\n  if (this.p1.compareTo(this.p0) < 0) { this.reverse(); }\n};\nLineSegment.prototype.angle = function angle () {\n  return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)\n};\nLineSegment.prototype.getCoordinate = function getCoordinate (i) {\n  if (i === 0) { return this.p0 }\n  return this.p1\n};\nLineSegment.prototype.distancePerpendicular = function distancePerpendicular (p) {\n  return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1)\n};\nLineSegment.prototype.minY = function minY () {\n  return Math.min(this.p0.y, this.p1.y)\n};\nLineSegment.prototype.midPoint = function midPoint () {\n  return LineSegment.midPoint(this.p0, this.p1)\n};\nLineSegment.prototype.projectionFactor = function projectionFactor (p) {\n  if (p.equals(this.p0)) { return 0.0 }\n  if (p.equals(this.p1)) { return 1.0 }\n  var dx = this.p1.x - this.p0.x;\n  var dy = this.p1.y - this.p0.y;\n  var len = dx * dx + dy * dy;\n  if (len <= 0.0) { return Double.NaN }\n  var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n  return r\n};\nLineSegment.prototype.closestPoints = function closestPoints (line) {\n  var intPt = this.intersection(line);\n  if (intPt !== null) {\n    return [intPt, intPt]\n  }\n  var closestPt = new Array(2).fill(null);\n  var minDistance = Double.MAX_VALUE;\n  var dist = null;\n  var close00 = this.closestPoint(line.p0);\n  minDistance = close00.distance(line.p0);\n  closestPt[0] = close00;\n  closestPt[1] = line.p0;\n  var close01 = this.closestPoint(line.p1);\n  dist = close01.distance(line.p1);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = close01;\n    closestPt[1] = line.p1;\n  }\n  var close10 = line.closestPoint(this.p0);\n  dist = close10.distance(this.p0);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = this.p0;\n    closestPt[1] = close10;\n  }\n  var close11 = line.closestPoint(this.p1);\n  dist = close11.distance(this.p1);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = this.p1;\n    closestPt[1] = close11;\n  }\n  return closestPt\n};\nLineSegment.prototype.closestPoint = function closestPoint (p) {\n  var factor = this.projectionFactor(p);\n  if (factor > 0 && factor < 1) {\n    return this.project(p)\n  }\n  var dist0 = this.p0.distance(p);\n  var dist1 = this.p1.distance(p);\n  if (dist0 < dist1) { return this.p0 }\n  return this.p1\n};\nLineSegment.prototype.maxX = function maxX () {\n  return Math.max(this.p0.x, this.p1.x)\n};\nLineSegment.prototype.getLength = function getLength () {\n  return this.p0.distance(this.p1)\n};\nLineSegment.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  var comp0 = this.p0.compareTo(other.p0);\n  if (comp0 !== 0) { return comp0 }\n  return this.p1.compareTo(other.p1)\n};\nLineSegment.prototype.reverse = function reverse () {\n  var temp = this.p0;\n  this.p0 = this.p1;\n  this.p1 = temp;\n};\nLineSegment.prototype.equalsTopo = function equalsTopo (other) {\n  return this.p0.equals(other.p0) &&\n        (this.p1.equals(other.p1) || this.p0.equals(other.p1)) &&\n         this.p1.equals(other.p0)\n};\nLineSegment.prototype.lineIntersection = function lineIntersection (line) {\n  try {\n    var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n    return intPt\n  } catch (ex) {\n    if (ex instanceof NotRepresentableException) {} else { throw ex }\n  } finally {}\n  return null\n};\nLineSegment.prototype.maxY = function maxY () {\n  return Math.max(this.p0.y, this.p1.y)\n};\nLineSegment.prototype.pointAlongOffset = function pointAlongOffset (segmentLengthFraction, offsetDistance) {\n  var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  var dx = this.p1.x - this.p0.x;\n  var dy = this.p1.y - this.p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = 0.0;\n  var uy = 0.0;\n  if (offsetDistance !== 0.0) {\n    if (len <= 0.0) { throw new Error('Cannot compute offset from zero-length line segment') }\n    ux = offsetDistance * dx / len;\n    uy = offsetDistance * dy / len;\n  }\n  var offsetx = segx - uy;\n  var offsety = segy + ux;\n  var coord = new Coordinate(offsetx, offsety);\n  return coord\n};\nLineSegment.prototype.setCoordinates = function setCoordinates () {\n  if (arguments.length === 1) {\n    var ls = arguments[0];\n    this.setCoordinates(ls.p0, ls.p1);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this.p0.x = p0.x;\n    this.p0.y = p0.y;\n    this.p1.x = p1.x;\n    this.p1.y = p1.y;\n  }\n};\nLineSegment.prototype.segmentFraction = function segmentFraction (inputPt) {\n  var segFrac = this.projectionFactor(inputPt);\n  if (segFrac < 0.0) { segFrac = 0.0; } else if (segFrac > 1.0 || Double.isNaN(segFrac)) { segFrac = 1.0; }\n  return segFrac\n};\nLineSegment.prototype.toString = function toString () {\n  return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'\n};\nLineSegment.prototype.isHorizontal = function isHorizontal () {\n  return this.p0.y === this.p1.y\n};\nLineSegment.prototype.distance = function distance () {\n  if (arguments[0] instanceof LineSegment) {\n    var ls = arguments[0];\n    return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1)\n  } else if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    return CGAlgorithms.distancePointLine(p, this.p0, this.p1)\n  }\n};\nLineSegment.prototype.pointAlong = function pointAlong (segmentLengthFraction) {\n  var coord = new Coordinate();\n  coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  return coord\n};\nLineSegment.prototype.hashCode = function hashCode () {\n  var bits0 = Double.doubleToLongBits(this.p0.x);\n  bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;\n  var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n  var bits1 = Double.doubleToLongBits(this.p1.x);\n  bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;\n  var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n  return hash0 ^ hash1\n};\nLineSegment.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Serializable]\n};\nLineSegment.prototype.getClass = function getClass () {\n  return LineSegment\n};\nLineSegment.midPoint = function midPoint (p0, p1) {\n  return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)\n};\nstaticAccessors$24.serialVersionUID.get = function () { return 3252005833466256227 };\n\nObject.defineProperties( LineSegment, staticAccessors$24 );\n\nvar MonotoneChainOverlapAction = function MonotoneChainOverlapAction () {\n  this.tempEnv1 = new Envelope();\n  this.tempEnv2 = new Envelope();\n  this._overlapSeg1 = new LineSegment();\n  this._overlapSeg2 = new LineSegment();\n};\nMonotoneChainOverlapAction.prototype.overlap = function overlap () {\n  if (arguments.length === 2) {\n    // const seg1 = arguments[0]\n    // const seg2 = arguments[1]\n  } else if (arguments.length === 4) {\n    var mc1 = arguments[0];\n    var start1 = arguments[1];\n    var mc2 = arguments[2];\n    var start2 = arguments[3];\n    mc1.getLineSegment(start1, this._overlapSeg1);\n    mc2.getLineSegment(start2, this._overlapSeg2);\n    this.overlap(this._overlapSeg1, this._overlapSeg2);\n  }\n};\nMonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainOverlapAction.prototype.getClass = function getClass () {\n  return MonotoneChainOverlapAction\n};\n\nvar MonotoneChain = function MonotoneChain () {\n  this._pts = null;\n  this._start = null;\n  this._end = null;\n  this._env = null;\n  this._context = null;\n  this._id = null;\n  var pts = arguments[0];\n  var start = arguments[1];\n  var end = arguments[2];\n  var context = arguments[3];\n  this._pts = pts;\n  this._start = start;\n  this._end = end;\n  this._context = context;\n};\nMonotoneChain.prototype.getLineSegment = function getLineSegment (index, ls) {\n  ls.p0 = this._pts[index];\n  ls.p1 = this._pts[index + 1];\n};\nMonotoneChain.prototype.computeSelect = function computeSelect (searchEnv, start0, end0, mcs) {\n  var p0 = this._pts[start0];\n  var p1 = this._pts[end0];\n  mcs.tempEnv1.init(p0, p1);\n  if (end0 - start0 === 1) {\n    mcs.select(this, start0);\n    return null\n  }\n  if (!searchEnv.intersects(mcs.tempEnv1)) { return null }\n  var mid = Math.trunc((start0 + end0) / 2);\n  if (start0 < mid) {\n    this.computeSelect(searchEnv, start0, mid, mcs);\n  }\n  if (mid < end0) {\n    this.computeSelect(searchEnv, mid, end0, mcs);\n  }\n};\nMonotoneChain.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n  var coord = new Array(this._end - this._start + 1).fill(null);\n  var index = 0;\n  for (var i = this._start; i <= this._end; i++) {\n    coord[index++] = this$1._pts[i];\n  }\n  return coord\n};\nMonotoneChain.prototype.computeOverlaps = function computeOverlaps (mc, mco) {\n  this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);\n};\nMonotoneChain.prototype.setId = function setId (id) {\n  this._id = id;\n};\nMonotoneChain.prototype.select = function select (searchEnv, mcs) {\n  this.computeSelect(searchEnv, this._start, this._end, mcs);\n};\nMonotoneChain.prototype.getEnvelope = function getEnvelope () {\n  if (this._env === null) {\n    var p0 = this._pts[this._start];\n    var p1 = this._pts[this._end];\n    this._env = new Envelope(p0, p1);\n  }\n  return this._env\n};\nMonotoneChain.prototype.getEndIndex = function getEndIndex () {\n  return this._end\n};\nMonotoneChain.prototype.getStartIndex = function getStartIndex () {\n  return this._start\n};\nMonotoneChain.prototype.getContext = function getContext () {\n  return this._context\n};\nMonotoneChain.prototype.getId = function getId () {\n  return this._id\n};\nMonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal (start0, end0, mc, start1, end1, mco) {\n  var p00 = this._pts[start0];\n  var p01 = this._pts[end0];\n  var p10 = mc._pts[start1];\n  var p11 = mc._pts[end1];\n  if (end0 - start0 === 1 && end1 - start1 === 1) {\n    mco.overlap(this, start0, mc, start1);\n    return null\n  }\n  mco.tempEnv1.init(p00, p01);\n  mco.tempEnv2.init(p10, p11);\n  if (!mco.tempEnv1.intersects(mco.tempEnv2)) { return null }\n  var mid0 = Math.trunc((start0 + end0) / 2);\n  var mid1 = Math.trunc((start1 + end1) / 2);\n  if (start0 < mid0) {\n    if (start1 < mid1) { this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco); }\n    if (mid1 < end1) { this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco); }\n  }\n  if (mid0 < end0) {\n    if (start1 < mid1) { this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco); }\n    if (mid1 < end1) { this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco); }\n  }\n};\nMonotoneChain.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChain.prototype.getClass = function getClass () {\n  return MonotoneChain\n};\n\nvar MonotoneChainBuilder = function MonotoneChainBuilder () {};\n\nMonotoneChainBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainBuilder.prototype.getClass = function getClass () {\n  return MonotoneChainBuilder\n};\nMonotoneChainBuilder.getChainStartIndices = function getChainStartIndices (pts) {\n  var start = 0;\n  var startIndexList = new ArrayList();\n  startIndexList.add(new Integer(start));\n  do {\n    var last = MonotoneChainBuilder.findChainEnd(pts, start);\n    startIndexList.add(new Integer(last));\n    start = last;\n  } while (start < pts.length - 1)\n  var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n  return startIndex\n};\nMonotoneChainBuilder.findChainEnd = function findChainEnd (pts, start) {\n  var safeStart = start;\n  while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n    safeStart++;\n  }\n  if (safeStart >= pts.length - 1) {\n    return pts.length - 1\n  }\n  var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n  var last = start + 1;\n  while (last < pts.length) {\n    if (!pts[last - 1].equals2D(pts[last])) {\n      var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n      if (quad !== chainQuad) { break }\n    }\n    last++;\n  }\n  return last - 1\n};\nMonotoneChainBuilder.getChains = function getChains () {\n  if (arguments.length === 1) {\n    var pts = arguments[0];\n    return MonotoneChainBuilder.getChains(pts, null)\n  } else if (arguments.length === 2) {\n    var pts$1 = arguments[0];\n    var context = arguments[1];\n    var mcList = new ArrayList();\n    var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);\n    for (var i = 0; i < startIndex.length - 1; i++) {\n      var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);\n      mcList.add(mc);\n    }\n    return mcList\n  }\n};\nMonotoneChainBuilder.toIntArray = function toIntArray (list) {\n  var array = new Array(list.size()).fill(null);\n  for (var i = 0; i < array.length; i++) {\n    array[i] = list.get(i).intValue();\n  }\n  return array\n};\n\nvar Noder = function Noder () {};\n\nNoder.prototype.computeNodes = function computeNodes (segStrings) {};\nNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {};\nNoder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNoder.prototype.getClass = function getClass () {\n  return Noder\n};\n\nvar SinglePassNoder = function SinglePassNoder () {\n  this._segInt = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var segInt = arguments[0];\n    this.setSegmentIntersector(segInt);\n  }\n};\nSinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector (segInt) {\n  this._segInt = segInt;\n};\nSinglePassNoder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nSinglePassNoder.prototype.getClass = function getClass () {\n  return SinglePassNoder\n};\n\nvar MCIndexNoder = (function (SinglePassNoder$$1) {\n  function MCIndexNoder (si) {\n    if (si) { SinglePassNoder$$1.call(this, si); }\n    else { SinglePassNoder$$1.call(this); }\n    this._monoChains = new ArrayList();\n    this._index = new STRtree();\n    this._idCounter = 0;\n    this._nodedSegStrings = null;\n    this._nOverlaps = 0;\n  }\n\n  if ( SinglePassNoder$$1 ) MCIndexNoder.__proto__ = SinglePassNoder$$1;\n  MCIndexNoder.prototype = Object.create( SinglePassNoder$$1 && SinglePassNoder$$1.prototype );\n  MCIndexNoder.prototype.constructor = MCIndexNoder;\n\n  var staticAccessors = { SegmentOverlapAction: { configurable: true } };\n  MCIndexNoder.prototype.getMonotoneChains = function getMonotoneChains () {\n    return this._monoChains\n  };\n  MCIndexNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n  };\n  MCIndexNoder.prototype.getIndex = function getIndex () {\n    return this._index\n  };\n  MCIndexNoder.prototype.add = function add (segStr) {\n    var this$1 = this;\n\n    var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n    for (var i = segChains.iterator(); i.hasNext();) {\n      var mc = i.next();\n      mc.setId(this$1._idCounter++);\n      this$1._index.insert(mc.getEnvelope(), mc);\n      this$1._monoChains.add(mc);\n    }\n  };\n  MCIndexNoder.prototype.computeNodes = function computeNodes (inputSegStrings) {\n    var this$1 = this;\n\n    this._nodedSegStrings = inputSegStrings;\n    for (var i = inputSegStrings.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    this.intersectChains();\n  };\n  MCIndexNoder.prototype.intersectChains = function intersectChains () {\n    var this$1 = this;\n\n    var overlapAction = new SegmentOverlapAction(this._segInt);\n    for (var i = this._monoChains.iterator(); i.hasNext();) {\n      var queryChain = i.next();\n      var overlapChains = this$1._index.query(queryChain.getEnvelope());\n      for (var j = overlapChains.iterator(); j.hasNext();) {\n        var testChain = j.next();\n        if (testChain.getId() > queryChain.getId()) {\n          queryChain.computeOverlaps(testChain, overlapAction);\n          this$1._nOverlaps++;\n        }\n        if (this$1._segInt.isDone()) { return null }\n      }\n    }\n  };\n  MCIndexNoder.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MCIndexNoder.prototype.getClass = function getClass () {\n    return MCIndexNoder\n  };\n  staticAccessors.SegmentOverlapAction.get = function () { return SegmentOverlapAction };\n\n  Object.defineProperties( MCIndexNoder, staticAccessors );\n\n  return MCIndexNoder;\n}(SinglePassNoder));\n\nvar SegmentOverlapAction = (function (MonotoneChainOverlapAction$$1) {\n  function SegmentOverlapAction () {\n    MonotoneChainOverlapAction$$1.call(this);\n    this._si = null;\n    var si = arguments[0];\n    this._si = si;\n  }\n\n  if ( MonotoneChainOverlapAction$$1 ) SegmentOverlapAction.__proto__ = MonotoneChainOverlapAction$$1;\n  SegmentOverlapAction.prototype = Object.create( MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype );\n  SegmentOverlapAction.prototype.constructor = SegmentOverlapAction;\n  SegmentOverlapAction.prototype.overlap = function overlap () {\n    if (arguments.length === 4) {\n      var mc1 = arguments[0];\n      var start1 = arguments[1];\n      var mc2 = arguments[2];\n      var start2 = arguments[3];\n      var ss1 = mc1.getContext();\n      var ss2 = mc2.getContext();\n      this._si.processIntersections(ss1, start1, ss2, start2);\n    } else { return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments) }\n  };\n  SegmentOverlapAction.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SegmentOverlapAction.prototype.getClass = function getClass () {\n    return SegmentOverlapAction\n  };\n\n  return SegmentOverlapAction;\n}(MonotoneChainOverlapAction));\n\nvar BufferParameters = function BufferParameters () {\n  this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  this._endCapStyle = BufferParameters.CAP_ROUND;\n  this._joinStyle = BufferParameters.JOIN_ROUND;\n  this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n  this._isSingleSided = false;\n  this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var quadrantSegments = arguments[0];\n    this.setQuadrantSegments(quadrantSegments);\n  } else if (arguments.length === 2) {\n    var quadrantSegments$1 = arguments[0];\n    var endCapStyle = arguments[1];\n    this.setQuadrantSegments(quadrantSegments$1);\n    this.setEndCapStyle(endCapStyle);\n  } else if (arguments.length === 4) {\n    var quadrantSegments$2 = arguments[0];\n    var endCapStyle$1 = arguments[1];\n    var joinStyle = arguments[2];\n    var mitreLimit = arguments[3];\n    this.setQuadrantSegments(quadrantSegments$2);\n    this.setEndCapStyle(endCapStyle$1);\n    this.setJoinStyle(joinStyle);\n    this.setMitreLimit(mitreLimit);\n  }\n};\n\nvar staticAccessors$25 = { CAP_ROUND: { configurable: true },CAP_FLAT: { configurable: true },CAP_SQUARE: { configurable: true },JOIN_ROUND: { configurable: true },JOIN_MITRE: { configurable: true },JOIN_BEVEL: { configurable: true },DEFAULT_QUADRANT_SEGMENTS: { configurable: true },DEFAULT_MITRE_LIMIT: { configurable: true },DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };\nBufferParameters.prototype.getEndCapStyle = function getEndCapStyle () {\n  return this._endCapStyle\n};\nBufferParameters.prototype.isSingleSided = function isSingleSided () {\n  return this._isSingleSided\n};\nBufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments (quadSegs) {\n  this._quadrantSegments = quadSegs;\n  if (this._quadrantSegments === 0) { this._joinStyle = BufferParameters.JOIN_BEVEL; }\n  if (this._quadrantSegments < 0) {\n    this._joinStyle = BufferParameters.JOIN_MITRE;\n    this._mitreLimit = Math.abs(this._quadrantSegments);\n  }\n  if (quadSegs <= 0) {\n    this._quadrantSegments = 1;\n  }\n  if (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  }\n};\nBufferParameters.prototype.getJoinStyle = function getJoinStyle () {\n  return this._joinStyle\n};\nBufferParameters.prototype.setJoinStyle = function setJoinStyle (joinStyle) {\n  this._joinStyle = joinStyle;\n};\nBufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor (simplifyFactor) {\n  this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n};\nBufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor () {\n  return this._simplifyFactor\n};\nBufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments () {\n  return this._quadrantSegments\n};\nBufferParameters.prototype.setEndCapStyle = function setEndCapStyle (endCapStyle) {\n  this._endCapStyle = endCapStyle;\n};\nBufferParameters.prototype.getMitreLimit = function getMitreLimit () {\n  return this._mitreLimit\n};\nBufferParameters.prototype.setMitreLimit = function setMitreLimit (mitreLimit) {\n  this._mitreLimit = mitreLimit;\n};\nBufferParameters.prototype.setSingleSided = function setSingleSided (isSingleSided) {\n  this._isSingleSided = isSingleSided;\n};\nBufferParameters.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferParameters.prototype.getClass = function getClass () {\n  return BufferParameters\n};\nBufferParameters.bufferDistanceError = function bufferDistanceError (quadSegs) {\n  var alpha = Math.PI / 2.0 / quadSegs;\n  return 1 - Math.cos(alpha / 2.0)\n};\nstaticAccessors$25.CAP_ROUND.get = function () { return 1 };\nstaticAccessors$25.CAP_FLAT.get = function () { return 2 };\nstaticAccessors$25.CAP_SQUARE.get = function () { return 3 };\nstaticAccessors$25.JOIN_ROUND.get = function () { return 1 };\nstaticAccessors$25.JOIN_MITRE.get = function () { return 2 };\nstaticAccessors$25.JOIN_BEVEL.get = function () { return 3 };\nstaticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function () { return 8 };\nstaticAccessors$25.DEFAULT_MITRE_LIMIT.get = function () { return 5.0 };\nstaticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function () { return 0.01 };\n\nObject.defineProperties( BufferParameters, staticAccessors$25 );\n\nvar BufferInputLineSimplifier = function BufferInputLineSimplifier (inputLine) {\n  this._distanceTol = null;\n  this._isDeleted = null;\n  this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;\n  this._inputLine = inputLine || null;\n};\n\nvar staticAccessors$26 = { INIT: { configurable: true },DELETE: { configurable: true },KEEP: { configurable: true },NUM_PTS_TO_CHECK: { configurable: true } };\nBufferInputLineSimplifier.prototype.isDeletable = function isDeletable (i0, i1, i2, distanceTol) {\n  var p0 = this._inputLine[i0];\n  var p1 = this._inputLine[i1];\n  var p2 = this._inputLine[i2];\n  if (!this.isConcave(p0, p1, p2)) { return false }\n  if (!this.isShallow(p0, p1, p2, distanceTol)) { return false }\n  return this.isShallowSampled(p0, p1, i0, i2, distanceTol)\n};\nBufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities () {\n    var this$1 = this;\n\n  var index = 1;\n  // const maxIndex = this._inputLine.length - 1\n  var midIndex = this.findNextNonDeletedIndex(index);\n  var lastIndex = this.findNextNonDeletedIndex(midIndex);\n  var isChanged = false;\n  while (lastIndex < this._inputLine.length) {\n    var isMiddleVertexDeleted = false;\n    if (this$1.isDeletable(index, midIndex, lastIndex, this$1._distanceTol)) {\n      this$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n      isMiddleVertexDeleted = true;\n      isChanged = true;\n    }\n    if (isMiddleVertexDeleted) { index = lastIndex; } else { index = midIndex; }\n    midIndex = this$1.findNextNonDeletedIndex(index);\n    lastIndex = this$1.findNextNonDeletedIndex(midIndex);\n  }\n  return isChanged\n};\nBufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity (p0, p1, p2, distanceTol) {\n  var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  var isAngleToSimplify = orientation === this._angleOrientation;\n  if (!isAngleToSimplify) { return false }\n  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  return dist < distanceTol\n};\nBufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled (p0, p2, i0, i2, distanceTol) {\n    var this$1 = this;\n\n  var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n  if (inc <= 0) { inc = 1; }\n  for (var i = i0; i < i2; i += inc) {\n    if (!this$1.isShallow(p0, p2, this$1._inputLine[i], distanceTol)) { return false }\n  }\n  return true\n};\nBufferInputLineSimplifier.prototype.isConcave = function isConcave (p0, p1, p2) {\n  var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  var isConcave = orientation === this._angleOrientation;\n  return isConcave\n};\nBufferInputLineSimplifier.prototype.simplify = function simplify (distanceTol) {\n    var this$1 = this;\n\n  this._distanceTol = Math.abs(distanceTol);\n  if (distanceTol < 0) { this._angleOrientation = CGAlgorithms.CLOCKWISE; }\n  this._isDeleted = new Array(this._inputLine.length).fill(null);\n  var isChanged = false;\n  do {\n    isChanged = this$1.deleteShallowConcavities();\n  } while (isChanged)\n  return this.collapseLine()\n};\nBufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex (index) {\n  var next = index + 1;\n  while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) { next++; }\n  return next\n};\nBufferInputLineSimplifier.prototype.isShallow = function isShallow (p0, p1, p2, distanceTol) {\n  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  return dist < distanceTol\n};\nBufferInputLineSimplifier.prototype.collapseLine = function collapseLine () {\n    var this$1 = this;\n\n  var coordList = new CoordinateList();\n  for (var i = 0; i < this._inputLine.length; i++) {\n    if (this$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) { coordList.add(this$1._inputLine[i]); }\n  }\n  return coordList.toCoordinateArray()\n};\nBufferInputLineSimplifier.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferInputLineSimplifier.prototype.getClass = function getClass () {\n  return BufferInputLineSimplifier\n};\nBufferInputLineSimplifier.simplify = function simplify (inputLine, distanceTol) {\n  var simp = new BufferInputLineSimplifier(inputLine);\n  return simp.simplify(distanceTol)\n};\nstaticAccessors$26.INIT.get = function () { return 0 };\nstaticAccessors$26.DELETE.get = function () { return 1 };\nstaticAccessors$26.KEEP.get = function () { return 1 };\nstaticAccessors$26.NUM_PTS_TO_CHECK.get = function () { return 10 };\n\nObject.defineProperties( BufferInputLineSimplifier, staticAccessors$26 );\n\nvar OffsetSegmentString = function OffsetSegmentString () {\n  this._ptList = null;\n  this._precisionModel = null;\n  this._minimimVertexDistance = 0.0;\n  this._ptList = new ArrayList();\n};\n\nvar staticAccessors$28 = { COORDINATE_ARRAY_TYPE: { configurable: true } };\nOffsetSegmentString.prototype.getCoordinates = function getCoordinates () {\n  var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n  return coord\n};\nOffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel (precisionModel) {\n  this._precisionModel = precisionModel;\n};\nOffsetSegmentString.prototype.addPt = function addPt (pt) {\n  var bufPt = new Coordinate(pt);\n  this._precisionModel.makePrecise(bufPt);\n  if (this.isRedundant(bufPt)) { return null }\n  this._ptList.add(bufPt);\n};\nOffsetSegmentString.prototype.revere = function revere () {};\nOffsetSegmentString.prototype.addPts = function addPts (pt, isForward) {\n    var this$1 = this;\n\n  if (isForward) {\n    for (var i = 0; i < pt.length; i++) {\n      this$1.addPt(pt[i]);\n    }\n  } else {\n    for (var i$1 = pt.length - 1; i$1 >= 0; i$1--) {\n      this$1.addPt(pt[i$1]);\n    }\n  }\n};\nOffsetSegmentString.prototype.isRedundant = function isRedundant (pt) {\n  if (this._ptList.size() < 1) { return false }\n  var lastPt = this._ptList.get(this._ptList.size() - 1);\n  var ptDist = pt.distance(lastPt);\n  if (ptDist < this._minimimVertexDistance) { return true }\n  return false\n};\nOffsetSegmentString.prototype.toString = function toString () {\n  var fact = new GeometryFactory();\n  var line = fact.createLineString(this.getCoordinates());\n  return line.toString()\n};\nOffsetSegmentString.prototype.closeRing = function closeRing () {\n  if (this._ptList.size() < 1) { return null }\n  var startPt = new Coordinate(this._ptList.get(0));\n  var lastPt = this._ptList.get(this._ptList.size() - 1);\n  // const last2Pt = null\n  // if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2)\n  if (startPt.equals(lastPt)) { return null }\n  this._ptList.add(startPt);\n};\nOffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance (minimimVertexDistance) {\n  this._minimimVertexDistance = minimimVertexDistance;\n};\nOffsetSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetSegmentString.prototype.getClass = function getClass () {\n  return OffsetSegmentString\n};\nstaticAccessors$28.COORDINATE_ARRAY_TYPE.get = function () { return new Array(0).fill(null) };\n\nObject.defineProperties( OffsetSegmentString, staticAccessors$28 );\n\nvar Angle = function Angle () {};\n\nvar staticAccessors$29 = { PI_TIMES_2: { configurable: true },PI_OVER_2: { configurable: true },PI_OVER_4: { configurable: true },COUNTERCLOCKWISE: { configurable: true },CLOCKWISE: { configurable: true },NONE: { configurable: true } };\n\nAngle.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nAngle.prototype.getClass = function getClass () {\n  return Angle\n};\nAngle.toDegrees = function toDegrees (radians) {\n  return radians * 180 / Math.PI\n};\nAngle.normalize = function normalize (angle) {\n  while (angle > Math.PI) { angle -= Angle.PI_TIMES_2; }\n  while (angle <= -Math.PI) { angle += Angle.PI_TIMES_2; }\n  return angle\n};\nAngle.angle = function angle () {\n  if (arguments.length === 1) {\n    var p = arguments[0];\n    return Math.atan2(p.y, p.x)\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    return Math.atan2(dy, dx)\n  }\n};\nAngle.isAcute = function isAcute (p0, p1, p2) {\n  var dx0 = p0.x - p1.x;\n  var dy0 = p0.y - p1.y;\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dotprod = dx0 * dx1 + dy0 * dy1;\n  return dotprod > 0\n};\nAngle.isObtuse = function isObtuse (p0, p1, p2) {\n  var dx0 = p0.x - p1.x;\n  var dy0 = p0.y - p1.y;\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dotprod = dx0 * dx1 + dy0 * dy1;\n  return dotprod < 0\n};\nAngle.interiorAngle = function interiorAngle (p0, p1, p2) {\n  var anglePrev = Angle.angle(p1, p0);\n  var angleNext = Angle.angle(p1, p2);\n  return Math.abs(angleNext - anglePrev)\n};\nAngle.normalizePositive = function normalizePositive (angle) {\n  if (angle < 0.0) {\n    while (angle < 0.0) { angle += Angle.PI_TIMES_2; }\n    if (angle >= Angle.PI_TIMES_2) { angle = 0.0; }\n  } else {\n    while (angle >= Angle.PI_TIMES_2) { angle -= Angle.PI_TIMES_2; }\n    if (angle < 0.0) { angle = 0.0; }\n  }\n  return angle\n};\nAngle.angleBetween = function angleBetween (tip1, tail, tip2) {\n  var a1 = Angle.angle(tail, tip1);\n  var a2 = Angle.angle(tail, tip2);\n  return Angle.diff(a1, a2)\n};\nAngle.diff = function diff (ang1, ang2) {\n  var delAngle = null;\n  if (ang1 < ang2) {\n    delAngle = ang2 - ang1;\n  } else {\n    delAngle = ang1 - ang2;\n  }\n  if (delAngle > Math.PI) {\n    delAngle = 2 * Math.PI - delAngle;\n  }\n  return delAngle\n};\nAngle.toRadians = function toRadians (angleDegrees) {\n  return angleDegrees * Math.PI / 180.0\n};\nAngle.getTurn = function getTurn (ang1, ang2) {\n  var crossproduct = Math.sin(ang2 - ang1);\n  if (crossproduct > 0) {\n    return Angle.COUNTERCLOCKWISE\n  }\n  if (crossproduct < 0) {\n    return Angle.CLOCKWISE\n  }\n  return Angle.NONE\n};\nAngle.angleBetweenOriented = function angleBetweenOriented (tip1, tail, tip2) {\n  var a1 = Angle.angle(tail, tip1);\n  var a2 = Angle.angle(tail, tip2);\n  var angDel = a2 - a1;\n  if (angDel <= -Math.PI) { return angDel + Angle.PI_TIMES_2 }\n  if (angDel > Math.PI) { return angDel - Angle.PI_TIMES_2 }\n  return angDel\n};\nstaticAccessors$29.PI_TIMES_2.get = function () { return 2.0 * Math.PI };\nstaticAccessors$29.PI_OVER_2.get = function () { return Math.PI / 2.0 };\nstaticAccessors$29.PI_OVER_4.get = function () { return Math.PI / 4.0 };\nstaticAccessors$29.COUNTERCLOCKWISE.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };\nstaticAccessors$29.CLOCKWISE.get = function () { return CGAlgorithms.CLOCKWISE };\nstaticAccessors$29.NONE.get = function () { return CGAlgorithms.COLLINEAR };\n\nObject.defineProperties( Angle, staticAccessors$29 );\n\nvar OffsetSegmentGenerator = function OffsetSegmentGenerator () {\n  this._maxCurveSegmentError = 0.0;\n  this._filletAngleQuantum = null;\n  this._closingSegLengthFactor = 1;\n  this._segList = null;\n  this._distance = 0.0;\n  this._precisionModel = null;\n  this._bufParams = null;\n  this._li = null;\n  this._s0 = null;\n  this._s1 = null;\n  this._s2 = null;\n  this._seg0 = new LineSegment();\n  this._seg1 = new LineSegment();\n  this._offset0 = new LineSegment();\n  this._offset1 = new LineSegment();\n  this._side = 0;\n  this._hasNarrowConcaveAngle = false;\n  var precisionModel = arguments[0];\n  var bufParams = arguments[1];\n  var distance = arguments[2];\n  this._precisionModel = precisionModel;\n  this._bufParams = bufParams;\n  this._li = new RobustLineIntersector();\n  this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n  if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) { this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR; }\n  this.init(distance);\n};\n\nvar staticAccessors$27 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true },INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true },CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true },MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };\nOffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment (p, addStartPoint) {\n  this._s0 = this._s1;\n  this._s1 = this._s2;\n  this._s2 = p;\n  this._seg0.setCoordinates(this._s0, this._s1);\n  this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n  this._seg1.setCoordinates(this._s1, this._s2);\n  this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n  if (this._s1.equals(this._s2)) { return null }\n  var orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);\n  var outsideTurn = (orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT) || (orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT);\n  if (orientation === 0) {\n    this.addCollinear(addStartPoint);\n  } else if (outsideTurn) {\n    this.addOutsideTurn(orientation, addStartPoint);\n  } else {\n    this.addInsideTurn(orientation, addStartPoint);\n  }\n};\nOffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap (p0, p1) {\n  var seg = new LineSegment(p0, p1);\n  var offsetL = new LineSegment();\n  this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n  var offsetR = new LineSegment();\n  this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n  var dx = p1.x - p0.x;\n  var dy = p1.y - p0.y;\n  var angle = Math.atan2(dy, dx);\n  switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      this._segList.addPt(offsetL.p1);\n      this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);\n      this._segList.addPt(offsetR.p1);\n      break\n    case BufferParameters.CAP_FLAT:\n      this._segList.addPt(offsetL.p1);\n      this._segList.addPt(offsetR.p1);\n      break\n    case BufferParameters.CAP_SQUARE:\n      var squareCapSideOffset = new Coordinate();\n      squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n      squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n      var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n      var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n      this._segList.addPt(squareCapLOffset);\n      this._segList.addPt(squareCapROffset);\n      break\n    default:\n  }\n};\nOffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates () {\n  var pts = this._segList.getCoordinates();\n  return pts\n};\nOffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin (p, offset0, offset1, distance) {\n  var isMitreWithinLimit = true;\n  var intPt = null;\n  try {\n    intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n    var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n    if (mitreRatio > this._bufParams.getMitreLimit()) { isMitreWithinLimit = false; }\n  } catch (ex) {\n    if (ex instanceof NotRepresentableException) {\n      intPt = new Coordinate(0, 0);\n      isMitreWithinLimit = false;\n    } else { throw ex }\n  } finally {}\n  if (isMitreWithinLimit) {\n    this._segList.addPt(intPt);\n  } else {\n    this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n  }\n};\nOffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner (p, p0, p1, direction, radius) {\n  var dx0 = p0.x - p.x;\n  var dy0 = p0.y - p.y;\n  var startAngle = Math.atan2(dy0, dx0);\n  var dx1 = p1.x - p.x;\n  var dy1 = p1.y - p.y;\n  var endAngle = Math.atan2(dy1, dx1);\n  if (direction === CGAlgorithms.CLOCKWISE) {\n    if (startAngle <= endAngle) { startAngle += 2.0 * Math.PI; }\n  } else {\n    if (startAngle >= endAngle) { startAngle -= 2.0 * Math.PI; }\n  }\n  this._segList.addPt(p0);\n  this.addFilletArc(p, startAngle, endAngle, direction, radius);\n  this._segList.addPt(p1);\n};\nOffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn (orientation, addStartPoint) {\n  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n    this._segList.addPt(this._offset0.p1);\n    return null\n  }\n  if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n    this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n  } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n    this.addBevelJoin(this._offset0, this._offset1);\n  } else {\n    if (addStartPoint) { this._segList.addPt(this._offset0.p1); }\n    this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n    this._segList.addPt(this._offset1.p0);\n  }\n};\nOffsetSegmentGenerator.prototype.createSquare = function createSquare (p) {\n  this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n  this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n  this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n  this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.addSegments = function addSegments (pt, isForward) {\n  this._segList.addPts(pt, isForward);\n};\nOffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment () {\n  this._segList.addPt(this._offset1.p0);\n};\nOffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment () {\n  this._segList.addPt(this._offset1.p1);\n};\nOffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments (s1, s2, side) {\n  this._s1 = s1;\n  this._s2 = s2;\n  this._side = side;\n  this._seg1.setCoordinates(s1, s2);\n  this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n};\nOffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin (offset0, offset1, distance, mitreLimit) {\n  var basePt = this._seg0.p1;\n  var ang0 = Angle.angle(basePt, this._seg0.p0);\n  // const ang1 = Angle.angle(basePt, this._seg1.p1)\n  var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n  var angDiffHalf = angDiff / 2;\n  var midAng = Angle.normalize(ang0 + angDiffHalf);\n  var mitreMidAng = Angle.normalize(midAng + Math.PI);\n  var mitreDist = mitreLimit * distance;\n  var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n  var bevelHalfLen = distance - bevelDelta;\n  var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n  var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n  var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n  var mitreMidLine = new LineSegment(basePt, bevelMidPt);\n  var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n  var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n  if (this._side === Position.LEFT) {\n    this._segList.addPt(bevelEndLeft);\n    this._segList.addPt(bevelEndRight);\n  } else {\n    this._segList.addPt(bevelEndRight);\n    this._segList.addPt(bevelEndLeft);\n  }\n};\nOffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment (seg, side, distance, offset) {\n  var sideSign = side === Position.LEFT ? 1 : -1;\n  var dx = seg.p1.x - seg.p0.x;\n  var dy = seg.p1.y - seg.p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = sideSign * distance * dx / len;\n  var uy = sideSign * distance * dy / len;\n  offset.p0.x = seg.p0.x - uy;\n  offset.p0.y = seg.p0.y + ux;\n  offset.p1.x = seg.p1.x - uy;\n  offset.p1.y = seg.p1.y + ux;\n};\nOffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc (p, startAngle, endAngle, direction, radius) {\n    var this$1 = this;\n\n  var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;\n  var totalAngle = Math.abs(startAngle - endAngle);\n  var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n  if (nSegs < 1) { return null }\n  var initAngle = 0.0;\n  var currAngleInc = totalAngle / nSegs;\n  var currAngle = initAngle;\n  var pt = new Coordinate();\n  while (currAngle < totalAngle) {\n    var angle = startAngle + directionFactor * currAngle;\n    pt.x = p.x + radius * Math.cos(angle);\n    pt.y = p.y + radius * Math.sin(angle);\n    this$1._segList.addPt(pt);\n    currAngle += currAngleInc;\n  }\n};\nOffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn (orientation, addStartPoint) {\n  this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n  if (this._li.hasIntersection()) {\n    this._segList.addPt(this._li.getIntersection(0));\n  } else {\n    this._hasNarrowConcaveAngle = true;\n    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n      this._segList.addPt(this._offset0.p1);\n    } else {\n      this._segList.addPt(this._offset0.p1);\n      if (this._closingSegLengthFactor > 0) {\n        var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n        this._segList.addPt(mid0);\n        var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n        this._segList.addPt(mid1);\n      } else {\n        this._segList.addPt(this._s1);\n      }\n      this._segList.addPt(this._offset1.p0);\n    }\n  }\n};\nOffsetSegmentGenerator.prototype.createCircle = function createCircle (p) {\n  var pt = new Coordinate(p.x + this._distance, p.y);\n  this._segList.addPt(pt);\n  this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin (offset0, offset1) {\n  this._segList.addPt(offset0.p1);\n  this._segList.addPt(offset1.p0);\n};\nOffsetSegmentGenerator.prototype.init = function init (distance) {\n  this._distance = distance;\n  this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n  this._segList = new OffsetSegmentString();\n  this._segList.setPrecisionModel(this._precisionModel);\n  this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n};\nOffsetSegmentGenerator.prototype.addCollinear = function addCollinear (addStartPoint) {\n  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n  var numInt = this._li.getIntersectionNum();\n  if (numInt >= 2) {\n    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n      if (addStartPoint) { this._segList.addPt(this._offset0.p1); }\n      this._segList.addPt(this._offset1.p0);\n    } else {\n      this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);\n    }\n  }\n};\nOffsetSegmentGenerator.prototype.closeRing = function closeRing () {\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle () {\n  return this._hasNarrowConcaveAngle\n};\nOffsetSegmentGenerator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetSegmentGenerator.prototype.getClass = function getClass () {\n  return OffsetSegmentGenerator\n};\nstaticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () { return 1.0E-3 };\nstaticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-3 };\nstaticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-6 };\nstaticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function () { return 80 };\n\nObject.defineProperties( OffsetSegmentGenerator, staticAccessors$27 );\n\nvar OffsetCurveBuilder = function OffsetCurveBuilder () {\n  this._distance = 0.0;\n  this._precisionModel = null;\n  this._bufParams = null;\n  var precisionModel = arguments[0];\n  var bufParams = arguments[1];\n  this._precisionModel = precisionModel;\n  this._bufParams = bufParams;\n};\nOffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve (inputPts, distance) {\n  this._distance = distance;\n  if (distance === 0.0) { return null }\n  var isRightSide = distance < 0.0;\n  var posDistance = Math.abs(distance);\n  var segGen = this.getSegGen(posDistance);\n  if (inputPts.length <= 1) {\n    this.computePointCurve(inputPts[0], segGen);\n  } else {\n    this.computeOffsetCurve(inputPts, isRightSide, segGen);\n  }\n  var curvePts = segGen.getCoordinates();\n  if (isRightSide) { CoordinateArrays.reverse(curvePts); }\n  return curvePts\n};\nOffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve (inputPts, isRightSide, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (isRightSide) {\n    segGen.addSegments(inputPts, true);\n    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n    var n2 = simp2.length - 1;\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i = n2 - 2; i >= 0; i--) {\n      segGen.addNextSegment(simp2[i], true);\n    }\n  } else {\n    segGen.addSegments(inputPts, false);\n    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n    var n1 = simp1.length - 1;\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i$1 = 2; i$1 <= n1; i$1++) {\n      segGen.addNextSegment(simp1[i$1], true);\n    }\n  }\n  segGen.addLastSegment();\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve (inputPts, side, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (side === Position.RIGHT) { distTol = -distTol; }\n  var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  var n = simp.length - 1;\n  segGen.initSideSegments(simp[n - 1], simp[0], side);\n  for (var i = 1; i <= n; i++) {\n    var addStartPoint = i !== 1;\n    segGen.addNextSegment(simp[i], addStartPoint);\n  }\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve (inputPts, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  var n1 = simp1.length - 1;\n  segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  for (var i = 2; i <= n1; i++) {\n    segGen.addNextSegment(simp1[i], true);\n  }\n  segGen.addLastSegment();\n  segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n  var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  var n2 = simp2.length - 1;\n  segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  for (var i$1 = n2 - 2; i$1 >= 0; i$1--) {\n    segGen.addNextSegment(simp2[i$1], true);\n  }\n  segGen.addLastSegment();\n  segGen.addLineEndCap(simp2[1], simp2[0]);\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computePointCurve = function computePointCurve (pt, segGen) {\n  switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      segGen.createCircle(pt);\n      break\n    case BufferParameters.CAP_SQUARE:\n      segGen.createSquare(pt);\n      break\n    default:\n  }\n};\nOffsetCurveBuilder.prototype.getLineCurve = function getLineCurve (inputPts, distance) {\n  this._distance = distance;\n  if (distance < 0.0 && !this._bufParams.isSingleSided()) { return null }\n  if (distance === 0.0) { return null }\n  var posDistance = Math.abs(distance);\n  var segGen = this.getSegGen(posDistance);\n  if (inputPts.length <= 1) {\n    this.computePointCurve(inputPts[0], segGen);\n  } else {\n    if (this._bufParams.isSingleSided()) {\n      var isRightSide = distance < 0.0;\n      this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n    } else { this.computeLineBufferCurve(inputPts, segGen); }\n  }\n  var lineCoord = segGen.getCoordinates();\n  return lineCoord\n};\nOffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters () {\n  return this._bufParams\n};\nOffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance (bufDistance) {\n  return bufDistance * this._bufParams.getSimplifyFactor()\n};\nOffsetCurveBuilder.prototype.getRingCurve = function getRingCurve (inputPts, side, distance) {\n  this._distance = distance;\n  if (inputPts.length <= 2) { return this.getLineCurve(inputPts, distance) }\n  if (distance === 0.0) {\n    return OffsetCurveBuilder.copyCoordinates(inputPts)\n  }\n  var segGen = this.getSegGen(distance);\n  this.computeRingBufferCurve(inputPts, side, segGen);\n  return segGen.getCoordinates()\n};\nOffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve (inputPts, isRightSide, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (isRightSide) {\n    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n    var n2 = simp2.length - 1;\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i = n2 - 2; i >= 0; i--) {\n      segGen.addNextSegment(simp2[i], true);\n    }\n  } else {\n    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n    var n1 = simp1.length - 1;\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i$1 = 2; i$1 <= n1; i$1++) {\n      segGen.addNextSegment(simp1[i$1], true);\n    }\n  }\n  segGen.addLastSegment();\n};\nOffsetCurveBuilder.prototype.getSegGen = function getSegGen (distance) {\n  return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)\n};\nOffsetCurveBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetCurveBuilder.prototype.getClass = function getClass () {\n  return OffsetCurveBuilder\n};\nOffsetCurveBuilder.copyCoordinates = function copyCoordinates (pts) {\n  var copy = new Array(pts.length).fill(null);\n  for (var i = 0; i < copy.length; i++) {\n    copy[i] = new Coordinate(pts[i]);\n  }\n  return copy\n};\n\nvar SubgraphDepthLocater = function SubgraphDepthLocater () {\n  this._subgraphs = null;\n  this._seg = new LineSegment();\n  this._cga = new CGAlgorithms();\n  var subgraphs = arguments[0];\n  this._subgraphs = subgraphs;\n};\n\nvar staticAccessors$30 = { DepthSegment: { configurable: true } };\nSubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var stabbingRayLeftPt = arguments[0];\n    var stabbedSegments = new ArrayList();\n    for (var i = this._subgraphs.iterator(); i.hasNext();) {\n      var bsg = i.next();\n      var env = bsg.getEnvelope();\n      if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) { continue }\n      this$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n    }\n    return stabbedSegments\n  } else if (arguments.length === 3) {\n    if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {\n      var stabbingRayLeftPt$1 = arguments[0];\n      var dirEdge = arguments[1];\n      var stabbedSegments$1 = arguments[2];\n      var pts = dirEdge.getEdge().getCoordinates();\n      for (var i$1 = 0; i$1 < pts.length - 1; i$1++) {\n        this$1._seg.p0 = pts[i$1];\n        this$1._seg.p1 = pts[i$1 + 1];\n        if (this$1._seg.p0.y > this$1._seg.p1.y) { this$1._seg.reverse(); }\n        var maxx = Math.max(this$1._seg.p0.x, this$1._seg.p1.x);\n        if (maxx < stabbingRayLeftPt$1.x) { continue }\n        if (this$1._seg.isHorizontal()) { continue }\n        if (stabbingRayLeftPt$1.y < this$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1._seg.p1.y) { continue }\n        if (CGAlgorithms.computeOrientation(this$1._seg.p0, this$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) { continue }\n        var depth = dirEdge.getDepth(Position.LEFT);\n        if (!this$1._seg.p0.equals(pts[i$1])) { depth = dirEdge.getDepth(Position.RIGHT); }\n        var ds = new DepthSegment(this$1._seg, depth);\n        stabbedSegments$1.add(ds);\n      }\n    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {\n      var stabbingRayLeftPt$2 = arguments[0];\n      var dirEdges = arguments[1];\n      var stabbedSegments$2 = arguments[2];\n      for (var i$2 = dirEdges.iterator(); i$2.hasNext();) {\n        var de = i$2.next();\n        if (!de.isForward()) { continue }\n        this$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);\n      }\n    }\n  }\n};\nSubgraphDepthLocater.prototype.getDepth = function getDepth (p) {\n  var stabbedSegments = this.findStabbedSegments(p);\n  if (stabbedSegments.size() === 0) { return 0 }\n  var ds = Collections.min(stabbedSegments);\n  return ds._leftDepth\n};\nSubgraphDepthLocater.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSubgraphDepthLocater.prototype.getClass = function getClass () {\n  return SubgraphDepthLocater\n};\nstaticAccessors$30.DepthSegment.get = function () { return DepthSegment };\n\nObject.defineProperties( SubgraphDepthLocater, staticAccessors$30 );\n\nvar DepthSegment = function DepthSegment () {\n  this._upwardSeg = null;\n  this._leftDepth = null;\n  var seg = arguments[0];\n  var depth = arguments[1];\n  this._upwardSeg = new LineSegment(seg);\n  this._leftDepth = depth;\n};\nDepthSegment.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) { return 1 }\n  if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) { return -1 }\n  var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n  if (orientIndex !== 0) { return orientIndex }\n  orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n  if (orientIndex !== 0) { return orientIndex }\n  return this._upwardSeg.compareTo(other._upwardSeg)\n};\nDepthSegment.prototype.compareX = function compareX (seg0, seg1) {\n  var compare0 = seg0.p0.compareTo(seg1.p0);\n  if (compare0 !== 0) { return compare0 }\n  return seg0.p1.compareTo(seg1.p1)\n};\nDepthSegment.prototype.toString = function toString () {\n  return this._upwardSeg.toString()\n};\nDepthSegment.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nDepthSegment.prototype.getClass = function getClass () {\n  return DepthSegment\n};\n\nvar Triangle = function Triangle (p0, p1, p2) {\n  this.p0 = p0 || null;\n  this.p1 = p1 || null;\n  this.p2 = p2 || null;\n};\nTriangle.prototype.area = function area () {\n  return Triangle.area(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.signedArea = function signedArea () {\n  return Triangle.signedArea(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.interpolateZ = function interpolateZ (p) {\n  if (p === null) { throw new IllegalArgumentException('Supplied point is null.') }\n  return Triangle.interpolateZ(p, this.p0, this.p1, this.p2)\n};\nTriangle.prototype.longestSideLength = function longestSideLength () {\n  return Triangle.longestSideLength(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.isAcute = function isAcute () {\n  return Triangle.isAcute(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.circumcentre = function circumcentre () {\n  return Triangle.circumcentre(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.area3D = function area3D () {\n  return Triangle.area3D(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.centroid = function centroid () {\n  return Triangle.centroid(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.inCentre = function inCentre () {\n  return Triangle.inCentre(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nTriangle.prototype.getClass = function getClass () {\n  return Triangle\n};\nTriangle.area = function area (a, b, c) {\n  return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)\n};\nTriangle.signedArea = function signedArea (a, b, c) {\n  return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2\n};\nTriangle.det = function det (m00, m01, m10, m11) {\n  return m00 * m11 - m01 * m10\n};\nTriangle.interpolateZ = function interpolateZ (p, v0, v1, v2) {\n  var x0 = v0.x;\n  var y0 = v0.y;\n  var a = v1.x - x0;\n  var b = v2.x - x0;\n  var c = v1.y - y0;\n  var d = v2.y - y0;\n  var det = a * d - b * c;\n  var dx = p.x - x0;\n  var dy = p.y - y0;\n  var t = (d * dx - b * dy) / det;\n  var u = (-c * dx + a * dy) / det;\n  var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n  return z\n};\nTriangle.longestSideLength = function longestSideLength (a, b, c) {\n  var lenAB = a.distance(b);\n  var lenBC = b.distance(c);\n  var lenCA = c.distance(a);\n  var maxLen = lenAB;\n  if (lenBC > maxLen) { maxLen = lenBC; }\n  if (lenCA > maxLen) { maxLen = lenCA; }\n  return maxLen\n};\nTriangle.isAcute = function isAcute (a, b, c) {\n  if (!Angle.isAcute(a, b, c)) { return false }\n  if (!Angle.isAcute(b, c, a)) { return false }\n  if (!Angle.isAcute(c, a, b)) { return false }\n  return true\n};\nTriangle.circumcentre = function circumcentre (a, b, c) {\n  var cx = c.x;\n  var cy = c.y;\n  var ax = a.x - cx;\n  var ay = a.y - cy;\n  var bx = b.x - cx;\n  var by = b.y - cy;\n  var denom = 2 * Triangle.det(ax, ay, bx, by);\n  var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n  var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n  var ccx = cx - numx / denom;\n  var ccy = cy + numy / denom;\n  return new Coordinate(ccx, ccy)\n};\nTriangle.perpendicularBisector = function perpendicularBisector (a, b) {\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n  var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n  return new HCoordinate(l1, l2)\n};\nTriangle.angleBisector = function angleBisector (a, b, c) {\n  var len0 = b.distance(a);\n  var len2 = b.distance(c);\n  var frac = len0 / (len0 + len2);\n  var dx = c.x - a.x;\n  var dy = c.y - a.y;\n  var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n  return splitPt\n};\nTriangle.area3D = function area3D (a, b, c) {\n  var ux = b.x - a.x;\n  var uy = b.y - a.y;\n  var uz = b.z - a.z;\n  var vx = c.x - a.x;\n  var vy = c.y - a.y;\n  var vz = c.z - a.z;\n  var crossx = uy * vz - uz * vy;\n  var crossy = uz * vx - ux * vz;\n  var crossz = ux * vy - uy * vx;\n  var absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n  var area3D = Math.sqrt(absSq) / 2;\n  return area3D\n};\nTriangle.centroid = function centroid (a, b, c) {\n  var x = (a.x + b.x + c.x) / 3;\n  var y = (a.y + b.y + c.y) / 3;\n  return new Coordinate(x, y)\n};\nTriangle.inCentre = function inCentre (a, b, c) {\n  var len0 = b.distance(c);\n  var len1 = a.distance(c);\n  var len2 = a.distance(b);\n  var circum = len0 + len1 + len2;\n  var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n  var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n  return new Coordinate(inCentreX, inCentreY)\n};\n\nvar OffsetCurveSetBuilder = function OffsetCurveSetBuilder () {\n  this._inputGeom = null;\n  this._distance = null;\n  this._curveBuilder = null;\n  this._curveList = new ArrayList();\n  var inputGeom = arguments[0];\n  var distance = arguments[1];\n  var curveBuilder = arguments[2];\n  this._inputGeom = inputGeom;\n  this._distance = distance;\n  this._curveBuilder = curveBuilder;\n};\nOffsetCurveSetBuilder.prototype.addPoint = function addPoint (p) {\n  if (this._distance <= 0.0) { return null }\n  var coord = p.getCoordinates();\n  var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n};\nOffsetCurveSetBuilder.prototype.addPolygon = function addPolygon (p) {\n    var this$1 = this;\n\n  var offsetDistance = this._distance;\n  var offsetSide = Position.LEFT;\n  if (this._distance < 0.0) {\n    offsetDistance = -this._distance;\n    offsetSide = Position.RIGHT;\n  }\n  var shell = p.getExteriorRing();\n  var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n  if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) { return null }\n  if (this._distance <= 0.0 && shellCoord.length < 3) { return null }\n  this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n  for (var i = 0; i < p.getNumInteriorRing(); i++) {\n    var hole = p.getInteriorRingN(i);\n    var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n    if (this$1._distance > 0.0 && this$1.isErodedCompletely(hole, -this$1._distance)) { continue }\n    this$1.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n  }\n};\nOffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely (triangleCoord, bufferDistance) {\n  var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n  var inCentre = tri.inCentre();\n  var distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);\n  return distToCentre < Math.abs(bufferDistance)\n};\nOffsetCurveSetBuilder.prototype.addLineString = function addLineString (line) {\n  if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) { return null }\n  var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n};\nOffsetCurveSetBuilder.prototype.addCurve = function addCurve (coord, leftLoc, rightLoc) {\n  if (coord === null || coord.length < 2) { return null }\n  var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n  this._curveList.add(e);\n};\nOffsetCurveSetBuilder.prototype.getCurves = function getCurves () {\n  this.add(this._inputGeom);\n  return this._curveList\n};\nOffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n  if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) { return null }\n  var leftLoc = cwLeftLoc;\n  var rightLoc = cwRightLoc;\n  if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {\n    leftLoc = cwRightLoc;\n    rightLoc = cwLeftLoc;\n    side = Position.opposite(side);\n  }\n  var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n  this.addCurve(curve, leftLoc, rightLoc);\n};\nOffsetCurveSetBuilder.prototype.add = function add (g) {\n  if (g.isEmpty()) { return null }\n  if (g instanceof Polygon) { this.addPolygon(g); }\n  else if (g instanceof LineString) { this.addLineString(g); }\n  else if (g instanceof Point) { this.addPoint(g); }\n  else if (g instanceof MultiPoint) { this.addCollection(g); }\n  else if (g instanceof MultiLineString) { this.addCollection(g); }\n  else if (g instanceof MultiPolygon) { this.addCollection(g); }\n  else if (g instanceof GeometryCollection) { this.addCollection(g); }\n  // else throw new UnsupportedOperationException(g.getClass().getName())\n};\nOffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely (ring, bufferDistance) {\n  var ringCoord = ring.getCoordinates();\n  // const minDiam = 0.0\n  if (ringCoord.length < 4) { return bufferDistance < 0 }\n  if (ringCoord.length === 4) { return this.isTriangleErodedCompletely(ringCoord, bufferDistance) }\n  var env = ring.getEnvelopeInternal();\n  var envMinDimension = Math.min(env.getHeight(), env.getWidth());\n  if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) { return true }\n  return false\n};\nOffsetCurveSetBuilder.prototype.addCollection = function addCollection (gc) {\n    var this$1 = this;\n\n  for (var i = 0; i < gc.getNumGeometries(); i++) {\n    var g = gc.getGeometryN(i);\n    this$1.add(g);\n  }\n};\nOffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetCurveSetBuilder.prototype.getClass = function getClass () {\n  return OffsetCurveSetBuilder\n};\n\nvar PointOnGeometryLocator = function PointOnGeometryLocator () {};\n\nPointOnGeometryLocator.prototype.locate = function locate (p) {};\nPointOnGeometryLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointOnGeometryLocator.prototype.getClass = function getClass () {\n  return PointOnGeometryLocator\n};\n\nvar GeometryCollectionIterator = function GeometryCollectionIterator () {\n  this._parent = null;\n  this._atStart = null;\n  this._max = null;\n  this._index = null;\n  this._subcollectionIterator = null;\n  var parent = arguments[0];\n  this._parent = parent;\n  this._atStart = true;\n  this._index = 0;\n  this._max = parent.getNumGeometries();\n};\nGeometryCollectionIterator.prototype.next = function next () {\n  if (this._atStart) {\n    this._atStart = false;\n    if (GeometryCollectionIterator.isAtomic(this._parent)) { this._index++; }\n    return this._parent\n  }\n  if (this._subcollectionIterator !== null) {\n    if (this._subcollectionIterator.hasNext()) {\n      return this._subcollectionIterator.next()\n    } else {\n      this._subcollectionIterator = null;\n    }\n  }\n  if (this._index >= this._max) {\n    throw new NoSuchElementException()\n  }\n  var obj = this._parent.getGeometryN(this._index++);\n  if (obj instanceof GeometryCollection) {\n    this._subcollectionIterator = new GeometryCollectionIterator(obj);\n    return this._subcollectionIterator.next()\n  }\n  return obj\n};\nGeometryCollectionIterator.prototype.remove = function remove () {\n  throw new Error(this.getClass().getName())\n};\nGeometryCollectionIterator.prototype.hasNext = function hasNext () {\n  if (this._atStart) {\n    return true\n  }\n  if (this._subcollectionIterator !== null) {\n    if (this._subcollectionIterator.hasNext()) {\n      return true\n    }\n    this._subcollectionIterator = null;\n  }\n  if (this._index >= this._max) {\n    return false\n  }\n  return true\n};\nGeometryCollectionIterator.prototype.interfaces_ = function interfaces_ () {\n  return [Iterator]\n};\nGeometryCollectionIterator.prototype.getClass = function getClass () {\n  return GeometryCollectionIterator\n};\nGeometryCollectionIterator.isAtomic = function isAtomic (geom) {\n  return !(geom instanceof GeometryCollection)\n};\n\nvar SimplePointInAreaLocator = function SimplePointInAreaLocator () {\n  this._geom = null;\n  var geom = arguments[0];\n  this._geom = geom;\n};\nSimplePointInAreaLocator.prototype.locate = function locate (p) {\n  return SimplePointInAreaLocator.locate(p, this._geom)\n};\nSimplePointInAreaLocator.prototype.interfaces_ = function interfaces_ () {\n  return [PointOnGeometryLocator]\n};\nSimplePointInAreaLocator.prototype.getClass = function getClass () {\n  return SimplePointInAreaLocator\n};\nSimplePointInAreaLocator.isPointInRing = function isPointInRing (p, ring) {\n  if (!ring.getEnvelopeInternal().intersects(p)) { return false }\n  return CGAlgorithms.isPointInRing(p, ring.getCoordinates())\n};\nSimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon (p, poly) {\n  if (poly.isEmpty()) { return false }\n  var shell = poly.getExteriorRing();\n  if (!SimplePointInAreaLocator.isPointInRing(p, shell)) { return false }\n  for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n    var hole = poly.getInteriorRingN(i);\n    if (SimplePointInAreaLocator.isPointInRing(p, hole)) { return false }\n  }\n  return true\n};\nSimplePointInAreaLocator.containsPoint = function containsPoint (p, geom) {\n  if (geom instanceof Polygon) {\n    return SimplePointInAreaLocator.containsPointInPolygon(p, geom)\n  } else if (geom instanceof GeometryCollection) {\n    var geomi = new GeometryCollectionIterator(geom);\n    while (geomi.hasNext()) {\n      var g2 = geomi.next();\n      if (g2 !== geom) { if (SimplePointInAreaLocator.containsPoint(p, g2)) { return true } }\n    }\n  }\n  return false\n};\nSimplePointInAreaLocator.locate = function locate (p, geom) {\n  if (geom.isEmpty()) { return Location.EXTERIOR }\n  if (SimplePointInAreaLocator.containsPoint(p, geom)) { return Location.INTERIOR }\n  return Location.EXTERIOR\n};\n\nvar EdgeEndStar = function EdgeEndStar () {\n  this._edgeMap = new TreeMap();\n  this._edgeList = null;\n  this._ptInAreaLocation = [Location.NONE, Location.NONE];\n};\nEdgeEndStar.prototype.getNextCW = function getNextCW (ee) {\n  this.getEdges();\n  var i = this._edgeList.indexOf(ee);\n  var iNextCW = i - 1;\n  if (i === 0) { iNextCW = this._edgeList.size() - 1; }\n  return this._edgeList.get(iNextCW)\n};\nEdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels (geomIndex) {\n  var startLoc = Location.NONE;\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) { startLoc = label.getLocation(geomIndex, Position.LEFT); }\n  }\n  if (startLoc === Location.NONE) { return null }\n  var currLoc = startLoc;\n  for (var it$1 = this.iterator(); it$1.hasNext();) {\n    var e$1 = it$1.next();\n    var label$1 = e$1.getLabel();\n    if (label$1.getLocation(geomIndex, Position.ON) === Location.NONE) { label$1.setLocation(geomIndex, Position.ON, currLoc); }\n    if (label$1.isArea(geomIndex)) {\n      var leftLoc = label$1.getLocation(geomIndex, Position.LEFT);\n      var rightLoc = label$1.getLocation(geomIndex, Position.RIGHT);\n      if (rightLoc !== Location.NONE) {\n        if (rightLoc !== currLoc) { throw new TopologyException('side location conflict', e$1.getCoordinate()) }\n        if (leftLoc === Location.NONE) {\n          Assert.shouldNeverReachHere('found single null side (at ' + e$1.getCoordinate() + ')');\n        }\n        currLoc = leftLoc;\n      } else {\n        Assert.isTrue(label$1.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side');\n        label$1.setLocation(geomIndex, Position.RIGHT, currLoc);\n        label$1.setLocation(geomIndex, Position.LEFT, currLoc);\n      }\n    }\n  }\n};\nEdgeEndStar.prototype.getCoordinate = function getCoordinate () {\n  var it = this.iterator();\n  if (!it.hasNext()) { return null }\n  var e = it.next();\n  return e.getCoordinate()\n};\nEdgeEndStar.prototype.print = function print (out) {\n  System.out.println('EdgeEndStar:   ' + this.getCoordinate());\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    e.print(out);\n  }\n};\nEdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent (geomGraph) {\n  this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n  return this.checkAreaLabelsConsistent(0)\n};\nEdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent (geomIndex) {\n  var edges = this.getEdges();\n  if (edges.size() <= 0) { return true }\n  var lastEdgeIndex = edges.size() - 1;\n  var startLabel = edges.get(lastEdgeIndex).getLabel();\n  var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n  Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');\n  var currLoc = startLoc;\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');\n    var leftLoc = label.getLocation(geomIndex, Position.LEFT);\n    var rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n    if (leftLoc === rightLoc) {\n      return false\n    }\n    if (rightLoc !== currLoc) {\n      return false\n    }\n    currLoc = leftLoc;\n  }\n  return true\n};\nEdgeEndStar.prototype.findIndex = function findIndex (eSearch) {\n    var this$1 = this;\n\n  this.iterator();\n  for (var i = 0; i < this._edgeList.size(); i++) {\n    var e = this$1._edgeList.get(i);\n    if (e === eSearch) { return i }\n  }\n  return -1\n};\nEdgeEndStar.prototype.iterator = function iterator () {\n  return this.getEdges().iterator()\n};\nEdgeEndStar.prototype.getEdges = function getEdges () {\n  if (this._edgeList === null) {\n    this._edgeList = new ArrayList(this._edgeMap.values());\n  }\n  return this._edgeList\n};\nEdgeEndStar.prototype.getLocation = function getLocation (geomIndex, p, geom) {\n  if (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n    this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n  }\n  return this._ptInAreaLocation[geomIndex]\n};\nEdgeEndStar.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  buf.append('EdgeEndStar:   ' + this.getCoordinate());\n  buf.append('\\n');\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    buf.append(e);\n    buf.append('\\n');\n  }\n  return buf.toString()\n};\nEdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels (boundaryNodeRule) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var ee = it.next();\n    ee.computeLabel(boundaryNodeRule);\n  }\n};\nEdgeEndStar.prototype.computeLabelling = function computeLabelling (geomGraph) {\n    var this$1 = this;\n\n  this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n  this.propagateSideLabels(0);\n  this.propagateSideLabels(1);\n  var hasDimensionalCollapseEdge = [false, false];\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    for (var geomi = 0; geomi < 2; geomi++) {\n      if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) { hasDimensionalCollapseEdge[geomi] = true; }\n    }\n  }\n  for (var it$1 = this.iterator(); it$1.hasNext();) {\n    var e$1 = it$1.next();\n    var label$1 = e$1.getLabel();\n    for (var geomi$1 = 0; geomi$1 < 2; geomi$1++) {\n      if (label$1.isAnyNull(geomi$1)) {\n        var loc = Location.NONE;\n        if (hasDimensionalCollapseEdge[geomi$1]) {\n          loc = Location.EXTERIOR;\n        } else {\n          var p = e$1.getCoordinate();\n          loc = this$1.getLocation(geomi$1, p, geomGraph);\n        }\n        label$1.setAllLocationsIfNull(geomi$1, loc);\n      }\n    }\n  }\n};\nEdgeEndStar.prototype.getDegree = function getDegree () {\n  return this._edgeMap.size()\n};\nEdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd (e, obj) {\n  this._edgeMap.put(e, obj);\n  this._edgeList = null;\n};\nEdgeEndStar.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeEndStar.prototype.getClass = function getClass () {\n  return EdgeEndStar\n};\n\nvar DirectedEdgeStar = (function (EdgeEndStar$$1) {\n  function DirectedEdgeStar () {\n    EdgeEndStar$$1.call(this);\n    this._resultAreaEdgeList = null;\n    this._label = null;\n    this._SCANNING_FOR_INCOMING = 1;\n    this._LINKING_TO_OUTGOING = 2;\n  }\n\n  if ( EdgeEndStar$$1 ) DirectedEdgeStar.__proto__ = EdgeEndStar$$1;\n  DirectedEdgeStar.prototype = Object.create( EdgeEndStar$$1 && EdgeEndStar$$1.prototype );\n  DirectedEdgeStar.prototype.constructor = DirectedEdgeStar;\n  DirectedEdgeStar.prototype.linkResultDirectedEdges = function linkResultDirectedEdges () {\n    var this$1 = this;\n\n    this.getResultAreaEdges();\n    var firstOut = null;\n    var incoming = null;\n    var state = this._SCANNING_FOR_INCOMING;\n    for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {\n      var nextOut = this$1._resultAreaEdgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (!nextOut.getLabel().isArea()) { continue }\n      if (firstOut === null && nextOut.isInResult()) { firstOut = nextOut; }\n      switch (state) {\n        case this$1._SCANNING_FOR_INCOMING:\n          if (!nextIn.isInResult()) { continue }\n          incoming = nextIn;\n          state = this$1._LINKING_TO_OUTGOING;\n          break\n        case this$1._LINKING_TO_OUTGOING:\n          if (!nextOut.isInResult()) { continue }\n          incoming.setNext(nextOut);\n          state = this$1._SCANNING_FOR_INCOMING;\n          break\n        default:\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      if (firstOut === null) { throw new TopologyException('no outgoing dirEdge found', this.getCoordinate()) }\n      Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');\n      incoming.setNext(firstOut);\n    }\n  };\n  DirectedEdgeStar.prototype.insert = function insert (ee) {\n    var de = ee;\n    this.insertEdgeEnd(de, de);\n  };\n  DirectedEdgeStar.prototype.getRightmostEdge = function getRightmostEdge () {\n    var edges = this.getEdges();\n    var size = edges.size();\n    if (size < 1) { return null }\n    var de0 = edges.get(0);\n    if (size === 1) { return de0 }\n    var deLast = edges.get(size - 1);\n    var quad0 = de0.getQuadrant();\n    var quad1 = deLast.getQuadrant();\n    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) { return de0; } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) { return deLast; } else {\n      // const nonHorizontalEdge = null\n      if (de0.getDy() !== 0) { return de0; } else if (deLast.getDy() !== 0) { return deLast }\n    }\n    Assert.shouldNeverReachHere('found two horizontal edges incident on node');\n    return null\n  };\n  DirectedEdgeStar.prototype.print = function print (out) {\n    System.out.println('DirectedEdgeStar: ' + this.getCoordinate());\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      out.print('out ');\n      de.print(out);\n      out.println();\n      out.print('in ');\n      de.getSym().print(out);\n      out.println();\n    }\n  };\n  DirectedEdgeStar.prototype.getResultAreaEdges = function getResultAreaEdges () {\n    var this$1 = this;\n\n    if (this._resultAreaEdgeList !== null) { return this._resultAreaEdgeList }\n    this._resultAreaEdgeList = new ArrayList();\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      if (de.isInResult() || de.getSym().isInResult()) { this$1._resultAreaEdgeList.add(de); }\n    }\n    return this._resultAreaEdgeList\n  };\n  DirectedEdgeStar.prototype.updateLabelling = function updateLabelling (nodeLabel) {\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n    }\n  };\n  DirectedEdgeStar.prototype.linkAllDirectedEdges = function linkAllDirectedEdges () {\n    var this$1 = this;\n\n    this.getEdges();\n    var prevOut = null;\n    var firstIn = null;\n    for (var i = this._edgeList.size() - 1; i >= 0; i--) {\n      var nextOut = this$1._edgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (firstIn === null) { firstIn = nextIn; }\n      if (prevOut !== null) { nextIn.setNext(prevOut); }\n      prevOut = nextOut;\n    }\n    firstIn.setNext(prevOut);\n  };\n  DirectedEdgeStar.prototype.computeDepths = function computeDepths () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var de = arguments[0];\n      var edgeIndex = this.findIndex(de);\n      // const label = de.getLabel()\n      var startDepth = de.getDepth(Position.LEFT);\n      var targetLastDepth = de.getDepth(Position.RIGHT);\n      var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n      var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n      if (lastDepth !== targetLastDepth) { throw new TopologyException('depth mismatch at ' + de.getCoordinate()) }\n    } else if (arguments.length === 3) {\n      var startIndex = arguments[0];\n      var endIndex = arguments[1];\n      var startDepth$1 = arguments[2];\n      var currDepth = startDepth$1;\n      for (var i = startIndex; i < endIndex; i++) {\n        var nextDe = this$1._edgeList.get(i);\n        // const label = nextDe.getLabel()\n        nextDe.setEdgeDepths(Position.RIGHT, currDepth);\n        currDepth = nextDe.getDepth(Position.LEFT);\n      }\n      return currDepth\n    }\n  };\n  DirectedEdgeStar.prototype.mergeSymLabels = function mergeSymLabels () {\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      label.merge(de.getSym().getLabel());\n    }\n  };\n  DirectedEdgeStar.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges (er) {\n    var this$1 = this;\n\n    var firstOut = null;\n    var incoming = null;\n    var state = this._SCANNING_FOR_INCOMING;\n    for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n      var nextOut = this$1._resultAreaEdgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (firstOut === null && nextOut.getEdgeRing() === er) { firstOut = nextOut; }\n      switch (state) {\n        case this$1._SCANNING_FOR_INCOMING:\n          if (nextIn.getEdgeRing() !== er) { continue }\n          incoming = nextIn;\n          state = this$1._LINKING_TO_OUTGOING;\n          break\n        case this$1._LINKING_TO_OUTGOING:\n          if (nextOut.getEdgeRing() !== er) { continue }\n          incoming.setNextMin(nextOut);\n          state = this$1._SCANNING_FOR_INCOMING;\n          break\n        default:\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');\n      Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');\n      incoming.setNextMin(firstOut);\n    }\n  };\n  DirectedEdgeStar.prototype.getOutgoingDegree = function getOutgoingDegree () {\n    if (arguments.length === 0) {\n      var degree = 0;\n      for (var it = this.iterator(); it.hasNext();) {\n        var de = it.next();\n        if (de.isInResult()) { degree++; }\n      }\n      return degree\n    } else if (arguments.length === 1) {\n      var er = arguments[0];\n      var degree$1 = 0;\n      for (var it$1 = this.iterator(); it$1.hasNext();) {\n        var de$1 = it$1.next();\n        if (de$1.getEdgeRing() === er) { degree$1++; }\n      }\n      return degree$1\n    }\n  };\n  DirectedEdgeStar.prototype.getLabel = function getLabel () {\n    return this._label\n  };\n  DirectedEdgeStar.prototype.findCoveredLineEdges = function findCoveredLineEdges () {\n    var startLoc = Location.NONE;\n    for (var it = this.iterator(); it.hasNext();) {\n      var nextOut = it.next();\n      var nextIn = nextOut.getSym();\n      if (!nextOut.isLineEdge()) {\n        if (nextOut.isInResult()) {\n          startLoc = Location.INTERIOR;\n          break\n        }\n        if (nextIn.isInResult()) {\n          startLoc = Location.EXTERIOR;\n          break\n        }\n      }\n    }\n    if (startLoc === Location.NONE) { return null }\n    var currLoc = startLoc;\n    for (var it$1 = this.iterator(); it$1.hasNext();) {\n      var nextOut$1 = it$1.next();\n      var nextIn$1 = nextOut$1.getSym();\n      if (nextOut$1.isLineEdge()) {\n        nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);\n      } else {\n        if (nextOut$1.isInResult()) { currLoc = Location.EXTERIOR; }\n        if (nextIn$1.isInResult()) { currLoc = Location.INTERIOR; }\n      }\n    }\n  };\n  DirectedEdgeStar.prototype.computeLabelling = function computeLabelling (geom) {\n    var this$1 = this;\n\n    EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);\n    this._label = new Label(Location.NONE);\n    for (var it = this.iterator(); it.hasNext();) {\n      var ee = it.next();\n      var e = ee.getEdge();\n      var eLabel = e.getLabel();\n      for (var i = 0; i < 2; i++) {\n        var eLoc = eLabel.getLocation(i);\n        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) { this$1._label.setLocation(i, Location.INTERIOR); }\n      }\n    }\n  };\n  DirectedEdgeStar.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  DirectedEdgeStar.prototype.getClass = function getClass () {\n    return DirectedEdgeStar\n  };\n\n  return DirectedEdgeStar;\n}(EdgeEndStar));\n\nvar OverlayNodeFactory = (function (NodeFactory$$1) {\n  function OverlayNodeFactory () {\n    NodeFactory$$1.apply(this, arguments);\n  }\n\n  if ( NodeFactory$$1 ) OverlayNodeFactory.__proto__ = NodeFactory$$1;\n  OverlayNodeFactory.prototype = Object.create( NodeFactory$$1 && NodeFactory$$1.prototype );\n  OverlayNodeFactory.prototype.constructor = OverlayNodeFactory;\n\n  OverlayNodeFactory.prototype.createNode = function createNode (coord) {\n    return new Node(coord, new DirectedEdgeStar())\n  };\n  OverlayNodeFactory.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  OverlayNodeFactory.prototype.getClass = function getClass () {\n    return OverlayNodeFactory\n  };\n\n  return OverlayNodeFactory;\n}(NodeFactory));\n\nvar OrientedCoordinateArray = function OrientedCoordinateArray () {\n  this._pts = null;\n  this._orientation = null;\n  var pts = arguments[0];\n  this._pts = pts;\n  this._orientation = OrientedCoordinateArray.orientation(pts);\n};\nOrientedCoordinateArray.prototype.compareTo = function compareTo (o1) {\n  var oca = o1;\n  var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n  return comp\n};\nOrientedCoordinateArray.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nOrientedCoordinateArray.prototype.getClass = function getClass () {\n  return OrientedCoordinateArray\n};\nOrientedCoordinateArray.orientation = function orientation (pts) {\n  return CoordinateArrays.increasingDirection(pts) === 1\n};\nOrientedCoordinateArray.compareOriented = function compareOriented (pts1, orientation1, pts2, orientation2) {\n  var dir1 = orientation1 ? 1 : -1;\n  var dir2 = orientation2 ? 1 : -1;\n  var limit1 = orientation1 ? pts1.length : -1;\n  var limit2 = orientation2 ? pts2.length : -1;\n  var i1 = orientation1 ? 0 : pts1.length - 1;\n  var i2 = orientation2 ? 0 : pts2.length - 1;\n  // const comp = 0\n  while (true) {\n    var compPt = pts1[i1].compareTo(pts2[i2]);\n    if (compPt !== 0) { return compPt }\n    i1 += dir1;\n    i2 += dir2;\n    var done1 = i1 === limit1;\n    var done2 = i2 === limit2;\n    if (done1 && !done2) { return -1 }\n    if (!done1 && done2) { return 1 }\n    if (done1 && done2) { return 0 }\n  }\n};\n\nvar EdgeList = function EdgeList () {\n  this._edges = new ArrayList();\n  this._ocaMap = new TreeMap();\n};\nEdgeList.prototype.print = function print (out) {\n    var this$1 = this;\n\n  out.print('MULTILINESTRING ( ');\n  for (var j = 0; j < this._edges.size(); j++) {\n    var e = this$1._edges.get(j);\n    if (j > 0) { out.print(','); }\n    out.print('(');\n    var pts = e.getCoordinates();\n    for (var i = 0; i < pts.length; i++) {\n      if (i > 0) { out.print(','); }\n      out.print(pts[i].x + ' ' + pts[i].y);\n    }\n    out.println(')');\n  }\n  out.print(')  ');\n};\nEdgeList.prototype.addAll = function addAll (edgeColl) {\n    var this$1 = this;\n\n  for (var i = edgeColl.iterator(); i.hasNext();) {\n    this$1.add(i.next());\n  }\n};\nEdgeList.prototype.findEdgeIndex = function findEdgeIndex (e) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    if (this$1._edges.get(i).equals(e)) { return i }\n  }\n  return -1\n};\nEdgeList.prototype.iterator = function iterator () {\n  return this._edges.iterator()\n};\nEdgeList.prototype.getEdges = function getEdges () {\n  return this._edges\n};\nEdgeList.prototype.get = function get (i) {\n  return this._edges.get(i)\n};\nEdgeList.prototype.findEqualEdge = function findEqualEdge (e) {\n  var oca = new OrientedCoordinateArray(e.getCoordinates());\n  var matchEdge = this._ocaMap.get(oca);\n  return matchEdge\n};\nEdgeList.prototype.add = function add (e) {\n  this._edges.add(e);\n  var oca = new OrientedCoordinateArray(e.getCoordinates());\n  this._ocaMap.put(oca, e);\n};\nEdgeList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeList.prototype.getClass = function getClass () {\n  return EdgeList\n};\n\nvar SegmentIntersector = function SegmentIntersector () {};\n\nSegmentIntersector.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {};\nSegmentIntersector.prototype.isDone = function isDone () {};\nSegmentIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentIntersector.prototype.getClass = function getClass () {\n  return SegmentIntersector\n};\n\nvar IntersectionAdder = function IntersectionAdder () {\n  this._hasIntersection = false;\n  this._hasProper = false;\n  this._hasProperInterior = false;\n  this._hasInterior = false;\n  this._properIntersectionPoint = null;\n  this._li = null;\n  this._isSelfIntersection = null;\n  this.numIntersections = 0;\n  this.numInteriorIntersections = 0;\n  this.numProperIntersections = 0;\n  this.numTests = 0;\n  var li = arguments[0];\n  this._li = li;\n};\nIntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1) {\n    if (this._li.getIntersectionNum() === 1) {\n      if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) { return true }\n      if (e0.isClosed()) {\n        var maxSegIndex = e0.size() - 1;\n        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||\n            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {\n          return true\n        }\n      }\n    }\n  }\n  return false\n};\nIntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint () {\n  return this._properIntersectionPoint\n};\nIntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection () {\n  return this._hasProperInterior\n};\nIntersectionAdder.prototype.getLineIntersector = function getLineIntersector () {\n  return this._li\n};\nIntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection () {\n  return this._hasProper\n};\nIntersectionAdder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  this.numTests++;\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    this.numIntersections++;\n    if (this._li.isInteriorIntersection()) {\n      this.numInteriorIntersections++;\n      this._hasInterior = true;\n    }\n    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n      this._hasIntersection = true;\n      e0.addIntersections(this._li, segIndex0, 0);\n      e1.addIntersections(this._li, segIndex1, 1);\n      if (this._li.isProper()) {\n        this.numProperIntersections++;\n        this._hasProper = true;\n        this._hasProperInterior = true;\n      }\n    }\n  }\n};\nIntersectionAdder.prototype.hasIntersection = function hasIntersection () {\n  return this._hasIntersection\n};\nIntersectionAdder.prototype.isDone = function isDone () {\n  return false\n};\nIntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection () {\n  return this._hasInterior\n};\nIntersectionAdder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nIntersectionAdder.prototype.getClass = function getClass () {\n  return IntersectionAdder\n};\nIntersectionAdder.isAdjacentSegments = function isAdjacentSegments (i1, i2) {\n  return Math.abs(i1 - i2) === 1\n};\n\nvar EdgeIntersection = function EdgeIntersection () {\n  this.coord = null;\n  this.segmentIndex = null;\n  this.dist = null;\n  var coord = arguments[0];\n  var segmentIndex = arguments[1];\n  var dist = arguments[2];\n  this.coord = new Coordinate(coord);\n  this.segmentIndex = segmentIndex;\n  this.dist = dist;\n};\nEdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex () {\n  return this.segmentIndex\n};\nEdgeIntersection.prototype.getCoordinate = function getCoordinate () {\n  return this.coord\n};\nEdgeIntersection.prototype.print = function print (out) {\n  out.print(this.coord);\n  out.print(' seg # = ' + this.segmentIndex);\n  out.println(' dist = ' + this.dist);\n};\nEdgeIntersection.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  return this.compare(other.segmentIndex, other.dist)\n};\nEdgeIntersection.prototype.isEndPoint = function isEndPoint (maxSegmentIndex) {\n  if (this.segmentIndex === 0 && this.dist === 0.0) { return true }\n  if (this.segmentIndex === maxSegmentIndex) { return true }\n  return false\n};\nEdgeIntersection.prototype.toString = function toString () {\n  return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist\n};\nEdgeIntersection.prototype.getDistance = function getDistance () {\n  return this.dist\n};\nEdgeIntersection.prototype.compare = function compare (segmentIndex, dist) {\n  if (this.segmentIndex < segmentIndex) { return -1 }\n  if (this.segmentIndex > segmentIndex) { return 1 }\n  if (this.dist < dist) { return -1 }\n  if (this.dist > dist) { return 1 }\n  return 0\n};\nEdgeIntersection.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nEdgeIntersection.prototype.getClass = function getClass () {\n  return EdgeIntersection\n};\n\nvar EdgeIntersectionList = function EdgeIntersectionList () {\n  this._nodeMap = new TreeMap();\n  this.edge = null;\n  var edge = arguments[0];\n  this.edge = edge;\n};\nEdgeIntersectionList.prototype.print = function print (out) {\n  out.println('Intersections:');\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    ei.print(out);\n  }\n};\nEdgeIntersectionList.prototype.iterator = function iterator () {\n  return this._nodeMap.values().iterator()\n};\nEdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges (edgeList) {\n    var this$1 = this;\n\n  this.addEndpoints();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var newEdge = this$1.createSplitEdge(eiPrev, ei);\n    edgeList.add(newEdge);\n    eiPrev = ei;\n  }\n};\nEdgeIntersectionList.prototype.addEndpoints = function addEndpoints () {\n  var maxSegIndex = this.edge.pts.length - 1;\n  this.add(this.edge.pts[0], 0, 0.0);\n  this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n};\nEdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge (ei0, ei1) {\n    var this$1 = this;\n\n  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  var lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n  var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n  if (!useIntPt1) {\n    npts--;\n  }\n  var pts = new Array(npts).fill(null);\n  var ipt = 0;\n  pts[ipt++] = new Coordinate(ei0.coord);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    pts[ipt++] = this$1.edge.pts[i];\n  }\n  if (useIntPt1) { pts[ipt] = ei1.coord; }\n  return new Edge(pts, new Label(this.edge._label))\n};\nEdgeIntersectionList.prototype.add = function add (intPt, segmentIndex, dist) {\n  var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n  var ei = this._nodeMap.get(eiNew);\n  if (ei !== null) {\n    return ei\n  }\n  this._nodeMap.put(eiNew, eiNew);\n  return eiNew\n};\nEdgeIntersectionList.prototype.isIntersection = function isIntersection (pt) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    if (ei.coord.equals(pt)) { return true }\n  }\n  return false\n};\nEdgeIntersectionList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeIntersectionList.prototype.getClass = function getClass () {\n  return EdgeIntersectionList\n};\n\nvar MonotoneChainIndexer = function MonotoneChainIndexer () {};\n\nMonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices (pts) {\n    var this$1 = this;\n\n  var start = 0;\n  var startIndexList = new ArrayList();\n  startIndexList.add(new Integer(start));\n  do {\n    var last = this$1.findChainEnd(pts, start);\n    startIndexList.add(new Integer(last));\n    start = last;\n  } while (start < pts.length - 1)\n  var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n  return startIndex\n};\nMonotoneChainIndexer.prototype.findChainEnd = function findChainEnd (pts, start) {\n  var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n  var last = start + 1;\n  while (last < pts.length) {\n    var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n    if (quad !== chainQuad) { break }\n    last++;\n  }\n  return last - 1\n};\nMonotoneChainIndexer.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainIndexer.prototype.getClass = function getClass () {\n  return MonotoneChainIndexer\n};\nMonotoneChainIndexer.toIntArray = function toIntArray (list) {\n  var array = new Array(list.size()).fill(null);\n  for (var i = 0; i < array.length; i++) {\n    array[i] = list.get(i).intValue();\n  }\n  return array\n};\n\nvar MonotoneChainEdge = function MonotoneChainEdge () {\n  this.e = null;\n  this.pts = null;\n  this.startIndex = null;\n  this.env1 = new Envelope();\n  this.env2 = new Envelope();\n  var e = arguments[0];\n  this.e = e;\n  this.pts = e.getCoordinates();\n  var mcb = new MonotoneChainIndexer();\n  this.startIndex = mcb.getChainStartIndices(this.pts);\n};\nMonotoneChainEdge.prototype.getCoordinates = function getCoordinates () {\n  return this.pts\n};\nMonotoneChainEdge.prototype.getMaxX = function getMaxX (chainIndex) {\n  var x1 = this.pts[this.startIndex[chainIndex]].x;\n  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  return x1 > x2 ? x1 : x2\n};\nMonotoneChainEdge.prototype.getMinX = function getMinX (chainIndex) {\n  var x1 = this.pts[this.startIndex[chainIndex]].x;\n  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  return x1 < x2 ? x1 : x2\n};\nMonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain () {\n  if (arguments.length === 4) {\n    var chainIndex0 = arguments[0];\n    var mce = arguments[1];\n    var chainIndex1 = arguments[2];\n    var si = arguments[3];\n    this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n  } else if (arguments.length === 6) {\n    var start0 = arguments[0];\n    var end0 = arguments[1];\n    var mce$1 = arguments[2];\n    var start1 = arguments[3];\n    var end1 = arguments[4];\n    var ei = arguments[5];\n    var p00 = this.pts[start0];\n    var p01 = this.pts[end0];\n    var p10 = mce$1.pts[start1];\n    var p11 = mce$1.pts[end1];\n    if (end0 - start0 === 1 && end1 - start1 === 1) {\n      ei.addIntersections(this.e, start0, mce$1.e, start1);\n      return null\n    }\n    this.env1.init(p00, p01);\n    this.env2.init(p10, p11);\n    if (!this.env1.intersects(this.env2)) { return null }\n    var mid0 = Math.trunc((start0 + end0) / 2);\n    var mid1 = Math.trunc((start1 + end1) / 2);\n    if (start0 < mid0) {\n      if (start1 < mid1) { this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei); }\n      if (mid1 < end1) { this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei); }\n    }\n    if (mid0 < end0) {\n      if (start1 < mid1) { this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei); }\n      if (mid1 < end1) { this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei); }\n    }\n  }\n};\nMonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes () {\n  return this.startIndex\n};\nMonotoneChainEdge.prototype.computeIntersects = function computeIntersects (mce, si) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.startIndex.length - 1; i++) {\n    for (var j = 0; j < mce.startIndex.length - 1; j++) {\n      this$1.computeIntersectsForChain(i, mce, j, si);\n    }\n  }\n};\nMonotoneChainEdge.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainEdge.prototype.getClass = function getClass () {\n  return MonotoneChainEdge\n};\n\nvar Depth = function Depth () {\n  var this$1 = this;\n\n  this._depth = Array(2).fill().map(function () { return Array(3); });\n  for (var i = 0; i < 2; i++) {\n    for (var j = 0; j < 3; j++) {\n      this$1._depth[i][j] = Depth.NULL_VALUE;\n    }\n  }\n};\n\nvar staticAccessors$31 = { NULL_VALUE: { configurable: true } };\nDepth.prototype.getDepth = function getDepth (geomIndex, posIndex) {\n  return this._depth[geomIndex][posIndex]\n};\nDepth.prototype.setDepth = function setDepth (geomIndex, posIndex, depthValue) {\n  this._depth[geomIndex][posIndex] = depthValue;\n};\nDepth.prototype.isNull = function isNull () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = 0; i < 2; i++) {\n      for (var j = 0; j < 3; j++) {\n        if (this$1._depth[i][j] !== Depth.NULL_VALUE) { return false }\n      }\n    }\n    return true\n  } else if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this._depth[geomIndex][1] === Depth.NULL_VALUE\n  } else if (arguments.length === 2) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE\n  }\n};\nDepth.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n  for (var i = 0; i < 2; i++) {\n    if (!this$1.isNull(i)) {\n      var minDepth = this$1._depth[i][1];\n      if (this$1._depth[i][2] < minDepth) { minDepth = this$1._depth[i][2]; }\n      if (minDepth < 0) { minDepth = 0; }\n      for (var j = 1; j < 3; j++) {\n        var newValue = 0;\n        if (this$1._depth[i][j] > minDepth) { newValue = 1; }\n        this$1._depth[i][j] = newValue;\n      }\n    }\n  }\n};\nDepth.prototype.getDelta = function getDelta (geomIndex) {\n  return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT]\n};\nDepth.prototype.getLocation = function getLocation (geomIndex, posIndex) {\n  if (this._depth[geomIndex][posIndex] <= 0) { return Location.EXTERIOR }\n  return Location.INTERIOR\n};\nDepth.prototype.toString = function toString () {\n  return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]\n};\nDepth.prototype.add = function add () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var lbl = arguments[0];\n    for (var i = 0; i < 2; i++) {\n      for (var j = 1; j < 3; j++) {\n        var loc = lbl.getLocation(i, j);\n        if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n          if (this$1.isNull(i, j)) {\n            this$1._depth[i][j] = Depth.depthAtLocation(loc);\n          } else { this$1._depth[i][j] += Depth.depthAtLocation(loc); }\n        }\n      }\n    }\n  } else if (arguments.length === 3) {\n    var geomIndex = arguments[0];\n    var posIndex = arguments[1];\n    var location = arguments[2];\n    if (location === Location.INTERIOR) { this._depth[geomIndex][posIndex]++; }\n  }\n};\nDepth.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDepth.prototype.getClass = function getClass () {\n  return Depth\n};\nDepth.depthAtLocation = function depthAtLocation (location) {\n  if (location === Location.EXTERIOR) { return 0 }\n  if (location === Location.INTERIOR) { return 1 }\n  return Depth.NULL_VALUE\n};\nstaticAccessors$31.NULL_VALUE.get = function () { return -1 };\n\nObject.defineProperties( Depth, staticAccessors$31 );\n\nvar Edge = (function (GraphComponent$$1) {\n  function Edge () {\n    GraphComponent$$1.call(this);\n    this.pts = null;\n    this._env = null;\n    this.eiList = new EdgeIntersectionList(this);\n    this._name = null;\n    this._mce = null;\n    this._isIsolated = true;\n    this._depth = new Depth();\n    this._depthDelta = 0;\n    if (arguments.length === 1) {\n      var pts = arguments[0];\n      Edge.call(this, pts, null);\n    } else if (arguments.length === 2) {\n      var pts$1 = arguments[0];\n      var label = arguments[1];\n      this.pts = pts$1;\n      this._label = label;\n    }\n  }\n\n  if ( GraphComponent$$1 ) Edge.__proto__ = GraphComponent$$1;\n  Edge.prototype = Object.create( GraphComponent$$1 && GraphComponent$$1.prototype );\n  Edge.prototype.constructor = Edge;\n  Edge.prototype.getDepth = function getDepth () {\n    return this._depth\n  };\n  Edge.prototype.getCollapsedEdge = function getCollapsedEdge () {\n    var newPts = new Array(2).fill(null);\n    newPts[0] = this.pts[0];\n    newPts[1] = this.pts[1];\n    var newe = new Edge(newPts, Label.toLineLabel(this._label));\n    return newe\n  };\n  Edge.prototype.isIsolated = function isIsolated () {\n    return this._isIsolated\n  };\n  Edge.prototype.getCoordinates = function getCoordinates () {\n    return this.pts\n  };\n  Edge.prototype.setIsolated = function setIsolated (isIsolated) {\n    this._isIsolated = isIsolated;\n  };\n  Edge.prototype.setName = function setName (name) {\n    this._name = name;\n  };\n  Edge.prototype.equals = function equals (o) {\n    var this$1 = this;\n\n    if (!(o instanceof Edge)) { return false }\n    var e = o;\n    if (this.pts.length !== e.pts.length) { return false }\n    var isEqualForward = true;\n    var isEqualReverse = true;\n    var iRev = this.pts.length;\n    for (var i = 0; i < this.pts.length; i++) {\n      if (!this$1.pts[i].equals2D(e.pts[i])) {\n        isEqualForward = false;\n      }\n      if (!this$1.pts[i].equals2D(e.pts[--iRev])) {\n        isEqualReverse = false;\n      }\n      if (!isEqualForward && !isEqualReverse) { return false }\n    }\n    return true\n  };\n  Edge.prototype.getCoordinate = function getCoordinate () {\n    if (arguments.length === 0) {\n      if (this.pts.length > 0) { return this.pts[0] }\n      return null\n    } else if (arguments.length === 1) {\n      var i = arguments[0];\n      return this.pts[i]\n    }\n  };\n  Edge.prototype.print = function print (out) {\n    var this$1 = this;\n\n    out.print('edge ' + this._name + ': ');\n    out.print('LINESTRING (');\n    for (var i = 0; i < this.pts.length; i++) {\n      if (i > 0) { out.print(','); }\n      out.print(this$1.pts[i].x + ' ' + this$1.pts[i].y);\n    }\n    out.print(')  ' + this._label + ' ' + this._depthDelta);\n  };\n  Edge.prototype.computeIM = function computeIM (im) {\n    Edge.updateIM(this._label, im);\n  };\n  Edge.prototype.isCollapsed = function isCollapsed () {\n    if (!this._label.isArea()) { return false }\n    if (this.pts.length !== 3) { return false }\n    if (this.pts[0].equals(this.pts[2])) { return true }\n    return false\n  };\n  Edge.prototype.isClosed = function isClosed () {\n    return this.pts[0].equals(this.pts[this.pts.length - 1])\n  };\n  Edge.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex () {\n    return this.pts.length - 1\n  };\n  Edge.prototype.getDepthDelta = function getDepthDelta () {\n    return this._depthDelta\n  };\n  Edge.prototype.getNumPoints = function getNumPoints () {\n    return this.pts.length\n  };\n  Edge.prototype.printReverse = function printReverse (out) {\n    var this$1 = this;\n\n    out.print('edge ' + this._name + ': ');\n    for (var i = this.pts.length - 1; i >= 0; i--) {\n      out.print(this$1.pts[i] + ' ');\n    }\n    out.println('');\n  };\n  Edge.prototype.getMonotoneChainEdge = function getMonotoneChainEdge () {\n    if (this._mce === null) { this._mce = new MonotoneChainEdge(this); }\n    return this._mce\n  };\n  Edge.prototype.getEnvelope = function getEnvelope () {\n    var this$1 = this;\n\n    if (this._env === null) {\n      this._env = new Envelope();\n      for (var i = 0; i < this.pts.length; i++) {\n        this$1._env.expandToInclude(this$1.pts[i]);\n      }\n    }\n    return this._env\n  };\n  Edge.prototype.addIntersection = function addIntersection (li, segmentIndex, geomIndex, intIndex) {\n    var intPt = new Coordinate(li.getIntersection(intIndex));\n    var normalizedSegmentIndex = segmentIndex;\n    var dist = li.getEdgeDistance(geomIndex, intIndex);\n    var nextSegIndex = normalizedSegmentIndex + 1;\n    if (nextSegIndex < this.pts.length) {\n      var nextPt = this.pts[nextSegIndex];\n      if (intPt.equals2D(nextPt)) {\n        normalizedSegmentIndex = nextSegIndex;\n        dist = 0.0;\n      }\n    }\n    this.eiList.add(intPt, normalizedSegmentIndex, dist);\n  };\n  Edge.prototype.toString = function toString () {\n    var this$1 = this;\n\n    var buf = new StringBuffer();\n    buf.append('edge ' + this._name + ': ');\n    buf.append('LINESTRING (');\n    for (var i = 0; i < this.pts.length; i++) {\n      if (i > 0) { buf.append(','); }\n      buf.append(this$1.pts[i].x + ' ' + this$1.pts[i].y);\n    }\n    buf.append(')  ' + this._label + ' ' + this._depthDelta);\n    return buf.toString()\n  };\n  Edge.prototype.isPointwiseEqual = function isPointwiseEqual (e) {\n    var this$1 = this;\n\n    if (this.pts.length !== e.pts.length) { return false }\n    for (var i = 0; i < this.pts.length; i++) {\n      if (!this$1.pts[i].equals2D(e.pts[i])) {\n        return false\n      }\n    }\n    return true\n  };\n  Edge.prototype.setDepthDelta = function setDepthDelta (depthDelta) {\n    this._depthDelta = depthDelta;\n  };\n  Edge.prototype.getEdgeIntersectionList = function getEdgeIntersectionList () {\n    return this.eiList\n  };\n  Edge.prototype.addIntersections = function addIntersections (li, segmentIndex, geomIndex) {\n    var this$1 = this;\n\n    for (var i = 0; i < li.getIntersectionNum(); i++) {\n      this$1.addIntersection(li, segmentIndex, geomIndex, i);\n    }\n  };\n  Edge.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  Edge.prototype.getClass = function getClass () {\n    return Edge\n  };\n  Edge.updateIM = function updateIM () {\n    if (arguments.length === 2) {\n      var label = arguments[0];\n      var im = arguments[1];\n      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n      if (label.isArea()) {\n        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n      }\n    } else { return GraphComponent$$1.prototype.updateIM.apply(this, arguments) }\n  };\n\n  return Edge;\n}(GraphComponent));\n\nvar BufferBuilder = function BufferBuilder (bufParams) {\n  this._workingPrecisionModel = null;\n  this._workingNoder = null;\n  this._geomFact = null;\n  this._graph = null;\n  this._edgeList = new EdgeList();\n  this._bufParams = bufParams || null;\n};\nBufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel (pm) {\n  this._workingPrecisionModel = pm;\n};\nBufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge (e) {\n  var existingEdge = this._edgeList.findEqualEdge(e);\n  if (existingEdge !== null) {\n    var existingLabel = existingEdge.getLabel();\n    var labelToMerge = e.getLabel();\n    if (!existingEdge.isPointwiseEqual(e)) {\n      labelToMerge = new Label(e.getLabel());\n      labelToMerge.flip();\n    }\n    existingLabel.merge(labelToMerge);\n    var mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n    var existingDelta = existingEdge.getDepthDelta();\n    var newDelta = existingDelta + mergeDelta;\n    existingEdge.setDepthDelta(newDelta);\n  } else {\n    this._edgeList.add(e);\n    e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n  }\n};\nBufferBuilder.prototype.buildSubgraphs = function buildSubgraphs (subgraphList, polyBuilder) {\n  var processedGraphs = new ArrayList();\n  for (var i = subgraphList.iterator(); i.hasNext();) {\n    var subgraph = i.next();\n    var p = subgraph.getRightmostCoordinate();\n    var locater = new SubgraphDepthLocater(processedGraphs);\n    var outsideDepth = locater.getDepth(p);\n    subgraph.computeDepth(outsideDepth);\n    subgraph.findResultEdges();\n    processedGraphs.add(subgraph);\n    polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n  }\n};\nBufferBuilder.prototype.createSubgraphs = function createSubgraphs (graph) {\n  var subgraphList = new ArrayList();\n  for (var i = graph.getNodes().iterator(); i.hasNext();) {\n    var node = i.next();\n    if (!node.isVisited()) {\n      var subgraph = new BufferSubgraph();\n      subgraph.create(node);\n      subgraphList.add(subgraph);\n    }\n  }\n  Collections.sort(subgraphList, Collections.reverseOrder());\n  return subgraphList\n};\nBufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry () {\n  var emptyGeom = this._geomFact.createPolygon();\n  return emptyGeom\n};\nBufferBuilder.prototype.getNoder = function getNoder (precisionModel) {\n  if (this._workingNoder !== null) { return this._workingNoder }\n  var noder = new MCIndexNoder();\n  var li = new RobustLineIntersector();\n  li.setPrecisionModel(precisionModel);\n  noder.setSegmentIntersector(new IntersectionAdder(li));\n  return noder\n};\nBufferBuilder.prototype.buffer = function buffer (g, distance) {\n  var precisionModel = this._workingPrecisionModel;\n  if (precisionModel === null) { precisionModel = g.getPrecisionModel(); }\n  this._geomFact = g.getFactory();\n  var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n  var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n  var bufferSegStrList = curveSetBuilder.getCurves();\n  if (bufferSegStrList.size() <= 0) {\n    return this.createEmptyResultGeometry()\n  }\n  this.computeNodedEdges(bufferSegStrList, precisionModel);\n  this._graph = new PlanarGraph(new OverlayNodeFactory());\n  this._graph.addEdges(this._edgeList.getEdges());\n  var subgraphList = this.createSubgraphs(this._graph);\n  var polyBuilder = new PolygonBuilder(this._geomFact);\n  this.buildSubgraphs(subgraphList, polyBuilder);\n  var resultPolyList = polyBuilder.getPolygons();\n  if (resultPolyList.size() <= 0) {\n    return this.createEmptyResultGeometry()\n  }\n  var resultGeom = this._geomFact.buildGeometry(resultPolyList);\n  return resultGeom\n};\nBufferBuilder.prototype.computeNodedEdges = function computeNodedEdges (bufferSegStrList, precisionModel) {\n    var this$1 = this;\n\n  var noder = this.getNoder(precisionModel);\n  noder.computeNodes(bufferSegStrList);\n  var nodedSegStrings = noder.getNodedSubstrings();\n  for (var i = nodedSegStrings.iterator(); i.hasNext();) {\n    var segStr = i.next();\n    var pts = segStr.getCoordinates();\n    if (pts.length === 2 && pts[0].equals2D(pts[1])) { continue }\n    var oldLabel = segStr.getData();\n    var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n    this$1.insertUniqueEdge(edge);\n  }\n};\nBufferBuilder.prototype.setNoder = function setNoder (noder) {\n  this._workingNoder = noder;\n};\nBufferBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferBuilder.prototype.getClass = function getClass () {\n  return BufferBuilder\n};\nBufferBuilder.depthDelta = function depthDelta (label) {\n  var lLoc = label.getLocation(0, Position.LEFT);\n  var rLoc = label.getLocation(0, Position.RIGHT);\n  if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) { return 1; } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) { return -1 }\n  return 0\n};\nBufferBuilder.convertSegStrings = function convertSegStrings (it) {\n  var fact = new GeometryFactory();\n  var lines = new ArrayList();\n  while (it.hasNext()) {\n    var ss = it.next();\n    var line = fact.createLineString(ss.getCoordinates());\n    lines.add(line);\n  }\n  return fact.buildGeometry(lines)\n};\n\nvar ScaledNoder = function ScaledNoder () {\n  this._noder = null;\n  this._scaleFactor = null;\n  this._offsetX = null;\n  this._offsetY = null;\n  this._isScaled = false;\n  if (arguments.length === 2) {\n    var noder = arguments[0];\n    var scaleFactor = arguments[1];\n    this._noder = noder;\n    this._scaleFactor = scaleFactor;\n    this._offsetX = 0.0;\n    this._offsetY = 0.0;\n    this._isScaled = !this.isIntegerPrecision();\n  } else if (arguments.length === 4) {\n    var noder$1 = arguments[0];\n    var scaleFactor$1 = arguments[1];\n    var offsetX = arguments[2];\n    var offsetY = arguments[3];\n    this._noder = noder$1;\n    this._scaleFactor = scaleFactor$1;\n    this._offsetX = offsetX;\n    this._offsetY = offsetY;\n    this._isScaled = !this.isIntegerPrecision();\n  }\n};\nScaledNoder.prototype.rescale = function rescale () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var segStrings = arguments[0];\n    for (var i = segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      this$1.rescale(ss.getCoordinates());\n    }\n  } else if (arguments[0] instanceof Array) {\n    var pts = arguments[0];\n    // let p0 = null\n    // let p1 = null\n    // if (pts.length === 2) {\n    // p0 = new Coordinate(pts[0])\n    // p1 = new Coordinate(pts[1])\n    // }\n    for (var i$1 = 0; i$1 < pts.length; i$1++) {\n      pts[i$1].x = pts[i$1].x / this$1._scaleFactor + this$1._offsetX;\n      pts[i$1].y = pts[i$1].y / this$1._scaleFactor + this$1._offsetY;\n    }\n    if (pts.length === 2 && pts[0].equals2D(pts[1])) {\n      System.out.println(pts);\n    }\n  }\n};\nScaledNoder.prototype.scale = function scale () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var segStrings = arguments[0];\n    var nodedSegmentStrings = new ArrayList();\n    for (var i = segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      nodedSegmentStrings.add(new NodedSegmentString(this$1.scale(ss.getCoordinates()), ss.getData()));\n    }\n    return nodedSegmentStrings\n  } else if (arguments[0] instanceof Array) {\n    var pts = arguments[0];\n    var roundPts = new Array(pts.length).fill(null);\n    for (var i$1 = 0; i$1 < pts.length; i$1++) {\n      roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1._offsetX) * this$1._scaleFactor), Math.round((pts[i$1].y - this$1._offsetY) * this$1._scaleFactor), pts[i$1].z);\n    }\n    var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n    return roundPtsNoDup\n  }\n};\nScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision () {\n  return this._scaleFactor === 1.0\n};\nScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n  var splitSS = this._noder.getNodedSubstrings();\n  if (this._isScaled) { this.rescale(splitSS); }\n  return splitSS\n};\nScaledNoder.prototype.computeNodes = function computeNodes (inputSegStrings) {\n  var intSegStrings = inputSegStrings;\n  if (this._isScaled) { intSegStrings = this.scale(inputSegStrings); }\n  this._noder.computeNodes(intSegStrings);\n};\nScaledNoder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nScaledNoder.prototype.getClass = function getClass () {\n  return ScaledNoder\n};\n\nvar NodingValidator = function NodingValidator () {\n  this._li = new RobustLineIntersector();\n  this._segStrings = null;\n  var segStrings = arguments[0];\n  this._segStrings = segStrings;\n};\n\nvar staticAccessors$33 = { fact: { configurable: true } };\nNodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      var pts = ss.getCoordinates();\n      this$1.checkEndPtVertexIntersections(pts[0], this$1._segStrings);\n      this$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1._segStrings);\n    }\n  } else if (arguments.length === 2) {\n    var testPt = arguments[0];\n    var segStrings = arguments[1];\n    for (var i$1 = segStrings.iterator(); i$1.hasNext();) {\n      var ss$1 = i$1.next();\n      var pts$1 = ss$1.getCoordinates();\n      for (var j = 1; j < pts$1.length - 1; j++) {\n        if (pts$1[j].equals(testPt)) { throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt) }\n      }\n    }\n  }\n};\nNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss0 = i.next();\n      for (var j = this._segStrings.iterator(); j.hasNext();) {\n        var ss1 = j.next();\n        this$1.checkInteriorIntersections(ss0, ss1);\n      }\n    }\n  } else if (arguments.length === 2) {\n    var ss0$1 = arguments[0];\n    var ss1$1 = arguments[1];\n    var pts0 = ss0$1.getCoordinates();\n    var pts1 = ss1$1.getCoordinates();\n    for (var i0 = 0; i0 < pts0.length - 1; i0++) {\n      for (var i1 = 0; i1 < pts1.length - 1; i1++) {\n        this$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);\n      }\n    }\n  } else if (arguments.length === 4) {\n    var e0 = arguments[0];\n    var segIndex0 = arguments[1];\n    var e1 = arguments[2];\n    var segIndex1 = arguments[3];\n    if (e0 === e1 && segIndex0 === segIndex1) { return null }\n    var p00 = e0.getCoordinates()[segIndex0];\n    var p01 = e0.getCoordinates()[segIndex0 + 1];\n    var p10 = e1.getCoordinates()[segIndex1];\n    var p11 = e1.getCoordinates()[segIndex1 + 1];\n    this._li.computeIntersection(p00, p01, p10, p11);\n    if (this._li.hasIntersection()) {\n      if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n        throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)\n      }\n    }\n  }\n};\nNodingValidator.prototype.checkValid = function checkValid () {\n  this.checkEndPtVertexIntersections();\n  this.checkInteriorIntersections();\n  this.checkCollapses();\n};\nNodingValidator.prototype.checkCollapses = function checkCollapses () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      this$1.checkCollapses(ss);\n    }\n  } else if (arguments.length === 1) {\n    var ss$1 = arguments[0];\n    var pts = ss$1.getCoordinates();\n    for (var i$1 = 0; i$1 < pts.length - 2; i$1++) {\n      this$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);\n    }\n  }\n};\nNodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection (li, p0, p1) {\n  for (var i = 0; i < li.getIntersectionNum(); i++) {\n    var intPt = li.getIntersection(i);\n    if (!(intPt.equals(p0) || intPt.equals(p1))) { return true }\n  }\n  return false\n};\nNodingValidator.prototype.checkCollapse = function checkCollapse (p0, p1, p2) {\n  if (p0.equals(p2)) { throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2])) }\n};\nNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodingValidator.prototype.getClass = function getClass () {\n  return NodingValidator\n};\nstaticAccessors$33.fact.get = function () { return new GeometryFactory() };\n\nObject.defineProperties( NodingValidator, staticAccessors$33 );\n\nvar HotPixel = function HotPixel () {\n  this._li = null;\n  this._pt = null;\n  this._originalPt = null;\n  this._ptScaled = null;\n  this._p0Scaled = null;\n  this._p1Scaled = null;\n  this._scaleFactor = null;\n  this._minx = null;\n  this._maxx = null;\n  this._miny = null;\n  this._maxy = null;\n  this._corner = new Array(4).fill(null);\n  this._safeEnv = null;\n  var pt = arguments[0];\n  var scaleFactor = arguments[1];\n  var li = arguments[2];\n  this._originalPt = pt;\n  this._pt = pt;\n  this._scaleFactor = scaleFactor;\n  this._li = li;\n  if (scaleFactor <= 0) { throw new IllegalArgumentException('Scale factor must be non-zero') }\n  if (scaleFactor !== 1.0) {\n    this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n    this._p0Scaled = new Coordinate();\n    this._p1Scaled = new Coordinate();\n  }\n  this.initCorners(this._pt);\n};\n\nvar staticAccessors$34 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };\nHotPixel.prototype.intersectsScaled = function intersectsScaled (p0, p1) {\n  var segMinx = Math.min(p0.x, p1.x);\n  var segMaxx = Math.max(p0.x, p1.x);\n  var segMiny = Math.min(p0.y, p1.y);\n  var segMaxy = Math.max(p0.y, p1.y);\n  var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n  if (isOutsidePixelEnv) { return false }\n  var intersects = this.intersectsToleranceSquare(p0, p1);\n  Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');\n  return intersects\n};\nHotPixel.prototype.initCorners = function initCorners (pt) {\n  var tolerance = 0.5;\n  this._minx = pt.x - tolerance;\n  this._maxx = pt.x + tolerance;\n  this._miny = pt.y - tolerance;\n  this._maxy = pt.y + tolerance;\n  this._corner[0] = new Coordinate(this._maxx, this._maxy);\n  this._corner[1] = new Coordinate(this._minx, this._maxy);\n  this._corner[2] = new Coordinate(this._minx, this._miny);\n  this._corner[3] = new Coordinate(this._maxx, this._miny);\n};\nHotPixel.prototype.intersects = function intersects (p0, p1) {\n  if (this._scaleFactor === 1.0) { return this.intersectsScaled(p0, p1) }\n  this.copyScaled(p0, this._p0Scaled);\n  this.copyScaled(p1, this._p1Scaled);\n  return this.intersectsScaled(this._p0Scaled, this._p1Scaled)\n};\nHotPixel.prototype.scale = function scale (val) {\n  return Math.round(val * this._scaleFactor)\n};\nHotPixel.prototype.getCoordinate = function getCoordinate () {\n  return this._originalPt\n};\nHotPixel.prototype.copyScaled = function copyScaled (p, pScaled) {\n  pScaled.x = this.scale(p.x);\n  pScaled.y = this.scale(p.y);\n};\nHotPixel.prototype.getSafeEnvelope = function getSafeEnvelope () {\n  if (this._safeEnv === null) {\n    var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n    this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n  }\n  return this._safeEnv\n};\nHotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure (p0, p1) {\n  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  if (this._li.hasIntersection()) { return true }\n  return false\n};\nHotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare (p0, p1) {\n  var intersectsLeft = false;\n  var intersectsBottom = false;\n  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  if (this._li.isProper()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  if (this._li.isProper()) { return true }\n  if (this._li.hasIntersection()) { intersectsLeft = true; }\n  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  if (this._li.isProper()) { return true }\n  if (this._li.hasIntersection()) { intersectsBottom = true; }\n  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  if (this._li.isProper()) { return true }\n  if (intersectsLeft && intersectsBottom) { return true }\n  if (p0.equals(this._pt)) { return true }\n  if (p1.equals(this._pt)) { return true }\n  return false\n};\nHotPixel.prototype.addSnappedNode = function addSnappedNode (segStr, segIndex) {\n  var p0 = segStr.getCoordinate(segIndex);\n  var p1 = segStr.getCoordinate(segIndex + 1);\n  if (this.intersects(p0, p1)) {\n    segStr.addIntersection(this.getCoordinate(), segIndex);\n    return true\n  }\n  return false\n};\nHotPixel.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nHotPixel.prototype.getClass = function getClass () {\n  return HotPixel\n};\nstaticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function () { return 0.75 };\n\nObject.defineProperties( HotPixel, staticAccessors$34 );\n\nvar MonotoneChainSelectAction = function MonotoneChainSelectAction () {\n  this.tempEnv1 = new Envelope();\n  this.selectedSegment = new LineSegment();\n};\nMonotoneChainSelectAction.prototype.select = function select () {\n  if (arguments.length === 1) {\n    // const seg = arguments[0]\n  } else if (arguments.length === 2) {\n    var mc = arguments[0];\n    var startIndex = arguments[1];\n    mc.getLineSegment(startIndex, this.selectedSegment);\n    this.select(this.selectedSegment);\n  }\n};\nMonotoneChainSelectAction.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainSelectAction.prototype.getClass = function getClass () {\n  return MonotoneChainSelectAction\n};\n\nvar MCIndexPointSnapper = function MCIndexPointSnapper () {\n  this._index = null;\n  var index = arguments[0];\n  this._index = index;\n};\n\nvar staticAccessors$35 = { HotPixelSnapAction: { configurable: true } };\nMCIndexPointSnapper.prototype.snap = function snap () {\n  if (arguments.length === 1) {\n    var hotPixel = arguments[0];\n    return this.snap(hotPixel, null, -1)\n  } else if (arguments.length === 3) {\n    var hotPixel$1 = arguments[0];\n    var parentEdge = arguments[1];\n    var hotPixelVertexIndex = arguments[2];\n    var pixelEnv = hotPixel$1.getSafeEnvelope();\n    var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);\n    this._index.query(pixelEnv, {\n      interfaces_: function () {\n        return [ItemVisitor]\n      },\n      visitItem: function (item) {\n        var testChain = item;\n        testChain.select(pixelEnv, hotPixelSnapAction);\n      }\n    });\n    return hotPixelSnapAction.isNodeAdded()\n  }\n};\nMCIndexPointSnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMCIndexPointSnapper.prototype.getClass = function getClass () {\n  return MCIndexPointSnapper\n};\nstaticAccessors$35.HotPixelSnapAction.get = function () { return HotPixelSnapAction };\n\nObject.defineProperties( MCIndexPointSnapper, staticAccessors$35 );\n\nvar HotPixelSnapAction = (function (MonotoneChainSelectAction$$1) {\n  function HotPixelSnapAction () {\n    MonotoneChainSelectAction$$1.call(this);\n    this._hotPixel = null;\n    this._parentEdge = null;\n    this._hotPixelVertexIndex = null;\n    this._isNodeAdded = false;\n    var hotPixel = arguments[0];\n    var parentEdge = arguments[1];\n    var hotPixelVertexIndex = arguments[2];\n    this._hotPixel = hotPixel;\n    this._parentEdge = parentEdge;\n    this._hotPixelVertexIndex = hotPixelVertexIndex;\n  }\n\n  if ( MonotoneChainSelectAction$$1 ) HotPixelSnapAction.__proto__ = MonotoneChainSelectAction$$1;\n  HotPixelSnapAction.prototype = Object.create( MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype );\n  HotPixelSnapAction.prototype.constructor = HotPixelSnapAction;\n  HotPixelSnapAction.prototype.isNodeAdded = function isNodeAdded () {\n    return this._isNodeAdded\n  };\n  HotPixelSnapAction.prototype.select = function select () {\n    if (arguments.length === 2) {\n      var mc = arguments[0];\n      var startIndex = arguments[1];\n      var ss = mc.getContext();\n      if (this._parentEdge !== null) {\n        if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) { return null }\n      }\n      this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n    } else { return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments) }\n  };\n  HotPixelSnapAction.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  HotPixelSnapAction.prototype.getClass = function getClass () {\n    return HotPixelSnapAction\n  };\n\n  return HotPixelSnapAction;\n}(MonotoneChainSelectAction));\n\nvar InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder () {\n  this._li = null;\n  this._interiorIntersections = null;\n  var li = arguments[0];\n  this._li = li;\n  this._interiorIntersections = new ArrayList();\n};\nInteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n    var this$1 = this;\n\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._li.isInteriorIntersection()) {\n      for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {\n        this$1._interiorIntersections.add(this$1._li.getIntersection(intIndex));\n      }\n      e0.addIntersections(this._li, segIndex0, 0);\n      e1.addIntersections(this._li, segIndex1, 1);\n    }\n  }\n};\nInteriorIntersectionFinderAdder.prototype.isDone = function isDone () {\n  return false\n};\nInteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections () {\n  return this._interiorIntersections\n};\nInteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nInteriorIntersectionFinderAdder.prototype.getClass = function getClass () {\n  return InteriorIntersectionFinderAdder\n};\n\nvar MCIndexSnapRounder = function MCIndexSnapRounder () {\n  this._pm = null;\n  this._li = null;\n  this._scaleFactor = null;\n  this._noder = null;\n  this._pointSnapper = null;\n  this._nodedSegStrings = null;\n  var pm = arguments[0];\n  this._pm = pm;\n  this._li = new RobustLineIntersector();\n  this._li.setPrecisionModel(pm);\n  this._scaleFactor = pm.getScale();\n};\nMCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness (inputSegmentStrings) {\n  var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n  var nv = new NodingValidator(resultSegStrings);\n  try {\n    nv.checkValid();\n  } catch (ex) {\n    if (ex instanceof Exception) {\n      ex.printStackTrace();\n    } else { throw ex }\n  } finally {}\n};\nMCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n  return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n};\nMCIndexSnapRounder.prototype.snapRound = function snapRound (segStrings, li) {\n  var intersections = this.findInteriorIntersections(segStrings, li);\n  this.computeIntersectionSnaps(intersections);\n  this.computeVertexSnaps(segStrings);\n};\nMCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections (segStrings, li) {\n  var intFinderAdder = new InteriorIntersectionFinderAdder(li);\n  this._noder.setSegmentIntersector(intFinderAdder);\n  this._noder.computeNodes(segStrings);\n  return intFinderAdder.getInteriorIntersections()\n};\nMCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var edges = arguments[0];\n    for (var i0 = edges.iterator(); i0.hasNext();) {\n      var edge0 = i0.next();\n      this$1.computeVertexSnaps(edge0);\n    }\n  } else if (arguments[0] instanceof NodedSegmentString) {\n    var e = arguments[0];\n    var pts0 = e.getCoordinates();\n    for (var i = 0; i < pts0.length; i++) {\n      var hotPixel = new HotPixel(pts0[i], this$1._scaleFactor, this$1._li);\n      var isNodeAdded = this$1._pointSnapper.snap(hotPixel, e, i);\n      if (isNodeAdded) {\n        e.addIntersection(pts0[i], i);\n      }\n    }\n  }\n};\nMCIndexSnapRounder.prototype.computeNodes = function computeNodes (inputSegmentStrings) {\n  this._nodedSegStrings = inputSegmentStrings;\n  this._noder = new MCIndexNoder();\n  this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n  this.snapRound(inputSegmentStrings, this._li);\n};\nMCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps (snapPts) {\n    var this$1 = this;\n\n  for (var it = snapPts.iterator(); it.hasNext();) {\n    var snapPt = it.next();\n    var hotPixel = new HotPixel(snapPt, this$1._scaleFactor, this$1._li);\n    this$1._pointSnapper.snap(hotPixel);\n  }\n};\nMCIndexSnapRounder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nMCIndexSnapRounder.prototype.getClass = function getClass () {\n  return MCIndexSnapRounder\n};\n\nvar BufferOp = function BufferOp () {\n  this._argGeom = null;\n  this._distance = null;\n  this._bufParams = new BufferParameters();\n  this._resultGeometry = null;\n  this._saveException = null;\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    this._argGeom = g;\n  } else if (arguments.length === 2) {\n    var g$1 = arguments[0];\n    var bufParams = arguments[1];\n    this._argGeom = g$1;\n    this._bufParams = bufParams;\n  }\n};\n\nvar staticAccessors$32 = { CAP_ROUND: { configurable: true },CAP_BUTT: { configurable: true },CAP_FLAT: { configurable: true },CAP_SQUARE: { configurable: true },MAX_PRECISION_DIGITS: { configurable: true } };\nBufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision (fixedPM) {\n  var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n  var bufBuilder = new BufferBuilder(this._bufParams);\n  bufBuilder.setWorkingPrecisionModel(fixedPM);\n  bufBuilder.setNoder(noder);\n  this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n};\nBufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n      try {\n        this$1.bufferReducedPrecision(precDigits);\n      } catch (ex) {\n        if (ex instanceof TopologyException) {\n          this$1._saveException = ex;\n        } else { throw ex }\n      } finally {}\n      if (this$1._resultGeometry !== null) { return null }\n    }\n    throw this._saveException\n  } else if (arguments.length === 1) {\n    var precisionDigits = arguments[0];\n    var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n    var fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n    this.bufferFixedPrecision(fixedPM);\n  }\n};\nBufferOp.prototype.computeGeometry = function computeGeometry () {\n  this.bufferOriginalPrecision();\n  if (this._resultGeometry !== null) { return null }\n  var argPM = this._argGeom.getFactory().getPrecisionModel();\n  if (argPM.getType() === PrecisionModel.FIXED) { this.bufferFixedPrecision(argPM); } else { this.bufferReducedPrecision(); }\n};\nBufferOp.prototype.setQuadrantSegments = function setQuadrantSegments (quadrantSegments) {\n  this._bufParams.setQuadrantSegments(quadrantSegments);\n};\nBufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision () {\n  try {\n    var bufBuilder = new BufferBuilder(this._bufParams);\n    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n  } catch (ex) {\n    if (ex instanceof RuntimeException) {\n      this._saveException = ex;\n    } else { throw ex }\n  } finally {}\n};\nBufferOp.prototype.getResultGeometry = function getResultGeometry (distance) {\n  this._distance = distance;\n  this.computeGeometry();\n  return this._resultGeometry\n};\nBufferOp.prototype.setEndCapStyle = function setEndCapStyle (endCapStyle) {\n  this._bufParams.setEndCapStyle(endCapStyle);\n};\nBufferOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferOp.prototype.getClass = function getClass () {\n  return BufferOp\n};\nBufferOp.bufferOp = function bufferOp () {\n  if (arguments.length === 2) {\n    var g = arguments[0];\n    var distance = arguments[1];\n    var gBuf = new BufferOp(g);\n    var geomBuf = gBuf.getResultGeometry(distance);\n    return geomBuf\n  } else if (arguments.length === 3) {\n    if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n      var g$1 = arguments[0];\n      var distance$1 = arguments[1];\n      var quadrantSegments = arguments[2];\n      var bufOp = new BufferOp(g$1);\n      bufOp.setQuadrantSegments(quadrantSegments);\n      var geomBuf$1 = bufOp.getResultGeometry(distance$1);\n      return geomBuf$1\n    } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n      var g$2 = arguments[0];\n      var distance$2 = arguments[1];\n      var params = arguments[2];\n      var bufOp$1 = new BufferOp(g$2, params);\n      var geomBuf$2 = bufOp$1.getResultGeometry(distance$2);\n      return geomBuf$2\n    }\n  } else if (arguments.length === 4) {\n    var g$3 = arguments[0];\n    var distance$3 = arguments[1];\n    var quadrantSegments$1 = arguments[2];\n    var endCapStyle = arguments[3];\n    var bufOp$2 = new BufferOp(g$3);\n    bufOp$2.setQuadrantSegments(quadrantSegments$1);\n    bufOp$2.setEndCapStyle(endCapStyle);\n    var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);\n    return geomBuf$3\n  }\n};\nBufferOp.precisionScaleFactor = function precisionScaleFactor (g, distance, maxPrecisionDigits) {\n  var env = g.getEnvelopeInternal();\n  var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n  var expandByDistance = distance > 0.0 ? distance : 0.0;\n  var bufEnvMax = envMax + 2 * expandByDistance;\n  var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n  var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n  var scaleFactor = Math.pow(10.0, minUnitLog10);\n  return scaleFactor\n};\nstaticAccessors$32.CAP_ROUND.get = function () { return BufferParameters.CAP_ROUND };\nstaticAccessors$32.CAP_BUTT.get = function () { return BufferParameters.CAP_FLAT };\nstaticAccessors$32.CAP_FLAT.get = function () { return BufferParameters.CAP_FLAT };\nstaticAccessors$32.CAP_SQUARE.get = function () { return BufferParameters.CAP_SQUARE };\nstaticAccessors$32.MAX_PRECISION_DIGITS.get = function () { return 12 };\n\nObject.defineProperties( BufferOp, staticAccessors$32 );\n\nvar PointPairDistance = function PointPairDistance () {\n  this._pt = [new Coordinate(), new Coordinate()];\n  this._distance = Double.NaN;\n  this._isNull = true;\n};\nPointPairDistance.prototype.getCoordinates = function getCoordinates () {\n  return this._pt\n};\nPointPairDistance.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pt[i]\n};\nPointPairDistance.prototype.setMinimum = function setMinimum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist < this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance.prototype.initialize = function initialize () {\n  if (arguments.length === 0) {\n    this._isNull = true;\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this._pt[0].setCoordinate(p0);\n    this._pt[1].setCoordinate(p1);\n    this._distance = p0.distance(p1);\n    this._isNull = false;\n  } else if (arguments.length === 3) {\n    var p0$1 = arguments[0];\n    var p1$1 = arguments[1];\n    var distance = arguments[2];\n    this._pt[0].setCoordinate(p0$1);\n    this._pt[1].setCoordinate(p1$1);\n    this._distance = distance;\n    this._isNull = false;\n  }\n};\nPointPairDistance.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nPointPairDistance.prototype.setMaximum = function setMaximum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist > this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointPairDistance.prototype.getClass = function getClass () {\n  return PointPairDistance\n};\n\nvar DistanceToPointFinder = function DistanceToPointFinder () {};\n\nDistanceToPointFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceToPointFinder.prototype.getClass = function getClass () {\n  return DistanceToPointFinder\n};\nDistanceToPointFinder.computeDistance = function computeDistance () {\n  if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {\n    var line = arguments[0];\n    var pt = arguments[1];\n    var ptDist = arguments[2];\n    var coords = line.getCoordinates();\n    var tempSegment = new LineSegment();\n    for (var i = 0; i < coords.length - 1; i++) {\n      tempSegment.setCoordinates(coords[i], coords[i + 1]);\n      var closestPt = tempSegment.closestPoint(pt);\n      ptDist.setMinimum(closestPt, pt);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {\n    var poly = arguments[0];\n    var pt$1 = arguments[1];\n    var ptDist$1 = arguments[2];\n    DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);\n    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {\n      DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {\n    var geom = arguments[0];\n    var pt$2 = arguments[1];\n    var ptDist$2 = arguments[2];\n    if (geom instanceof LineString) {\n      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof Polygon) {\n      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof GeometryCollection) {\n      var gc = geom;\n      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {\n        var g = gc.getGeometryN(i$2);\n        DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);\n      }\n    } else {\n      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {\n    var segment = arguments[0];\n    var pt$3 = arguments[1];\n    var ptDist$3 = arguments[2];\n    var closestPt$1 = segment.closestPoint(pt$3);\n    ptDist$3.setMinimum(closestPt$1, pt$3);\n  }\n};\n\nvar BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder (inputGeom) {\n  this._maxPtDist = new PointPairDistance();\n  this._inputGeom = inputGeom || null;\n};\n\nvar staticAccessors$36 = { MaxPointDistanceFilter: { configurable: true },MaxMidpointDistanceFilter: { configurable: true } };\nBufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance (curve) {\n  var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);\n  curve.apply(distFilter);\n  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());\n};\nBufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance (curve) {\n  var distFilter = new MaxPointDistanceFilter(this._inputGeom);\n  curve.apply(distFilter);\n  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());\n};\nBufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance (bufferCurve) {\n  this.computeMaxVertexDistance(bufferCurve);\n  this.computeMaxMidpointDistance(bufferCurve);\n  return this._maxPtDist.getDistance()\n};\nBufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints () {\n  return this._maxPtDist\n};\nBufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferCurveMaximumDistanceFinder.prototype.getClass = function getClass () {\n  return BufferCurveMaximumDistanceFinder\n};\nstaticAccessors$36.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter };\nstaticAccessors$36.MaxMidpointDistanceFilter.get = function () { return MaxMidpointDistanceFilter };\n\nObject.defineProperties( BufferCurveMaximumDistanceFinder, staticAccessors$36 );\n\nvar MaxPointDistanceFilter = function MaxPointDistanceFilter (geom) {\n  this._maxPtDist = new PointPairDistance();\n  this._minPtDist = new PointPairDistance();\n  this._geom = geom || null;\n};\nMaxPointDistanceFilter.prototype.filter = function filter (pt) {\n  this._minPtDist.initialize();\n  DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxPointDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nMaxPointDistanceFilter.prototype.getClass = function getClass () {\n  return MaxPointDistanceFilter\n};\n\nvar MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter (geom) {\n  this._maxPtDist = new PointPairDistance();\n  this._minPtDist = new PointPairDistance();\n  this._geom = geom || null;\n};\nMaxMidpointDistanceFilter.prototype.filter = function filter (seq, index) {\n  if (index === 0) { return null }\n  var p0 = seq.getCoordinate(index - 1);\n  var p1 = seq.getCoordinate(index);\n  var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n  this._minPtDist.initialize();\n  DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxMidpointDistanceFilter.prototype.isDone = function isDone () {\n  return false\n};\nMaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged () {\n  return false\n};\nMaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nMaxMidpointDistanceFilter.prototype.getClass = function getClass () {\n  return MaxMidpointDistanceFilter\n};\n\nvar PolygonExtracter = function PolygonExtracter (comps) {\n  this._comps = comps || null;\n};\nPolygonExtracter.prototype.filter = function filter (geom) {\n  if (geom instanceof Polygon) { this._comps.add(geom); }\n};\nPolygonExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPolygonExtracter.prototype.getClass = function getClass () {\n  return PolygonExtracter\n};\nPolygonExtracter.getPolygons = function getPolygons () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return PolygonExtracter.getPolygons(geom, new ArrayList())\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var list = arguments[1];\n    if (geom$1 instanceof Polygon) {\n      list.add(geom$1);\n    } else if (geom$1 instanceof GeometryCollection) {\n      geom$1.apply(new PolygonExtracter(list));\n    }\n    return list\n  }\n};\n\nvar LinearComponentExtracter = function LinearComponentExtracter () {\n  this._lines = null;\n  this._isForcedToLineString = false;\n  if (arguments.length === 1) {\n    var lines = arguments[0];\n    this._lines = lines;\n  } else if (arguments.length === 2) {\n    var lines$1 = arguments[0];\n    var isForcedToLineString = arguments[1];\n    this._lines = lines$1;\n    this._isForcedToLineString = isForcedToLineString;\n  }\n};\nLinearComponentExtracter.prototype.filter = function filter (geom) {\n  if (this._isForcedToLineString && geom instanceof LinearRing) {\n    var line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n    this._lines.add(line);\n    return null\n  }\n  if (geom instanceof LineString) { this._lines.add(geom); }\n};\nLinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString (isForcedToLineString) {\n  this._isForcedToLineString = isForcedToLineString;\n};\nLinearComponentExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryComponentFilter]\n};\nLinearComponentExtracter.prototype.getClass = function getClass () {\n  return LinearComponentExtracter\n};\nLinearComponentExtracter.getGeometry = function getGeometry () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom))\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var forceToLineString = arguments[1];\n    return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString))\n  }\n};\nLinearComponentExtracter.getLines = function getLines () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return LinearComponentExtracter.getLines(geom, false)\n  } else if (arguments.length === 2) {\n    if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n      var geoms = arguments[0];\n      var lines$1 = arguments[1];\n      for (var i = geoms.iterator(); i.hasNext();) {\n        var g = i.next();\n        LinearComponentExtracter.getLines(g, lines$1);\n      }\n      return lines$1\n    } else if (arguments[0] instanceof Geometry && typeof arguments[1] === 'boolean') {\n      var geom$1 = arguments[0];\n      var forceToLineString = arguments[1];\n      var lines = new ArrayList();\n      geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));\n      return lines\n    } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n      var geom$2 = arguments[0];\n      var lines$2 = arguments[1];\n      if (geom$2 instanceof LineString) {\n        lines$2.add(geom$2);\n      } else {\n        geom$2.apply(new LinearComponentExtracter(lines$2));\n      }\n      return lines$2\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {\n      var geoms$1 = arguments[0];\n      var lines$3 = arguments[1];\n      var forceToLineString$1 = arguments[2];\n      for (var i$1 = geoms$1.iterator(); i$1.hasNext();) {\n        var g$1 = i$1.next();\n        LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);\n      }\n      return lines$3\n    } else if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {\n      var geom$3 = arguments[0];\n      var lines$4 = arguments[1];\n      var forceToLineString$2 = arguments[2];\n      geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));\n      return lines$4\n    }\n  }\n};\n\nvar PointLocator = function PointLocator () {\n  this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n  this._isIn = null;\n  this._numBoundaries = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var boundaryRule = arguments[0];\n    if (boundaryRule === null) { throw new IllegalArgumentException('Rule must be non-null') }\n    this._boundaryRule = boundaryRule;\n  }\n};\nPointLocator.prototype.locateInternal = function locateInternal () {\n    var this$1 = this;\n\n  if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {\n    var p = arguments[0];\n    var poly = arguments[1];\n    if (poly.isEmpty()) { return Location.EXTERIOR }\n    var shell = poly.getExteriorRing();\n    var shellLoc = this.locateInPolygonRing(p, shell);\n    if (shellLoc === Location.EXTERIOR) { return Location.EXTERIOR }\n    if (shellLoc === Location.BOUNDARY) { return Location.BOUNDARY }\n    for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n      var hole = poly.getInteriorRingN(i);\n      var holeLoc = this$1.locateInPolygonRing(p, hole);\n      if (holeLoc === Location.INTERIOR) { return Location.EXTERIOR }\n      if (holeLoc === Location.BOUNDARY) { return Location.BOUNDARY }\n    }\n    return Location.INTERIOR\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {\n    var p$1 = arguments[0];\n    var l = arguments[1];\n    if (!l.getEnvelopeInternal().intersects(p$1)) { return Location.EXTERIOR }\n    var pt = l.getCoordinates();\n    if (!l.isClosed()) {\n      if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {\n        return Location.BOUNDARY\n      }\n    }\n    if (CGAlgorithms.isOnLine(p$1, pt)) { return Location.INTERIOR }\n    return Location.EXTERIOR\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {\n    var p$2 = arguments[0];\n    var pt$1 = arguments[1];\n    var ptCoord = pt$1.getCoordinate();\n    if (ptCoord.equals2D(p$2)) { return Location.INTERIOR }\n    return Location.EXTERIOR\n  }\n};\nPointLocator.prototype.locateInPolygonRing = function locateInPolygonRing (p, ring) {\n  if (!ring.getEnvelopeInternal().intersects(p)) { return Location.EXTERIOR }\n  return CGAlgorithms.locatePointInRing(p, ring.getCoordinates())\n};\nPointLocator.prototype.intersects = function intersects (p, geom) {\n  return this.locate(p, geom) !== Location.EXTERIOR\n};\nPointLocator.prototype.updateLocationInfo = function updateLocationInfo (loc) {\n  if (loc === Location.INTERIOR) { this._isIn = true; }\n  if (loc === Location.BOUNDARY) { this._numBoundaries++; }\n};\nPointLocator.prototype.computeLocation = function computeLocation (p, geom) {\n    var this$1 = this;\n\n  if (geom instanceof Point) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  }\n  if (geom instanceof LineString) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  } else if (geom instanceof Polygon) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  } else if (geom instanceof MultiLineString) {\n    var ml = geom;\n    for (var i = 0; i < ml.getNumGeometries(); i++) {\n      var l = ml.getGeometryN(i);\n      this$1.updateLocationInfo(this$1.locateInternal(p, l));\n    }\n  } else if (geom instanceof MultiPolygon) {\n    var mpoly = geom;\n    for (var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++) {\n      var poly = mpoly.getGeometryN(i$1);\n      this$1.updateLocationInfo(this$1.locateInternal(p, poly));\n    }\n  } else if (geom instanceof GeometryCollection) {\n    var geomi = new GeometryCollectionIterator(geom);\n    while (geomi.hasNext()) {\n      var g2 = geomi.next();\n      if (g2 !== geom) { this$1.computeLocation(p, g2); }\n    }\n  }\n};\nPointLocator.prototype.locate = function locate (p, geom) {\n  if (geom.isEmpty()) { return Location.EXTERIOR }\n  if (geom instanceof LineString) {\n    return this.locateInternal(p, geom)\n  } else if (geom instanceof Polygon) {\n    return this.locateInternal(p, geom)\n  }\n  this._isIn = false;\n  this._numBoundaries = 0;\n  this.computeLocation(p, geom);\n  if (this._boundaryRule.isInBoundary(this._numBoundaries)) { return Location.BOUNDARY }\n  if (this._numBoundaries > 0 || this._isIn) { return Location.INTERIOR }\n  return Location.EXTERIOR\n};\nPointLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointLocator.prototype.getClass = function getClass () {\n  return PointLocator\n};\n\nvar GeometryLocation = function GeometryLocation () {\n  this._component = null;\n  this._segIndex = null;\n  this._pt = null;\n  if (arguments.length === 2) {\n    var component = arguments[0];\n    var pt = arguments[1];\n    GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n  } else if (arguments.length === 3) {\n    var component$1 = arguments[0];\n    var segIndex = arguments[1];\n    var pt$1 = arguments[2];\n    this._component = component$1;\n    this._segIndex = segIndex;\n    this._pt = pt$1;\n  }\n};\n\nvar staticAccessors$38 = { INSIDE_AREA: { configurable: true } };\nGeometryLocation.prototype.isInsideArea = function isInsideArea () {\n  return this._segIndex === GeometryLocation.INSIDE_AREA\n};\nGeometryLocation.prototype.getCoordinate = function getCoordinate () {\n  return this._pt\n};\nGeometryLocation.prototype.getGeometryComponent = function getGeometryComponent () {\n  return this._component\n};\nGeometryLocation.prototype.getSegmentIndex = function getSegmentIndex () {\n  return this._segIndex\n};\nGeometryLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryLocation.prototype.getClass = function getClass () {\n  return GeometryLocation\n};\nstaticAccessors$38.INSIDE_AREA.get = function () { return -1 };\n\nObject.defineProperties( GeometryLocation, staticAccessors$38 );\n\nvar PointExtracter = function PointExtracter (pts) {\n  this._pts = pts || null;\n};\nPointExtracter.prototype.filter = function filter (geom) {\n  if (geom instanceof Point) { this._pts.add(geom); }\n};\nPointExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPointExtracter.prototype.getClass = function getClass () {\n  return PointExtracter\n};\nPointExtracter.getPoints = function getPoints () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    if (geom instanceof Point) {\n      return Collections.singletonList(geom)\n    }\n    return PointExtracter.getPoints(geom, new ArrayList())\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var list = arguments[1];\n    if (geom$1 instanceof Point) {\n      list.add(geom$1);\n    } else if (geom$1 instanceof GeometryCollection) {\n      geom$1.apply(new PointExtracter(list));\n    }\n    return list\n  }\n};\n\nvar ConnectedElementLocationFilter = function ConnectedElementLocationFilter () {\n  this._locations = null;\n  var locations = arguments[0];\n  this._locations = locations;\n};\nConnectedElementLocationFilter.prototype.filter = function filter (geom) {\n  if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) { this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate())); }\n};\nConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nConnectedElementLocationFilter.prototype.getClass = function getClass () {\n  return ConnectedElementLocationFilter\n};\nConnectedElementLocationFilter.getLocations = function getLocations (geom) {\n  var locations = new ArrayList();\n  geom.apply(new ConnectedElementLocationFilter(locations));\n  return locations\n};\n\nvar DistanceOp = function DistanceOp () {\n  this._geom = null;\n  this._terminateDistance = 0.0;\n  this._ptLocator = new PointLocator();\n  this._minDistanceLocation = null;\n  this._minDistance = Double.MAX_VALUE;\n  if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    this._geom = [g0, g1];\n    this._terminateDistance = 0.0;\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var terminateDistance = arguments[2];\n    this._geom = new Array(2).fill(null);\n    this._geom[0] = g0$1;\n    this._geom[1] = g1$1;\n    this._terminateDistance = terminateDistance;\n  }\n};\nDistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    var locPtPoly = new Array(2).fill(null);\n    this.computeContainmentDistance(0, locPtPoly);\n    if (this._minDistance <= this._terminateDistance) { return null }\n    this.computeContainmentDistance(1, locPtPoly);\n  } else if (arguments.length === 2) {\n    var polyGeomIndex = arguments[0];\n    var locPtPoly$1 = arguments[1];\n    var locationsIndex = 1 - polyGeomIndex;\n    var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);\n    if (polys.size() > 0) {\n      var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n      this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);\n      if (this._minDistance <= this._terminateDistance) {\n        this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];\n        this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];\n        return null\n      }\n    }\n  } else if (arguments.length === 3) {\n    if (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n      var locs = arguments[0];\n      var polys$1 = arguments[1];\n      var locPtPoly$2 = arguments[2];\n      for (var i = 0; i < locs.size(); i++) {\n        var loc = locs.get(i);\n        for (var j = 0; j < polys$1.size(); j++) {\n          this$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);\n          if (this$1._minDistance <= this$1._terminateDistance) { return null }\n        }\n      }\n    } else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon)) {\n      var ptLoc = arguments[0];\n      var poly = arguments[1];\n      var locPtPoly$3 = arguments[2];\n      var pt = ptLoc.getCoordinate();\n      if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n        this._minDistance = 0.0;\n        locPtPoly$3[0] = ptLoc;\n        locPtPoly$3[1] = new GeometryLocation(poly, pt);\n\n        return null\n      }\n    }\n  }\n};\nDistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints (lines, points, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < lines.size(); i++) {\n    var line = lines.get(i);\n    for (var j = 0; j < points.size(); j++) {\n      var pt = points.get(j);\n      this$1.computeMinDistance(line, pt, locGeom);\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.computeFacetDistance = function computeFacetDistance () {\n  var locGeom = new Array(2).fill(null);\n  var lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n  var lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n  var pts0 = PointExtracter.getPoints(this._geom[0]);\n  var pts1 = PointExtracter.getPoints(this._geom[1]);\n  this.computeMinDistanceLines(lines0, lines1, locGeom);\n  this.updateMinDistance(locGeom, false);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n  this.updateMinDistance(locGeom, false);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n  this.updateMinDistance(locGeom, true);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistancePoints(pts0, pts1, locGeom);\n  this.updateMinDistance(locGeom, false);\n};\nDistanceOp.prototype.nearestLocations = function nearestLocations () {\n  this.computeMinDistance();\n  return this._minDistanceLocation\n};\nDistanceOp.prototype.updateMinDistance = function updateMinDistance (locGeom, flip) {\n  if (locGeom[0] === null) { return null }\n  if (flip) {\n    this._minDistanceLocation[0] = locGeom[1];\n    this._minDistanceLocation[1] = locGeom[0];\n  } else {\n    this._minDistanceLocation[0] = locGeom[0];\n    this._minDistanceLocation[1] = locGeom[1];\n  }\n};\nDistanceOp.prototype.nearestPoints = function nearestPoints () {\n  this.computeMinDistance();\n  var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n  return nearestPts\n};\nDistanceOp.prototype.computeMinDistance = function computeMinDistance () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this._minDistanceLocation !== null) { return null }\n    this._minDistanceLocation = new Array(2).fill(null);\n    this.computeContainmentDistance();\n    if (this._minDistance <= this._terminateDistance) { return null }\n    this.computeFacetDistance();\n  } else if (arguments.length === 3) {\n    if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof Point)) {\n      var line = arguments[0];\n      var pt = arguments[1];\n      var locGeom = arguments[2];\n      if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) { return null }\n      var coord0 = line.getCoordinates();\n      var coord = pt.getCoordinate();\n      for (var i = 0; i < coord0.length - 1; i++) {\n        var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);\n        if (dist < this$1._minDistance) {\n          this$1._minDistance = dist;\n          var seg = new LineSegment(coord0[i], coord0[i + 1]);\n          var segClosestPoint = seg.closestPoint(coord);\n          locGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n          locGeom[1] = new GeometryLocation(pt, 0, coord);\n        }\n        if (this$1._minDistance <= this$1._terminateDistance) { return null }\n      }\n    } else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof LineString)) {\n      var line0 = arguments[0];\n      var line1 = arguments[1];\n      var locGeom$1 = arguments[2];\n      if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) { return null }\n      var coord0$1 = line0.getCoordinates();\n      var coord1 = line1.getCoordinates();\n      for (var i$1 = 0; i$1 < coord0$1.length - 1; i$1++) {\n        for (var j = 0; j < coord1.length - 1; j++) {\n          var dist$1 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);\n          if (dist$1 < this$1._minDistance) {\n            this$1._minDistance = dist$1;\n            var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);\n            var seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n            var closestPt = seg0.closestPoints(seg1);\n            locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);\n            locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);\n          }\n          if (this$1._minDistance <= this$1._terminateDistance) { return null }\n        }\n      }\n    }\n  }\n};\nDistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints (points0, points1, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < points0.size(); i++) {\n    var pt0 = points0.get(i);\n    for (var j = 0; j < points1.size(); j++) {\n      var pt1 = points1.get(j);\n      var dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n      if (dist < this$1._minDistance) {\n        this$1._minDistance = dist;\n        locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n        locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n      }\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.distance = function distance () {\n  if (this._geom[0] === null || this._geom[1] === null) { throw new IllegalArgumentException('null geometries are not supported') }\n  if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) { return 0.0 }\n  this.computeMinDistance();\n  return this._minDistance\n};\nDistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines (lines0, lines1, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < lines0.size(); i++) {\n    var line0 = lines0.get(i);\n    for (var j = 0; j < lines1.size(); j++) {\n      var line1 = lines1.get(j);\n      this$1.computeMinDistance(line0, line1, locGeom);\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceOp.prototype.getClass = function getClass () {\n  return DistanceOp\n};\nDistanceOp.distance = function distance (g0, g1) {\n  var distOp = new DistanceOp(g0, g1);\n  return distOp.distance()\n};\nDistanceOp.isWithinDistance = function isWithinDistance (g0, g1, distance) {\n  var distOp = new DistanceOp(g0, g1, distance);\n  return distOp.distance() <= distance\n};\nDistanceOp.nearestPoints = function nearestPoints (g0, g1) {\n  var distOp = new DistanceOp(g0, g1);\n  return distOp.nearestPoints()\n};\n\nvar PointPairDistance$2 = function PointPairDistance () {\n  this._pt = [new Coordinate(), new Coordinate()];\n  this._distance = Double.NaN;\n  this._isNull = true;\n};\nPointPairDistance$2.prototype.getCoordinates = function getCoordinates () {\n  return this._pt\n};\nPointPairDistance$2.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pt[i]\n};\nPointPairDistance$2.prototype.setMinimum = function setMinimum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist < this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance$2.prototype.initialize = function initialize () {\n  if (arguments.length === 0) {\n    this._isNull = true;\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this._pt[0].setCoordinate(p0);\n    this._pt[1].setCoordinate(p1);\n    this._distance = p0.distance(p1);\n    this._isNull = false;\n  } else if (arguments.length === 3) {\n    var p0$1 = arguments[0];\n    var p1$1 = arguments[1];\n    var distance = arguments[2];\n    this._pt[0].setCoordinate(p0$1);\n    this._pt[1].setCoordinate(p1$1);\n    this._distance = distance;\n    this._isNull = false;\n  }\n};\nPointPairDistance$2.prototype.toString = function toString () {\n  return WKTWriter.toLineString(this._pt[0], this._pt[1])\n};\nPointPairDistance$2.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nPointPairDistance$2.prototype.setMaximum = function setMaximum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist > this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointPairDistance$2.prototype.getClass = function getClass () {\n  return PointPairDistance$2\n};\n\nvar DistanceToPoint = function DistanceToPoint () {};\n\nDistanceToPoint.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceToPoint.prototype.getClass = function getClass () {\n  return DistanceToPoint\n};\nDistanceToPoint.computeDistance = function computeDistance () {\n  if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {\n    var line = arguments[0];\n    var pt = arguments[1];\n    var ptDist = arguments[2];\n    var tempSegment = new LineSegment();\n    var coords = line.getCoordinates();\n    for (var i = 0; i < coords.length - 1; i++) {\n      tempSegment.setCoordinates(coords[i], coords[i + 1]);\n      var closestPt = tempSegment.closestPoint(pt);\n      ptDist.setMinimum(closestPt, pt);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {\n    var poly = arguments[0];\n    var pt$1 = arguments[1];\n    var ptDist$1 = arguments[2];\n    DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);\n    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {\n      DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {\n    var geom = arguments[0];\n    var pt$2 = arguments[1];\n    var ptDist$2 = arguments[2];\n    if (geom instanceof LineString) {\n      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof Polygon) {\n      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof GeometryCollection) {\n      var gc = geom;\n      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {\n        var g = gc.getGeometryN(i$2);\n        DistanceToPoint.computeDistance(g, pt$2, ptDist$2);\n      }\n    } else {\n      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {\n    var segment = arguments[0];\n    var pt$3 = arguments[1];\n    var ptDist$3 = arguments[2];\n    var closestPt$1 = segment.closestPoint(pt$3);\n    ptDist$3.setMinimum(closestPt$1, pt$3);\n  }\n};\n\nvar DiscreteHausdorffDistance = function DiscreteHausdorffDistance () {\n  this._g0 = null;\n  this._g1 = null;\n  this._ptDist = new PointPairDistance$2();\n  this._densifyFrac = 0.0;\n  var g0 = arguments[0];\n  var g1 = arguments[1];\n  this._g0 = g0;\n  this._g1 = g1;\n};\n\nvar staticAccessors$39 = { MaxPointDistanceFilter: { configurable: true },MaxDensifiedByFractionDistanceFilter: { configurable: true } };\nDiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates () {\n  return this._ptDist.getCoordinates()\n};\nDiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction (densifyFrac) {\n  if (densifyFrac > 1.0 || densifyFrac <= 0.0) { throw new IllegalArgumentException('Fraction is not in range (0.0 - 1.0]') }\n  this._densifyFrac = densifyFrac;\n};\nDiscreteHausdorffDistance.prototype.compute = function compute (g0, g1) {\n  this.computeOrientedDistance(g0, g1, this._ptDist);\n  this.computeOrientedDistance(g1, g0, this._ptDist);\n};\nDiscreteHausdorffDistance.prototype.distance = function distance () {\n  this.compute(this._g0, this._g1);\n  return this._ptDist.getDistance()\n};\nDiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance (discreteGeom, geom, ptDist) {\n  var distFilter = new MaxPointDistanceFilter$1(geom);\n  discreteGeom.apply(distFilter);\n  ptDist.setMaximum(distFilter.getMaxPointDistance());\n  if (this._densifyFrac > 0) {\n    var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);\n    discreteGeom.apply(fracFilter);\n    ptDist.setMaximum(fracFilter.getMaxPointDistance());\n  }\n};\nDiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance () {\n  this.computeOrientedDistance(this._g0, this._g1, this._ptDist);\n  return this._ptDist.getDistance()\n};\nDiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDiscreteHausdorffDistance.prototype.getClass = function getClass () {\n  return DiscreteHausdorffDistance\n};\nDiscreteHausdorffDistance.distance = function distance () {\n  if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var dist = new DiscreteHausdorffDistance(g0, g1);\n    return dist.distance()\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var densifyFrac = arguments[2];\n    var dist$1 = new DiscreteHausdorffDistance(g0$1, g1$1);\n    dist$1.setDensifyFraction(densifyFrac);\n    return dist$1.distance()\n  }\n};\nstaticAccessors$39.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter$1 };\nstaticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function () { return MaxDensifiedByFractionDistanceFilter };\n\nObject.defineProperties( DiscreteHausdorffDistance, staticAccessors$39 );\n\nvar MaxPointDistanceFilter$1 = function MaxPointDistanceFilter () {\n  this._maxPtDist = new PointPairDistance$2();\n  this._minPtDist = new PointPairDistance$2();\n  this._euclideanDist = new DistanceToPoint();\n  this._geom = null;\n  var geom = arguments[0];\n  this._geom = geom;\n};\nMaxPointDistanceFilter$1.prototype.filter = function filter (pt) {\n  this._minPtDist.initialize();\n  DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nMaxPointDistanceFilter$1.prototype.getClass = function getClass () {\n  return MaxPointDistanceFilter$1\n};\n\nvar MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter () {\n  this._maxPtDist = new PointPairDistance$2();\n  this._minPtDist = new PointPairDistance$2();\n  this._geom = null;\n  this._numSubSegs = 0;\n  var geom = arguments[0];\n  var fraction = arguments[1];\n  this._geom = geom;\n  this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));\n};\nMaxDensifiedByFractionDistanceFilter.prototype.filter = function filter (seq, index) {\n    var this$1 = this;\n\n  if (index === 0) { return null }\n  var p0 = seq.getCoordinate(index - 1);\n  var p1 = seq.getCoordinate(index);\n  var delx = (p1.x - p0.x) / this._numSubSegs;\n  var dely = (p1.y - p0.y) / this._numSubSegs;\n  for (var i = 0; i < this._numSubSegs; i++) {\n    var x = p0.x + i * delx;\n    var y = p0.y + i * dely;\n    var pt = new Coordinate(x, y);\n    this$1._minPtDist.initialize();\n    DistanceToPoint.computeDistance(this$1._geom, pt, this$1._minPtDist);\n    this$1._maxPtDist.setMaximum(this$1._minPtDist);\n  }\n};\nMaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone () {\n  return false\n};\nMaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged () {\n  return false\n};\nMaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nMaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass () {\n  return MaxDensifiedByFractionDistanceFilter\n};\n\nvar BufferDistanceValidator = function BufferDistanceValidator (input, bufDistance, result) {\n  this._minValidDistance = null;\n  this._maxValidDistance = null;\n  this._minDistanceFound = null;\n  this._maxDistanceFound = null;\n  this._isValid = true;\n  this._errMsg = null;\n  this._errorLocation = null;\n  this._errorIndicator = null;\n  this._input = input || null;\n  this._bufDistance = bufDistance || null;\n  this._result = result || null;\n};\n\nvar staticAccessors$37 = { VERBOSE: { configurable: true },MAX_DISTANCE_DIFF_FRAC: { configurable: true } };\nBufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance (input, bufCurve, maxDist) {\n  var haus = new DiscreteHausdorffDistance(bufCurve, input);\n  haus.setDensifyFraction(0.25);\n  this._maxDistanceFound = haus.orientedDistance();\n  if (this._maxDistanceFound > maxDist) {\n    this._isValid = false;\n    var pts = haus.getCoordinates();\n    this._errorLocation = pts[1];\n    this._errorIndicator = input.getFactory().createLineString(pts);\n    this._errMsg = 'Distance between buffer curve and input is too large (' + this._maxDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ')';\n  }\n};\nBufferDistanceValidator.prototype.isValid = function isValid () {\n  var posDistance = Math.abs(this._bufDistance);\n  var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;\n  this._minValidDistance = posDistance - distDelta;\n  this._maxValidDistance = posDistance + distDelta;\n  if (this._input.isEmpty() || this._result.isEmpty()) { return true }\n  if (this._bufDistance > 0.0) {\n    this.checkPositiveValid();\n  } else {\n    this.checkNegativeValid();\n  }\n  if (BufferDistanceValidator.VERBOSE) {\n    System.out.println('Min Dist= ' + this._minDistanceFound + '  err= ' + (1.0 - this._minDistanceFound / this._bufDistance) + '  Max Dist= ' + this._maxDistanceFound + '  err= ' + (this._maxDistanceFound / this._bufDistance - 1.0));\n  }\n  return this._isValid\n};\nBufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid () {\n  if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {\n    return null\n  }\n  var inputCurve = this.getPolygonLines(this._input);\n  this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);\n  if (!this._isValid) { return null }\n  this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);\n};\nBufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator () {\n  return this._errorIndicator\n};\nBufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance (g1, g2, minDist) {\n  var distOp = new DistanceOp(g1, g2, minDist);\n  this._minDistanceFound = distOp.distance();\n  if (this._minDistanceFound < minDist) {\n    this._isValid = false;\n    var pts = distOp.nearestPoints();\n    this._errorLocation = distOp.nearestPoints()[1];\n    this._errorIndicator = g1.getFactory().createLineString(pts);\n    this._errMsg = 'Distance between buffer curve and input is too small (' + this._minDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ' )';\n  }\n};\nBufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid () {\n  var bufCurve = this._result.getBoundary();\n  this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);\n  if (!this._isValid) { return null }\n  this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);\n};\nBufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation () {\n  return this._errorLocation\n};\nBufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines (g) {\n  var lines = new ArrayList();\n  var lineExtracter = new LinearComponentExtracter(lines);\n  var polys = PolygonExtracter.getPolygons(g);\n  for (var i = polys.iterator(); i.hasNext();) {\n    var poly = i.next();\n    poly.apply(lineExtracter);\n  }\n  return g.getFactory().buildGeometry(lines)\n};\nBufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage () {\n  return this._errMsg\n};\nBufferDistanceValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferDistanceValidator.prototype.getClass = function getClass () {\n  return BufferDistanceValidator\n};\nstaticAccessors$37.VERBOSE.get = function () { return false };\nstaticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function () { return 0.012 };\n\nObject.defineProperties( BufferDistanceValidator, staticAccessors$37 );\n\nvar BufferResultValidator = function BufferResultValidator (input, distance, result) {\n  this._isValid = true;\n  this._errorMsg = null;\n  this._errorLocation = null;\n  this._errorIndicator = null;\n  this._input = input || null;\n  this._distance = distance || null;\n  this._result = result || null;\n};\n\nvar staticAccessors$40 = { VERBOSE: { configurable: true },MAX_ENV_DIFF_FRAC: { configurable: true } };\nBufferResultValidator.prototype.isValid = function isValid () {\n  this.checkPolygonal();\n  if (!this._isValid) { return this._isValid }\n  this.checkExpectedEmpty();\n  if (!this._isValid) { return this._isValid }\n  this.checkEnvelope();\n  if (!this._isValid) { return this._isValid }\n  this.checkArea();\n  if (!this._isValid) { return this._isValid }\n  this.checkDistance();\n  return this._isValid\n};\nBufferResultValidator.prototype.checkEnvelope = function checkEnvelope () {\n  if (this._distance < 0.0) { return null }\n  var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;\n  if (padding === 0.0) { padding = 0.001; }\n  var expectedEnv = new Envelope(this._input.getEnvelopeInternal());\n  expectedEnv.expandBy(this._distance);\n  var bufEnv = new Envelope(this._result.getEnvelopeInternal());\n  bufEnv.expandBy(padding);\n  if (!bufEnv.contains(expectedEnv)) {\n    this._isValid = false;\n    this._errorMsg = 'Buffer envelope is incorrect';\n    this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);\n  }\n  this.report('Envelope');\n};\nBufferResultValidator.prototype.checkDistance = function checkDistance () {\n  var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);\n  if (!distValid.isValid()) {\n    this._isValid = false;\n    this._errorMsg = distValid.getErrorMessage();\n    this._errorLocation = distValid.getErrorLocation();\n    this._errorIndicator = distValid.getErrorIndicator();\n  }\n  this.report('Distance');\n};\nBufferResultValidator.prototype.checkArea = function checkArea () {\n  var inputArea = this._input.getArea();\n  var resultArea = this._result.getArea();\n  if (this._distance > 0.0 && inputArea > resultArea) {\n    this._isValid = false;\n    this._errorMsg = 'Area of positive buffer is smaller than input';\n    this._errorIndicator = this._result;\n  }\n  if (this._distance < 0.0 && inputArea < resultArea) {\n    this._isValid = false;\n    this._errorMsg = 'Area of negative buffer is larger than input';\n    this._errorIndicator = this._result;\n  }\n  this.report('Area');\n};\nBufferResultValidator.prototype.checkPolygonal = function checkPolygonal () {\n  if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) { this._isValid = false; }\n  this._errorMsg = 'Result is not polygonal';\n  this._errorIndicator = this._result;\n  this.report('Polygonal');\n};\nBufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator () {\n  return this._errorIndicator\n};\nBufferResultValidator.prototype.getErrorLocation = function getErrorLocation () {\n  return this._errorLocation\n};\nBufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty () {\n  if (this._input.getDimension() >= 2) { return null }\n  if (this._distance > 0.0) { return null }\n  if (!this._result.isEmpty()) {\n    this._isValid = false;\n    this._errorMsg = 'Result is non-empty';\n    this._errorIndicator = this._result;\n  }\n  this.report('ExpectedEmpty');\n};\nBufferResultValidator.prototype.report = function report (checkName) {\n  if (!BufferResultValidator.VERBOSE) { return null }\n  System.out.println('Check ' + checkName + ': ' + (this._isValid ? 'passed' : 'FAILED'));\n};\nBufferResultValidator.prototype.getErrorMessage = function getErrorMessage () {\n  return this._errorMsg\n};\nBufferResultValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferResultValidator.prototype.getClass = function getClass () {\n  return BufferResultValidator\n};\nBufferResultValidator.isValidMsg = function isValidMsg (g, distance, result) {\n  var validator = new BufferResultValidator(g, distance, result);\n  if (!validator.isValid()) { return validator.getErrorMessage() }\n  return null\n};\nBufferResultValidator.isValid = function isValid (g, distance, result) {\n  var validator = new BufferResultValidator(g, distance, result);\n  if (validator.isValid()) { return true }\n  return false\n};\nstaticAccessors$40.VERBOSE.get = function () { return false };\nstaticAccessors$40.MAX_ENV_DIFF_FRAC.get = function () { return 0.012 };\n\nObject.defineProperties( BufferResultValidator, staticAccessors$40 );\n\n// operation.buffer\n\nvar BasicSegmentString = function BasicSegmentString () {\n  this._pts = null;\n  this._data = null;\n  var pts = arguments[0];\n  var data = arguments[1];\n  this._pts = pts;\n  this._data = data;\n};\nBasicSegmentString.prototype.getCoordinates = function getCoordinates () {\n  return this._pts\n};\nBasicSegmentString.prototype.size = function size () {\n  return this._pts.length\n};\nBasicSegmentString.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts[i]\n};\nBasicSegmentString.prototype.isClosed = function isClosed () {\n  return this._pts[0].equals(this._pts[this._pts.length - 1])\n};\nBasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant (index) {\n  if (index === this._pts.length - 1) { return -1 }\n  return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1))\n};\nBasicSegmentString.prototype.setData = function setData (data) {\n  this._data = data;\n};\nBasicSegmentString.prototype.getData = function getData () {\n  return this._data\n};\nBasicSegmentString.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))\n};\nBasicSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentString]\n};\nBasicSegmentString.prototype.getClass = function getClass () {\n  return BasicSegmentString\n};\n\nvar InteriorIntersectionFinder = function InteriorIntersectionFinder () {\n  this._findAllIntersections = false;\n  this._isCheckEndSegmentsOnly = false;\n  this._li = null;\n  this._interiorIntersection = null;\n  this._intSegments = null;\n  this._intersections = new ArrayList();\n  this._intersectionCount = 0;\n  this._keepIntersections = true;\n  var li = arguments[0];\n  this._li = li;\n  this._interiorIntersection = null;\n};\nInteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection () {\n  return this._interiorIntersection\n};\nInteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly (isCheckEndSegmentsOnly) {\n  this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n};\nInteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments () {\n  return this._intSegments\n};\nInteriorIntersectionFinder.prototype.count = function count () {\n  return this._intersectionCount\n};\nInteriorIntersectionFinder.prototype.getIntersections = function getIntersections () {\n  return this._intersections\n};\nInteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections (findAllIntersections) {\n  this._findAllIntersections = findAllIntersections;\n};\nInteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections (keepIntersections) {\n  this._keepIntersections = keepIntersections;\n};\nInteriorIntersectionFinder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n  if (!this._findAllIntersections && this.hasIntersection()) { return null }\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  if (this._isCheckEndSegmentsOnly) {\n    var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n    if (!isEndSegPresent) { return null }\n  }\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._li.isInteriorIntersection()) {\n      this._intSegments = new Array(4).fill(null);\n      this._intSegments[0] = p00;\n      this._intSegments[1] = p01;\n      this._intSegments[2] = p10;\n      this._intSegments[3] = p11;\n      this._interiorIntersection = this._li.getIntersection(0);\n      if (this._keepIntersections) { this._intersections.add(this._interiorIntersection); }\n      this._intersectionCount++;\n    }\n  }\n};\nInteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment (segStr, index) {\n  if (index === 0) { return true }\n  if (index >= segStr.size() - 2) { return true }\n  return false\n};\nInteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection () {\n  return this._interiorIntersection !== null\n};\nInteriorIntersectionFinder.prototype.isDone = function isDone () {\n  if (this._findAllIntersections) { return false }\n  return this._interiorIntersection !== null\n};\nInteriorIntersectionFinder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nInteriorIntersectionFinder.prototype.getClass = function getClass () {\n  return InteriorIntersectionFinder\n};\nInteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder (li) {\n  var finder = new InteriorIntersectionFinder(li);\n  finder.setFindAllIntersections(true);\n  return finder\n};\nInteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder (li) {\n  return new InteriorIntersectionFinder(li)\n};\nInteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter (li) {\n  var finder = new InteriorIntersectionFinder(li);\n  finder.setFindAllIntersections(true);\n  finder.setKeepIntersections(false);\n  return finder\n};\n\nvar FastNodingValidator = function FastNodingValidator () {\n  this._li = new RobustLineIntersector();\n  this._segStrings = null;\n  this._findAllIntersections = false;\n  this._segInt = null;\n  this._isValid = true;\n  var segStrings = arguments[0];\n  this._segStrings = segStrings;\n};\nFastNodingValidator.prototype.execute = function execute () {\n  if (this._segInt !== null) { return null }\n  this.checkInteriorIntersections();\n};\nFastNodingValidator.prototype.getIntersections = function getIntersections () {\n  return this._segInt.getIntersections()\n};\nFastNodingValidator.prototype.isValid = function isValid () {\n  this.execute();\n  return this._isValid\n};\nFastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections (findAllIntersections) {\n  this._findAllIntersections = findAllIntersections;\n};\nFastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections () {\n  this._isValid = true;\n  this._segInt = new InteriorIntersectionFinder(this._li);\n  this._segInt.setFindAllIntersections(this._findAllIntersections);\n  var noder = new MCIndexNoder();\n  noder.setSegmentIntersector(this._segInt);\n  noder.computeNodes(this._segStrings);\n  if (this._segInt.hasIntersection()) {\n    this._isValid = false;\n    return null\n  }\n};\nFastNodingValidator.prototype.checkValid = function checkValid () {\n  this.execute();\n  if (!this._isValid) { throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection()) }\n};\nFastNodingValidator.prototype.getErrorMessage = function getErrorMessage () {\n  if (this._isValid) { return 'no intersections found' }\n  var intSegs = this._segInt.getIntersectionSegments();\n  return 'found non-noded intersection between ' + WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' + WKTWriter.toLineString(intSegs[2], intSegs[3])\n};\nFastNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nFastNodingValidator.prototype.getClass = function getClass () {\n  return FastNodingValidator\n};\nFastNodingValidator.computeIntersections = function computeIntersections (segStrings) {\n  var nv = new FastNodingValidator(segStrings);\n  nv.setFindAllIntersections(true);\n  nv.isValid();\n  return nv.getIntersections()\n};\n\nvar EdgeNodingValidator = function EdgeNodingValidator () {\n  this._nv = null;\n  var edges = arguments[0];\n  this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n};\nEdgeNodingValidator.prototype.checkValid = function checkValid () {\n  this._nv.checkValid();\n};\nEdgeNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeNodingValidator.prototype.getClass = function getClass () {\n  return EdgeNodingValidator\n};\nEdgeNodingValidator.toSegmentStrings = function toSegmentStrings (edges) {\n  var segStrings = new ArrayList();\n  for (var i = edges.iterator(); i.hasNext();) {\n    var e = i.next();\n    segStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n  }\n  return segStrings\n};\nEdgeNodingValidator.checkValid = function checkValid (edges) {\n  var validator = new EdgeNodingValidator(edges);\n  validator.checkValid();\n};\n\nvar GeometryCollectionMapper = function GeometryCollectionMapper (mapOp) {\n  this._mapOp = mapOp;\n};\nGeometryCollectionMapper.prototype.map = function map (gc) {\n    var this$1 = this;\n\n  var mapped = new ArrayList();\n  for (var i = 0; i < gc.getNumGeometries(); i++) {\n    var g = this$1._mapOp.map(gc.getGeometryN(i));\n    if (!g.isEmpty()) { mapped.add(g); }\n  }\n  return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped))\n};\nGeometryCollectionMapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryCollectionMapper.prototype.getClass = function getClass () {\n  return GeometryCollectionMapper\n};\nGeometryCollectionMapper.map = function map (gc, op) {\n  var mapper = new GeometryCollectionMapper(op);\n  return mapper.map(gc)\n};\n\nvar LineBuilder = function LineBuilder () {\n  this._op = null;\n  this._geometryFactory = null;\n  this._ptLocator = null;\n  this._lineEdgesList = new ArrayList();\n  this._resultLineList = new ArrayList();\n  var op = arguments[0];\n  var geometryFactory = arguments[1];\n  var ptLocator = arguments[2];\n  this._op = op;\n  this._geometryFactory = geometryFactory;\n  this._ptLocator = ptLocator;\n};\nLineBuilder.prototype.collectLines = function collectLines (opCode) {\n    var this$1 = this;\n\n  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n    var de = it.next();\n    this$1.collectLineEdge(de, opCode, this$1._lineEdgesList);\n    this$1.collectBoundaryTouchEdge(de, opCode, this$1._lineEdgesList);\n  }\n};\nLineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine (e, targetIndex) {\n  var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n  e.getLabel().setLocation(targetIndex, loc);\n};\nLineBuilder.prototype.build = function build (opCode) {\n  this.findCoveredLineEdges();\n  this.collectLines(opCode);\n  this.buildLines(opCode);\n  return this._resultLineList\n};\nLineBuilder.prototype.collectLineEdge = function collectLineEdge (de, opCode, edges) {\n  var label = de.getLabel();\n  var e = de.getEdge();\n  if (de.isLineEdge()) {\n    if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n      edges.add(e);\n      de.setVisitedEdge(true);\n    }\n  }\n};\nLineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges () {\n    var this$1 = this;\n\n  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().findCoveredLineEdges();\n  }\n  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n    var de = it.next();\n    var e = de.getEdge();\n    if (de.isLineEdge() && !e.isCoveredSet()) {\n      var isCovered = this$1._op.isCoveredByA(de.getCoordinate());\n      e.setCovered(isCovered);\n    }\n  }\n};\nLineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines (edgesList) {\n    var this$1 = this;\n\n  for (var it = edgesList.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    if (e.isIsolated()) {\n      if (label.isNull(0)) { this$1.labelIsolatedLine(e, 0); } else { this$1.labelIsolatedLine(e, 1); }\n    }\n  }\n};\nLineBuilder.prototype.buildLines = function buildLines (opCode) {\n    var this$1 = this;\n\n  for (var it = this._lineEdgesList.iterator(); it.hasNext();) {\n    var e = it.next();\n    // const label = e.getLabel()\n    var line = this$1._geometryFactory.createLineString(e.getCoordinates());\n    this$1._resultLineList.add(line);\n    e.setInResult(true);\n  }\n};\nLineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge (de, opCode, edges) {\n  var label = de.getLabel();\n  if (de.isLineEdge()) { return null }\n  if (de.isVisited()) { return null }\n  if (de.isInteriorAreaEdge()) { return null }\n  if (de.getEdge().isInResult()) { return null }\n  Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n  if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n    edges.add(de.getEdge());\n    de.setVisitedEdge(true);\n  }\n};\nLineBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineBuilder.prototype.getClass = function getClass () {\n  return LineBuilder\n};\n\nvar PointBuilder = function PointBuilder () {\n  this._op = null;\n  this._geometryFactory = null;\n  this._resultPointList = new ArrayList();\n  var op = arguments[0];\n  var geometryFactory = arguments[1];\n  // const ptLocator = arguments[2]\n  this._op = op;\n  this._geometryFactory = geometryFactory;\n};\nPointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint (n) {\n  var coord = n.getCoordinate();\n  if (!this._op.isCoveredByLA(coord)) {\n    var pt = this._geometryFactory.createPoint(coord);\n    this._resultPointList.add(pt);\n  }\n};\nPointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes (opCode) {\n    var this$1 = this;\n\n  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n    var n = nodeit.next();\n    if (n.isInResult()) { continue }\n    if (n.isIncidentEdgeInResult()) { continue }\n    if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n      var label = n.getLabel();\n      if (OverlayOp.isResultOfOp(label, opCode)) {\n        this$1.filterCoveredNodeToPoint(n);\n      }\n    }\n  }\n};\nPointBuilder.prototype.build = function build (opCode) {\n  this.extractNonCoveredResultNodes(opCode);\n  return this._resultPointList\n};\nPointBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointBuilder.prototype.getClass = function getClass () {\n  return PointBuilder\n};\n\nvar GeometryTransformer = function GeometryTransformer () {\n  this._inputGeom = null;\n  this._factory = null;\n  this._pruneEmptyGeometry = true;\n  this._preserveGeometryCollectionType = true;\n  this._preserveCollections = false;\n  this._preserveType = false;\n};\nGeometryTransformer.prototype.transformPoint = function transformPoint (geom, parent) {\n  return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom))\n};\nGeometryTransformer.prototype.transformPolygon = function transformPolygon (geom, parent) {\n    var this$1 = this;\n\n  var isAllValidLinearRings = true;\n  var shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n  if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) { isAllValidLinearRings = false; }\n  var holes = new ArrayList();\n  for (var i = 0; i < geom.getNumInteriorRing(); i++) {\n    var hole = this$1.transformLinearRing(geom.getInteriorRingN(i), geom);\n    if (hole === null || hole.isEmpty()) {\n      continue\n    }\n    if (!(hole instanceof LinearRing)) { isAllValidLinearRings = false; }\n    holes.add(hole);\n  }\n  if (isAllValidLinearRings) { return this._factory.createPolygon(shell, holes.toArray([])); } else {\n    var components = new ArrayList();\n    if (shell !== null) { components.add(shell); }\n    components.addAll(holes);\n    return this._factory.buildGeometry(components)\n  }\n};\nGeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence (coords) {\n  return this._factory.getCoordinateSequenceFactory().create(coords)\n};\nGeometryTransformer.prototype.getInputGeometry = function getInputGeometry () {\n  return this._inputGeom\n};\nGeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformLineString(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transformCoordinates = function transformCoordinates (coords, parent) {\n  return this.copy(coords)\n};\nGeometryTransformer.prototype.transformLineString = function transformLineString (geom, parent) {\n  return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom))\n};\nGeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformPoint(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformPolygon(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.copy = function copy (seq) {\n  return seq.copy()\n};\nGeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transform(geom.getGeometryN(i));\n    if (transformGeom === null) { continue }\n    if (this$1._pruneEmptyGeometry && transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  if (this._preserveGeometryCollectionType) { return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList)) }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transform = function transform (inputGeom) {\n  this._inputGeom = inputGeom;\n  this._factory = inputGeom.getFactory();\n  if (inputGeom instanceof Point) { return this.transformPoint(inputGeom, null) }\n  if (inputGeom instanceof MultiPoint) { return this.transformMultiPoint(inputGeom, null) }\n  if (inputGeom instanceof LinearRing) { return this.transformLinearRing(inputGeom, null) }\n  if (inputGeom instanceof LineString) { return this.transformLineString(inputGeom, null) }\n  if (inputGeom instanceof MultiLineString) { return this.transformMultiLineString(inputGeom, null) }\n  if (inputGeom instanceof Polygon) { return this.transformPolygon(inputGeom, null) }\n  if (inputGeom instanceof MultiPolygon) { return this.transformMultiPolygon(inputGeom, null) }\n  if (inputGeom instanceof GeometryCollection) { return this.transformGeometryCollection(inputGeom, null) }\n  throw new IllegalArgumentException('Unknown Geometry subtype: ' + inputGeom.getClass().getName())\n};\nGeometryTransformer.prototype.transformLinearRing = function transformLinearRing (geom, parent) {\n  var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n  if (seq === null) { return this._factory.createLinearRing(null) }\n  var seqSize = seq.size();\n  if (seqSize > 0 && seqSize < 4 && !this._preserveType) { return this._factory.createLineString(seq) }\n  return this._factory.createLinearRing(seq)\n};\nGeometryTransformer.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryTransformer.prototype.getClass = function getClass () {\n  return GeometryTransformer\n};\n\nvar LineStringSnapper = function LineStringSnapper () {\n  this._snapTolerance = 0.0;\n  this._srcPts = null;\n  this._seg = new LineSegment();\n  this._allowSnappingToSourceVertices = false;\n  this._isClosed = false;\n  if (arguments[0] instanceof LineString && typeof arguments[1] === 'number') {\n    var srcLine = arguments[0];\n    var snapTolerance = arguments[1];\n    LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n  } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {\n    var srcPts = arguments[0];\n    var snapTolerance$1 = arguments[1];\n    this._srcPts = srcPts;\n    this._isClosed = LineStringSnapper.isClosed(srcPts);\n    this._snapTolerance = snapTolerance$1;\n  }\n};\nLineStringSnapper.prototype.snapVertices = function snapVertices (srcCoords, snapPts) {\n    var this$1 = this;\n\n  var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n  for (var i = 0; i < end; i++) {\n    var srcPt = srcCoords.get(i);\n    var snapVert = this$1.findSnapForVertex(srcPt, snapPts);\n    if (snapVert !== null) {\n      srcCoords.set(i, new Coordinate(snapVert));\n      if (i === 0 && this$1._isClosed) { srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert)); }\n    }\n  }\n};\nLineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex (pt, snapPts) {\n    var this$1 = this;\n\n  for (var i = 0; i < snapPts.length; i++) {\n    if (pt.equals2D(snapPts[i])) { return null }\n    if (pt.distance(snapPts[i]) < this$1._snapTolerance) { return snapPts[i] }\n  }\n  return null\n};\nLineStringSnapper.prototype.snapTo = function snapTo (snapPts) {\n  var coordList = new CoordinateList(this._srcPts);\n  this.snapVertices(coordList, snapPts);\n  this.snapSegments(coordList, snapPts);\n  var newPts = coordList.toCoordinateArray();\n  return newPts\n};\nLineStringSnapper.prototype.snapSegments = function snapSegments (srcCoords, snapPts) {\n    var this$1 = this;\n\n  if (snapPts.length === 0) { return null }\n  var distinctPtCount = snapPts.length;\n  if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) { distinctPtCount = snapPts.length - 1; }\n  for (var i = 0; i < distinctPtCount; i++) {\n    var snapPt = snapPts[i];\n    var index = this$1.findSegmentIndexToSnap(snapPt, srcCoords);\n    if (index >= 0) {\n      srcCoords.add(index + 1, new Coordinate(snapPt), false);\n    }\n  }\n};\nLineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap (snapPt, srcCoords) {\n    var this$1 = this;\n\n  var minDist = Double.MAX_VALUE;\n  var snapIndex = -1;\n  for (var i = 0; i < srcCoords.size() - 1; i++) {\n    this$1._seg.p0 = srcCoords.get(i);\n    this$1._seg.p1 = srcCoords.get(i + 1);\n    if (this$1._seg.p0.equals2D(snapPt) || this$1._seg.p1.equals2D(snapPt)) {\n      if (this$1._allowSnappingToSourceVertices) { continue; } else { return -1 }\n    }\n    var dist = this$1._seg.distance(snapPt);\n    if (dist < this$1._snapTolerance && dist < minDist) {\n      minDist = dist;\n      snapIndex = i;\n    }\n  }\n  return snapIndex\n};\nLineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices (allowSnappingToSourceVertices) {\n  this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n};\nLineStringSnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineStringSnapper.prototype.getClass = function getClass () {\n  return LineStringSnapper\n};\nLineStringSnapper.isClosed = function isClosed (pts) {\n  if (pts.length <= 1) { return false }\n  return pts[0].equals2D(pts[pts.length - 1])\n};\n\nvar GeometrySnapper = function GeometrySnapper (srcGeom) {\n  this._srcGeom = srcGeom || null;\n};\n\nvar staticAccessors$41 = { SNAP_PRECISION_FACTOR: { configurable: true } };\nGeometrySnapper.prototype.snapTo = function snapTo (snapGeom, snapTolerance) {\n  var snapPts = this.extractTargetCoordinates(snapGeom);\n  var snapTrans = new SnapTransformer(snapTolerance, snapPts);\n  return snapTrans.transform(this._srcGeom)\n};\nGeometrySnapper.prototype.snapToSelf = function snapToSelf (snapTolerance, cleanResult) {\n  var snapPts = this.extractTargetCoordinates(this._srcGeom);\n  var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n  var snappedGeom = snapTrans.transform(this._srcGeom);\n  var result = snappedGeom;\n  if (cleanResult && hasInterface(result, Polygonal)) {\n    result = snappedGeom.buffer(0);\n  }\n  return result\n};\nGeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance (ringPts) {\n  var minSegLen = this.computeMinimumSegmentLength(ringPts);\n  var snapTol = minSegLen / 10;\n  return snapTol\n};\nGeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates (g) {\n  var ptSet = new TreeSet();\n  var pts = g.getCoordinates();\n  for (var i = 0; i < pts.length; i++) {\n    ptSet.add(pts[i]);\n  }\n  return ptSet.toArray(new Array(0).fill(null))\n};\nGeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength (pts) {\n  var minSegLen = Double.MAX_VALUE;\n  for (var i = 0; i < pts.length - 1; i++) {\n    var segLen = pts[i].distance(pts[i + 1]);\n    if (segLen < minSegLen) { minSegLen = segLen; }\n  }\n  return minSegLen\n};\nGeometrySnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometrySnapper.prototype.getClass = function getClass () {\n  return GeometrySnapper\n};\nGeometrySnapper.snap = function snap (g0, g1, snapTolerance) {\n  var snapGeom = new Array(2).fill(null);\n  var snapper0 = new GeometrySnapper(g0);\n  snapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n  var snapper1 = new GeometrySnapper(g1);\n  snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n  return snapGeom\n};\nGeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance () {\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n    var pm = g.getPrecisionModel();\n    if (pm.getType() === PrecisionModel.FIXED) {\n      var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n      if (fixedSnapTol > snapTolerance) { snapTolerance = fixedSnapTol; }\n    }\n    return snapTolerance\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1))\n  }\n};\nGeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance (g) {\n  var env = g.getEnvelopeInternal();\n  var minDimension = Math.min(env.getHeight(), env.getWidth());\n  var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n  return snapTol\n};\nGeometrySnapper.snapToSelf = function snapToSelf (geom, snapTolerance, cleanResult) {\n  var snapper0 = new GeometrySnapper(geom);\n  return snapper0.snapToSelf(snapTolerance, cleanResult)\n};\nstaticAccessors$41.SNAP_PRECISION_FACTOR.get = function () { return 1e-9 };\n\nObject.defineProperties( GeometrySnapper, staticAccessors$41 );\n\nvar SnapTransformer = (function (GeometryTransformer$$1) {\n  function SnapTransformer (snapTolerance, snapPts, isSelfSnap) {\n    GeometryTransformer$$1.call(this);\n    this._snapTolerance = snapTolerance || null;\n    this._snapPts = snapPts || null;\n    this._isSelfSnap = (isSelfSnap !== undefined) ? isSelfSnap : false;\n  }\n\n  if ( GeometryTransformer$$1 ) SnapTransformer.__proto__ = GeometryTransformer$$1;\n  SnapTransformer.prototype = Object.create( GeometryTransformer$$1 && GeometryTransformer$$1.prototype );\n  SnapTransformer.prototype.constructor = SnapTransformer;\n  SnapTransformer.prototype.snapLine = function snapLine (srcPts, snapPts) {\n    var snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n    snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n    return snapper.snapTo(snapPts)\n  };\n  SnapTransformer.prototype.transformCoordinates = function transformCoordinates (coords, parent) {\n    var srcPts = coords.toCoordinateArray();\n    var newPts = this.snapLine(srcPts, this._snapPts);\n    return this._factory.getCoordinateSequenceFactory().create(newPts)\n  };\n  SnapTransformer.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SnapTransformer.prototype.getClass = function getClass () {\n    return SnapTransformer\n  };\n\n  return SnapTransformer;\n}(GeometryTransformer));\n\nvar CommonBits = function CommonBits () {\n  this._isFirst = true;\n  this._commonMantissaBitsCount = 53;\n  this._commonBits = 0;\n  this._commonSignExp = null;\n};\nCommonBits.prototype.getCommon = function getCommon () {\n  return Double.longBitsToDouble(this._commonBits)\n};\nCommonBits.prototype.add = function add (num) {\n  var numBits = Double.doubleToLongBits(num);\n  if (this._isFirst) {\n    this._commonBits = numBits;\n    this._commonSignExp = CommonBits.signExpBits(this._commonBits);\n    this._isFirst = false;\n    return null\n  }\n  var numSignExp = CommonBits.signExpBits(numBits);\n  if (numSignExp !== this._commonSignExp) {\n    this._commonBits = 0;\n    return null\n  }\n  this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n  this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n};\nCommonBits.prototype.toString = function toString () {\n  if (arguments.length === 1) {\n    var bits = arguments[0];\n    var x = Double.longBitsToDouble(bits);\n    var numStr = Double.toBinaryString(bits);\n    var padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;\n    var bitStr = padStr.substring(padStr.length - 64);\n    var str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';\n    return str\n  }\n};\nCommonBits.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCommonBits.prototype.getClass = function getClass () {\n  return CommonBits\n};\nCommonBits.getBit = function getBit (bits, i) {\n  var mask = 1 << i;\n  return (bits & mask) !== 0 ? 1 : 0\n};\nCommonBits.signExpBits = function signExpBits (num) {\n  return num >> 52\n};\nCommonBits.zeroLowerBits = function zeroLowerBits (bits, nBits) {\n  var invMask = (1 << nBits) - 1;\n  var mask = ~invMask;\n  var zeroed = bits & mask;\n  return zeroed\n};\nCommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits (num1, num2) {\n  var count = 0;\n  for (var i = 52; i >= 0; i--) {\n    if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) { return count }\n    count++;\n  }\n  return 52\n};\n\nvar CommonBitsRemover = function CommonBitsRemover () {\n  this._commonCoord = null;\n  this._ccFilter = new CommonCoordinateFilter();\n};\n\nvar staticAccessors$42 = { CommonCoordinateFilter: { configurable: true },Translater: { configurable: true } };\nCommonBitsRemover.prototype.addCommonBits = function addCommonBits (geom) {\n  var trans = new Translater(this._commonCoord);\n  geom.apply(trans);\n  geom.geometryChanged();\n};\nCommonBitsRemover.prototype.removeCommonBits = function removeCommonBits (geom) {\n  if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) { return geom }\n  var invCoord = new Coordinate(this._commonCoord);\n  invCoord.x = -invCoord.x;\n  invCoord.y = -invCoord.y;\n  var trans = new Translater(invCoord);\n  geom.apply(trans);\n  geom.geometryChanged();\n  return geom\n};\nCommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate () {\n  return this._commonCoord\n};\nCommonBitsRemover.prototype.add = function add (geom) {\n  geom.apply(this._ccFilter);\n  this._commonCoord = this._ccFilter.getCommonCoordinate();\n};\nCommonBitsRemover.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCommonBitsRemover.prototype.getClass = function getClass () {\n  return CommonBitsRemover\n};\nstaticAccessors$42.CommonCoordinateFilter.get = function () { return CommonCoordinateFilter };\nstaticAccessors$42.Translater.get = function () { return Translater };\n\nObject.defineProperties( CommonBitsRemover, staticAccessors$42 );\n\nvar CommonCoordinateFilter = function CommonCoordinateFilter () {\n  this._commonBitsX = new CommonBits();\n  this._commonBitsY = new CommonBits();\n};\nCommonCoordinateFilter.prototype.filter = function filter (coord) {\n  this._commonBitsX.add(coord.x);\n  this._commonBitsY.add(coord.y);\n};\nCommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate () {\n  return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())\n};\nCommonCoordinateFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nCommonCoordinateFilter.prototype.getClass = function getClass () {\n  return CommonCoordinateFilter\n};\n\nvar Translater = function Translater () {\n  this.trans = null;\n  var trans = arguments[0];\n  this.trans = trans;\n};\nTranslater.prototype.filter = function filter (seq, i) {\n  var xp = seq.getOrdinate(i, 0) + this.trans.x;\n  var yp = seq.getOrdinate(i, 1) + this.trans.y;\n  seq.setOrdinate(i, 0, xp);\n  seq.setOrdinate(i, 1, yp);\n};\nTranslater.prototype.isDone = function isDone () {\n  return false\n};\nTranslater.prototype.isGeometryChanged = function isGeometryChanged () {\n  return true\n};\nTranslater.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nTranslater.prototype.getClass = function getClass () {\n  return Translater\n};\n\nvar SnapOverlayOp = function SnapOverlayOp (g1, g2) {\n  this._geom = new Array(2).fill(null);\n  this._snapTolerance = null;\n  this._cbr = null;\n  this._geom[0] = g1;\n  this._geom[1] = g2;\n  this.computeSnapTolerance();\n};\nSnapOverlayOp.prototype.selfSnap = function selfSnap (geom) {\n  var snapper0 = new GeometrySnapper(geom);\n  var snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n  return snapGeom\n};\nSnapOverlayOp.prototype.removeCommonBits = function removeCommonBits (geom) {\n  this._cbr = new CommonBitsRemover();\n  this._cbr.add(geom[0]);\n  this._cbr.add(geom[1]);\n  var remGeom = new Array(2).fill(null);\n  remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n  remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n  return remGeom\n};\nSnapOverlayOp.prototype.prepareResult = function prepareResult (geom) {\n  this._cbr.addCommonBits(geom);\n  return geom\n};\nSnapOverlayOp.prototype.getResultGeometry = function getResultGeometry (opCode) {\n  var prepGeom = this.snap(this._geom);\n  var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n  return this.prepareResult(result)\n};\nSnapOverlayOp.prototype.checkValid = function checkValid (g) {\n  if (!g.isValid()) {\n    System.out.println('Snapped geometry is invalid');\n  }\n};\nSnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance () {\n  this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n};\nSnapOverlayOp.prototype.snap = function snap (geom) {\n  var remGeom = this.removeCommonBits(geom);\n  var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n  return snapGeom\n};\nSnapOverlayOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSnapOverlayOp.prototype.getClass = function getClass () {\n  return SnapOverlayOp\n};\nSnapOverlayOp.overlayOp = function overlayOp (g0, g1, opCode) {\n  var op = new SnapOverlayOp(g0, g1);\n  return op.getResultGeometry(opCode)\n};\nSnapOverlayOp.union = function union (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)\n};\nSnapOverlayOp.intersection = function intersection (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)\n};\nSnapOverlayOp.symDifference = function symDifference (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)\n};\nSnapOverlayOp.difference = function difference (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)\n};\n\nvar SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp (g1, g2) {\n  this._geom = new Array(2).fill(null);\n  this._geom[0] = g1;\n  this._geom[1] = g2;\n};\nSnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry (opCode) {\n  var result = null;\n  var isSuccess = false;\n  var savedException = null;\n  try {\n    result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n    var isValid = true;\n    if (isValid) { isSuccess = true; }\n  } catch (ex) {\n    if (ex instanceof RuntimeException) {\n      savedException = ex;\n    } else { throw ex }\n  } finally {}\n  if (!isSuccess) {\n    try {\n      result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n    } catch (ex) {\n      if (ex instanceof RuntimeException) {\n        throw savedException\n      } else { throw ex }\n    } finally {}\n  }\n  return result\n};\nSnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSnapIfNeededOverlayOp.prototype.getClass = function getClass () {\n  return SnapIfNeededOverlayOp\n};\nSnapIfNeededOverlayOp.overlayOp = function overlayOp (g0, g1, opCode) {\n  var op = new SnapIfNeededOverlayOp(g0, g1);\n  return op.getResultGeometry(opCode)\n};\nSnapIfNeededOverlayOp.union = function union (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)\n};\nSnapIfNeededOverlayOp.intersection = function intersection (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)\n};\nSnapIfNeededOverlayOp.symDifference = function symDifference (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)\n};\nSnapIfNeededOverlayOp.difference = function difference (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)\n};\n\nvar MonotoneChain$2 = function MonotoneChain () {\n  this.mce = null;\n  this.chainIndex = null;\n  var mce = arguments[0];\n  var chainIndex = arguments[1];\n  this.mce = mce;\n  this.chainIndex = chainIndex;\n};\nMonotoneChain$2.prototype.computeIntersections = function computeIntersections (mc, si) {\n  this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n};\nMonotoneChain$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChain$2.prototype.getClass = function getClass () {\n  return MonotoneChain$2\n};\n\nvar SweepLineEvent = function SweepLineEvent () {\n  this._label = null;\n  this._xValue = null;\n  this._eventType = null;\n  this._insertEvent = null;\n  this._deleteEventIndex = null;\n  this._obj = null;\n  if (arguments.length === 2) {\n    var x = arguments[0];\n    var insertEvent = arguments[1];\n    this._eventType = SweepLineEvent.DELETE;\n    this._xValue = x;\n    this._insertEvent = insertEvent;\n  } else if (arguments.length === 3) {\n    var label = arguments[0];\n    var x$1 = arguments[1];\n    var obj = arguments[2];\n    this._eventType = SweepLineEvent.INSERT;\n    this._label = label;\n    this._xValue = x$1;\n    this._obj = obj;\n  }\n};\n\nvar staticAccessors$43 = { INSERT: { configurable: true },DELETE: { configurable: true } };\nSweepLineEvent.prototype.isDelete = function isDelete () {\n  return this._eventType === SweepLineEvent.DELETE\n};\nSweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex (deleteEventIndex) {\n  this._deleteEventIndex = deleteEventIndex;\n};\nSweepLineEvent.prototype.getObject = function getObject () {\n  return this._obj\n};\nSweepLineEvent.prototype.compareTo = function compareTo (o) {\n  var pe = o;\n  if (this._xValue < pe._xValue) { return -1 }\n  if (this._xValue > pe._xValue) { return 1 }\n  if (this._eventType < pe._eventType) { return -1 }\n  if (this._eventType > pe._eventType) { return 1 }\n  return 0\n};\nSweepLineEvent.prototype.getInsertEvent = function getInsertEvent () {\n  return this._insertEvent\n};\nSweepLineEvent.prototype.isInsert = function isInsert () {\n  return this._eventType === SweepLineEvent.INSERT\n};\nSweepLineEvent.prototype.isSameLabel = function isSameLabel (ev) {\n  if (this._label === null) { return false }\n  return this._label === ev._label\n};\nSweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex () {\n  return this._deleteEventIndex\n};\nSweepLineEvent.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nSweepLineEvent.prototype.getClass = function getClass () {\n  return SweepLineEvent\n};\nstaticAccessors$43.INSERT.get = function () { return 1 };\nstaticAccessors$43.DELETE.get = function () { return 2 };\n\nObject.defineProperties( SweepLineEvent, staticAccessors$43 );\n\nvar EdgeSetIntersector = function EdgeSetIntersector () {};\n\nEdgeSetIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeSetIntersector.prototype.getClass = function getClass () {\n  return EdgeSetIntersector\n};\n\nvar SegmentIntersector$2 = function SegmentIntersector () {\n  this._hasIntersection = false;\n  this._hasProper = false;\n  this._hasProperInterior = false;\n  this._properIntersectionPoint = null;\n  this._li = null;\n  this._includeProper = null;\n  this._recordIsolated = null;\n  this._isSelfIntersection = null;\n  this._numIntersections = 0;\n  this.numTests = 0;\n  this._bdyNodes = null;\n  this._isDone = false;\n  this._isDoneWhenProperInt = false;\n  var li = arguments[0];\n  var includeProper = arguments[1];\n  var recordIsolated = arguments[2];\n  this._li = li;\n  this._includeProper = includeProper;\n  this._recordIsolated = recordIsolated;\n};\nSegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1) {\n    if (this._li.getIntersectionNum() === 1) {\n      if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) { return true }\n      if (e0.isClosed()) {\n        var maxSegIndex = e0.getNumPoints() - 1;\n        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||\n            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {\n          return true\n        }\n      }\n    }\n  }\n  return false\n};\nSegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint () {\n  return this._properIntersectionPoint\n};\nSegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt (isDoneWhenProperInt) {\n  this._isDoneWhenProperInt = isDoneWhenProperInt;\n};\nSegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection () {\n  return this._hasProperInterior\n};\nSegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal (li, bdyNodes) {\n  for (var i = bdyNodes.iterator(); i.hasNext();) {\n    var node = i.next();\n    var pt = node.getCoordinate();\n    if (li.isIntersection(pt)) { return true }\n  }\n  return false\n};\nSegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection () {\n  return this._hasProper\n};\nSegmentIntersector$2.prototype.hasIntersection = function hasIntersection () {\n  return this._hasIntersection\n};\nSegmentIntersector$2.prototype.isDone = function isDone () {\n  return this._isDone\n};\nSegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint (li, bdyNodes) {\n  if (bdyNodes === null) { return false }\n  if (this.isBoundaryPointInternal(li, bdyNodes[0])) { return true }\n  if (this.isBoundaryPointInternal(li, bdyNodes[1])) { return true }\n  return false\n};\nSegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes (bdyNodes0, bdyNodes1) {\n  this._bdyNodes = new Array(2).fill(null);\n  this._bdyNodes[0] = bdyNodes0;\n  this._bdyNodes[1] = bdyNodes1;\n};\nSegmentIntersector$2.prototype.addIntersections = function addIntersections (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  this.numTests++;\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._recordIsolated) {\n      e0.setIsolated(false);\n      e1.setIsolated(false);\n    }\n    this._numIntersections++;\n    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n      this._hasIntersection = true;\n      if (this._includeProper || !this._li.isProper()) {\n        e0.addIntersections(this._li, segIndex0, 0);\n        e1.addIntersections(this._li, segIndex1, 1);\n      }\n      if (this._li.isProper()) {\n        this._properIntersectionPoint = this._li.getIntersection(0).copy();\n        this._hasProper = true;\n        if (this._isDoneWhenProperInt) {\n          this._isDone = true;\n        }\n        if (!this.isBoundaryPoint(this._li, this._bdyNodes)) { this._hasProperInterior = true; }\n      }\n    }\n  }\n};\nSegmentIntersector$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentIntersector$2.prototype.getClass = function getClass () {\n  return SegmentIntersector$2\n};\nSegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments (i1, i2) {\n  return Math.abs(i1 - i2) === 1\n};\n\nvar SimpleMCSweepLineIntersector = (function (EdgeSetIntersector$$1) {\n  function SimpleMCSweepLineIntersector () {\n    EdgeSetIntersector$$1.call(this);\n    this.events = new ArrayList();\n    this.nOverlaps = null;\n  }\n\n  if ( EdgeSetIntersector$$1 ) SimpleMCSweepLineIntersector.__proto__ = EdgeSetIntersector$$1;\n  SimpleMCSweepLineIntersector.prototype = Object.create( EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype );\n  SimpleMCSweepLineIntersector.prototype.constructor = SimpleMCSweepLineIntersector;\n  SimpleMCSweepLineIntersector.prototype.prepareEvents = function prepareEvents () {\n    var this$1 = this;\n\n    Collections.sort(this.events);\n    for (var i = 0; i < this.events.size(); i++) {\n      var ev = this$1.events.get(i);\n      if (ev.isDelete()) {\n        ev.getInsertEvent().setDeleteEventIndex(i);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.computeIntersections = function computeIntersections () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var si = arguments[0];\n      this.nOverlaps = 0;\n      this.prepareEvents();\n      for (var i = 0; i < this.events.size(); i++) {\n        var ev = this$1.events.get(i);\n        if (ev.isInsert()) {\n          this$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n        }\n        if (si.isDone()) {\n          break\n        }\n      }\n    } else if (arguments.length === 3) {\n      if (arguments[2] instanceof SegmentIntersector$2 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n        var edges0 = arguments[0];\n        var edges1 = arguments[1];\n        var si$1 = arguments[2];\n        this.addEdges(edges0, edges0);\n        this.addEdges(edges1, edges1);\n        this.computeIntersections(si$1);\n      } else if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2)) {\n        var edges = arguments[0];\n        var si$2 = arguments[1];\n        var testAllSegments = arguments[2];\n        if (testAllSegments) { this.addEdges(edges, null); } else { this.addEdges(edges); }\n        this.computeIntersections(si$2);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.addEdge = function addEdge (edge, edgeSet) {\n    var this$1 = this;\n\n    var mce = edge.getMonotoneChainEdge();\n    var startIndex = mce.getStartIndexes();\n    for (var i = 0; i < startIndex.length - 1; i++) {\n      var mc = new MonotoneChain$2(mce, i);\n      var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n      this$1.events.add(insertEvent);\n      this$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.processOverlaps = function processOverlaps (start, end, ev0, si) {\n    var this$1 = this;\n\n    var mc0 = ev0.getObject();\n    for (var i = start; i < end; i++) {\n      var ev1 = this$1.events.get(i);\n      if (ev1.isInsert()) {\n        var mc1 = ev1.getObject();\n        if (!ev0.isSameLabel(ev1)) {\n          mc0.computeIntersections(mc1, si);\n          this$1.nOverlaps++;\n        }\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.addEdges = function addEdges () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var edges = arguments[0];\n      for (var i = edges.iterator(); i.hasNext();) {\n        var edge = i.next();\n        this$1.addEdge(edge, edge);\n      }\n    } else if (arguments.length === 2) {\n      var edges$1 = arguments[0];\n      var edgeSet = arguments[1];\n      for (var i$1 = edges$1.iterator(); i$1.hasNext();) {\n        var edge$1 = i$1.next();\n        this$1.addEdge(edge$1, edgeSet);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SimpleMCSweepLineIntersector.prototype.getClass = function getClass () {\n    return SimpleMCSweepLineIntersector\n  };\n\n  return SimpleMCSweepLineIntersector;\n}(EdgeSetIntersector));\n\nvar IntervalRTreeNode = function IntervalRTreeNode () {\n  this._min = Double.POSITIVE_INFINITY;\n  this._max = Double.NEGATIVE_INFINITY;\n};\n\nvar staticAccessors$45 = { NodeComparator: { configurable: true } };\nIntervalRTreeNode.prototype.getMin = function getMin () {\n  return this._min\n};\nIntervalRTreeNode.prototype.intersects = function intersects (queryMin, queryMax) {\n  if (this._min > queryMax || this._max < queryMin) { return false }\n  return true\n};\nIntervalRTreeNode.prototype.getMax = function getMax () {\n  return this._max\n};\nIntervalRTreeNode.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0))\n};\nIntervalRTreeNode.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nIntervalRTreeNode.prototype.getClass = function getClass () {\n  return IntervalRTreeNode\n};\nstaticAccessors$45.NodeComparator.get = function () { return NodeComparator };\n\nObject.defineProperties( IntervalRTreeNode, staticAccessors$45 );\n\nvar NodeComparator = function NodeComparator () {};\n\nNodeComparator.prototype.compare = function compare (o1, o2) {\n  var n1 = o1;\n  var n2 = o2;\n  var mid1 = (n1._min + n1._max) / 2;\n  var mid2 = (n2._min + n2._max) / 2;\n  if (mid1 < mid2) { return -1 }\n  if (mid1 > mid2) { return 1 }\n  return 0\n};\nNodeComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nNodeComparator.prototype.getClass = function getClass () {\n  return NodeComparator\n};\n\nvar IntervalRTreeLeafNode = (function (IntervalRTreeNode$$1) {\n  function IntervalRTreeLeafNode () {\n    IntervalRTreeNode$$1.call(this);\n    this._item = null;\n    var min = arguments[0];\n    var max = arguments[1];\n    var item = arguments[2];\n    this._min = min;\n    this._max = max;\n    this._item = item;\n  }\n\n  if ( IntervalRTreeNode$$1 ) IntervalRTreeLeafNode.__proto__ = IntervalRTreeNode$$1;\n  IntervalRTreeLeafNode.prototype = Object.create( IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype );\n  IntervalRTreeLeafNode.prototype.constructor = IntervalRTreeLeafNode;\n  IntervalRTreeLeafNode.prototype.query = function query (queryMin, queryMax, visitor) {\n    if (!this.intersects(queryMin, queryMax)) { return null }\n    visitor.visitItem(this._item);\n  };\n  IntervalRTreeLeafNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  IntervalRTreeLeafNode.prototype.getClass = function getClass () {\n    return IntervalRTreeLeafNode\n  };\n\n  return IntervalRTreeLeafNode;\n}(IntervalRTreeNode));\n\nvar IntervalRTreeBranchNode = (function (IntervalRTreeNode$$1) {\n  function IntervalRTreeBranchNode () {\n    IntervalRTreeNode$$1.call(this);\n    this._node1 = null;\n    this._node2 = null;\n    var n1 = arguments[0];\n    var n2 = arguments[1];\n    this._node1 = n1;\n    this._node2 = n2;\n    this.buildExtent(this._node1, this._node2);\n  }\n\n  if ( IntervalRTreeNode$$1 ) IntervalRTreeBranchNode.__proto__ = IntervalRTreeNode$$1;\n  IntervalRTreeBranchNode.prototype = Object.create( IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype );\n  IntervalRTreeBranchNode.prototype.constructor = IntervalRTreeBranchNode;\n  IntervalRTreeBranchNode.prototype.buildExtent = function buildExtent (n1, n2) {\n    this._min = Math.min(n1._min, n2._min);\n    this._max = Math.max(n1._max, n2._max);\n  };\n  IntervalRTreeBranchNode.prototype.query = function query (queryMin, queryMax, visitor) {\n    if (!this.intersects(queryMin, queryMax)) {\n      return null\n    }\n    if (this._node1 !== null) { this._node1.query(queryMin, queryMax, visitor); }\n    if (this._node2 !== null) { this._node2.query(queryMin, queryMax, visitor); }\n  };\n  IntervalRTreeBranchNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  IntervalRTreeBranchNode.prototype.getClass = function getClass () {\n    return IntervalRTreeBranchNode\n  };\n\n  return IntervalRTreeBranchNode;\n}(IntervalRTreeNode));\n\nvar SortedPackedIntervalRTree = function SortedPackedIntervalRTree () {\n  this._leaves = new ArrayList();\n  this._root = null;\n  this._level = 0;\n};\nSortedPackedIntervalRTree.prototype.buildTree = function buildTree () {\n    var this$1 = this;\n\n  Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n  var src = this._leaves;\n  var temp = null;\n  var dest = new ArrayList();\n  while (true) {\n    this$1.buildLevel(src, dest);\n    if (dest.size() === 1) { return dest.get(0) }\n    temp = src;\n    src = dest;\n    dest = temp;\n  }\n};\nSortedPackedIntervalRTree.prototype.insert = function insert (min, max, item) {\n  if (this._root !== null) { throw new Error('Index cannot be added to once it has been queried') }\n  this._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n};\nSortedPackedIntervalRTree.prototype.query = function query (min, max, visitor) {\n  this.init();\n  this._root.query(min, max, visitor);\n};\nSortedPackedIntervalRTree.prototype.buildRoot = function buildRoot () {\n  if (this._root !== null) { return null }\n  this._root = this.buildTree();\n};\nSortedPackedIntervalRTree.prototype.printNode = function printNode (node) {\n  System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n};\nSortedPackedIntervalRTree.prototype.init = function init () {\n  if (this._root !== null) { return null }\n  this.buildRoot();\n};\nSortedPackedIntervalRTree.prototype.buildLevel = function buildLevel (src, dest) {\n  this._level++;\n  dest.clear();\n  for (var i = 0; i < src.size(); i += 2) {\n    var n1 = src.get(i);\n    var n2 = i + 1 < src.size() ? src.get(i) : null;\n    if (n2 === null) {\n      dest.add(n1);\n    } else {\n      var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n      dest.add(node);\n    }\n  }\n};\nSortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSortedPackedIntervalRTree.prototype.getClass = function getClass () {\n  return SortedPackedIntervalRTree\n};\n\nvar ArrayListVisitor = function ArrayListVisitor () {\n  this._items = new ArrayList();\n};\nArrayListVisitor.prototype.visitItem = function visitItem (item) {\n  this._items.add(item);\n};\nArrayListVisitor.prototype.getItems = function getItems () {\n  return this._items\n};\nArrayListVisitor.prototype.interfaces_ = function interfaces_ () {\n  return [ItemVisitor]\n};\nArrayListVisitor.prototype.getClass = function getClass () {\n  return ArrayListVisitor\n};\n\nvar IndexedPointInAreaLocator = function IndexedPointInAreaLocator () {\n  this._index = null;\n  var g = arguments[0];\n  if (!hasInterface(g, Polygonal)) { throw new IllegalArgumentException('Argument must be Polygonal') }\n  this._index = new IntervalIndexedGeometry(g);\n};\n\nvar staticAccessors$44 = { SegmentVisitor: { configurable: true },IntervalIndexedGeometry: { configurable: true } };\nIndexedPointInAreaLocator.prototype.locate = function locate (p) {\n  var rcc = new RayCrossingCounter(p);\n  var visitor = new SegmentVisitor(rcc);\n  this._index.query(p.y, p.y, visitor);\n  return rcc.getLocation()\n};\nIndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_ () {\n  return [PointOnGeometryLocator]\n};\nIndexedPointInAreaLocator.prototype.getClass = function getClass () {\n  return IndexedPointInAreaLocator\n};\nstaticAccessors$44.SegmentVisitor.get = function () { return SegmentVisitor };\nstaticAccessors$44.IntervalIndexedGeometry.get = function () { return IntervalIndexedGeometry };\n\nObject.defineProperties( IndexedPointInAreaLocator, staticAccessors$44 );\n\nvar SegmentVisitor = function SegmentVisitor () {\n  this._counter = null;\n  var counter = arguments[0];\n  this._counter = counter;\n};\nSegmentVisitor.prototype.visitItem = function visitItem (item) {\n  var seg = item;\n  this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n};\nSegmentVisitor.prototype.interfaces_ = function interfaces_ () {\n  return [ItemVisitor]\n};\nSegmentVisitor.prototype.getClass = function getClass () {\n  return SegmentVisitor\n};\n\nvar IntervalIndexedGeometry = function IntervalIndexedGeometry () {\n  this._index = new SortedPackedIntervalRTree();\n  var geom = arguments[0];\n  this.init(geom);\n};\nIntervalIndexedGeometry.prototype.init = function init (geom) {\n    var this$1 = this;\n\n  var lines = LinearComponentExtracter.getLines(geom);\n  for (var i = lines.iterator(); i.hasNext();) {\n    var line = i.next();\n    var pts = line.getCoordinates();\n    this$1.addLine(pts);\n  }\n};\nIntervalIndexedGeometry.prototype.addLine = function addLine (pts) {\n    var this$1 = this;\n\n  for (var i = 1; i < pts.length; i++) {\n    var seg = new LineSegment(pts[i - 1], pts[i]);\n    var min = Math.min(seg.p0.y, seg.p1.y);\n    var max = Math.max(seg.p0.y, seg.p1.y);\n    this$1._index.insert(min, max, seg);\n  }\n};\nIntervalIndexedGeometry.prototype.query = function query () {\n  if (arguments.length === 2) {\n    var min = arguments[0];\n    var max = arguments[1];\n    var visitor = new ArrayListVisitor();\n    this._index.query(min, max, visitor);\n    return visitor.getItems()\n  } else if (arguments.length === 3) {\n    var min$1 = arguments[0];\n    var max$1 = arguments[1];\n    var visitor$1 = arguments[2];\n    this._index.query(min$1, max$1, visitor$1);\n  }\n};\nIntervalIndexedGeometry.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nIntervalIndexedGeometry.prototype.getClass = function getClass () {\n  return IntervalIndexedGeometry\n};\n\nvar GeometryGraph = (function (PlanarGraph$$1) {\n  function GeometryGraph () {\n    PlanarGraph$$1.call(this);\n    this._parentGeom = null;\n    this._lineEdgeMap = new HashMap();\n    this._boundaryNodeRule = null;\n    this._useBoundaryDeterminationRule = true;\n    this._argIndex = null;\n    this._boundaryNodes = null;\n    this._hasTooFewPoints = false;\n    this._invalidPoint = null;\n    this._areaPtLocator = null;\n    this._ptLocator = new PointLocator();\n    if (arguments.length === 2) {\n      var argIndex = arguments[0];\n      var parentGeom = arguments[1];\n      var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n      this._argIndex = argIndex;\n      this._parentGeom = parentGeom;\n      this._boundaryNodeRule = boundaryNodeRule;\n      if (parentGeom !== null) {\n        this.add(parentGeom);\n      }\n    } else if (arguments.length === 3) {\n      var argIndex$1 = arguments[0];\n      var parentGeom$1 = arguments[1];\n      var boundaryNodeRule$1 = arguments[2];\n      this._argIndex = argIndex$1;\n      this._parentGeom = parentGeom$1;\n      this._boundaryNodeRule = boundaryNodeRule$1;\n      if (parentGeom$1 !== null) {\n        this.add(parentGeom$1);\n      }\n    }\n  }\n\n  if ( PlanarGraph$$1 ) GeometryGraph.__proto__ = PlanarGraph$$1;\n  GeometryGraph.prototype = Object.create( PlanarGraph$$1 && PlanarGraph$$1.prototype );\n  GeometryGraph.prototype.constructor = GeometryGraph;\n  GeometryGraph.prototype.insertBoundaryPoint = function insertBoundaryPoint (argIndex, coord) {\n    var n = this._nodes.addNode(coord);\n    var lbl = n.getLabel();\n    var boundaryCount = 1;\n    var loc = Location.NONE;\n    loc = lbl.getLocation(argIndex, Position.ON);\n    if (loc === Location.BOUNDARY) { boundaryCount++; }\n    var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n    lbl.setLocation(argIndex, newLoc);\n  };\n  GeometryGraph.prototype.computeSelfNodes = function computeSelfNodes () {\n    if (arguments.length === 2) {\n      var li = arguments[0];\n      var computeRingSelfNodes = arguments[1];\n      return this.computeSelfNodes(li, computeRingSelfNodes, false)\n    } else if (arguments.length === 3) {\n      var li$1 = arguments[0];\n      var computeRingSelfNodes$1 = arguments[1];\n      var isDoneIfProperInt = arguments[2];\n      var si = new SegmentIntersector$2(li$1, true, false);\n      si.setIsDoneIfProperInt(isDoneIfProperInt);\n      var esi = this.createEdgeSetIntersector();\n      var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n      var computeAllSegments = computeRingSelfNodes$1 || !isRings;\n      esi.computeIntersections(this._edges, si, computeAllSegments);\n      this.addSelfIntersectionNodes(this._argIndex);\n      return si\n    }\n  };\n  GeometryGraph.prototype.computeSplitEdges = function computeSplitEdges (edgelist) {\n    for (var i = this._edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      e.eiList.addSplitEdges(edgelist);\n    }\n  };\n  GeometryGraph.prototype.computeEdgeIntersections = function computeEdgeIntersections (g, li, includeProper) {\n    var si = new SegmentIntersector$2(li, includeProper, true);\n    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n    var esi = this.createEdgeSetIntersector();\n    esi.computeIntersections(this._edges, g._edges, si);\n    return si\n  };\n  GeometryGraph.prototype.getGeometry = function getGeometry () {\n    return this._parentGeom\n  };\n  GeometryGraph.prototype.getBoundaryNodeRule = function getBoundaryNodeRule () {\n    return this._boundaryNodeRule\n  };\n  GeometryGraph.prototype.hasTooFewPoints = function hasTooFewPoints () {\n    return this._hasTooFewPoints\n  };\n  GeometryGraph.prototype.addPoint = function addPoint () {\n    if (arguments[0] instanceof Point) {\n      var p = arguments[0];\n      var coord = p.getCoordinate();\n      this.insertPoint(this._argIndex, coord, Location.INTERIOR);\n    } else if (arguments[0] instanceof Coordinate) {\n      var pt = arguments[0];\n      this.insertPoint(this._argIndex, pt, Location.INTERIOR);\n    }\n  };\n  GeometryGraph.prototype.addPolygon = function addPolygon (p) {\n    var this$1 = this;\n\n    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n    for (var i = 0; i < p.getNumInteriorRing(); i++) {\n      var hole = p.getInteriorRingN(i);\n      this$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n    }\n  };\n  GeometryGraph.prototype.addEdge = function addEdge (e) {\n    this.insertEdge(e);\n    var coord = e.getCoordinates();\n    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n    this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n  };\n  GeometryGraph.prototype.addLineString = function addLineString (line) {\n    var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n    if (coord.length < 2) {\n      this._hasTooFewPoints = true;\n      this._invalidPoint = coord[0];\n      return null\n    }\n    var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n    this._lineEdgeMap.put(line, e);\n    this.insertEdge(e);\n    Assert.isTrue(coord.length >= 2, 'found LineString with single point');\n    this.insertBoundaryPoint(this._argIndex, coord[0]);\n    this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n  };\n  GeometryGraph.prototype.getInvalidPoint = function getInvalidPoint () {\n    return this._invalidPoint\n  };\n  GeometryGraph.prototype.getBoundaryPoints = function getBoundaryPoints () {\n    var coll = this.getBoundaryNodes();\n    var pts = new Array(coll.size()).fill(null);\n    var i = 0;\n    for (var it = coll.iterator(); it.hasNext();) {\n      var node = it.next();\n      pts[i++] = node.getCoordinate().copy();\n    }\n    return pts\n  };\n  GeometryGraph.prototype.getBoundaryNodes = function getBoundaryNodes () {\n    if (this._boundaryNodes === null) { this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex); }\n    return this._boundaryNodes\n  };\n  GeometryGraph.prototype.addSelfIntersectionNode = function addSelfIntersectionNode (argIndex, coord, loc) {\n    if (this.isBoundaryNode(argIndex, coord)) { return null }\n    if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) { this.insertBoundaryPoint(argIndex, coord); } else { this.insertPoint(argIndex, coord, loc); }\n  };\n  GeometryGraph.prototype.addPolygonRing = function addPolygonRing (lr, cwLeft, cwRight) {\n    if (lr.isEmpty()) { return null }\n    var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n    if (coord.length < 4) {\n      this._hasTooFewPoints = true;\n      this._invalidPoint = coord[0];\n      return null\n    }\n    var left = cwLeft;\n    var right = cwRight;\n    if (CGAlgorithms.isCCW(coord)) {\n      left = cwRight;\n      right = cwLeft;\n    }\n    var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n    this._lineEdgeMap.put(lr, e);\n    this.insertEdge(e);\n    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n  };\n  GeometryGraph.prototype.insertPoint = function insertPoint (argIndex, coord, onLocation) {\n    var n = this._nodes.addNode(coord);\n    var lbl = n.getLabel();\n    if (lbl === null) {\n      n._label = new Label(argIndex, onLocation);\n    } else { lbl.setLocation(argIndex, onLocation); }\n  };\n  GeometryGraph.prototype.createEdgeSetIntersector = function createEdgeSetIntersector () {\n    return new SimpleMCSweepLineIntersector()\n  };\n  GeometryGraph.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes (argIndex) {\n    var this$1 = this;\n\n    for (var i = this._edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      var eLoc = e.getLabel().getLocation(argIndex);\n      for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {\n        var ei = eiIt.next();\n        this$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n      }\n    }\n  };\n  GeometryGraph.prototype.add = function add () {\n    if (arguments.length === 1) {\n      var g = arguments[0];\n      if (g.isEmpty()) { return null }\n      if (g instanceof MultiPolygon) { this._useBoundaryDeterminationRule = false; }\n      if (g instanceof Polygon) { this.addPolygon(g); }\n      else if (g instanceof LineString) { this.addLineString(g); }\n      else if (g instanceof Point) { this.addPoint(g); }\n      else if (g instanceof MultiPoint) { this.addCollection(g); }\n      else if (g instanceof MultiLineString) { this.addCollection(g); }\n      else if (g instanceof MultiPolygon) { this.addCollection(g); }\n      else if (g instanceof GeometryCollection) { this.addCollection(g); }\n      else { throw new Error(g.getClass().getName()) }\n    } else { return PlanarGraph$$1.prototype.add.apply(this, arguments) }\n  };\n  GeometryGraph.prototype.addCollection = function addCollection (gc) {\n    var this$1 = this;\n\n    for (var i = 0; i < gc.getNumGeometries(); i++) {\n      var g = gc.getGeometryN(i);\n      this$1.add(g);\n    }\n  };\n  GeometryGraph.prototype.locate = function locate (pt) {\n    if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n      if (this._areaPtLocator === null) {\n        this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n      }\n      return this._areaPtLocator.locate(pt)\n    }\n    return this._ptLocator.locate(pt, this._parentGeom)\n  };\n  GeometryGraph.prototype.findEdge = function findEdge () {\n    if (arguments.length === 1) {\n      var line = arguments[0];\n      return this._lineEdgeMap.get(line)\n    } else { return PlanarGraph$$1.prototype.findEdge.apply(this, arguments) }\n  };\n  GeometryGraph.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  GeometryGraph.prototype.getClass = function getClass () {\n    return GeometryGraph\n  };\n  GeometryGraph.determineBoundary = function determineBoundary (boundaryNodeRule, boundaryCount) {\n    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR\n  };\n\n  return GeometryGraph;\n}(PlanarGraph));\n\nvar GeometryGraphOp = function GeometryGraphOp () {\n  this._li = new RobustLineIntersector();\n  this._resultPrecisionModel = null;\n  this._arg = null;\n  if (arguments.length === 1) {\n    var g0 = arguments[0];\n    this.setComputationPrecision(g0.getPrecisionModel());\n    this._arg = new Array(1).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0);\n  } else if (arguments.length === 2) {\n    var g0$1 = arguments[0];\n    var g1 = arguments[1];\n    var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n    if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$1.getPrecisionModel()); } else { this.setComputationPrecision(g1.getPrecisionModel()); }\n    this._arg = new Array(2).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);\n    this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n  } else if (arguments.length === 3) {\n    var g0$2 = arguments[0];\n    var g1$1 = arguments[1];\n    var boundaryNodeRule$1 = arguments[2];\n    if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$2.getPrecisionModel()); } else { this.setComputationPrecision(g1$1.getPrecisionModel()); }\n    this._arg = new Array(2).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);\n    this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);\n  }\n};\nGeometryGraphOp.prototype.getArgGeometry = function getArgGeometry (i) {\n  return this._arg[i].getGeometry()\n};\nGeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision (pm) {\n  this._resultPrecisionModel = pm;\n  this._li.setPrecisionModel(this._resultPrecisionModel);\n};\nGeometryGraphOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryGraphOp.prototype.getClass = function getClass () {\n  return GeometryGraphOp\n};\n\n// operation.geometrygraph\n\nvar GeometryMapper = function GeometryMapper () {};\n\nGeometryMapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryMapper.prototype.getClass = function getClass () {\n  return GeometryMapper\n};\nGeometryMapper.map = function map () {\n  if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {\n    var geom = arguments[0];\n    var op = arguments[1];\n    var mapped = new ArrayList();\n    for (var i = 0; i < geom.getNumGeometries(); i++) {\n      var g = op.map(geom.getGeometryN(i));\n      if (g !== null) { mapped.add(g); }\n    }\n    return geom.getFactory().buildGeometry(mapped)\n  } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {\n    var geoms = arguments[0];\n    var op$1 = arguments[1];\n    var mapped$1 = new ArrayList();\n    for (var i$1 = geoms.iterator(); i$1.hasNext();) {\n      var g$1 = i$1.next();\n      var gr = op$1.map(g$1);\n      if (gr !== null) { mapped$1.add(gr); }\n    }\n    return mapped$1\n  }\n};\nGeometryMapper.MapOp = function MapOp () {};\n\nvar OverlayOp = (function (GeometryGraphOp) {\n  function OverlayOp () {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    GeometryGraphOp.call(this, g0, g1);\n    this._ptLocator = new PointLocator();\n    this._geomFact = null;\n    this._resultGeom = null;\n    this._graph = null;\n    this._edgeList = new EdgeList();\n    this._resultPolyList = new ArrayList();\n    this._resultLineList = new ArrayList();\n    this._resultPointList = new ArrayList();\n    this._graph = new PlanarGraph(new OverlayNodeFactory());\n    this._geomFact = g0.getFactory();\n  }\n\n  if ( GeometryGraphOp ) OverlayOp.__proto__ = GeometryGraphOp;\n  OverlayOp.prototype = Object.create( GeometryGraphOp && GeometryGraphOp.prototype );\n  OverlayOp.prototype.constructor = OverlayOp;\n  OverlayOp.prototype.insertUniqueEdge = function insertUniqueEdge (e) {\n    var existingEdge = this._edgeList.findEqualEdge(e);\n    if (existingEdge !== null) {\n      var existingLabel = existingEdge.getLabel();\n      var labelToMerge = e.getLabel();\n      if (!existingEdge.isPointwiseEqual(e)) {\n        labelToMerge = new Label(e.getLabel());\n        labelToMerge.flip();\n      }\n      var depth = existingEdge.getDepth();\n      if (depth.isNull()) {\n        depth.add(existingLabel);\n      }\n      depth.add(labelToMerge);\n      existingLabel.merge(labelToMerge);\n    } else {\n      this._edgeList.add(e);\n    }\n  };\n  OverlayOp.prototype.getGraph = function getGraph () {\n    return this._graph\n  };\n  OverlayOp.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges () {\n    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n      var de = it.next();\n      var sym = de.getSym();\n      if (de.isInResult() && sym.isInResult()) {\n        de.setInResult(false);\n        sym.setInResult(false);\n      }\n    }\n  };\n  OverlayOp.prototype.isCoveredByLA = function isCoveredByLA (coord) {\n    if (this.isCovered(coord, this._resultLineList)) { return true }\n    if (this.isCovered(coord, this._resultPolyList)) { return true }\n    return false\n  };\n  OverlayOp.prototype.computeGeometry = function computeGeometry (resultPointList, resultLineList, resultPolyList, opcode) {\n    var geomList = new ArrayList();\n    geomList.addAll(resultPointList);\n    geomList.addAll(resultLineList);\n    geomList.addAll(resultPolyList);\n    if (geomList.isEmpty()) { return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) }\n    return this._geomFact.buildGeometry(geomList)\n  };\n  OverlayOp.prototype.mergeSymLabels = function mergeSymLabels () {\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      node.getEdges().mergeSymLabels();\n    }\n  };\n  OverlayOp.prototype.isCovered = function isCovered (coord, geomList) {\n    var this$1 = this;\n\n    for (var it = geomList.iterator(); it.hasNext();) {\n      var geom = it.next();\n      var loc = this$1._ptLocator.locate(coord, geom);\n      if (loc !== Location.EXTERIOR) { return true }\n    }\n    return false\n  };\n  OverlayOp.prototype.replaceCollapsedEdges = function replaceCollapsedEdges () {\n    var newEdges = new ArrayList();\n    for (var it = this._edgeList.iterator(); it.hasNext();) {\n      var e = it.next();\n      if (e.isCollapsed()) {\n        it.remove();\n        newEdges.add(e.getCollapsedEdge());\n      }\n    }\n    this._edgeList.addAll(newEdges);\n  };\n  OverlayOp.prototype.updateNodeLabelling = function updateNodeLabelling () {\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      var lbl = node.getEdges().getLabel();\n      node.getLabel().merge(lbl);\n    }\n  };\n  OverlayOp.prototype.getResultGeometry = function getResultGeometry (overlayOpCode) {\n    this.computeOverlay(overlayOpCode);\n    return this._resultGeom\n  };\n  OverlayOp.prototype.insertUniqueEdges = function insertUniqueEdges (edges) {\n    var this$1 = this;\n\n    for (var i = edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      this$1.insertUniqueEdge(e);\n    }\n  };\n  OverlayOp.prototype.computeOverlay = function computeOverlay (opCode) {\n    this.copyPoints(0);\n    this.copyPoints(1);\n    this._arg[0].computeSelfNodes(this._li, false);\n    this._arg[1].computeSelfNodes(this._li, false);\n    this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n    var baseSplitEdges = new ArrayList();\n    this._arg[0].computeSplitEdges(baseSplitEdges);\n    this._arg[1].computeSplitEdges(baseSplitEdges);\n    // const splitEdges = baseSplitEdges\n    this.insertUniqueEdges(baseSplitEdges);\n    this.computeLabelsFromDepths();\n    this.replaceCollapsedEdges();\n    EdgeNodingValidator.checkValid(this._edgeList.getEdges());\n    this._graph.addEdges(this._edgeList.getEdges());\n    this.computeLabelling();\n    this.labelIncompleteNodes();\n    this.findResultAreaEdges(opCode);\n    this.cancelDuplicateResultEdges();\n    var polyBuilder = new PolygonBuilder(this._geomFact);\n    polyBuilder.add(this._graph);\n    this._resultPolyList = polyBuilder.getPolygons();\n    var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n    this._resultLineList = lineBuilder.build(opCode);\n    var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n    this._resultPointList = pointBuilder.build(opCode);\n    this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n  };\n  OverlayOp.prototype.labelIncompleteNode = function labelIncompleteNode (n, targetIndex) {\n    var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n    n.getLabel().setLocation(targetIndex, loc);\n  };\n  OverlayOp.prototype.copyPoints = function copyPoints (argIndex) {\n    var this$1 = this;\n\n    for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n      var graphNode = i.next();\n      var newNode = this$1._graph.addNode(graphNode.getCoordinate());\n      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n    }\n  };\n  OverlayOp.prototype.findResultAreaEdges = function findResultAreaEdges (opCode) {\n    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n        de.setInResult(true);\n      }\n    }\n  };\n  OverlayOp.prototype.computeLabelsFromDepths = function computeLabelsFromDepths () {\n    for (var it = this._edgeList.iterator(); it.hasNext();) {\n      var e = it.next();\n      var lbl = e.getLabel();\n      var depth = e.getDepth();\n      if (!depth.isNull()) {\n        depth.normalize();\n        for (var i = 0; i < 2; i++) {\n          if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n            if (depth.getDelta(i) === 0) {\n              lbl.toLine(i);\n            } else {\n              Assert.isTrue(!depth.isNull(i, Position.LEFT), 'depth of LEFT side has not been initialized');\n              lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n              Assert.isTrue(!depth.isNull(i, Position.RIGHT), 'depth of RIGHT side has not been initialized');\n              lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n            }\n          }\n        }\n      }\n    }\n  };\n  OverlayOp.prototype.computeLabelling = function computeLabelling () {\n    var this$1 = this;\n\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      node.getEdges().computeLabelling(this$1._arg);\n    }\n    this.mergeSymLabels();\n    this.updateNodeLabelling();\n  };\n  OverlayOp.prototype.labelIncompleteNodes = function labelIncompleteNodes () {\n    var this$1 = this;\n\n    // let nodeCount = 0\n    for (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {\n      var n = ni.next();\n      var label = n.getLabel();\n      if (n.isIsolated()) {\n        // nodeCount++\n        if (label.isNull(0)) { this$1.labelIncompleteNode(n, 0); } else { this$1.labelIncompleteNode(n, 1); }\n      }\n      n.getEdges().updateLabelling(label);\n    }\n  };\n  OverlayOp.prototype.isCoveredByA = function isCoveredByA (coord) {\n    if (this.isCovered(coord, this._resultPolyList)) { return true }\n    return false\n  };\n  OverlayOp.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  OverlayOp.prototype.getClass = function getClass () {\n    return OverlayOp\n  };\n\n  return OverlayOp;\n}(GeometryGraphOp));\n\nOverlayOp.overlayOp = function (geom0, geom1, opCode) {\n  var gov = new OverlayOp(geom0, geom1);\n  var geomOv = gov.getResultGeometry(opCode);\n  return geomOv\n};\nOverlayOp.intersection = function (g, other) {\n  if (g.isEmpty() || other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory()) }\n  if (g.isGeometryCollection()) {\n    var g2 = other;\n    return GeometryCollectionMapper.map(g, {\n      interfaces_: function () {\n        return [GeometryMapper.MapOp]\n      },\n      map: function (g) {\n        return g.intersection(g2)\n      }\n    })\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION)\n};\nOverlayOp.symDifference = function (g, other) {\n  if (g.isEmpty() || other.isEmpty()) {\n    if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory()) }\n    if (g.isEmpty()) { return other.copy() }\n    if (other.isEmpty()) { return g.copy() }\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE)\n};\nOverlayOp.resultDimension = function (opCode, g0, g1) {\n  var dim0 = g0.getDimension();\n  var dim1 = g1.getDimension();\n  var resultDimension = -1;\n  switch (opCode) {\n    case OverlayOp.INTERSECTION:\n      resultDimension = Math.min(dim0, dim1);\n      break\n    case OverlayOp.UNION:\n      resultDimension = Math.max(dim0, dim1);\n      break\n    case OverlayOp.DIFFERENCE:\n      resultDimension = dim0;\n      break\n    case OverlayOp.SYMDIFFERENCE:\n      resultDimension = Math.max(dim0, dim1);\n      break\n    default:\n  }\n  return resultDimension\n};\nOverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n  var result = null;\n  switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n    case -1:\n      result = geomFact.createGeometryCollection(new Array(0).fill(null));\n      break\n    case 0:\n      result = geomFact.createPoint();\n      break\n    case 1:\n      result = geomFact.createLineString();\n      break\n    case 2:\n      result = geomFact.createPolygon();\n      break\n    default:\n  }\n  return result\n};\nOverlayOp.difference = function (g, other) {\n  if (g.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory()) }\n  if (other.isEmpty()) { return g.copy() }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE)\n};\nOverlayOp.isResultOfOp = function () {\n  if (arguments.length === 2) {\n    var label = arguments[0];\n    var opCode = arguments[1];\n    var loc0 = label.getLocation(0);\n    var loc1 = label.getLocation(1);\n    return OverlayOp.isResultOfOp(loc0, loc1, opCode)\n  } else if (arguments.length === 3) {\n    var loc0$1 = arguments[0];\n    var loc1$1 = arguments[1];\n    var overlayOpCode = arguments[2];\n    if (loc0$1 === Location.BOUNDARY) { loc0$1 = Location.INTERIOR; }\n    if (loc1$1 === Location.BOUNDARY) { loc1$1 = Location.INTERIOR; }\n    switch (overlayOpCode) {\n      case OverlayOp.INTERSECTION:\n        return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR\n      case OverlayOp.UNION:\n        return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR\n      case OverlayOp.DIFFERENCE:\n        return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR\n      case OverlayOp.SYMDIFFERENCE:\n        return (loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR) || (loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR)\n      default:\n    }\n    return false\n  }\n};\nOverlayOp.INTERSECTION = 1;\nOverlayOp.UNION = 2;\nOverlayOp.DIFFERENCE = 3;\nOverlayOp.SYMDIFFERENCE = 4;\n\nvar FuzzyPointLocator = function FuzzyPointLocator () {\n  this._g = null;\n  this._boundaryDistanceTolerance = null;\n  this._linework = null;\n  this._ptLocator = new PointLocator();\n  this._seg = new LineSegment();\n  var g = arguments[0];\n  var boundaryDistanceTolerance = arguments[1];\n  this._g = g;\n  this._boundaryDistanceTolerance = boundaryDistanceTolerance;\n  this._linework = this.extractLinework(g);\n};\nFuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary (pt) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._linework.getNumGeometries(); i++) {\n    var line = this$1._linework.getGeometryN(i);\n    var seq = line.getCoordinateSequence();\n    for (var j = 0; j < seq.size() - 1; j++) {\n      seq.getCoordinate(j, this$1._seg.p0);\n      seq.getCoordinate(j + 1, this$1._seg.p1);\n      var dist = this$1._seg.distance(pt);\n      if (dist <= this$1._boundaryDistanceTolerance) { return true }\n    }\n  }\n  return false\n};\nFuzzyPointLocator.prototype.getLocation = function getLocation (pt) {\n  if (this.isWithinToleranceOfBoundary(pt)) { return Location.BOUNDARY }\n  return this._ptLocator.locate(pt, this._g)\n};\nFuzzyPointLocator.prototype.extractLinework = function extractLinework (g) {\n  var extracter = new PolygonalLineworkExtracter();\n  g.apply(extracter);\n  var linework = extracter.getLinework();\n  var lines = GeometryFactory.toLineStringArray(linework);\n  return g.getFactory().createMultiLineString(lines)\n};\nFuzzyPointLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nFuzzyPointLocator.prototype.getClass = function getClass () {\n  return FuzzyPointLocator\n};\n\nvar PolygonalLineworkExtracter = function PolygonalLineworkExtracter () {\n  this._linework = null;\n  this._linework = new ArrayList();\n};\nPolygonalLineworkExtracter.prototype.getLinework = function getLinework () {\n  return this._linework\n};\nPolygonalLineworkExtracter.prototype.filter = function filter (g) {\n    var this$1 = this;\n\n  if (g instanceof Polygon) {\n    var poly = g;\n    this._linework.add(poly.getExteriorRing());\n    for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n      this$1._linework.add(poly.getInteriorRingN(i));\n    }\n  }\n};\nPolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPolygonalLineworkExtracter.prototype.getClass = function getClass () {\n  return PolygonalLineworkExtracter\n};\n\nvar OffsetPointGenerator = function OffsetPointGenerator () {\n  this._g = null;\n  this._doLeft = true;\n  this._doRight = true;\n  var g = arguments[0];\n  this._g = g;\n};\nOffsetPointGenerator.prototype.extractPoints = function extractPoints (line, offsetDistance, offsetPts) {\n    var this$1 = this;\n\n  var pts = line.getCoordinates();\n  for (var i = 0; i < pts.length - 1; i++) {\n    this$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);\n  }\n};\nOffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate (doLeft, doRight) {\n  this._doLeft = doLeft;\n  this._doRight = doRight;\n};\nOffsetPointGenerator.prototype.getPoints = function getPoints (offsetDistance) {\n    var this$1 = this;\n\n  var offsetPts = new ArrayList();\n  var lines = LinearComponentExtracter.getLines(this._g);\n  for (var i = lines.iterator(); i.hasNext();) {\n    var line = i.next();\n    this$1.extractPoints(line, offsetDistance, offsetPts);\n  }\n  return offsetPts\n};\nOffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints (p0, p1, offsetDistance, offsetPts) {\n  var dx = p1.x - p0.x;\n  var dy = p1.y - p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = offsetDistance * dx / len;\n  var uy = offsetDistance * dy / len;\n  var midX = (p1.x + p0.x) / 2;\n  var midY = (p1.y + p0.y) / 2;\n  if (this._doLeft) {\n    var offsetLeft = new Coordinate(midX - uy, midY + ux);\n    offsetPts.add(offsetLeft);\n  }\n  if (this._doRight) {\n    var offsetRight = new Coordinate(midX + uy, midY - ux);\n    offsetPts.add(offsetRight);\n  }\n};\nOffsetPointGenerator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetPointGenerator.prototype.getClass = function getClass () {\n  return OffsetPointGenerator\n};\n\nvar OverlayResultValidator = function OverlayResultValidator () {\n  this._geom = null;\n  this._locFinder = null;\n  this._location = new Array(3).fill(null);\n  this._invalidLocation = null;\n  this._boundaryDistanceTolerance = OverlayResultValidator.TOLERANCE;\n  this._testCoords = new ArrayList();\n  var a = arguments[0];\n  var b = arguments[1];\n  var result = arguments[2];\n  this._boundaryDistanceTolerance = OverlayResultValidator.computeBoundaryDistanceTolerance(a, b);\n  this._geom = [a, b, result];\n  this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];\n};\n\nvar staticAccessors$46 = { TOLERANCE: { configurable: true } };\nOverlayResultValidator.prototype.reportResult = function reportResult (overlayOp, location, expectedInterior) {\n  System.out.println('Overlay result invalid - A:' + Location.toLocationSymbol(location[0]) + ' B:' + Location.toLocationSymbol(location[1]) + ' expected:' + (expectedInterior ? 'i' : 'e') + ' actual:' + Location.toLocationSymbol(location[2]));\n};\nOverlayResultValidator.prototype.isValid = function isValid (overlayOp) {\n  this.addTestPts(this._geom[0]);\n  this.addTestPts(this._geom[1]);\n  var isValid = this.checkValid(overlayOp);\n  return isValid\n};\nOverlayResultValidator.prototype.checkValid = function checkValid () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var overlayOp = arguments[0];\n    for (var i = 0; i < this._testCoords.size(); i++) {\n      var pt = this$1._testCoords.get(i);\n      if (!this$1.checkValid(overlayOp, pt)) {\n        this$1._invalidLocation = pt;\n        return false\n      }\n    }\n    return true\n  } else if (arguments.length === 2) {\n    var overlayOp$1 = arguments[0];\n    var pt$1 = arguments[1];\n    this._location[0] = this._locFinder[0].getLocation(pt$1);\n    this._location[1] = this._locFinder[1].getLocation(pt$1);\n    this._location[2] = this._locFinder[2].getLocation(pt$1);\n    if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) { return true }\n    return this.isValidResult(overlayOp$1, this._location)\n  }\n};\nOverlayResultValidator.prototype.addTestPts = function addTestPts (g) {\n  var ptGen = new OffsetPointGenerator(g);\n  this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));\n};\nOverlayResultValidator.prototype.isValidResult = function isValidResult (overlayOp, location) {\n  var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp);\n  var resultInInterior = location[2] === Location.INTERIOR;\n  var isValid = !(expectedInterior ^ resultInInterior);\n  if (!isValid) { this.reportResult(overlayOp, location, expectedInterior); }\n  return isValid\n};\nOverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation () {\n  return this._invalidLocation\n};\nOverlayResultValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOverlayResultValidator.prototype.getClass = function getClass () {\n  return OverlayResultValidator\n};\nOverlayResultValidator.hasLocation = function hasLocation (location, loc) {\n  for (var i = 0; i < 3; i++) {\n    if (location[i] === loc) { return true }\n  }\n  return false\n};\nOverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance (g0, g1) {\n  return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1))\n};\nOverlayResultValidator.isValid = function isValid (a, b, overlayOp, result) {\n  var validator = new OverlayResultValidator(a, b, result);\n  return validator.isValid(overlayOp)\n};\nstaticAccessors$46.TOLERANCE.get = function () { return 0.000001 };\n\nObject.defineProperties( OverlayResultValidator, staticAccessors$46 );\n\n// operation.overlay\n\nvar GeometryCombiner = function GeometryCombiner (geoms) {\n  this._geomFactory = null;\n  this._skipEmpty = false;\n  this._inputGeoms = null;\n  this._geomFactory = GeometryCombiner.extractFactory(geoms);\n  this._inputGeoms = geoms;\n};\nGeometryCombiner.prototype.extractElements = function extractElements (geom, elems) {\n    var this$1 = this;\n\n  if (geom === null) { return null }\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var elemGeom = geom.getGeometryN(i);\n    if (this$1._skipEmpty && elemGeom.isEmpty()) { continue }\n    elems.add(elemGeom);\n  }\n};\nGeometryCombiner.prototype.combine = function combine () {\n    var this$1 = this;\n\n  var elems = new ArrayList();\n  for (var i = this._inputGeoms.iterator(); i.hasNext();) {\n    var g = i.next();\n    this$1.extractElements(g, elems);\n  }\n  if (elems.size() === 0) {\n    if (this._geomFactory !== null) {\n      return this._geomFactory.createGeometryCollection(null)\n    }\n    return null\n  }\n  return this._geomFactory.buildGeometry(elems)\n};\nGeometryCombiner.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryCombiner.prototype.getClass = function getClass () {\n  return GeometryCombiner\n};\nGeometryCombiner.combine = function combine () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    var combiner = new GeometryCombiner(geoms);\n    return combiner.combine()\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n    return combiner$1.combine()\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var g2 = arguments[2];\n    var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));\n    return combiner$2.combine()\n  }\n};\nGeometryCombiner.extractFactory = function extractFactory (geoms) {\n  if (geoms.isEmpty()) { return null }\n  return geoms.iterator().next().getFactory()\n};\nGeometryCombiner.createList = function createList () {\n  if (arguments.length === 2) {\n    var obj0 = arguments[0];\n    var obj1 = arguments[1];\n    var list = new ArrayList();\n    list.add(obj0);\n    list.add(obj1);\n    return list\n  } else if (arguments.length === 3) {\n    var obj0$1 = arguments[0];\n    var obj1$1 = arguments[1];\n    var obj2 = arguments[2];\n    var list$1 = new ArrayList();\n    list$1.add(obj0$1);\n    list$1.add(obj1$1);\n    list$1.add(obj2);\n    return list$1\n  }\n};\n\nvar CascadedPolygonUnion = function CascadedPolygonUnion () {\n  this._inputPolys = null;\n  this._geomFactory = null;\n  var polys = arguments[0];\n  this._inputPolys = polys;\n  if (this._inputPolys === null) { this._inputPolys = new ArrayList(); }\n};\n\nvar staticAccessors$47 = { STRTREE_NODE_CAPACITY: { configurable: true } };\nCascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries (geomTree) {\n    var this$1 = this;\n\n  var geoms = new ArrayList();\n  for (var i = geomTree.iterator(); i.hasNext();) {\n    var o = i.next();\n    var geom = null;\n    if (hasInterface(o, List)) {\n      geom = this$1.unionTree(o);\n    } else if (o instanceof Geometry) {\n      geom = o;\n    }\n    geoms.add(geom);\n  }\n  return geoms\n};\nCascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope (env, geom, disjointGeoms) {\n  var intersectingGeoms = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var elem = geom.getGeometryN(i);\n    if (elem.getEnvelopeInternal().intersects(env)) { intersectingGeoms.add(elem); } else { disjointGeoms.add(elem); }\n  }\n  return this._geomFactory.buildGeometry(intersectingGeoms)\n};\nCascadedPolygonUnion.prototype.unionOptimized = function unionOptimized (g0, g1) {\n  var g0Env = g0.getEnvelopeInternal();\n  var g1Env = g1.getEnvelopeInternal();\n  if (!g0Env.intersects(g1Env)) {\n    var combo = GeometryCombiner.combine(g0, g1);\n    return combo\n  }\n  if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) { return this.unionActual(g0, g1) }\n  var commonEnv = g0Env.intersection(g1Env);\n  return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv)\n};\nCascadedPolygonUnion.prototype.union = function union () {\n  if (this._inputPolys === null) { throw new Error('union() method cannot be called twice') }\n  if (this._inputPolys.isEmpty()) { return null }\n  this._geomFactory = this._inputPolys.iterator().next().getFactory();\n  var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n  for (var i = this._inputPolys.iterator(); i.hasNext();) {\n    var item = i.next();\n    index.insert(item.getEnvelopeInternal(), item);\n  }\n  this._inputPolys = null;\n  var itemTree = index.itemsTree();\n  var unionAll = this.unionTree(itemTree);\n  return unionAll\n};\nCascadedPolygonUnion.prototype.binaryUnion = function binaryUnion () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    return this.binaryUnion(geoms, 0, geoms.size())\n  } else if (arguments.length === 3) {\n    var geoms$1 = arguments[0];\n    var start = arguments[1];\n    var end = arguments[2];\n    if (end - start <= 1) {\n      var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start);\n      return this.unionSafe(g0, null)\n    } else if (end - start === 2) {\n      return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start), CascadedPolygonUnion.getGeometry(geoms$1, start + 1))\n    } else {\n      var mid = Math.trunc((end + start) / 2);\n      var g0$1 = this.binaryUnion(geoms$1, start, mid);\n      var g1 = this.binaryUnion(geoms$1, mid, end);\n      return this.unionSafe(g0$1, g1)\n    }\n  }\n};\nCascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion (geoms) {\n  var union = null;\n  for (var i = geoms.iterator(); i.hasNext();) {\n    var g = i.next();\n    if (union === null) { union = g.copy(); } else { union = union.union(g); }\n  }\n  return union\n};\nCascadedPolygonUnion.prototype.unionSafe = function unionSafe (g0, g1) {\n  if (g0 === null && g1 === null) { return null }\n  if (g0 === null) { return g1.copy() }\n  if (g1 === null) { return g0.copy() }\n  return this.unionOptimized(g0, g1)\n};\nCascadedPolygonUnion.prototype.unionActual = function unionActual (g0, g1) {\n  return CascadedPolygonUnion.restrictToPolygons(g0.union(g1))\n};\nCascadedPolygonUnion.prototype.unionTree = function unionTree (geomTree) {\n  var geoms = this.reduceToGeometries(geomTree);\n  var union = this.binaryUnion(geoms);\n  return union\n};\nCascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection (g0, g1, common) {\n  var disjointPolys = new ArrayList();\n  var g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n  var g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n  var union = this.unionActual(g0Int, g1Int);\n  disjointPolys.add(union);\n  var overallUnion = GeometryCombiner.combine(disjointPolys);\n  return overallUnion\n};\nCascadedPolygonUnion.prototype.bufferUnion = function bufferUnion () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    var factory = geoms.get(0).getFactory();\n    var gColl = factory.buildGeometry(geoms);\n    var unionAll = gColl.buffer(0.0);\n    return unionAll\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var factory$1 = g0.getFactory();\n    var gColl$1 = factory$1.createGeometryCollection([g0, g1]);\n    var unionAll$1 = gColl$1.buffer(0.0);\n    return unionAll$1\n  }\n};\nCascadedPolygonUnion.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCascadedPolygonUnion.prototype.getClass = function getClass () {\n  return CascadedPolygonUnion\n};\nCascadedPolygonUnion.restrictToPolygons = function restrictToPolygons (g) {\n  if (hasInterface(g, Polygonal)) {\n    return g\n  }\n  var polygons = PolygonExtracter.getPolygons(g);\n  if (polygons.size() === 1) { return polygons.get(0) }\n  return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons))\n};\nCascadedPolygonUnion.getGeometry = function getGeometry (list, index) {\n  if (index >= list.size()) { return null }\n  return list.get(index)\n};\nCascadedPolygonUnion.union = function union (polys) {\n  var op = new CascadedPolygonUnion(polys);\n  return op.union()\n};\nstaticAccessors$47.STRTREE_NODE_CAPACITY.get = function () { return 4 };\n\nObject.defineProperties( CascadedPolygonUnion, staticAccessors$47 );\n\nvar UnionOp = function UnionOp () {};\n\nUnionOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nUnionOp.prototype.getClass = function getClass () {\n  return UnionOp\n};\nUnionOp.union = function union (g, other) {\n  if (g.isEmpty() || other.isEmpty()) {\n    if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory()) }\n    if (g.isEmpty()) { return other.copy() }\n    if (other.isEmpty()) { return g.copy() }\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION)\n};\n\n// operation.union\n\n// operation\n\n/**\n * Polyfill for IE support\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHVyZi1qc3RzL2pzdHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsMEJBQTBCLGFBQWE7O0FBRXZDLG9DQUFvQztBQUNwQywwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDhDQUE4QztBQUM5QyxnREFBZ0Q7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlCQUF5QixvQkFBb0IscUJBQXFCLG9CQUFvQixrQkFBa0Isb0JBQW9CLE1BQU0sb0JBQW9CLE1BQU0sb0JBQW9CLE1BQU07QUFDOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QixP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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQSwwQkFBMEIsb0JBQW9CLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy90dXJmLWpzdHMvanN0cy5tanM/NWMyYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBQb2x5ZmlsbCBzZXJ2aWNlIHYzLjEzLjBcbiAqIEZvciBkZXRhaWxlZCBjcmVkaXRzIGFuZCBsaWNlbmNlIGluZm9ybWF0aW9uIHNlZSBodHRwOi8vZ2l0aHViLmNvbS9maW5hbmNpYWwtdGltZXMvcG9seWZpbGwtc2VydmljZVxuICpcbiAqIC0gQXJyYXkucHJvdG90eXBlLmZpbGwsIExpY2Vuc2U6IENDMCAqL1xuXG5pZiAoISgnZmlsbCcgaW4gQXJyYXkucHJvdG90eXBlKSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXJyYXkucHJvdG90eXBlLCAnZmlsbCcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGwgKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0aGlzICsgJyBpcyBub3QgYW4gb2JqZWN0JylcbiAgICAgIH1cblxuICAgICAgdmFyIGFycmF5TGlrZSA9IE9iamVjdCh0aGlzKTtcblxuICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGgubWluKGFycmF5TGlrZS5sZW5ndGgsIDkwMDcxOTkyNTQ3NDA5OTEpLCAwKSB8fCAwO1xuXG4gICAgICB2YXIgcmVsYXRpdmVTdGFydCA9IDEgaW4gYXJndW1lbnRzID8gcGFyc2VJbnQoTnVtYmVyKGFyZ3VtZW50c1sxXSksIDEwKSB8fCAwIDogMDtcblxuICAgICAgcmVsYXRpdmVTdGFydCA9IHJlbGF0aXZlU3RhcnQgPCAwID8gTWF0aC5tYXgobGVuZ3RoICsgcmVsYXRpdmVTdGFydCwgMCkgOiBNYXRoLm1pbihyZWxhdGl2ZVN0YXJ0LCBsZW5ndGgpO1xuXG4gICAgICB2YXIgcmVsYXRpdmVFbmQgPSAyIGluIGFyZ3VtZW50cyAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IHBhcnNlSW50KE51bWJlcihhcmd1bWVudHNbMl0pLCAxMCkgfHwgMCA6IGxlbmd0aDtcblxuICAgICAgcmVsYXRpdmVFbmQgPSByZWxhdGl2ZUVuZCA8IDAgPyBNYXRoLm1heChsZW5ndGggKyBhcmd1bWVudHNbMl0sIDApIDogTWF0aC5taW4ocmVsYXRpdmVFbmQsIGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlIChyZWxhdGl2ZVN0YXJ0IDwgcmVsYXRpdmVFbmQpIHtcbiAgICAgICAgYXJyYXlMaWtlW3JlbGF0aXZlU3RhcnRdID0gdmFsdWU7XG5cbiAgICAgICAgKytyZWxhdGl2ZVN0YXJ0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXlMaWtlXG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgSUUgc3VwcG9ydFxuICovXG5OdW1iZXIuaXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKVxufTtcblxuTnVtYmVyLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiZcbiAgaXNGaW5pdGUodmFsKSAmJlxuICBNYXRoLmZsb29yKHZhbCkgPT09IHZhbFxufTtcblxuTnVtYmVyLnBhcnNlRmxvYXQgPSBOdW1iZXIucGFyc2VGbG9hdCB8fCBwYXJzZUZsb2F0O1xuXG5OdW1iZXIuaXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufTtcblxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgSUUgc3VwcG9ydFxuICovXG5NYXRoLnRydW5jID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geCA8IDAgPyBNYXRoLmNlaWwoeCkgOiBNYXRoLmZsb29yKHgpXG59O1xuXG52YXIgTnVtYmVyVXRpbCA9IGZ1bmN0aW9uIE51bWJlclV0aWwgKCkge307XG5cbk51bWJlclV0aWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5OdW1iZXJVdGlsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE51bWJlclV0aWxcbn07XG5OdW1iZXJVdGlsLnByb3RvdHlwZS5lcXVhbHNXaXRoVG9sZXJhbmNlID0gZnVuY3Rpb24gZXF1YWxzV2l0aFRvbGVyYW5jZSAoeDEsIHgyLCB0b2xlcmFuY2UpIHtcbiAgcmV0dXJuIE1hdGguYWJzKHgxIC0geDIpIDw9IHRvbGVyYW5jZVxufTtcblxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoRXJyb3IpIHtcblx0ZnVuY3Rpb24gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uIChtZXNzYWdlKSB7XG5cdFx0RXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSAnSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uJztcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuXHR9XG5cblx0aWYgKCBFcnJvciApIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbi5fX3Byb3RvX18gPSBFcnJvcjtcblx0SWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVycm9yICYmIEVycm9yLnByb3RvdHlwZSApO1xuXHRJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xuXG5cdHJldHVybiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb247XG59KEVycm9yKSk7XG5cbnZhciBEb3VibGUgPSBmdW5jdGlvbiBEb3VibGUgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMSA9IHsgTUFYX1ZBTFVFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkRvdWJsZS5pc05hTiA9IGZ1bmN0aW9uIGlzTmFOIChuKSB7IHJldHVybiBOdW1iZXIuaXNOYU4obikgfTtcbkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzID0gZnVuY3Rpb24gZG91YmxlVG9Mb25nQml0cyAobikgeyByZXR1cm4gbiB9O1xuRG91YmxlLmxvbmdCaXRzVG9Eb3VibGUgPSBmdW5jdGlvbiBsb25nQml0c1RvRG91YmxlIChuKSB7IHJldHVybiBuIH07XG5Eb3VibGUuaXNJbmZpbml0ZSA9IGZ1bmN0aW9uIGlzSW5maW5pdGUgKG4pIHsgcmV0dXJuICFOdW1iZXIuaXNGaW5pdGUobikgfTtcbnN0YXRpY0FjY2Vzc29ycyQxLk1BWF9WQUxVRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEb3VibGUsIHN0YXRpY0FjY2Vzc29ycyQxICk7XG5cbnZhciBDb21wYXJhYmxlID0gZnVuY3Rpb24gQ29tcGFyYWJsZSAoKSB7fTtcblxudmFyIENsb25hYmxlID0gZnVuY3Rpb24gQ2xvbmFibGUgKCkge307XG5cbnZhciBDb21wYXJhdG9yID0gZnVuY3Rpb24gQ29tcGFyYXRvciAoKSB7fTtcblxuZnVuY3Rpb24gU2VyaWFsaXphYmxlICgpIHt9XG5cbi8vIGltcG9ydCBBc3NlcnQgZnJvbSAnLi4vdXRpbC9Bc3NlcnQnXG5cbnZhciBDb29yZGluYXRlID0gZnVuY3Rpb24gQ29vcmRpbmF0ZSAoKSB7XG4gIHRoaXMueCA9IG51bGw7XG4gIHRoaXMueSA9IG51bGw7XG4gIHRoaXMueiA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy54ID0gMC4wO1xuICAgIHRoaXMueSA9IDAuMDtcbiAgICB0aGlzLnogPSBDb29yZGluYXRlLk5VTExfT1JESU5BVEU7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBjID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMueCA9IGMueDtcbiAgICB0aGlzLnkgPSBjLnk7XG4gICAgdGhpcy56ID0gYy56O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0aGlzLnggPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy55ID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMueiA9IENvb3JkaW5hdGUuTlVMTF9PUkRJTkFURTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdGhpcy54ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMueSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLnogPSBhcmd1bWVudHNbMl07XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IERpbWVuc2lvbmFsQ29tcGFyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5VTExfT1JESU5BVEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sWDogeyBjb25maWd1cmFibGU6IHRydWUgfSxZOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFo6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLnNldE9yZGluYXRlID0gZnVuY3Rpb24gc2V0T3JkaW5hdGUgKG9yZGluYXRlSW5kZXgsIHZhbHVlKSB7XG4gIHN3aXRjaCAob3JkaW5hdGVJbmRleCkge1xuICAgIGNhc2UgQ29vcmRpbmF0ZS5YOlxuICAgICAgdGhpcy54ID0gdmFsdWU7XG4gICAgICBicmVha1xuICAgIGNhc2UgQ29vcmRpbmF0ZS5ZOlxuICAgICAgdGhpcy55ID0gdmFsdWU7XG4gICAgICBicmVha1xuICAgIGNhc2UgQ29vcmRpbmF0ZS5aOlxuICAgICAgdGhpcy56ID0gdmFsdWU7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdJbnZhbGlkIG9yZGluYXRlIGluZGV4OiAnICsgb3JkaW5hdGVJbmRleClcbiAgfVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmVxdWFsczJEID0gZnVuY3Rpb24gZXF1YWxzMkQgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodGhpcy54ICE9PSBvdGhlci54KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHRoaXMueSAhPT0gb3RoZXIueSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBjID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKCFOdW1iZXJVdGlsLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy54LCBjLngsIHRvbGVyYW5jZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAoIU51bWJlclV0aWwuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnksIGMueSwgdG9sZXJhbmNlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5nZXRPcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldE9yZGluYXRlIChvcmRpbmF0ZUluZGV4KSB7XG4gIHN3aXRjaCAob3JkaW5hdGVJbmRleCkge1xuICAgIGNhc2UgQ29vcmRpbmF0ZS5YOlxuICAgICAgcmV0dXJuIHRoaXMueFxuICAgIGNhc2UgQ29vcmRpbmF0ZS5ZOlxuICAgICAgcmV0dXJuIHRoaXMueVxuICAgIGNhc2UgQ29vcmRpbmF0ZS5aOlxuICAgICAgcmV0dXJuIHRoaXMuelxuICAgIGRlZmF1bHQ6XG4gIH1cbiAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogJyArIG9yZGluYXRlSW5kZXgpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZXF1YWxzM0QgPSBmdW5jdGlvbiBlcXVhbHMzRCAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXIueCAmJlxuICAgICAgICAgdGhpcy55ID09PSBvdGhlci55ICYmXG4gICAgICAgICAoKHRoaXMueiA9PT0gb3RoZXIueiB8fCBEb3VibGUuaXNOYU4odGhpcy56KSkgJiZcbiAgICAgICAgIERvdWJsZS5pc05hTihvdGhlci56KSlcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdGhpcy5lcXVhbHMyRChvdGhlcilcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5lcXVhbEluWiA9IGZ1bmN0aW9uIGVxdWFsSW5aIChjLCB0b2xlcmFuY2UpIHtcbiAgcmV0dXJuIE51bWJlclV0aWwuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLnosIGMueiwgdG9sZXJhbmNlKVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgb3RoZXIgPSBvO1xuICBpZiAodGhpcy54IDwgb3RoZXIueCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy54ID4gb3RoZXIueCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLnkgPCBvdGhlci55KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLnkgPiBvdGhlci55KSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgLy8gdHJ5IHtcbiAgLy8gdmFyIGNvb3JkID0gbnVsbFxuICAvLyByZXR1cm4gY29vcmRcbiAgLy8gfSBjYXRjaCAoZSkge1xuICAvLyBpZiAoZSBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKSB7XG4gIC8vICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgdGhpcyBjbGFzcyBpcyBDbG9uZWFibGVcIilcbiAgLy8gICByZXR1cm4gbnVsbFxuICAvLyB9IGVsc2UgdGhyb3cgZVxuICAvLyB9IGZpbmFsbHkge31cbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSh0aGlzKVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gJygnICsgdGhpcy54ICsgJywgJyArIHRoaXMueSArICcsICcgKyB0aGlzLnogKyAnKSdcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5kaXN0YW5jZTNEID0gZnVuY3Rpb24gZGlzdGFuY2UzRCAoYykge1xuICB2YXIgZHggPSB0aGlzLnggLSBjLng7XG4gIHZhciBkeSA9IHRoaXMueSAtIGMueTtcbiAgdmFyIGR6ID0gdGhpcy56IC0gYy56O1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkeilcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlIChjKSB7XG4gIHZhciBkeCA9IHRoaXMueCAtIGMueDtcbiAgdmFyIGR5ID0gdGhpcy55IC0gYy55O1xuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICB2YXIgcmVzdWx0ID0gMTc7XG4gIHJlc3VsdCA9IDM3ICogcmVzdWx0ICsgQ29vcmRpbmF0ZS5oYXNoQ29kZSh0aGlzLngpO1xuICByZXN1bHQgPSAzNyAqIHJlc3VsdCArIENvb3JkaW5hdGUuaGFzaENvZGUodGhpcy55KTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLnNldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlIChvdGhlcikge1xuICB0aGlzLnggPSBvdGhlci54O1xuICB0aGlzLnkgPSBvdGhlci55O1xuICB0aGlzLnogPSBvdGhlci56O1xufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGUsIENsb25hYmxlLCBTZXJpYWxpemFibGVdXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlXG59O1xuQ29vcmRpbmF0ZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZiA9IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHgpO1xuICAgIHJldHVybiBNYXRoLnRydW5jKChmIF4gZikgPj4+IDMyKVxuICB9XG59O1xuc3RhdGljQWNjZXNzb3JzLkRpbWVuc2lvbmFsQ29tcGFyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBEaW1lbnNpb25hbENvbXBhcmF0b3IgfTtcbnN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDY2ODMxMDg5MDI0MjgzNjY5MTAgfTtcbnN0YXRpY0FjY2Vzc29ycy5OVUxMX09SRElOQVRFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERvdWJsZS5OYU4gfTtcbnN0YXRpY0FjY2Vzc29ycy5YLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycy5ZLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycy5aLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvb3JkaW5hdGUsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG52YXIgRGltZW5zaW9uYWxDb21wYXJhdG9yID0gZnVuY3Rpb24gRGltZW5zaW9uYWxDb21wYXJhdG9yIChkaW1lbnNpb25zVG9UZXN0KSB7XG4gIHRoaXMuX2RpbWVuc2lvbnNUb1Rlc3QgPSAyO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge30gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBkaW1lbnNpb25zVG9UZXN0JDEgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGRpbWVuc2lvbnNUb1Rlc3QkMSAhPT0gMiAmJiBkaW1lbnNpb25zVG9UZXN0JDEgIT09IDMpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignb25seSAyIG9yIDMgZGltZW5zaW9ucyBtYXkgYmUgc3BlY2lmaWVkJykgfVxuICAgIHRoaXMuX2RpbWVuc2lvbnNUb1Rlc3QgPSBkaW1lbnNpb25zVG9UZXN0JDE7XG4gIH1cbn07XG5EaW1lbnNpb25hbENvbXBhcmF0b3IucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChvMSwgbzIpIHtcbiAgdmFyIGMxID0gbzE7XG4gIHZhciBjMiA9IG8yO1xuICB2YXIgY29tcFggPSBEaW1lbnNpb25hbENvbXBhcmF0b3IuY29tcGFyZShjMS54LCBjMi54KTtcbiAgaWYgKGNvbXBYICE9PSAwKSB7IHJldHVybiBjb21wWCB9XG4gIHZhciBjb21wWSA9IERpbWVuc2lvbmFsQ29tcGFyYXRvci5jb21wYXJlKGMxLnksIGMyLnkpO1xuICBpZiAoY29tcFkgIT09IDApIHsgcmV0dXJuIGNvbXBZIH1cbiAgaWYgKHRoaXMuX2RpbWVuc2lvbnNUb1Rlc3QgPD0gMikgeyByZXR1cm4gMCB9XG4gIHZhciBjb21wWiA9IERpbWVuc2lvbmFsQ29tcGFyYXRvci5jb21wYXJlKGMxLnosIGMyLnopO1xuICByZXR1cm4gY29tcFpcbn07XG5EaW1lbnNpb25hbENvbXBhcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmF0b3JdXG59O1xuRGltZW5zaW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERpbWVuc2lvbmFsQ29tcGFyYXRvclxufTtcbkRpbWVuc2lvbmFsQ29tcGFyYXRvci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoYSA8IGIpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKGEgPiBiKSB7IHJldHVybiAxIH1cbiAgaWYgKERvdWJsZS5pc05hTihhKSkge1xuICAgIGlmIChEb3VibGUuaXNOYU4oYikpIHsgcmV0dXJuIDAgfVxuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChEb3VibGUuaXNOYU4oYikpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcblxuLy8gaW1wb3J0IGhhc0ludGVyZmFjZSBmcm9tICcuLi8uLi8uLi8uLi9oYXNJbnRlcmZhY2UnXG4vLyBpbXBvcnQgQ29vcmRpbmF0ZVNlcXVlbmNlIGZyb20gJy4vQ29vcmRpbmF0ZVNlcXVlbmNlJ1xuXG52YXIgQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSA9IGZ1bmN0aW9uIENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgKCkge307XG5cbkNvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAoKSB7XG4gIC8vIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gIC8vIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAvLyAgIGxldCBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXVxuICAvLyB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgLy8gICBsZXQgY29vcmRTZXEgPSBhcmd1bWVudHNbMF1cbiAgLy8gfVxuICAvLyB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgLy8gbGV0IHNpemUgPSBhcmd1bWVudHNbMF1cbiAgLy8gbGV0IGRpbWVuc2lvbiA9IGFyZ3VtZW50c1sxXVxuICAvLyB9XG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeVxufTtcblxudmFyIExvY2F0aW9uID0gZnVuY3Rpb24gTG9jYXRpb24gKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNCA9IHsgSU5URVJJT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQk9VTkRBUlk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRVhURVJJT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTk9ORTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5Mb2NhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxvY2F0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExvY2F0aW9uXG59O1xuTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbCA9IGZ1bmN0aW9uIHRvTG9jYXRpb25TeW1ib2wgKGxvY2F0aW9uVmFsdWUpIHtcbiAgc3dpdGNoIChsb2NhdGlvblZhbHVlKSB7XG4gICAgY2FzZSBMb2NhdGlvbi5FWFRFUklPUjpcbiAgICAgIHJldHVybiAnZSdcbiAgICBjYXNlIExvY2F0aW9uLkJPVU5EQVJZOlxuICAgICAgcmV0dXJuICdiJ1xuICAgIGNhc2UgTG9jYXRpb24uSU5URVJJT1I6XG4gICAgICByZXR1cm4gJ2knXG4gICAgY2FzZSBMb2NhdGlvbi5OT05FOlxuICAgICAgcmV0dXJuICctJ1xuICAgIGRlZmF1bHQ6XG4gIH1cbiAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5rbm93biBsb2NhdGlvbiB2YWx1ZTogJyArIGxvY2F0aW9uVmFsdWUpXG59O1xuc3RhdGljQWNjZXNzb3JzJDQuSU5URVJJT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDQuQk9VTkRBUlkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDQuRVhURVJJT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuc3RhdGljQWNjZXNzb3JzJDQuTk9ORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTG9jYXRpb24sIHN0YXRpY0FjY2Vzc29ycyQ0ICk7XG5cbnZhciBoYXNJbnRlcmZhY2UgPSBmdW5jdGlvbiAobywgaSkge1xuICByZXR1cm4gby5pbnRlcmZhY2VzXyAmJiBvLmludGVyZmFjZXNfKCkuaW5kZXhPZihpKSA+IC0xXG59O1xuXG52YXIgTWF0aFV0aWwgPSBmdW5jdGlvbiBNYXRoVXRpbCAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ1ID0geyBMT0dfMTA6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuTWF0aFV0aWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5NYXRoVXRpbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNYXRoVXRpbFxufTtcbk1hdGhVdGlsLmxvZzEwID0gZnVuY3Rpb24gbG9nMTAgKHgpIHtcbiAgdmFyIGxuID0gTWF0aC5sb2coeCk7XG4gIGlmIChEb3VibGUuaXNJbmZpbml0ZShsbikpIHsgcmV0dXJuIGxuIH1cbiAgaWYgKERvdWJsZS5pc05hTihsbikpIHsgcmV0dXJuIGxuIH1cbiAgcmV0dXJuIGxuIC8gTWF0aFV0aWwuTE9HXzEwXG59O1xuTWF0aFV0aWwubWluID0gZnVuY3Rpb24gbWluICh2MSwgdjIsIHYzLCB2NCkge1xuICB2YXIgbWluID0gdjE7XG4gIGlmICh2MiA8IG1pbikgeyBtaW4gPSB2MjsgfVxuICBpZiAodjMgPCBtaW4pIHsgbWluID0gdjM7IH1cbiAgaWYgKHY0IDwgbWluKSB7IG1pbiA9IHY0OyB9XG4gIHJldHVybiBtaW5cbn07XG5NYXRoVXRpbC5jbGFtcCA9IGZ1bmN0aW9uIGNsYW1wICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdudW1iZXInICYmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbWluID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXggPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHggPCBtaW4pIHsgcmV0dXJuIG1pbiB9XG4gICAgaWYgKHggPiBtYXgpIHsgcmV0dXJuIG1heCB9XG4gICAgcmV0dXJuIHhcbiAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkgJiYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpKSB7XG4gICAgdmFyIHgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbWluJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1heCQxID0gYXJndW1lbnRzWzJdO1xuICAgIGlmICh4JDEgPCBtaW4kMSkgeyByZXR1cm4gbWluJDEgfVxuICAgIGlmICh4JDEgPiBtYXgkMSkgeyByZXR1cm4gbWF4JDEgfVxuICAgIHJldHVybiB4JDFcbiAgfVxufTtcbk1hdGhVdGlsLndyYXAgPSBmdW5jdGlvbiB3cmFwIChpbmRleCwgbWF4KSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gbWF4IC0gLWluZGV4ICUgbWF4XG4gIH1cbiAgcmV0dXJuIGluZGV4ICUgbWF4XG59O1xuTWF0aFV0aWwubWF4ID0gZnVuY3Rpb24gbWF4ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgdjEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHYyID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB2MyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgbWF4ID0gdjE7XG4gICAgaWYgKHYyID4gbWF4KSB7IG1heCA9IHYyOyB9XG4gICAgaWYgKHYzID4gbWF4KSB7IG1heCA9IHYzOyB9XG4gICAgcmV0dXJuIG1heFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgdjEkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgdjIkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdjMkMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgdjQgPSBhcmd1bWVudHNbM107XG4gICAgdmFyIG1heCQxID0gdjEkMTtcbiAgICBpZiAodjIkMSA+IG1heCQxKSB7IG1heCQxID0gdjIkMTsgfVxuICAgIGlmICh2MyQxID4gbWF4JDEpIHsgbWF4JDEgPSB2MyQxOyB9XG4gICAgaWYgKHY0ID4gbWF4JDEpIHsgbWF4JDEgPSB2NDsgfVxuICAgIHJldHVybiBtYXgkMVxuICB9XG59O1xuTWF0aFV0aWwuYXZlcmFnZSA9IGZ1bmN0aW9uIGF2ZXJhZ2UgKHgxLCB4Mikge1xuICByZXR1cm4gKHgxICsgeDIpIC8gMi4wXG59O1xuc3RhdGljQWNjZXNzb3JzJDUuTE9HXzEwLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGgubG9nKDEwKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTWF0aFV0aWwsIHN0YXRpY0FjY2Vzc29ycyQ1ICk7XG5cbnZhciBTdHJpbmdCdWZmZXIgPSBmdW5jdGlvbiBTdHJpbmdCdWZmZXIgKHN0cikge1xuICB0aGlzLnN0ciA9IHN0cjtcbn07XG5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAoZSkge1xuICB0aGlzLnN0ciArPSBlO1xufTtcblxuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXRDaGFyQXQgPSBmdW5jdGlvbiBzZXRDaGFyQXQgKGksIGMpIHtcbiAgdGhpcy5zdHIgPSB0aGlzLnN0ci5zdWJzdHIoMCwgaSkgKyBjICsgdGhpcy5zdHIuc3Vic3RyKGkgKyAxKTtcbn07XG5cblN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoZSkge1xuICByZXR1cm4gdGhpcy5zdHJcbn07XG5cbnZhciBJbnRlZ2VyID0gZnVuY3Rpb24gSW50ZWdlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufTtcbkludGVnZXIucHJvdG90eXBlLmludFZhbHVlID0gZnVuY3Rpb24gaW50VmFsdWUgKCkge1xuICByZXR1cm4gdGhpcy52YWx1ZVxufTtcbkludGVnZXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICBpZiAodGhpcy52YWx1ZSA8IG8pIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMudmFsdWUgPiBvKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5JbnRlZ2VyLmlzTmFOID0gZnVuY3Rpb24gaXNOYU4gKG4pIHsgcmV0dXJuIE51bWJlci5pc05hTihuKSB9O1xuXG52YXIgQ2hhcmFjdGVyID0gZnVuY3Rpb24gQ2hhcmFjdGVyICgpIHt9O1xuXG5DaGFyYWN0ZXIuaXNXaGl0ZXNwYWNlID0gZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChjKSB7IHJldHVybiAoKGMgPD0gMzIgJiYgYyA+PSAwKSB8fCBjID09PSAxMjcpIH07XG5DaGFyYWN0ZXIudG9VcHBlckNhc2UgPSBmdW5jdGlvbiB0b1VwcGVyQ2FzZSAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpIH07XG5cbnZhciBERCA9IGZ1bmN0aW9uIEREICgpIHtcbiAgdGhpcy5faGkgPSAwLjA7XG4gIHRoaXMuX2xvID0gMC4wO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuaW5pdCgwLjApO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KHgpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICAgIHZhciBkZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdChkZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHN0ciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIERELmNhbGwodGhpcywgREQucGFyc2Uoc3RyKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgaGkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuaW5pdChoaSwgbG8pO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDcgPSB7IFBJOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFRXT19QSTogeyBjb25maWd1cmFibGU6IHRydWUgfSxQSV8yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTmFOOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEVQUzogeyBjb25maWd1cmFibGU6IHRydWUgfSxTUExJVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxNQVhfUFJJTlRfRElHSVRTOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFRFTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxPTkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU0NJX05PVF9FWFBPTkVOVF9DSEFSOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNDSV9OT1RfWkVSTzogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuREQucHJvdG90eXBlLmxlID0gZnVuY3Rpb24gbGUgKHkpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA8IHkuX2hpIHx8IHRoaXMuX2hpID09PSB5Ll9oaSkgJiYgdGhpcy5fbG8gPD0geS5fbG9cbn07XG5ERC5wcm90b3R5cGUuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzID0gZnVuY3Rpb24gZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzIChpbnNlcnREZWNpbWFsUG9pbnQsIG1hZ25pdHVkZSkge1xuICB2YXIgeSA9IHRoaXMuYWJzKCk7XG4gIHZhciBtYWcgPSBERC5tYWduaXR1ZGUoeS5faGkpO1xuICB2YXIgc2NhbGUgPSBERC5URU4ucG93KG1hZyk7XG4gIHkgPSB5LmRpdmlkZShzY2FsZSk7XG4gIGlmICh5Lmd0KERELlRFTikpIHtcbiAgICB5ID0geS5kaXZpZGUoREQuVEVOKTtcbiAgICBtYWcgKz0gMTtcbiAgfSBlbHNlIGlmICh5Lmx0KERELk9ORSkpIHtcbiAgICB5ID0geS5tdWx0aXBseShERC5URU4pO1xuICAgIG1hZyAtPSAxO1xuICB9XG4gIHZhciBkZWNpbWFsUG9pbnRQb3MgPSBtYWcgKyAxO1xuICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICB2YXIgbnVtRGlnaXRzID0gREQuTUFYX1BSSU5UX0RJR0lUUyAtIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG51bURpZ2l0czsgaSsrKSB7XG4gICAgaWYgKGluc2VydERlY2ltYWxQb2ludCAmJiBpID09PSBkZWNpbWFsUG9pbnRQb3MpIHtcbiAgICAgIGJ1Zi5hcHBlbmQoJy4nKTtcbiAgICB9XG4gICAgdmFyIGRpZ2l0ID0gTWF0aC50cnVuYyh5Ll9oaSk7XG4gICAgaWYgKGRpZ2l0IDwgMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdmFyIHJlYmlhc0J5MTAgPSBmYWxzZTtcbiAgICB2YXIgZGlnaXRDaGFyID0gMDtcbiAgICBpZiAoZGlnaXQgPiA5KSB7XG4gICAgICByZWJpYXNCeTEwID0gdHJ1ZTtcbiAgICAgIGRpZ2l0Q2hhciA9ICc5JztcbiAgICB9IGVsc2Uge1xuICAgICAgZGlnaXRDaGFyID0gJzAnICsgZGlnaXQ7XG4gICAgfVxuICAgIGJ1Zi5hcHBlbmQoZGlnaXRDaGFyKTtcbiAgICB5ID0geS5zdWJ0cmFjdChERC52YWx1ZU9mKGRpZ2l0KSkubXVsdGlwbHkoREQuVEVOKTtcbiAgICBpZiAocmViaWFzQnkxMCkgeyB5LnNlbGZBZGQoREQuVEVOKTsgfVxuICAgIHZhciBjb250aW51ZUV4dHJhY3RpbmdEaWdpdHMgPSB0cnVlO1xuICAgIHZhciByZW1NYWcgPSBERC5tYWduaXR1ZGUoeS5faGkpO1xuICAgIGlmIChyZW1NYWcgPCAwICYmIE1hdGguYWJzKHJlbU1hZykgPj0gbnVtRGlnaXRzIC0gaSkgeyBjb250aW51ZUV4dHJhY3RpbmdEaWdpdHMgPSBmYWxzZTsgfVxuICAgIGlmICghY29udGludWVFeHRyYWN0aW5nRGlnaXRzKSB7IGJyZWFrIH1cbiAgfVxuICBtYWduaXR1ZGVbMF0gPSBtYWc7XG4gIHJldHVybiBidWYudG9TdHJpbmcoKVxufTtcbkRELnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICByZXR1cm4gdGhpcy5tdWx0aXBseSh0aGlzKVxufTtcbkRELnByb3RvdHlwZS5kb3VibGVWYWx1ZSA9IGZ1bmN0aW9uIGRvdWJsZVZhbHVlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hpICsgdGhpcy5fbG9cbn07XG5ERC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdCAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLmFkZCh5Lm5lZ2F0ZSgpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5hZGQoLXkkMSlcbiAgfVxufTtcbkRELnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLl9oaSA9PT0geS5faGkgJiYgdGhpcy5fbG8gPT09IHkuX2xvXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hpID09PSAwLjAgJiYgdGhpcy5fbG8gPT09IDAuMFxufTtcbkRELnByb3RvdHlwZS5zZWxmU3VidHJhY3QgPSBmdW5jdGlvbiBzZWxmU3VidHJhY3QgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiB0aGlzIH1cbiAgICByZXR1cm4gdGhpcy5zZWxmQWRkKC15Ll9oaSwgLXkuX2xvKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiB0aGlzIH1cbiAgICByZXR1cm4gdGhpcy5zZWxmQWRkKC15JDEsIDAuMClcbiAgfVxufTtcbkRELnByb3RvdHlwZS5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nID0gZnVuY3Rpb24gZ2V0U3BlY2lhbE51bWJlclN0cmluZyAoKSB7XG4gIGlmICh0aGlzLmlzWmVybygpKSB7IHJldHVybiAnMC4wJyB9XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuICdOYU4gJyB9XG4gIHJldHVybiBudWxsXG59O1xuREQucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIG1pbiAoeCkge1xuICBpZiAodGhpcy5sZSh4KSkge1xuICAgIHJldHVybiB0aGlzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHhcbiAgfVxufTtcbkRELnByb3RvdHlwZS5zZWxmRGl2aWRlID0gZnVuY3Rpb24gc2VsZkRpdmlkZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLnNlbGZEaXZpZGUoeS5faGksIHkuX2xvKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHkkMSwgMC4wKVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHloaSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeWxvID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBoYyA9IG51bGw7XG4gICAgdmFyIHRjID0gbnVsbDtcbiAgICB2YXIgaHkgPSBudWxsO1xuICAgIHZhciB0eSA9IG51bGw7XG4gICAgdmFyIEMgPSBudWxsO1xuICAgIHZhciBjID0gbnVsbDtcbiAgICB2YXIgVSA9IG51bGw7XG4gICAgdmFyIHUgPSBudWxsO1xuICAgIEMgPSB0aGlzLl9oaSAvIHloaTtcbiAgICBjID0gREQuU1BMSVQgKiBDO1xuICAgIGhjID0gYyAtIEM7XG4gICAgdSA9IERELlNQTElUICogeWhpO1xuICAgIGhjID0gYyAtIGhjO1xuICAgIHRjID0gQyAtIGhjO1xuICAgIGh5ID0gdSAtIHloaTtcbiAgICBVID0gQyAqIHloaTtcbiAgICBoeSA9IHUgLSBoeTtcbiAgICB0eSA9IHloaSAtIGh5O1xuICAgIHUgPSBoYyAqIGh5IC0gVSArIGhjICogdHkgKyB0YyAqIGh5ICsgdGMgKiB0eTtcbiAgICBjID0gKHRoaXMuX2hpIC0gVSAtIHUgKyB0aGlzLl9sbyAtIEMgKiB5bG8pIC8geWhpO1xuICAgIHUgPSBDICsgYztcbiAgICB0aGlzLl9oaSA9IHU7XG4gICAgdGhpcy5fbG8gPSBDIC0gdSArIGM7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufTtcbkRELnByb3RvdHlwZS5kdW1wID0gZnVuY3Rpb24gZHVtcCAoKSB7XG4gIHJldHVybiAnREQ8JyArIHRoaXMuX2hpICsgJywgJyArIHRoaXMuX2xvICsgJz4nXG59O1xuREQucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBoYyA9IG51bGw7XG4gICAgdmFyIHRjID0gbnVsbDtcbiAgICB2YXIgaHkgPSBudWxsO1xuICAgIHZhciB0eSA9IG51bGw7XG4gICAgdmFyIEMgPSBudWxsO1xuICAgIHZhciBjID0gbnVsbDtcbiAgICB2YXIgVSA9IG51bGw7XG4gICAgdmFyIHUgPSBudWxsO1xuICAgIEMgPSB0aGlzLl9oaSAvIHkuX2hpO1xuICAgIGMgPSBERC5TUExJVCAqIEM7XG4gICAgaGMgPSBjIC0gQztcbiAgICB1ID0gREQuU1BMSVQgKiB5Ll9oaTtcbiAgICBoYyA9IGMgLSBoYztcbiAgICB0YyA9IEMgLSBoYztcbiAgICBoeSA9IHUgLSB5Ll9oaTtcbiAgICBVID0gQyAqIHkuX2hpO1xuICAgIGh5ID0gdSAtIGh5O1xuICAgIHR5ID0geS5faGkgLSBoeTtcbiAgICB1ID0gaGMgKiBoeSAtIFUgKyBoYyAqIHR5ICsgdGMgKiBoeSArIHRjICogdHk7XG4gICAgYyA9ICh0aGlzLl9oaSAtIFUgLSB1ICsgdGhpcy5fbG8gLSBDICogeS5fbG8pIC8geS5faGk7XG4gICAgdSA9IEMgKyBjO1xuICAgIHZhciB6aGkgPSB1O1xuICAgIHZhciB6bG8gPSBDIC0gdSArIGM7XG4gICAgcmV0dXJuIG5ldyBERCh6aGksIHpsbylcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKERvdWJsZS5pc05hTih5JDEpKSB7IHJldHVybiBERC5jcmVhdGVOYU4oKSB9XG4gICAgcmV0dXJuIERELmNvcHkodGhpcykuc2VsZkRpdmlkZSh5JDEsIDAuMClcbiAgfVxufTtcbkRELnByb3RvdHlwZS5nZSA9IGZ1bmN0aW9uIGdlICh5KSB7XG4gIHJldHVybiAodGhpcy5faGkgPiB5Ll9oaSB8fCB0aGlzLl9oaSA9PT0geS5faGkpICYmIHRoaXMuX2xvID49IHkuX2xvXG59O1xuREQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoZXhwKSB7XG4gIGlmIChleHAgPT09IDAuMCkgeyByZXR1cm4gREQudmFsdWVPZigxLjApIH1cbiAgdmFyIHIgPSBuZXcgREQodGhpcyk7XG4gIHZhciBzID0gREQudmFsdWVPZigxLjApO1xuICB2YXIgbiA9IE1hdGguYWJzKGV4cCk7XG4gIGlmIChuID4gMSkge1xuICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7XG4gICAgICAgIHMuc2VsZk11bHRpcGx5KHIpO1xuICAgICAgfVxuICAgICAgbiAvPSAyO1xuICAgICAgaWYgKG4gPiAwKSB7IHIgPSByLnNxcigpOyB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHMgPSByO1xuICB9XG4gIGlmIChleHAgPCAwKSB7IHJldHVybiBzLnJlY2lwcm9jYWwoKSB9XG4gIHJldHVybiBzXG59O1xuREQucHJvdG90eXBlLmNlaWwgPSBmdW5jdGlvbiBjZWlsICgpIHtcbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gREQuTmFOIH1cbiAgdmFyIGZoaSA9IE1hdGguY2VpbCh0aGlzLl9oaSk7XG4gIHZhciBmbG8gPSAwLjA7XG4gIGlmIChmaGkgPT09IHRoaXMuX2hpKSB7XG4gICAgZmxvID0gTWF0aC5jZWlsKHRoaXMuX2xvKTtcbiAgfVxuICByZXR1cm4gbmV3IEREKGZoaSwgZmxvKVxufTtcbkRELnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIG90aGVyID0gbztcbiAgaWYgKHRoaXMuX2hpIDwgb3RoZXIuX2hpKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9oaSA+IG90aGVyLl9oaSkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9sbyA8IG90aGVyLl9sbykgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fbG8gPiBvdGhlci5fbG8pIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkRELnByb3RvdHlwZS5yaW50ID0gZnVuY3Rpb24gcmludCAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIHRoaXMgfVxuICB2YXIgcGx1czUgPSB0aGlzLmFkZCgwLjUpO1xuICByZXR1cm4gcGx1czUuZmxvb3IoKVxufTtcbkRELnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuaW5pdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIHZhciB2YWx1ZSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuaW5pdCh2YWx1ZSQxKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG59O1xuREQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uIG1heCAoeCkge1xuICBpZiAodGhpcy5nZSh4KSkge1xuICAgIHJldHVybiB0aGlzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHhcbiAgfVxufTtcbkRELnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoKSB7XG4gIGlmICh0aGlzLmlzWmVybygpKSB7IHJldHVybiBERC52YWx1ZU9mKDAuMCkgfVxuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICByZXR1cm4gREQuTmFOXG4gIH1cbiAgdmFyIHggPSAxLjAgLyBNYXRoLnNxcnQodGhpcy5faGkpO1xuICB2YXIgYXggPSB0aGlzLl9oaSAqIHg7XG4gIHZhciBheGRkID0gREQudmFsdWVPZihheCk7XG4gIHZhciBkaWZmU3EgPSB0aGlzLnN1YnRyYWN0KGF4ZGQuc3FyKCkpO1xuICB2YXIgZDIgPSBkaWZmU3EuX2hpICogKHggKiAwLjUpO1xuICByZXR1cm4gYXhkZC5hZGQoZDIpXG59O1xuREQucHJvdG90eXBlLnNlbGZBZGQgPSBmdW5jdGlvbiBzZWxmQWRkICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZkFkZCh5Ll9oaSwgeS5fbG8pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBIID0gbnVsbDtcbiAgICAgIHZhciBoID0gbnVsbDtcbiAgICAgIHZhciBTID0gbnVsbDtcbiAgICAgIHZhciBzID0gbnVsbDtcbiAgICAgIHZhciBlID0gbnVsbDtcbiAgICAgIHZhciBmID0gbnVsbDtcbiAgICAgIFMgPSB0aGlzLl9oaSArIHkkMTtcbiAgICAgIGUgPSBTIC0gdGhpcy5faGk7XG4gICAgICBzID0gUyAtIGU7XG4gICAgICBzID0geSQxIC0gZSArICh0aGlzLl9oaSAtIHMpO1xuICAgICAgZiA9IHMgKyB0aGlzLl9sbztcbiAgICAgIEggPSBTICsgZjtcbiAgICAgIGggPSBmICsgKFMgLSBIKTtcbiAgICAgIHRoaXMuX2hpID0gSCArIGg7XG4gICAgICB0aGlzLl9sbyA9IGggKyAoSCAtIHRoaXMuX2hpKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeWhpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5bG8gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIEgkMSA9IG51bGw7XG4gICAgdmFyIGgkMSA9IG51bGw7XG4gICAgdmFyIFQgPSBudWxsO1xuICAgIHZhciB0ID0gbnVsbDtcbiAgICB2YXIgUyQxID0gbnVsbDtcbiAgICB2YXIgcyQxID0gbnVsbDtcbiAgICB2YXIgZSQxID0gbnVsbDtcbiAgICB2YXIgZiQxID0gbnVsbDtcbiAgICBTJDEgPSB0aGlzLl9oaSArIHloaTtcbiAgICBUID0gdGhpcy5fbG8gKyB5bG87XG4gICAgZSQxID0gUyQxIC0gdGhpcy5faGk7XG4gICAgZiQxID0gVCAtIHRoaXMuX2xvO1xuICAgIHMkMSA9IFMkMSAtIGUkMTtcbiAgICB0ID0gVCAtIGYkMTtcbiAgICBzJDEgPSB5aGkgLSBlJDEgKyAodGhpcy5faGkgLSBzJDEpO1xuICAgIHQgPSB5bG8gLSBmJDEgKyAodGhpcy5fbG8gLSB0KTtcbiAgICBlJDEgPSBzJDEgKyBUO1xuICAgIEgkMSA9IFMkMSArIGUkMTtcbiAgICBoJDEgPSBlJDEgKyAoUyQxIC0gSCQxKTtcbiAgICBlJDEgPSB0ICsgaCQxO1xuICAgIHZhciB6aGkgPSBIJDEgKyBlJDE7XG4gICAgdmFyIHpsbyA9IGUkMSArIChIJDEgLSB6aGkpO1xuICAgIHRoaXMuX2hpID0gemhpO1xuICAgIHRoaXMuX2xvID0gemxvO1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuc2VsZk11bHRpcGx5ID0gZnVuY3Rpb24gc2VsZk11bHRpcGx5ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHkuX2hpLCB5Ll9sbylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHkkMSwgMC4wKVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHloaSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeWxvID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBoeCA9IG51bGw7XG4gICAgdmFyIHR4ID0gbnVsbDtcbiAgICB2YXIgaHkgPSBudWxsO1xuICAgIHZhciB0eSA9IG51bGw7XG4gICAgdmFyIEMgPSBudWxsO1xuICAgIHZhciBjID0gbnVsbDtcbiAgICBDID0gREQuU1BMSVQgKiB0aGlzLl9oaTtcbiAgICBoeCA9IEMgLSB0aGlzLl9oaTtcbiAgICBjID0gREQuU1BMSVQgKiB5aGk7XG4gICAgaHggPSBDIC0gaHg7XG4gICAgdHggPSB0aGlzLl9oaSAtIGh4O1xuICAgIGh5ID0gYyAtIHloaTtcbiAgICBDID0gdGhpcy5faGkgKiB5aGk7XG4gICAgaHkgPSBjIC0gaHk7XG4gICAgdHkgPSB5aGkgLSBoeTtcbiAgICBjID0gaHggKiBoeSAtIEMgKyBoeCAqIHR5ICsgdHggKiBoeSArIHR4ICogdHkgKyAodGhpcy5faGkgKiB5bG8gKyB0aGlzLl9sbyAqIHloaSk7XG4gICAgdmFyIHpoaSA9IEMgKyBjO1xuICAgIGh4ID0gQyAtIHpoaTtcbiAgICB2YXIgemxvID0gYyArIGh4O1xuICAgIHRoaXMuX2hpID0gemhpO1xuICAgIHRoaXMuX2xvID0gemxvO1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuc2VsZlNxciA9IGZ1bmN0aW9uIHNlbGZTcXIgKCkge1xuICByZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodGhpcylcbn07XG5ERC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbiBmbG9vciAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIERELk5hTiB9XG4gIHZhciBmaGkgPSBNYXRoLmZsb29yKHRoaXMuX2hpKTtcbiAgdmFyIGZsbyA9IDAuMDtcbiAgaWYgKGZoaSA9PT0gdGhpcy5faGkpIHtcbiAgICBmbG8gPSBNYXRoLmZsb29yKHRoaXMuX2xvKTtcbiAgfVxuICByZXR1cm4gbmV3IEREKGZoaSwgZmxvKVxufTtcbkRELnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUgKCkge1xuICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiB0aGlzIH1cbiAgcmV0dXJuIG5ldyBERCgtdGhpcy5faGksIC10aGlzLl9sbylcbn07XG5ERC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gIC8vIHRyeSB7XG4gIC8vIHJldHVybiBudWxsXG4gIC8vIH0gY2F0Y2ggKGV4KSB7XG4gIC8vIGlmIChleCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKSB7XG4gIC8vICAgcmV0dXJuIG51bGxcbiAgLy8gfSBlbHNlIHRocm93IGV4XG4gIC8vIH0gZmluYWxseSB7fVxufTtcbkRELnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5ICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHkuaXNOYU4oKSkgeyByZXR1cm4gREQuY3JlYXRlTmFOKCkgfVxuICAgIHJldHVybiBERC5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoRG91YmxlLmlzTmFOKHkkMSkpIHsgcmV0dXJuIERELmNyZWF0ZU5hTigpIH1cbiAgICByZXR1cm4gREQuY29weSh0aGlzKS5zZWxmTXVsdGlwbHkoeSQxLCAwLjApXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuaXNOYU4gPSBmdW5jdGlvbiBpc05hTiAoKSB7XG4gIHJldHVybiBEb3VibGUuaXNOYU4odGhpcy5faGkpXG59O1xuREQucHJvdG90eXBlLmludFZhbHVlID0gZnVuY3Rpb24gaW50VmFsdWUgKCkge1xuICByZXR1cm4gTWF0aC50cnVuYyh0aGlzLl9oaSlcbn07XG5ERC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBtYWcgPSBERC5tYWduaXR1ZGUodGhpcy5faGkpO1xuICBpZiAobWFnID49IC0zICYmIG1hZyA8PSAyMCkgeyByZXR1cm4gdGhpcy50b1N0YW5kYXJkTm90YXRpb24oKSB9XG4gIHJldHVybiB0aGlzLnRvU2NpTm90YXRpb24oKVxufTtcbkRELnByb3RvdHlwZS50b1N0YW5kYXJkTm90YXRpb24gPSBmdW5jdGlvbiB0b1N0YW5kYXJkTm90YXRpb24gKCkge1xuICB2YXIgc3BlY2lhbFN0ciA9IHRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO1xuICBpZiAoc3BlY2lhbFN0ciAhPT0gbnVsbCkgeyByZXR1cm4gc3BlY2lhbFN0ciB9XG4gIHZhciBtYWduaXR1ZGUgPSBuZXcgQXJyYXkoMSkuZmlsbChudWxsKTtcbiAgdmFyIHNpZ0RpZ2l0cyA9IHRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKHRydWUsIG1hZ25pdHVkZSk7XG4gIHZhciBkZWNpbWFsUG9pbnRQb3MgPSBtYWduaXR1ZGVbMF0gKyAxO1xuICB2YXIgbnVtID0gc2lnRGlnaXRzO1xuICBpZiAoc2lnRGlnaXRzLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgbnVtID0gJzAnICsgc2lnRGlnaXRzO1xuICB9IGVsc2UgaWYgKGRlY2ltYWxQb2ludFBvcyA8IDApIHtcbiAgICBudW0gPSAnMC4nICsgREQuc3RyaW5nT2ZDaGFyKCcwJywgLWRlY2ltYWxQb2ludFBvcykgKyBzaWdEaWdpdHM7XG4gIH0gZWxzZSBpZiAoc2lnRGlnaXRzLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcbiAgICB2YXIgbnVtWmVyb2VzID0gZGVjaW1hbFBvaW50UG9zIC0gc2lnRGlnaXRzLmxlbmd0aDtcbiAgICB2YXIgemVyb2VzID0gREQuc3RyaW5nT2ZDaGFyKCcwJywgbnVtWmVyb2VzKTtcbiAgICBudW0gPSBzaWdEaWdpdHMgKyB6ZXJvZXMgKyAnLjAnO1xuICB9XG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyByZXR1cm4gJy0nICsgbnVtIH1cbiAgcmV0dXJuIG51bVxufTtcbkRELnByb3RvdHlwZS5yZWNpcHJvY2FsID0gZnVuY3Rpb24gcmVjaXByb2NhbCAoKSB7XG4gIHZhciBoYyA9IG51bGw7XG4gIHZhciB0YyA9IG51bGw7XG4gIHZhciBoeSA9IG51bGw7XG4gIHZhciB0eSA9IG51bGw7XG4gIHZhciBDID0gbnVsbDtcbiAgdmFyIGMgPSBudWxsO1xuICB2YXIgVSA9IG51bGw7XG4gIHZhciB1ID0gbnVsbDtcbiAgQyA9IDEuMCAvIHRoaXMuX2hpO1xuICBjID0gREQuU1BMSVQgKiBDO1xuICBoYyA9IGMgLSBDO1xuICB1ID0gREQuU1BMSVQgKiB0aGlzLl9oaTtcbiAgaGMgPSBjIC0gaGM7XG4gIHRjID0gQyAtIGhjO1xuICBoeSA9IHUgLSB0aGlzLl9oaTtcbiAgVSA9IEMgKiB0aGlzLl9oaTtcbiAgaHkgPSB1IC0gaHk7XG4gIHR5ID0gdGhpcy5faGkgLSBoeTtcbiAgdSA9IGhjICogaHkgLSBVICsgaGMgKiB0eSArIHRjICogaHkgKyB0YyAqIHR5O1xuICBjID0gKDEuMCAtIFUgLSB1IC0gQyAqIHRoaXMuX2xvKSAvIHRoaXMuX2hpO1xuICB2YXIgemhpID0gQyArIGM7XG4gIHZhciB6bG8gPSBDIC0gemhpICsgYztcbiAgcmV0dXJuIG5ldyBERCh6aGksIHpsbylcbn07XG5ERC5wcm90b3R5cGUudG9TY2lOb3RhdGlvbiA9IGZ1bmN0aW9uIHRvU2NpTm90YXRpb24gKCkge1xuICBpZiAodGhpcy5pc1plcm8oKSkgeyByZXR1cm4gREQuU0NJX05PVF9aRVJPIH1cbiAgdmFyIHNwZWNpYWxTdHIgPSB0aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtcbiAgaWYgKHNwZWNpYWxTdHIgIT09IG51bGwpIHsgcmV0dXJuIHNwZWNpYWxTdHIgfVxuICB2YXIgbWFnbml0dWRlID0gbmV3IEFycmF5KDEpLmZpbGwobnVsbCk7XG4gIHZhciBkaWdpdHMgPSB0aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyhmYWxzZSwgbWFnbml0dWRlKTtcbiAgdmFyIGV4cFN0ciA9IERELlNDSV9OT1RfRVhQT05FTlRfQ0hBUiArIG1hZ25pdHVkZVswXTtcbiAgaWYgKGRpZ2l0cy5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgbGVhZGluZyB6ZXJvOiAnICsgZGlnaXRzKVxuICB9XG4gIHZhciB0cmFpbGluZ0RpZ2l0cyA9ICcnO1xuICBpZiAoZGlnaXRzLmxlbmd0aCA+IDEpIHsgdHJhaWxpbmdEaWdpdHMgPSBkaWdpdHMuc3Vic3RyaW5nKDEpOyB9XG4gIHZhciBkaWdpdHNXaXRoRGVjaW1hbCA9IGRpZ2l0cy5jaGFyQXQoMCkgKyAnLicgKyB0cmFpbGluZ0RpZ2l0cztcbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IHJldHVybiAnLScgKyBkaWdpdHNXaXRoRGVjaW1hbCArIGV4cFN0ciB9XG4gIHJldHVybiBkaWdpdHNXaXRoRGVjaW1hbCArIGV4cFN0clxufTtcbkRELnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiBERC5OYU4gfVxuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgcmV0dXJuIHRoaXMubmVnYXRlKCkgfVxuICByZXR1cm4gbmV3IEREKHRoaXMpXG59O1xuREQucHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlICgpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA+IDAuMCB8fCB0aGlzLl9oaSA9PT0gMC4wKSAmJiB0aGlzLl9sbyA+IDAuMFxufTtcbkRELnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0ICh5KSB7XG4gIHJldHVybiAodGhpcy5faGkgPCB5Ll9oaSB8fCB0aGlzLl9oaSA9PT0geS5faGkpICYmIHRoaXMuX2xvIDwgeS5fbG9cbn07XG5ERC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIERELmNvcHkodGhpcykuc2VsZkFkZCh5KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gREQuY29weSh0aGlzKS5zZWxmQWRkKHkkMSlcbiAgfVxufTtcbkRELnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX2hpID0geDtcbiAgICAgIHRoaXMuX2xvID0gMC4wO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICAgIHZhciBkZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX2hpID0gZGQuX2hpO1xuICAgICAgdGhpcy5fbG8gPSBkZC5fbG87XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgaGkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2hpID0gaGk7XG4gICAgdGhpcy5fbG8gPSBsbztcbiAgfVxufTtcbkRELnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0ICh5KSB7XG4gIHJldHVybiAodGhpcy5faGkgPiB5Ll9oaSB8fCB0aGlzLl9oaSA9PT0geS5faGkpICYmIHRoaXMuX2xvID4geS5fbG9cbn07XG5ERC5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUgKCkge1xuICByZXR1cm4gKHRoaXMuX2hpIDwgMC4wIHx8IHRoaXMuX2hpID09PSAwLjApICYmIHRoaXMuX2xvIDwgMC4wXG59O1xuREQucHJvdG90eXBlLnRydW5jID0gZnVuY3Rpb24gdHJ1bmMgKCkge1xuICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiBERC5OYU4gfVxuICBpZiAodGhpcy5pc1Bvc2l0aXZlKCkpIHsgcmV0dXJuIHRoaXMuZmxvb3IoKTsgfSBlbHNlIHsgcmV0dXJuIHRoaXMuY2VpbCgpIH1cbn07XG5ERC5wcm90b3R5cGUuc2lnbnVtID0gZnVuY3Rpb24gc2lnbnVtICgpIHtcbiAgaWYgKHRoaXMuX2hpID4gMCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9oaSA8IDApIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX2xvID4gMCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9sbyA8IDApIHsgcmV0dXJuIC0xIH1cbiAgcmV0dXJuIDBcbn07XG5ERC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VyaWFsaXphYmxlLCBDb21wYXJhYmxlLCBDbG9uYWJsZV1cbn07XG5ERC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBERFxufTtcbkRELnNxciA9IGZ1bmN0aW9uIHNxciAoeCkge1xuICByZXR1cm4gREQudmFsdWVPZih4KS5zZWxmTXVsdGlwbHkoeClcbn07XG5ERC52YWx1ZU9mID0gZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzdHIgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIERELnBhcnNlKHN0cilcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBuZXcgREQoeClcbiAgfVxufTtcbkRELnNxcnQgPSBmdW5jdGlvbiBzcXJ0ICh4KSB7XG4gIHJldHVybiBERC52YWx1ZU9mKHgpLnNxcnQoKVxufTtcbkRELnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHN0cikge1xuICB2YXIgaSA9IDA7XG4gIHZhciBzdHJsZW4gPSBzdHIubGVuZ3RoO1xuICB3aGlsZSAoQ2hhcmFjdGVyLmlzV2hpdGVzcGFjZShzdHIuY2hhckF0KGkpKSkgeyBpKys7IH1cbiAgdmFyIGlzTmVnYXRpdmUgPSBmYWxzZTtcbiAgaWYgKGkgPCBzdHJsZW4pIHtcbiAgICB2YXIgc2lnbkNoID0gc3RyLmNoYXJBdChpKTtcbiAgICBpZiAoc2lnbkNoID09PSAnLScgfHwgc2lnbkNoID09PSAnKycpIHtcbiAgICAgIGkrKztcbiAgICAgIGlmIChzaWduQ2ggPT09ICctJykgeyBpc05lZ2F0aXZlID0gdHJ1ZTsgfVxuICAgIH1cbiAgfVxuICB2YXIgdmFsID0gbmV3IEREKCk7XG4gIHZhciBudW1EaWdpdHMgPSAwO1xuICB2YXIgbnVtQmVmb3JlRGVjID0gMDtcbiAgdmFyIGV4cCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGkgPj0gc3RybGVuKSB7IGJyZWFrIH1cbiAgICB2YXIgY2ggPSBzdHIuY2hhckF0KGkpO1xuICAgIGkrKztcbiAgICBpZiAoQ2hhcmFjdGVyLmlzRGlnaXQoY2gpKSB7XG4gICAgICB2YXIgZCA9IGNoIC0gJzAnO1xuICAgICAgdmFsLnNlbGZNdWx0aXBseShERC5URU4pO1xuICAgICAgdmFsLnNlbGZBZGQoZCk7XG4gICAgICBudW1EaWdpdHMrKztcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICBudW1CZWZvcmVEZWMgPSBudW1EaWdpdHM7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICB2YXIgZXhwU3RyID0gc3RyLnN1YnN0cmluZyhpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGV4cCA9IEludGVnZXIucGFyc2VJbnQoZXhwU3RyKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGlmIChleCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGV4cG9uZW50ICcgKyBleHBTdHIgKyAnIGluIHN0cmluZyAnICsgc3RyKVxuICAgICAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gICAgICB9IGZpbmFsbHkge31cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNoICsgXCInIGF0IHBvc2l0aW9uIFwiICsgaSArICcgaW4gc3RyaW5nICcgKyBzdHIpXG4gIH1cbiAgdmFyIHZhbDIgPSB2YWw7XG4gIHZhciBudW1EZWNQbGFjZXMgPSBudW1EaWdpdHMgLSBudW1CZWZvcmVEZWMgLSBleHA7XG4gIGlmIChudW1EZWNQbGFjZXMgPT09IDApIHtcbiAgICB2YWwyID0gdmFsO1xuICB9IGVsc2UgaWYgKG51bURlY1BsYWNlcyA+IDApIHtcbiAgICB2YXIgc2NhbGUgPSBERC5URU4ucG93KG51bURlY1BsYWNlcyk7XG4gICAgdmFsMiA9IHZhbC5kaXZpZGUoc2NhbGUpO1xuICB9IGVsc2UgaWYgKG51bURlY1BsYWNlcyA8IDApIHtcbiAgICB2YXIgc2NhbGUkMSA9IERELlRFTi5wb3coLW51bURlY1BsYWNlcyk7XG4gICAgdmFsMiA9IHZhbC5tdWx0aXBseShzY2FsZSQxKTtcbiAgfVxuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIHJldHVybiB2YWwyLm5lZ2F0ZSgpXG4gIH1cbiAgcmV0dXJuIHZhbDJcbn07XG5ERC5jcmVhdGVOYU4gPSBmdW5jdGlvbiBjcmVhdGVOYU4gKCkge1xuICByZXR1cm4gbmV3IEREKERvdWJsZS5OYU4sIERvdWJsZS5OYU4pXG59O1xuREQuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRkKSB7XG4gIHJldHVybiBuZXcgREQoZGQpXG59O1xuREQubWFnbml0dWRlID0gZnVuY3Rpb24gbWFnbml0dWRlICh4KSB7XG4gIHZhciB4QWJzID0gTWF0aC5hYnMoeCk7XG4gIHZhciB4TG9nMTAgPSBNYXRoLmxvZyh4QWJzKSAvIE1hdGgubG9nKDEwKTtcbiAgdmFyIHhNYWcgPSBNYXRoLnRydW5jKE1hdGguZmxvb3IoeExvZzEwKSk7XG4gIHZhciB4QXBwcm94ID0gTWF0aC5wb3coMTAsIHhNYWcpO1xuICBpZiAoeEFwcHJveCAqIDEwIDw9IHhBYnMpIHsgeE1hZyArPSAxOyB9XG4gIHJldHVybiB4TWFnXG59O1xuREQuc3RyaW5nT2ZDaGFyID0gZnVuY3Rpb24gc3RyaW5nT2ZDaGFyIChjaCwgbGVuKSB7XG4gIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWYuYXBwZW5kKGNoKTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKClcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNy5QSS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgREQoMy4xNDE1OTI2NTM1ODk3OTMxMTZlKzAwLCAxLjIyNDY0Njc5OTE0NzM1MzIwN2UtMTYpIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5UV09fUEkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEREKDYuMjgzMTg1MzA3MTc5NTg2MjMyZSswMCwgMi40NDkyOTM1OTgyOTQ3MDY0MTRlLTE2KSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuUElfMi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgREQoMS41NzA3OTYzMjY3OTQ4OTY1NThlKzAwLCA2LjEyMzIzMzk5NTczNjc2NjAzNmUtMTcpIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5FLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBERCgyLjcxODI4MTgyODQ1OTA0NTA5MWUrMDAsIDEuNDQ1NjQ2ODkxNzI5MjUwMTU4ZS0xNikgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3Lk5hTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgREQoRG91YmxlLk5hTiwgRG91YmxlLk5hTikgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LkVQUy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxLjIzMjU5NTE2NDQwNzgzZS0zMiB9O1xuc3RhdGljQWNjZXNzb3JzJDcuU1BMSVQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMTM0MjE3NzI5LjAgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3Lk1BWF9QUklOVF9ESUdJVFMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMzIgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlRFTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBERC52YWx1ZU9mKDEwLjApIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5PTkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gREQudmFsdWVPZigxLjApIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5TQ0lfTk9UX0VYUE9ORU5UX0NIQVIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0UnIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5TQ0lfTk9UX1pFUk8uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzAuMEUwJyB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggREQsIHN0YXRpY0FjY2Vzc29ycyQ3ICk7XG5cbnZhciBDR0FsZ29yaXRobXNERCA9IGZ1bmN0aW9uIENHQWxnb3JpdGhtc0REICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDYgPSB7IERQX1NBRkVfRVBTSUxPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5DR0FsZ29yaXRobXNERC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNHQWxnb3JpdGhtc0RELnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtc0REXG59O1xuQ0dBbGdvcml0aG1zREQub3JpZW50YXRpb25JbmRleCA9IGZ1bmN0aW9uIG9yaWVudGF0aW9uSW5kZXggKHAxLCBwMiwgcSkge1xuICB2YXIgaW5kZXggPSBDR0FsZ29yaXRobXNERC5vcmllbnRhdGlvbkluZGV4RmlsdGVyKHAxLCBwMiwgcSk7XG4gIGlmIChpbmRleCA8PSAxKSB7IHJldHVybiBpbmRleCB9XG4gIHZhciBkeDEgPSBERC52YWx1ZU9mKHAyLngpLnNlbGZBZGQoLXAxLngpO1xuICB2YXIgZHkxID0gREQudmFsdWVPZihwMi55KS5zZWxmQWRkKC1wMS55KTtcbiAgdmFyIGR4MiA9IERELnZhbHVlT2YocS54KS5zZWxmQWRkKC1wMi54KTtcbiAgdmFyIGR5MiA9IERELnZhbHVlT2YocS55KS5zZWxmQWRkKC1wMi55KTtcbiAgcmV0dXJuIGR4MS5zZWxmTXVsdGlwbHkoZHkyKS5zZWxmU3VidHJhY3QoZHkxLnNlbGZNdWx0aXBseShkeDIpKS5zaWdudW0oKVxufTtcbkNHQWxnb3JpdGhtc0RELnNpZ25PZkRldDJ4MiA9IGZ1bmN0aW9uIHNpZ25PZkRldDJ4MiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGRldCA9IHgxLm11bHRpcGx5KHkyKS5zZWxmU3VidHJhY3QoeTEubXVsdGlwbHkoeDIpKTtcbiAgcmV0dXJuIGRldC5zaWdudW0oKVxufTtcbkNHQWxnb3JpdGhtc0RELmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAocDEsIHAyLCBxMSwgcTIpIHtcbiAgdmFyIGRlbm9tMSA9IERELnZhbHVlT2YocTIueSkuc2VsZlN1YnRyYWN0KHExLnkpLnNlbGZNdWx0aXBseShERC52YWx1ZU9mKHAyLngpLnNlbGZTdWJ0cmFjdChwMS54KSk7XG4gIHZhciBkZW5vbTIgPSBERC52YWx1ZU9mKHEyLngpLnNlbGZTdWJ0cmFjdChxMS54KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMi55KS5zZWxmU3VidHJhY3QocDEueSkpO1xuICB2YXIgZGVub20gPSBkZW5vbTEuc3VidHJhY3QoZGVub20yKTtcbiAgdmFyIG51bXgxID0gREQudmFsdWVPZihxMi54KS5zZWxmU3VidHJhY3QocTEueCkuc2VsZk11bHRpcGx5KERELnZhbHVlT2YocDEueSkuc2VsZlN1YnRyYWN0KHExLnkpKTtcbiAgdmFyIG51bXgyID0gREQudmFsdWVPZihxMi55KS5zZWxmU3VidHJhY3QocTEueSkuc2VsZk11bHRpcGx5KERELnZhbHVlT2YocDEueCkuc2VsZlN1YnRyYWN0KHExLngpKTtcbiAgdmFyIG51bXggPSBudW14MS5zdWJ0cmFjdChudW14Mik7XG4gIHZhciBmcmFjUCA9IG51bXguc2VsZkRpdmlkZShkZW5vbSkuZG91YmxlVmFsdWUoKTtcbiAgdmFyIHggPSBERC52YWx1ZU9mKHAxLngpLnNlbGZBZGQoREQudmFsdWVPZihwMi54KS5zZWxmU3VidHJhY3QocDEueCkuc2VsZk11bHRpcGx5KGZyYWNQKSkuZG91YmxlVmFsdWUoKTtcbiAgdmFyIG51bXkxID0gREQudmFsdWVPZihwMi54KS5zZWxmU3VidHJhY3QocDEueCkuc2VsZk11bHRpcGx5KERELnZhbHVlT2YocDEueSkuc2VsZlN1YnRyYWN0KHExLnkpKTtcbiAgdmFyIG51bXkyID0gREQudmFsdWVPZihwMi55KS5zZWxmU3VidHJhY3QocDEueSkuc2VsZk11bHRpcGx5KERELnZhbHVlT2YocDEueCkuc2VsZlN1YnRyYWN0KHExLngpKTtcbiAgdmFyIG51bXkgPSBudW15MS5zdWJ0cmFjdChudW15Mik7XG4gIHZhciBmcmFjUSA9IG51bXkuc2VsZkRpdmlkZShkZW5vbSkuZG91YmxlVmFsdWUoKTtcbiAgdmFyIHkgPSBERC52YWx1ZU9mKHExLnkpLnNlbGZBZGQoREQudmFsdWVPZihxMi55KS5zZWxmU3VidHJhY3QocTEueSkuc2VsZk11bHRpcGx5KGZyYWNRKSkuZG91YmxlVmFsdWUoKTtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHgsIHkpXG59O1xuQ0dBbGdvcml0aG1zREQub3JpZW50YXRpb25JbmRleEZpbHRlciA9IGZ1bmN0aW9uIG9yaWVudGF0aW9uSW5kZXhGaWx0ZXIgKHBhLCBwYiwgcGMpIHtcbiAgdmFyIGRldHN1bSA9IG51bGw7XG4gIHZhciBkZXRsZWZ0ID0gKHBhLnggLSBwYy54KSAqIChwYi55IC0gcGMueSk7XG4gIHZhciBkZXRyaWdodCA9IChwYS55IC0gcGMueSkgKiAocGIueCAtIHBjLngpO1xuICB2YXIgZGV0ID0gZGV0bGVmdCAtIGRldHJpZ2h0O1xuICBpZiAoZGV0bGVmdCA+IDAuMCkge1xuICAgIGlmIChkZXRyaWdodCA8PSAwLjApIHtcbiAgICAgIHJldHVybiBDR0FsZ29yaXRobXNERC5zaWdudW0oZGV0KVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXRzdW0gPSBkZXRsZWZ0ICsgZGV0cmlnaHQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRldGxlZnQgPCAwLjApIHtcbiAgICBpZiAoZGV0cmlnaHQgPj0gMC4wKSB7XG4gICAgICByZXR1cm4gQ0dBbGdvcml0aG1zREQuc2lnbnVtKGRldClcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0c3VtID0gLWRldGxlZnQgLSBkZXRyaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIENHQWxnb3JpdGhtc0RELnNpZ251bShkZXQpXG4gIH1cbiAgdmFyIGVycmJvdW5kID0gQ0dBbGdvcml0aG1zREQuRFBfU0FGRV9FUFNJTE9OICogZGV0c3VtO1xuICBpZiAoZGV0ID49IGVycmJvdW5kIHx8IC1kZXQgPj0gZXJyYm91bmQpIHtcbiAgICByZXR1cm4gQ0dBbGdvcml0aG1zREQuc2lnbnVtKGRldClcbiAgfVxuICByZXR1cm4gMlxufTtcbkNHQWxnb3JpdGhtc0RELnNpZ251bSA9IGZ1bmN0aW9uIHNpZ251bSAoeCkge1xuICBpZiAoeCA+IDApIHsgcmV0dXJuIDEgfVxuICBpZiAoeCA8IDApIHsgcmV0dXJuIC0xIH1cbiAgcmV0dXJuIDBcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNi5EUF9TQUZFX0VQU0lMT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMWUtMTUgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENHQWxnb3JpdGhtc0RELCBzdGF0aWNBY2Nlc3NvcnMkNiApO1xuXG52YXIgQ29vcmRpbmF0ZVNlcXVlbmNlID0gZnVuY3Rpb24gQ29vcmRpbmF0ZVNlcXVlbmNlICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDggPSB7IFg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sWTogeyBjb25maWd1cmFibGU6IHRydWUgfSxaOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE06IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuc3RhdGljQWNjZXNzb3JzJDguWC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkOC5ZLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQ4LlouZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuc3RhdGljQWNjZXNzb3JzJDguTS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzIH07XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLnNldE9yZGluYXRlID0gZnVuY3Rpb24gc2V0T3JkaW5hdGUgKGluZGV4LCBvcmRpbmF0ZUluZGV4LCB2YWx1ZSkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXRPcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldE9yZGluYXRlIChpbmRleCwgb3JkaW5hdGVJbmRleCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlQ29weSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVDb3B5IChpKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCAoaW5kZXgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5leHBhbmRFbnZlbG9wZSA9IGZ1bmN0aW9uIGV4cGFuZEVudmVsb3BlIChlbnYpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkgKGluZGV4KSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUudG9Db29yZGluYXRlQXJyYXkgPSBmdW5jdGlvbiB0b0Nvb3JkaW5hdGVBcnJheSAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ2xvbmFibGVdXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvb3JkaW5hdGVTZXF1ZW5jZSwgc3RhdGljQWNjZXNzb3JzJDggKTtcblxudmFyIEV4Y2VwdGlvbiA9IGZ1bmN0aW9uIEV4Y2VwdGlvbiAoKSB7fTtcblxudmFyIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24gPSAoZnVuY3Rpb24gKEV4Y2VwdGlvbiQkMSkge1xuICBmdW5jdGlvbiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uICgpIHtcbiAgICBFeGNlcHRpb24kJDEuY2FsbCh0aGlzLCAnUHJvamVjdGl2ZSBwb2ludCBub3QgcmVwcmVzZW50YWJsZSBvbiB0aGUgQ2FydGVzaWFuIHBsYW5lLicpO1xuICB9XG5cbiAgaWYgKCBFeGNlcHRpb24kJDEgKSBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uLl9fcHJvdG9fXyA9IEV4Y2VwdGlvbiQkMTtcbiAgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFeGNlcHRpb24kJDEgJiYgRXhjZXB0aW9uJCQxLnByb3RvdHlwZSApO1xuICBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb247XG4gIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvblxuICB9O1xuXG4gIHJldHVybiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uO1xufShFeGNlcHRpb24pKTtcblxudmFyIFN5c3RlbSA9IGZ1bmN0aW9uIFN5c3RlbSAoKSB7fTtcblxuU3lzdGVtLmFycmF5Y29weSA9IGZ1bmN0aW9uIGFycmF5Y29weSAoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbikge1xuICB2YXIgYyA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQb3M7IGkgPCBzcmNQb3MgKyBsZW47IGkrKykge1xuICAgIGRlc3RbZGVzdFBvcyArIGNdID0gc3JjW2ldO1xuICAgIGMrKztcbiAgfVxufTtcblxuU3lzdGVtLmdldFByb3BlcnR5ID0gZnVuY3Rpb24gZ2V0UHJvcGVydHkgKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAnbGluZS5zZXBhcmF0b3InOiAnXFxuJ1xuICB9W25hbWVdXG59O1xuXG52YXIgSENvb3JkaW5hdGUgPSBmdW5jdGlvbiBIQ29vcmRpbmF0ZSAoKSB7XG4gIHRoaXMueCA9IG51bGw7XG4gIHRoaXMueSA9IG51bGw7XG4gIHRoaXMudyA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy54ID0gMC4wO1xuICAgIHRoaXMueSA9IDAuMDtcbiAgICB0aGlzLncgPSAxLjA7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMueCA9IHAueDtcbiAgICB0aGlzLnkgPSBwLnk7XG4gICAgdGhpcy53ID0gMS4wO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBfeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBfeSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMueCA9IF94O1xuICAgICAgdGhpcy55ID0gX3k7XG4gICAgICB0aGlzLncgPSAxLjA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBIQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBIQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHAyID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy54ID0gcDEueSAqIHAyLncgLSBwMi55ICogcDEudztcbiAgICAgIHRoaXMueSA9IHAyLnggKiBwMS53IC0gcDEueCAqIHAyLnc7XG4gICAgICB0aGlzLncgPSBwMS54ICogcDIueSAtIHAyLnggKiBwMS55O1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcDEkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwMiQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy54ID0gcDEkMS55IC0gcDIkMS55O1xuICAgICAgdGhpcy55ID0gcDIkMS54IC0gcDEkMS54O1xuICAgICAgdGhpcy53ID0gcDEkMS54ICogcDIkMS55IC0gcDIkMS54ICogcDEkMS55O1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIF94JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIF95JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIF93ID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMueCA9IF94JDE7XG4gICAgdGhpcy55ID0gX3kkMTtcbiAgICB0aGlzLncgPSBfdztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHAxJDIgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAyJDIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHExID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBxMiA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgcHggPSBwMSQyLnkgLSBwMiQyLnk7XG4gICAgdmFyIHB5ID0gcDIkMi54IC0gcDEkMi54O1xuICAgIHZhciBwdyA9IHAxJDIueCAqIHAyJDIueSAtIHAyJDIueCAqIHAxJDIueTtcbiAgICB2YXIgcXggPSBxMS55IC0gcTIueTtcbiAgICB2YXIgcXkgPSBxMi54IC0gcTEueDtcbiAgICB2YXIgcXcgPSBxMS54ICogcTIueSAtIHEyLnggKiBxMS55O1xuICAgIHRoaXMueCA9IHB5ICogcXcgLSBxeSAqIHB3O1xuICAgIHRoaXMueSA9IHF4ICogcHcgLSBweCAqIHF3O1xuICAgIHRoaXMudyA9IHB4ICogcXkgLSBxeCAqIHB5O1xuICB9XG59O1xuSENvb3JkaW5hdGUucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZICgpIHtcbiAgdmFyIGEgPSB0aGlzLnkgLyB0aGlzLnc7XG4gIGlmIChEb3VibGUuaXNOYU4oYSkgfHwgRG91YmxlLmlzSW5maW5pdGUoYSkpIHtcbiAgICB0aHJvdyBuZXcgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbigpXG4gIH1cbiAgcmV0dXJuIGFcbn07XG5IQ29vcmRpbmF0ZS5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFggKCkge1xuICB2YXIgYSA9IHRoaXMueCAvIHRoaXMudztcbiAgaWYgKERvdWJsZS5pc05hTihhKSB8fCBEb3VibGUuaXNJbmZpbml0ZShhKSkge1xuICAgIHRocm93IG5ldyBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKClcbiAgfVxuICByZXR1cm4gYVxufTtcbkhDb29yZGluYXRlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHZhciBwID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgcC54ID0gdGhpcy5nZXRYKCk7XG4gIHAueSA9IHRoaXMuZ2V0WSgpO1xuICByZXR1cm4gcFxufTtcbkhDb29yZGluYXRlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuSENvb3JkaW5hdGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSENvb3JkaW5hdGVcbn07XG5IQ29vcmRpbmF0ZS5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKHAxLCBwMiwgcTEsIHEyKSB7XG4gIHZhciBweCA9IHAxLnkgLSBwMi55O1xuICB2YXIgcHkgPSBwMi54IC0gcDEueDtcbiAgdmFyIHB3ID0gcDEueCAqIHAyLnkgLSBwMi54ICogcDEueTtcbiAgdmFyIHF4ID0gcTEueSAtIHEyLnk7XG4gIHZhciBxeSA9IHEyLnggLSBxMS54O1xuICB2YXIgcXcgPSBxMS54ICogcTIueSAtIHEyLnggKiBxMS55O1xuICB2YXIgeCA9IHB5ICogcXcgLSBxeSAqIHB3O1xuICB2YXIgeSA9IHF4ICogcHcgLSBweCAqIHF3O1xuICB2YXIgdyA9IHB4ICogcXkgLSBxeCAqIHB5O1xuICB2YXIgeEludCA9IHggLyB3O1xuICB2YXIgeUludCA9IHkgLyB3O1xuICBpZiAoRG91YmxlLmlzTmFOKHhJbnQpIHx8IChEb3VibGUuaXNJbmZpbml0ZSh4SW50KSB8fCBEb3VibGUuaXNOYU4oeUludCkpIHx8IERvdWJsZS5pc0luZmluaXRlKHlJbnQpKSB7XG4gICAgdGhyb3cgbmV3IE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24oKVxuICB9XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSh4SW50LCB5SW50KVxufTtcblxudmFyIEVudmVsb3BlID0gZnVuY3Rpb24gRW52ZWxvcGUgKCkge1xuICB0aGlzLl9taW54ID0gbnVsbDtcbiAgdGhpcy5fbWF4eCA9IG51bGw7XG4gIHRoaXMuX21pbnkgPSBudWxsO1xuICB0aGlzLl9tYXh5ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KHAueCwgcC54LCBwLnksIHAueSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbnZlbG9wZSkge1xuICAgICAgdmFyIGVudiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdChlbnYpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmluaXQocDEueCwgcDIueCwgcDEueSwgcDIueSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciB4MSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeDIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHkxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciB5MiA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLmluaXQoeDEsIHgyLCB5MSwgeTIpO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDkgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gIHJldHVybiB0aGlzLmdldFdpZHRoKCkgKiB0aGlzLmdldEhlaWdodCgpXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBFbnZlbG9wZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgb3RoZXJFbnZlbG9wZSA9IG90aGVyO1xuICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgIHJldHVybiBvdGhlckVudmVsb3BlLmlzTnVsbCgpXG4gIH1cbiAgcmV0dXJuIHRoaXMuX21heHggPT09IG90aGVyRW52ZWxvcGUuZ2V0TWF4WCgpICYmIHRoaXMuX21heHkgPT09IG90aGVyRW52ZWxvcGUuZ2V0TWF4WSgpICYmIHRoaXMuX21pbnggPT09IG90aGVyRW52ZWxvcGUuZ2V0TWluWCgpICYmIHRoaXMuX21pbnkgPT09IG90aGVyRW52ZWxvcGUuZ2V0TWluWSgpXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAoZW52KSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpIHx8IGVudi5pc051bGwoKSB8fCAhdGhpcy5pbnRlcnNlY3RzKGVudikpIHsgcmV0dXJuIG5ldyBFbnZlbG9wZSgpIH1cbiAgdmFyIGludE1pblggPSB0aGlzLl9taW54ID4gZW52Ll9taW54ID8gdGhpcy5fbWlueCA6IGVudi5fbWlueDtcbiAgdmFyIGludE1pblkgPSB0aGlzLl9taW55ID4gZW52Ll9taW55ID8gdGhpcy5fbWlueSA6IGVudi5fbWlueTtcbiAgdmFyIGludE1heFggPSB0aGlzLl9tYXh4IDwgZW52Ll9tYXh4ID8gdGhpcy5fbWF4eCA6IGVudi5fbWF4eDtcbiAgdmFyIGludE1heFkgPSB0aGlzLl9tYXh5IDwgZW52Ll9tYXh5ID8gdGhpcy5fbWF4eSA6IGVudi5fbWF4eTtcbiAgcmV0dXJuIG5ldyBFbnZlbG9wZShpbnRNaW5YLCBpbnRNYXhYLCBpbnRNaW5ZLCBpbnRNYXhZKVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbiBpc051bGwgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4eCA8IHRoaXMuX21pbnhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0TWF4WCA9IGZ1bmN0aW9uIGdldE1heFggKCkge1xuICByZXR1cm4gdGhpcy5fbWF4eFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5jb3ZlcnMgPSBmdW5jdGlvbiBjb3ZlcnMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNvdmVycyhwLngsIHAueSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVudmVsb3BlKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAodGhpcy5pc051bGwoKSB8fCBvdGhlci5pc051bGwoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdGhlci5nZXRNaW5YKCkgPj0gdGhpcy5fbWlueCAmJiBvdGhlci5nZXRNYXhYKCkgPD0gdGhpcy5fbWF4eCAmJiBvdGhlci5nZXRNaW5ZKCkgPj0gdGhpcy5fbWlueSAmJiBvdGhlci5nZXRNYXhZKCkgPD0gdGhpcy5fbWF4eVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuaXNOdWxsKCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4geCA+PSB0aGlzLl9taW54ICYmIHggPD0gdGhpcy5fbWF4eCAmJiB5ID49IHRoaXMuX21pbnkgJiYgeSA8PSB0aGlzLl9tYXh5XG4gIH1cbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbnZlbG9wZSkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKHRoaXMuaXNOdWxsKCkgfHwgb3RoZXIuaXNOdWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gIShvdGhlci5fbWlueCA+IHRoaXMuX21heHggfHwgb3RoZXIuX21heHggPCB0aGlzLl9taW54IHx8IG90aGVyLl9taW55ID4gdGhpcy5fbWF4eSB8fCBvdGhlci5fbWF4eSA8IHRoaXMuX21pbnkpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdHMocC54LCBwLnkpXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiAhKHggPiB0aGlzLl9tYXh4IHx8IHggPCB0aGlzLl9taW54IHx8IHkgPiB0aGlzLl9tYXh5IHx8IHkgPCB0aGlzLl9taW55KVxuICB9XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldE1pblkgPSBmdW5jdGlvbiBnZXRNaW5ZICgpIHtcbiAgcmV0dXJuIHRoaXMuX21pbnlcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0TWluWCA9IGZ1bmN0aW9uIGdldE1pblggKCkge1xuICByZXR1cm4gdGhpcy5fbWlueFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5leHBhbmRUb0luY2x1ZGUgPSBmdW5jdGlvbiBleHBhbmRUb0luY2x1ZGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuZXhwYW5kVG9JbmNsdWRlKHAueCwgcC55KTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVudmVsb3BlKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAob3RoZXIuaXNOdWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgICAgIHRoaXMuX21pbnggPSBvdGhlci5nZXRNaW5YKCk7XG4gICAgICAgIHRoaXMuX21heHggPSBvdGhlci5nZXRNYXhYKCk7XG4gICAgICAgIHRoaXMuX21pbnkgPSBvdGhlci5nZXRNaW5ZKCk7XG4gICAgICAgIHRoaXMuX21heHkgPSBvdGhlci5nZXRNYXhZKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3RoZXIuX21pbnggPCB0aGlzLl9taW54KSB7XG4gICAgICAgICAgdGhpcy5fbWlueCA9IG90aGVyLl9taW54O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5fbWF4eCA+IHRoaXMuX21heHgpIHtcbiAgICAgICAgICB0aGlzLl9tYXh4ID0gb3RoZXIuX21heHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyLl9taW55IDwgdGhpcy5fbWlueSkge1xuICAgICAgICAgIHRoaXMuX21pbnkgPSBvdGhlci5fbWlueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIuX21heHkgPiB0aGlzLl9tYXh5KSB7XG4gICAgICAgICAgdGhpcy5fbWF4eSA9IG90aGVyLl9tYXh5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgICAgdGhpcy5fbWlueCA9IHg7XG4gICAgICB0aGlzLl9tYXh4ID0geDtcbiAgICAgIHRoaXMuX21pbnkgPSB5O1xuICAgICAgdGhpcy5fbWF4eSA9IHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4IDwgdGhpcy5fbWlueCkge1xuICAgICAgICB0aGlzLl9taW54ID0geDtcbiAgICAgIH1cbiAgICAgIGlmICh4ID4gdGhpcy5fbWF4eCkge1xuICAgICAgICB0aGlzLl9tYXh4ID0geDtcbiAgICAgIH1cbiAgICAgIGlmICh5IDwgdGhpcy5fbWlueSkge1xuICAgICAgICB0aGlzLl9taW55ID0geTtcbiAgICAgIH1cbiAgICAgIGlmICh5ID4gdGhpcy5fbWF4eSkge1xuICAgICAgICB0aGlzLl9tYXh5ID0geTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5FbnZlbG9wZS5wcm90b3R5cGUubWluRXh0ZW50ID0gZnVuY3Rpb24gbWluRXh0ZW50ICgpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHsgcmV0dXJuIDAuMCB9XG4gIHZhciB3ID0gdGhpcy5nZXRXaWR0aCgpO1xuICB2YXIgaCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gIGlmICh3IDwgaCkgeyByZXR1cm4gdyB9XG4gIHJldHVybiBoXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGggKCkge1xuICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgcmV0dXJuIHRoaXMuX21heHggLSB0aGlzLl9taW54XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgZW52ID0gbztcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICBpZiAoZW52LmlzTnVsbCgpKSB7IHJldHVybiAwIH1cbiAgICByZXR1cm4gLTFcbiAgfSBlbHNlIHtcbiAgICBpZiAoZW52LmlzTnVsbCgpKSB7IHJldHVybiAxIH1cbiAgfVxuICBpZiAodGhpcy5fbWlueCA8IGVudi5fbWlueCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fbWlueCA+IGVudi5fbWlueCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9taW55IDwgZW52Ll9taW55KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9taW55ID4gZW52Ll9taW55KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX21heHggPCBlbnYuX21heHgpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX21heHggPiBlbnYuX21heHgpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fbWF4eSA8IGVudi5fbWF4eSkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fbWF4eSA+IGVudi5fbWF4eSkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIHRyYW5zbGF0ZSAodHJhbnNYLCB0cmFuc1kpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHRoaXMuaW5pdCh0aGlzLmdldE1pblgoKSArIHRyYW5zWCwgdGhpcy5nZXRNYXhYKCkgKyB0cmFuc1gsIHRoaXMuZ2V0TWluWSgpICsgdHJhbnNZLCB0aGlzLmdldE1heFkoKSArIHRyYW5zWSk7XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gJ0VudlsnICsgdGhpcy5fbWlueCArICcgOiAnICsgdGhpcy5fbWF4eCArICcsICcgKyB0aGlzLl9taW55ICsgJyA6ICcgKyB0aGlzLl9tYXh5ICsgJ10nXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLnNldFRvTnVsbCA9IGZ1bmN0aW9uIHNldFRvTnVsbCAoKSB7XG4gIHRoaXMuX21pbnggPSAwO1xuICB0aGlzLl9tYXh4ID0gLTE7XG4gIHRoaXMuX21pbnkgPSAwO1xuICB0aGlzLl9tYXh5ID0gLTE7XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uIGdldEhlaWdodCAoKSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICByZXR1cm4gdGhpcy5fbWF4eSAtIHRoaXMuX21pbnlcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUubWF4RXh0ZW50ID0gZnVuY3Rpb24gbWF4RXh0ZW50ICgpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHsgcmV0dXJuIDAuMCB9XG4gIHZhciB3ID0gdGhpcy5nZXRXaWR0aCgpO1xuICB2YXIgaCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG4gIGlmICh3ID4gaCkgeyByZXR1cm4gdyB9XG4gIHJldHVybiBoXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmV4cGFuZEJ5ID0gZnVuY3Rpb24gZXhwYW5kQnkgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBkaXN0YW5jZSA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLmV4cGFuZEJ5KGRpc3RhbmNlLCBkaXN0YW5jZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBkZWx0YVggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGRlbHRhWSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdGhpcy5fbWlueCAtPSBkZWx0YVg7XG4gICAgdGhpcy5fbWF4eCArPSBkZWx0YVg7XG4gICAgdGhpcy5fbWlueSAtPSBkZWx0YVk7XG4gICAgdGhpcy5fbWF4eSArPSBkZWx0YVk7XG4gICAgaWYgKHRoaXMuX21pbnggPiB0aGlzLl9tYXh4IHx8IHRoaXMuX21pbnkgPiB0aGlzLl9tYXh5KSB7IHRoaXMuc2V0VG9OdWxsKCk7IH1cbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRW52ZWxvcGUpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNvdmVycyhvdGhlcilcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY292ZXJzKHApXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcbiAgICByZXR1cm4gdGhpcy5jb3ZlcnMoeCwgeSlcbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5jZW50cmUgPSBmdW5jdGlvbiBjZW50cmUgKCkge1xuICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gbnVsbCB9XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSgodGhpcy5nZXRNaW5YKCkgKyB0aGlzLmdldE1heFgoKSkgLyAyLjAsICh0aGlzLmdldE1pblkoKSArIHRoaXMuZ2V0TWF4WSgpKSAvIDIuMClcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuc2V0VG9OdWxsKCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdChwLngsIHAueCwgcC55LCBwLnkpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRW52ZWxvcGUpIHtcbiAgICAgIHZhciBlbnYgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9taW54ID0gZW52Ll9taW54O1xuICAgICAgdGhpcy5fbWF4eCA9IGVudi5fbWF4eDtcbiAgICAgIHRoaXMuX21pbnkgPSBlbnYuX21pbnk7XG4gICAgICB0aGlzLl9tYXh5ID0gZW52Ll9tYXh5O1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmluaXQocDEueCwgcDIueCwgcDEueSwgcDIueSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciB4MSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeDIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHkxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciB5MiA9IGFyZ3VtZW50c1szXTtcbiAgICBpZiAoeDEgPCB4Mikge1xuICAgICAgdGhpcy5fbWlueCA9IHgxO1xuICAgICAgdGhpcy5fbWF4eCA9IHgyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9taW54ID0geDI7XG4gICAgICB0aGlzLl9tYXh4ID0geDE7XG4gICAgfVxuICAgIGlmICh5MSA8IHkyKSB7XG4gICAgICB0aGlzLl9taW55ID0geTE7XG4gICAgICB0aGlzLl9tYXh5ID0geTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21pbnkgPSB5MjtcbiAgICAgIHRoaXMuX21heHkgPSB5MTtcbiAgICB9XG4gIH1cbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0TWF4WSA9IGZ1bmN0aW9uIGdldE1heFkgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4eVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlIChlbnYpIHtcbiAgaWYgKHRoaXMuaW50ZXJzZWN0cyhlbnYpKSB7IHJldHVybiAwIH1cbiAgdmFyIGR4ID0gMC4wO1xuICBpZiAodGhpcy5fbWF4eCA8IGVudi5fbWlueCkgeyBkeCA9IGVudi5fbWlueCAtIHRoaXMuX21heHg7IH0gZWxzZSBpZiAodGhpcy5fbWlueCA+IGVudi5fbWF4eCkgeyBkeCA9IHRoaXMuX21pbnggLSBlbnYuX21heHg7IH1cbiAgdmFyIGR5ID0gMC4wO1xuICBpZiAodGhpcy5fbWF4eSA8IGVudi5fbWlueSkgeyBkeSA9IGVudi5fbWlueSAtIHRoaXMuX21heHk7IH0gZWxzZSBpZiAodGhpcy5fbWlueSA+IGVudi5fbWF4eSkgeyBkeSA9IHRoaXMuX21pbnkgLSBlbnYuX21heHk7IH1cbiAgaWYgKGR4ID09PSAwLjApIHsgcmV0dXJuIGR5IH1cbiAgaWYgKGR5ID09PSAwLjApIHsgcmV0dXJuIGR4IH1cbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gIHZhciByZXN1bHQgPSAxNztcbiAgcmVzdWx0ID0gMzcgKiByZXN1bHQgKyBDb29yZGluYXRlLmhhc2hDb2RlKHRoaXMuX21pbngpO1xuICByZXN1bHQgPSAzNyAqIHJlc3VsdCArIENvb3JkaW5hdGUuaGFzaENvZGUodGhpcy5fbWF4eCk7XG4gIHJlc3VsdCA9IDM3ICogcmVzdWx0ICsgQ29vcmRpbmF0ZS5oYXNoQ29kZSh0aGlzLl9taW55KTtcbiAgcmVzdWx0ID0gMzcgKiByZXN1bHQgKyBDb29yZGluYXRlLmhhc2hDb2RlKHRoaXMuX21heHkpO1xuICByZXR1cm4gcmVzdWx0XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFbnZlbG9wZVxufTtcbkVudmVsb3BlLmludGVyc2VjdHMgPSBmdW5jdGlvbiBpbnRlcnNlY3RzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAyID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBxID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChxLnggPj0gKHAxLnggPCBwMi54ID8gcDEueCA6IHAyLngpICYmIHEueCA8PSAocDEueCA+IHAyLnggPyBwMS54IDogcDIueCkgJiYgKHEueSA+PSAocDEueSA8IHAyLnkgPyBwMS55IDogcDIueSkgJiYgcS55IDw9IChwMS55ID4gcDIueSA/IHAxLnkgOiBwMi55KSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgcDEkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDIkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHEyID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBtaW5xID0gTWF0aC5taW4ocTEueCwgcTIueCk7XG4gICAgdmFyIG1heHEgPSBNYXRoLm1heChxMS54LCBxMi54KTtcbiAgICB2YXIgbWlucCA9IE1hdGgubWluKHAxJDEueCwgcDIkMS54KTtcbiAgICB2YXIgbWF4cCA9IE1hdGgubWF4KHAxJDEueCwgcDIkMS54KTtcbiAgICBpZiAobWlucCA+IG1heHEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAobWF4cCA8IG1pbnEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBtaW5xID0gTWF0aC5taW4ocTEueSwgcTIueSk7XG4gICAgbWF4cSA9IE1hdGgubWF4KHExLnksIHEyLnkpO1xuICAgIG1pbnAgPSBNYXRoLm1pbihwMSQxLnksIHAyJDEueSk7XG4gICAgbWF4cCA9IE1hdGgubWF4KHAxJDEueSwgcDIkMS55KTtcbiAgICBpZiAobWlucCA+IG1heHEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAobWF4cCA8IG1pbnEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuc3RhdGljQWNjZXNzb3JzJDkuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA1ODczOTIxODg1MjczMTAyNDIwIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBFbnZlbG9wZSwgc3RhdGljQWNjZXNzb3JzJDkgKTtcblxudmFyIHJlZ0V4ZXMgPSB7XG4gICd0eXBlU3RyJzogL15cXHMqKFxcdyspXFxzKlxcKFxccyooLiopXFxzKlxcKVxccyokLyxcbiAgJ2VtcHR5VHlwZVN0cic6IC9eXFxzKihcXHcrKVxccypFTVBUWVxccyokLyxcbiAgJ3NwYWNlcyc6IC9cXHMrLyxcbiAgJ3BhcmVuQ29tbWEnOiAvXFwpXFxzKixcXHMqXFwoLyxcbiAgJ2RvdWJsZVBhcmVuQ29tbWEnOiAvXFwpXFxzKlxcKVxccyosXFxzKlxcKFxccypcXCgvLCAvLyBjYW4ndCB1c2UgezJ9IGhlcmVcbiAgJ3RyaW1QYXJlbnMnOiAvXlxccypcXCg/KC4qPylcXCk/XFxzKiQvXG59O1xuXG4vKipcbiAqIENsYXNzIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIFdlbGwtS25vd24gVGV4dC5cbiAqXG4gKiBOT1RFOiBBZGFwdGVkIGZyb20gT3BlbkxheWVycyAyLjExIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKiBDcmVhdGUgYSBuZXcgcGFyc2VyIGZvciBXS1RcbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5RmFjdG9yeX0gZ2VvbWV0cnlGYWN0b3J5XG4gKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIFdLVFBhcnNlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIFdLVFBhcnNlciA9IGZ1bmN0aW9uIFdLVFBhcnNlciAoZ2VvbWV0cnlGYWN0b3J5KSB7XG4gIHRoaXMuZ2VvbWV0cnlGYWN0b3J5ID0gZ2VvbWV0cnlGYWN0b3J5IHx8IG5ldyBHZW9tZXRyeUZhY3RvcnkoKTtcbn07XG4vKipcbiAqIERlc2VyaWFsaXplIGEgV0tUIHN0cmluZyBhbmQgcmV0dXJuIGEgZ2VvbWV0cnkuIFN1cHBvcnRzIFdLVCBmb3IgUE9JTlQsXG4gKiBNVUxUSVBPSU5ULCBMSU5FU1RSSU5HLCBMSU5FQVJSSU5HLCBNVUxUSUxJTkVTVFJJTkcsIFBPTFlHT04sIE1VTFRJUE9MWUdPTixcbiAqIGFuZCBHRU9NRVRSWUNPTExFQ1RJT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHdrdCBBIFdLVCBzdHJpbmcuXG4gKiBAcmV0dXJuIHtHZW9tZXRyeX0gQSBnZW9tZXRyeSBpbnN0YW5jZS5cbiAqIEBwcml2YXRlXG4gKi9cbldLVFBhcnNlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIHJlYWQgKHdrdCkge1xuICB2YXIgZ2VvbWV0cnksIHR5cGUsIHN0cjtcbiAgd2t0ID0gd2t0LnJlcGxhY2UoL1tcXG5cXHJdL2csICcgJyk7XG4gIHZhciBtYXRjaGVzID0gcmVnRXhlcy50eXBlU3RyLmV4ZWMod2t0KTtcbiAgaWYgKHdrdC5zZWFyY2goJ0VNUFRZJykgIT09IC0xKSB7XG4gICAgbWF0Y2hlcyA9IHJlZ0V4ZXMuZW1wdHlUeXBlU3RyLmV4ZWMod2t0KTtcbiAgICBtYXRjaGVzWzJdID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChtYXRjaGVzKSB7XG4gICAgdHlwZSA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICBzdHIgPSBtYXRjaGVzWzJdO1xuICAgIGlmIChwYXJzZSQxW3R5cGVdKSB7XG4gICAgICBnZW9tZXRyeSA9IHBhcnNlJDFbdHlwZV0uYXBwbHkodGhpcywgW3N0cl0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChnZW9tZXRyeSA9PT0gdW5kZWZpbmVkKSB7IHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHBhcnNlIFdLVCAnICsgd2t0KSB9XG5cbiAgcmV0dXJuIGdlb21ldHJ5XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSBhIGdlb21ldHJ5IGludG8gYSBXS1Qgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IEEgZmVhdHVyZSBvciBhcnJheSBvZiBmZWF0dXJlcy5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIFdLVCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGlucHV0IGdlb21ldHJpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5XS1RQYXJzZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKGdlb21ldHJ5KSB7XG4gIHJldHVybiB0aGlzLmV4dHJhY3RHZW9tZXRyeShnZW9tZXRyeSlcbn07XG5cbi8qKlxuICogRW50cnkgcG9pbnQgdG8gY29uc3RydWN0IHRoZSBXS1QgZm9yIGEgc2luZ2xlIEdlb21ldHJ5IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeVxuICogQHJldHVybiB7U3RyaW5nfSBBIFdLVCBzdHJpbmcgb2YgcmVwcmVzZW50aW5nIHRoZSBnZW9tZXRyeS5cbiAqIEBwcml2YXRlXG4gKi9cbldLVFBhcnNlci5wcm90b3R5cGUuZXh0cmFjdEdlb21ldHJ5ID0gZnVuY3Rpb24gZXh0cmFjdEdlb21ldHJ5IChnZW9tZXRyeSkge1xuICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldEdlb21ldHJ5VHlwZSgpLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghZXh0cmFjdCQxW3R5cGVdKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgd2t0VHlwZSA9IHR5cGUudG9VcHBlckNhc2UoKTtcbiAgdmFyIGRhdGE7XG4gIGlmIChnZW9tZXRyeS5pc0VtcHR5KCkpIHtcbiAgICBkYXRhID0gd2t0VHlwZSArICcgRU1QVFknO1xuICB9IGVsc2Uge1xuICAgIGRhdGEgPSB3a3RUeXBlICsgJygnICsgZXh0cmFjdCQxW3R5cGVdLmFwcGx5KHRoaXMsIFtnZW9tZXRyeV0pICsgJyknO1xuICB9XG4gIHJldHVybiBkYXRhXG59O1xuXG4vKipcbiAqIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2VvbWV0cnkgdHlwZXMuIFByb3BlcnR5IHZhbHVlc1xuICogYXJlIGZ1bmN0aW9ucyB0aGF0IGRvIHRoZSBhY3R1YWwgZGF0YSBleHRyYWN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4dHJhY3QkMSA9IHtcbiAgY29vcmRpbmF0ZTogZnVuY3Rpb24gY29vcmRpbmF0ZSAoY29vcmRpbmF0ZSQxKSB7XG4gICAgcmV0dXJuIGNvb3JkaW5hdGUkMS54ICsgJyAnICsgY29vcmRpbmF0ZSQxLnlcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgc3BhY2UgZGVsaW1pdGVkIHN0cmluZyBvZiBwb2ludCBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2ludH1cbiAgICogICAgICAgICAgcG9pbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyBvZiBjb29yZGluYXRlcyByZXByZXNlbnRpbmcgdGhlIHBvaW50LlxuICAgKi9cbiAgcG9pbnQ6IGZ1bmN0aW9uIHBvaW50IChwb2ludCQxKSB7XG4gICAgcmV0dXJuIGV4dHJhY3QkMS5jb29yZGluYXRlLmNhbGwodGhpcywgcG9pbnQkMS5fY29vcmRpbmF0ZXMuX2Nvb3JkaW5hdGVzWzBdKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nIG9mIHBvaW50IGNvb3JkaW5hdGVzIGZyb20gYSBtdWx0aXBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpUG9pbnR9XG4gICAqICAgICAgICAgIG11bHRpcG9pbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyBvZiBwb2ludCBjb29yZGluYXRlIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZVxuICAgKiAgICAgICAgIG11bHRpcG9pbnQuXG4gICAqL1xuICBtdWx0aXBvaW50OiBmdW5jdGlvbiBtdWx0aXBvaW50IChtdWx0aXBvaW50JDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtdWx0aXBvaW50JDEuX2dlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goJygnICsgZXh0cmFjdCQxLnBvaW50LmFwcGx5KHRoaXMkMSwgW211bHRpcG9pbnQkMS5fZ2VvbWV0cmllc1tpXV0pICsgJyknKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nIG9mIHBvaW50IGNvb3JkaW5hdGVzIGZyb20gYSBsaW5lLlxuICAgKlxuICAgKiBAcGFyYW0ge0xpbmVTdHJpbmd9IGxpbmVzdHJpbmdcbiAgICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyBvZiBwb2ludCBjb29yZGluYXRlIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBsaW5lc3RyaW5nLlxuICAgKi9cbiAgbGluZXN0cmluZzogZnVuY3Rpb24gbGluZXN0cmluZyAobGluZXN0cmluZyQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXN0cmluZyQxLl9wb2ludHMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKGV4dHJhY3QkMS5jb29yZGluYXRlLmFwcGx5KHRoaXMkMSwgW2xpbmVzdHJpbmckMS5fcG9pbnRzLl9jb29yZGluYXRlc1tpXV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9LFxuXG4gIGxpbmVhcnJpbmc6IGZ1bmN0aW9uIGxpbmVhcnJpbmcgKGxpbmVhcnJpbmckMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVhcnJpbmckMS5fcG9pbnRzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXJyYXkucHVzaChleHRyYWN0JDEuY29vcmRpbmF0ZS5hcHBseSh0aGlzJDEsIFtsaW5lYXJyaW5nJDEuX3BvaW50cy5fY29vcmRpbmF0ZXNbaV1dKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZyBvZiBsaW5lc3RyaW5nIHN0cmluZ3MgZnJvbSBhXG4gICAqIG11bHRpbGluZXN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aUxpbmVTdHJpbmd9IG11bHRpbGluZXN0cmluZ1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIG9mIG9mIGxpbmVzdHJpbmcgc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIG11bHRpbGluZXN0cmluZy5cbiAgICovXG4gIG11bHRpbGluZXN0cmluZzogZnVuY3Rpb24gbXVsdGlsaW5lc3RyaW5nIChtdWx0aWxpbmVzdHJpbmckMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG11bHRpbGluZXN0cmluZyQxLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKCcoJyArXG4gICAgICAgIGV4dHJhY3QkMS5saW5lc3RyaW5nLmFwcGx5KHRoaXMkMSwgW211bHRpbGluZXN0cmluZyQxLl9nZW9tZXRyaWVzW2ldXSkgK1xuICAgICAgICAnKScpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcgb2YgbGluZWFyIHJpbmcgYXJyYXlzIGZyb20gYSBwb2x5Z29uLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHlnb259IHBvbHlnb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBBbiBhcnJheSBvZiBsaW5lYXIgcmluZyBhcnJheXMgcmVwcmVzZW50aW5nIHRoZSBwb2x5Z29uLlxuICAgKi9cbiAgcG9seWdvbjogZnVuY3Rpb24gcG9seWdvbiAocG9seWdvbiQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBhcnJheS5wdXNoKCcoJyArIGV4dHJhY3QkMS5saW5lc3RyaW5nLmFwcGx5KHRoaXMsIFtwb2x5Z29uJDEuX3NoZWxsXSkgKyAnKScpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2x5Z29uJDEuX2hvbGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKCcoJyArIGV4dHJhY3QkMS5saW5lc3RyaW5nLmFwcGx5KHRoaXMkMSwgW3BvbHlnb24kMS5faG9sZXNbaV1dKSArICcpJyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHBvbHlnb24gYXJyYXlzIGZyb20gYSBtdWx0aXBvbHlnb24uXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlQb2x5Z29ufSBtdWx0aXBvbHlnb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBBbiBhcnJheSBvZiBwb2x5Z29uIGFycmF5cyByZXByZXNlbnRpbmcgdGhlIG11bHRpcG9seWdvbi5cbiAgICovXG4gIG11bHRpcG9seWdvbjogZnVuY3Rpb24gbXVsdGlwb2x5Z29uIChtdWx0aXBvbHlnb24kMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG11bHRpcG9seWdvbiQxLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKCcoJyArIGV4dHJhY3QkMS5wb2x5Z29uLmFwcGx5KHRoaXMkMSwgW211bHRpcG9seWdvbiQxLl9nZW9tZXRyaWVzW2ldXSkgKyAnKScpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgV0tUIHBvcnRpb24gYmV0d2VlbiAnR0VPTUVUUllDT0xMRUNUSU9OKCcgYW5kICcpJyBmb3IgYW5cbiAgICogZ2VvbWV0cnljb2xsZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5Q29sbGVjdGlvbn0gY29sbGVjdGlvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGludGVybmFsIFdLVCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICovXG4gIGdlb21ldHJ5Y29sbGVjdGlvbjogZnVuY3Rpb24gZ2VvbWV0cnljb2xsZWN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29sbGVjdGlvbi5fZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXJyYXkucHVzaCh0aGlzJDEuZXh0cmFjdEdlb21ldHJ5KGNvbGxlY3Rpb24uX2dlb21ldHJpZXNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9XG59O1xuXG4vKipcbiAqIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2VvbWV0cnkgdHlwZXMuIFByb3BlcnR5IHZhbHVlc1xuICogYXJlIGZ1bmN0aW9ucyB0aGF0IGRvIHRoZSBhY3R1YWwgcGFyc2luZy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBwYXJzZSQxID0ge1xuICAvKipcbiAgICogUmV0dXJuIHBvaW50IGdlb21ldHJ5IGdpdmVuIGEgcG9pbnQgV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgcG9pbnQuXG4gICAqIEByZXR1cm4ge1BvaW50fSBBIHBvaW50IGdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcG9pbnQ6IGZ1bmN0aW9uIHBvaW50IChzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludCgpXG4gICAgfVxuXG4gICAgdmFyIGNvb3JkcyA9IHN0ci50cmltKCkuc3BsaXQocmVnRXhlcy5zcGFjZXMpO1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChuZXcgQ29vcmRpbmF0ZShOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMF0pLFxuICAgICAgTnVtYmVyLnBhcnNlRmxvYXQoY29vcmRzWzFdKSkpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG11bHRpcG9pbnQgZ2VvbWV0cnkgZ2l2ZW4gYSBtdWx0aXBvaW50IFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIG11bHRpcG9pbnQuXG4gICAqIEByZXR1cm4ge1BvaW50fSBBIG11bHRpcG9pbnQgZmVhdHVyZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG11bHRpcG9pbnQ6IGZ1bmN0aW9uIG11bHRpcG9pbnQgKHN0cikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludCgpXG4gICAgfVxuXG4gICAgdmFyIHBvaW50O1xuICAgIHZhciBwb2ludHMgPSBzdHIudHJpbSgpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXS5yZXBsYWNlKHJlZ0V4ZXMudHJpbVBhcmVucywgJyQxJyk7XG4gICAgICBjb21wb25lbnRzLnB1c2gocGFyc2UkMS5wb2ludC5hcHBseSh0aGlzJDEsIFtwb2ludF0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoY29tcG9uZW50cylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbGluZXN0cmluZyBnZW9tZXRyeSBnaXZlbiBhIGxpbmVzdHJpbmcgV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7TGluZVN0cmluZ30gQSBsaW5lc3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbGluZXN0cmluZzogZnVuY3Rpb24gbGluZXN0cmluZyAoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZygpXG4gICAgfVxuXG4gICAgdmFyIHBvaW50cyA9IHN0ci50cmltKCkuc3BsaXQoJywnKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIHZhciBjb29yZHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29vcmRzID0gcG9pbnRzW2ldLnRyaW0oKS5zcGxpdChyZWdFeGVzLnNwYWNlcyk7XG4gICAgICBjb21wb25lbnRzLnB1c2gobmV3IENvb3JkaW5hdGUoTnVtYmVyLnBhcnNlRmxvYXQoY29vcmRzWzBdKSwgTnVtYmVyLnBhcnNlRmxvYXQoY29vcmRzWzFdKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhjb21wb25lbnRzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBsaW5lYXJyaW5nIGdlb21ldHJ5IGdpdmVuIGEgbGluZWFycmluZyBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBsaW5lYXJyaW5nLlxuICAgKiBAcmV0dXJuIHtMaW5lYXJSaW5nfSBBIGxpbmVhcnJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsaW5lYXJyaW5nOiBmdW5jdGlvbiBsaW5lYXJyaW5nIChzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKClcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRzID0gc3RyLnRyaW0oKS5zcGxpdCgnLCcpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgdmFyIGNvb3JkcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb29yZHMgPSBwb2ludHNbaV0udHJpbSgpLnNwbGl0KHJlZ0V4ZXMuc3BhY2VzKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChuZXcgQ29vcmRpbmF0ZShOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMF0pLCBOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMV0pKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGNvbXBvbmVudHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG11bHRpbGluZXN0cmluZyBnZW9tZXRyeSBnaXZlbiBhIG11bHRpbGluZXN0cmluZyBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqIEByZXR1cm4ge011bHRpTGluZVN0cmluZ30gQSBtdWx0aWxpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtdWx0aWxpbmVzdHJpbmc6IGZ1bmN0aW9uIG11bHRpbGluZXN0cmluZyAoc3RyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKVxuICAgIH1cblxuICAgIHZhciBsaW5lO1xuICAgIHZhciBsaW5lcyA9IHN0ci50cmltKCkuc3BsaXQocmVnRXhlcy5wYXJlbkNvbW1hKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgbGluZSA9IGxpbmVzW2ldLnJlcGxhY2UocmVnRXhlcy50cmltUGFyZW5zLCAnJDEnKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChwYXJzZSQxLmxpbmVzdHJpbmcuYXBwbHkodGhpcyQxLCBbbGluZV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhjb21wb25lbnRzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwb2x5Z29uIGdlb21ldHJ5IGdpdmVuIGEgcG9seWdvbiBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHtQb2x5Z29ufSBBIHBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwb2x5Z29uOiBmdW5jdGlvbiBwb2x5Z29uIChzdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24oKVxuICAgIH1cblxuICAgIHZhciByaW5nLCBsaW5lc3RyaW5nLCBsaW5lYXJyaW5nO1xuICAgIHZhciByaW5ncyA9IHN0ci50cmltKCkuc3BsaXQocmVnRXhlcy5wYXJlbkNvbW1hKTtcbiAgICB2YXIgc2hlbGw7XG4gICAgdmFyIGhvbGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICByaW5nID0gcmluZ3NbaV0ucmVwbGFjZShyZWdFeGVzLnRyaW1QYXJlbnMsICckMScpO1xuICAgICAgbGluZXN0cmluZyA9IHBhcnNlJDEubGluZXN0cmluZy5hcHBseSh0aGlzJDEsIFtyaW5nXSk7XG4gICAgICBsaW5lYXJyaW5nID0gdGhpcyQxLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGxpbmVzdHJpbmcuX3BvaW50cyk7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBzaGVsbCA9IGxpbmVhcnJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob2xlcy5wdXNoKGxpbmVhcnJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihzaGVsbCwgaG9sZXMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIG11bHRpcG9seWdvbiBnZW9tZXRyeSBnaXZlbiBhIG11bHRpcG9seWdvbiBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBtdWx0aXBvbHlnb24uXG4gICAqIEByZXR1cm4ge011bHRpUG9seWdvbn0gQSBtdWx0aXBvbHlnb24gZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtdWx0aXBvbHlnb246IGZ1bmN0aW9uIG11bHRpcG9seWdvbiAoc3RyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oKVxuICAgIH1cblxuICAgIHZhciBwb2x5Z29uO1xuICAgIHZhciBwb2x5Z29ucyA9IHN0ci50cmltKCkuc3BsaXQocmVnRXhlcy5kb3VibGVQYXJlbkNvbW1hKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2x5Z29ucy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgcG9seWdvbiA9IHBvbHlnb25zW2ldLnJlcGxhY2UocmVnRXhlcy50cmltUGFyZW5zLCAnJDEnKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChwYXJzZSQxLnBvbHlnb24uYXBwbHkodGhpcyQxLCBbcG9seWdvbl0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihjb21wb25lbnRzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBnZW9tZXRyeWNvbGxlY3Rpb24gZ2l2ZW4gYSBnZW9tZXRyeWNvbGxlY3Rpb24gV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgZ2VvbWV0cnljb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeUNvbGxlY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZW9tZXRyeWNvbGxlY3Rpb246IGZ1bmN0aW9uIGdlb21ldHJ5Y29sbGVjdGlvbiAoc3RyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKVxuICAgIH1cblxuICAgIC8vIHNlcGFyYXRlIGNvbXBvbmVudHMgb2YgdGhlIGNvbGxlY3Rpb24gd2l0aCB8XG4gICAgc3RyID0gc3RyLnJlcGxhY2UoLyxcXHMqKFtBLVphLXpdKS9nLCAnfCQxJyk7XG4gICAgdmFyIHdrdEFycmF5ID0gc3RyLnRyaW0oKS5zcGxpdCgnfCcpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHdrdEFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb21wb25lbnRzLnB1c2godGhpcyQxLnJlYWQod2t0QXJyYXlbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihjb21wb25lbnRzKVxuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB0aGUgV2VsbC1Lbm93biBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIGEge0BsaW5rIEdlb21ldHJ5fS4gVGhlXG4gKiBXZWxsLUtub3duIFRleHQgZm9ybWF0IGlzIGRlZmluZWQgaW4gdGhlIDxBXG4gKiBIUkVGPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm9yZy90ZWNobm8vc3BlY3MuaHRtXCI+IE9HQyBTaW1wbGUgRmVhdHVyZXNcbiAqIFNwZWNpZmljYXRpb24gZm9yIFNRTDwvQT4uXG4gKiA8cD5cbiAqIFRoZSA8Y29kZT5XS1RXcml0ZXI8L2NvZGU+IG91dHB1dHMgY29vcmRpbmF0ZXMgcm91bmRlZCB0byB0aGUgcHJlY2lzaW9uXG4gKiBtb2RlbC4gT25seSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGVcbiAqIG9yZGluYXRlcyB0byB0aGUgcmVxdWlyZWQgcHJlY2lzaW9uIHdpbGwgYmUgb3V0cHV0LlxuICogPHA+XG4gKiBUaGUgU0ZTIFdLVCBzcGVjIGRvZXMgbm90IGRlZmluZSBhIHNwZWNpYWwgdGFnIGZvciB7QGxpbmsgTGluZWFyUmluZ31zLlxuICogVW5kZXIgdGhlIHNwZWMsIHJpbmdzIGFyZSBvdXRwdXQgYXMgPGNvZGU+TElORVNUUklORzwvY29kZT5zLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtHZW9tZXRyeUZhY3Rvcnl9IGdlb21ldHJ5RmFjdG9yeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBXS1RXcml0ZXIgPSBmdW5jdGlvbiBXS1RXcml0ZXIgKGdlb21ldHJ5RmFjdG9yeSkge1xuICB0aGlzLnBhcnNlciA9IG5ldyBXS1RQYXJzZXIoZ2VvbWV0cnlGYWN0b3J5KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSA8Y29kZT5HZW9tZXRyeTwvY29kZT4gdG8gaXRzIFdlbGwta25vd24gVGV4dCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeSBhIDxjb2RlPkdlb21ldHJ5PC9jb2RlPiB0byBwcm9jZXNzLlxuICogQHJldHVybiB7c3RyaW5nfSBhIDxHZW9tZXRyeSBUYWdnZWQgVGV4dD4gc3RyaW5nIChzZWUgdGhlIE9wZW5HSVMgU2ltcGxlXG4gKiAgICAgICBGZWF0dXJlcyBTcGVjaWZpY2F0aW9uKS5cbiAqIEBtZW1iZXJvZiBXS1RXcml0ZXJcbiAqL1xuV0tUV3JpdGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChnZW9tZXRyeSkge1xuICByZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUoZ2VvbWV0cnkpXG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIFdLVCBmb3IgYSA8dHQ+TElORVNUUklORzwvdHQ+IHNwZWNpZmllZCBieSB0d29cbiAqIHtAbGluayBDb29yZGluYXRlfXMuXG4gKlxuICogQHBhcmFtIHAwIHRoZSBmaXJzdCBjb29yZGluYXRlLlxuICogQHBhcmFtIHAxIHRoZSBzZWNvbmQgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcmV0dXJuIHRoZSBXS1QuXG4gKiBAcHJpdmF0ZVxuICovXG5XS1RXcml0ZXIudG9MaW5lU3RyaW5nID0gZnVuY3Rpb24gdG9MaW5lU3RyaW5nIChwMCwgcDEpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpXG4gIH1cbiAgcmV0dXJuICdMSU5FU1RSSU5HICggJyArIHAwLnggKyAnICcgKyBwMC55ICsgJywgJyArIHAxLnggKyAnICcgKyBwMS55ICsgJyApJ1xufTtcblxudmFyIFJ1bnRpbWVFeGNlcHRpb24gPSAoZnVuY3Rpb24gKEVycm9yKSB7XG4gIGZ1bmN0aW9uIFJ1bnRpbWVFeGNlcHRpb24gKG1lc3NhZ2UpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdSdW50aW1lRXhjZXB0aW9uJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICB9XG5cbiAgaWYgKCBFcnJvciApIFJ1bnRpbWVFeGNlcHRpb24uX19wcm90b19fID0gRXJyb3I7XG4gIFJ1bnRpbWVFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXJyb3IgJiYgRXJyb3IucHJvdG90eXBlICk7XG4gIFJ1bnRpbWVFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUnVudGltZUV4Y2VwdGlvbjtcblxuICByZXR1cm4gUnVudGltZUV4Y2VwdGlvbjtcbn0oRXJyb3IpKTtcblxudmFyIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoUnVudGltZUV4Y2VwdGlvbiQkMSkge1xuICBmdW5jdGlvbiBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24gKCkge1xuICAgIFJ1bnRpbWVFeGNlcHRpb24kJDEuY2FsbCh0aGlzKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgUnVudGltZUV4Y2VwdGlvbiQkMS5jYWxsKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgICBSdW50aW1lRXhjZXB0aW9uJCQxLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBSdW50aW1lRXhjZXB0aW9uJCQxICkgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLl9fcHJvdG9fXyA9IFJ1bnRpbWVFeGNlcHRpb24kJDE7XG4gIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSdW50aW1lRXhjZXB0aW9uJCQxICYmIFJ1bnRpbWVFeGNlcHRpb24kJDEucHJvdG90eXBlICk7XG4gIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb247XG4gIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvblxuICB9O1xuXG4gIHJldHVybiBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb247XG59KFJ1bnRpbWVFeGNlcHRpb24pKTtcblxudmFyIEFzc2VydCA9IGZ1bmN0aW9uIEFzc2VydCAoKSB7fTtcblxuQXNzZXJ0LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQXNzZXJ0LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEFzc2VydFxufTtcbkFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSA9IGZ1bmN0aW9uIHNob3VsZE5ldmVyUmVhY2hIZXJlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUobnVsbCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBtZXNzYWdlID0gYXJndW1lbnRzWzBdO1xuICAgIHRocm93IG5ldyBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24oJ1Nob3VsZCBuZXZlciByZWFjaCBoZXJlJyArIChtZXNzYWdlICE9PSBudWxsID8gJzogJyArIG1lc3NhZ2UgOiAnJykpXG4gIH1cbn07XG5Bc3NlcnQuaXNUcnVlID0gZnVuY3Rpb24gaXNUcnVlICgpIHtcbiAgdmFyIGFzc2VydGlvbjtcbiAgdmFyIG1lc3NhZ2U7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgYXNzZXJ0aW9uID0gYXJndW1lbnRzWzBdO1xuICAgIEFzc2VydC5pc1RydWUoYXNzZXJ0aW9uLCBudWxsKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgYXNzZXJ0aW9uID0gYXJndW1lbnRzWzBdO1xuICAgIG1lc3NhZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgIGlmIChtZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbihtZXNzYWdlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkFzc2VydC5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKCkge1xuICB2YXIgZXhwZWN0ZWRWYWx1ZTtcbiAgdmFyIGFjdHVhbFZhbHVlO1xuICB2YXIgbWVzc2FnZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBleHBlY3RlZFZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgIGFjdHVhbFZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIEFzc2VydC5lcXVhbHMoZXhwZWN0ZWRWYWx1ZSwgYWN0dWFsVmFsdWUsIG51bGwpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBleHBlY3RlZFZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgIGFjdHVhbFZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIG1lc3NhZ2UgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKCFhY3R1YWxWYWx1ZS5lcXVhbHMoZXhwZWN0ZWRWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24oJ0V4cGVjdGVkICcgKyBleHBlY3RlZFZhbHVlICsgJyBidXQgZW5jb3VudGVyZWQgJyArIGFjdHVhbFZhbHVlICsgKG1lc3NhZ2UgIT09IG51bGwgPyAnOiAnICsgbWVzc2FnZSA6ICcnKSlcbiAgICB9XG4gIH1cbn07XG5cbnZhciBMaW5lSW50ZXJzZWN0b3IgPSBmdW5jdGlvbiBMaW5lSW50ZXJzZWN0b3IgKCkge1xuICB0aGlzLl9yZXN1bHQgPSBudWxsO1xuICB0aGlzLl9pbnB1dExpbmVzID0gQXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJheSgyKTsgfSk7XG4gIHRoaXMuX2ludFB0ID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHRoaXMuX2ludExpbmVJbmRleCA9IG51bGw7XG4gIHRoaXMuX2lzUHJvcGVyID0gbnVsbDtcbiAgdGhpcy5fcGEgPSBudWxsO1xuICB0aGlzLl9wYiA9IG51bGw7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gbnVsbDtcbiAgdGhpcy5faW50UHRbMF0gPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICB0aGlzLl9pbnRQdFsxXSA9IG5ldyBDb29yZGluYXRlKCk7XG4gIHRoaXMuX3BhID0gdGhpcy5faW50UHRbMF07XG4gIHRoaXMuX3BiID0gdGhpcy5faW50UHRbMV07XG4gIHRoaXMuX3Jlc3VsdCA9IDA7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDEwID0geyBET05UX0lOVEVSU0VDVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxET19JTlRFUlNFQ1Q6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ09MTElORUFSOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5PX0lOVEVSU0VDVElPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxQT0lOVF9JTlRFUlNFQ1RJT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ09MTElORUFSX0lOVEVSU0VDVElPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRJbmRleEFsb25nU2VnbWVudCA9IGZ1bmN0aW9uIGdldEluZGV4QWxvbmdTZWdtZW50IChzZWdtZW50SW5kZXgsIGludEluZGV4KSB7XG4gIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpO1xuICByZXR1cm4gdGhpcy5faW50TGluZUluZGV4W3NlZ21lbnRJbmRleF1baW50SW5kZXhdXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRUb3BvbG9neVN1bW1hcnkgPSBmdW5jdGlvbiBnZXRUb3BvbG9neVN1bW1hcnkgKCkge1xuICB2YXIgY2F0QnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICBpZiAodGhpcy5pc0VuZFBvaW50KCkpIHsgY2F0QnVmLmFwcGVuZCgnIGVuZHBvaW50Jyk7IH1cbiAgaWYgKHRoaXMuX2lzUHJvcGVyKSB7IGNhdEJ1Zi5hcHBlbmQoJyBwcm9wZXInKTsgfVxuICBpZiAodGhpcy5pc0NvbGxpbmVhcigpKSB7IGNhdEJ1Zi5hcHBlbmQoJyBjb2xsaW5lYXInKTsgfVxuICByZXR1cm4gY2F0QnVmLnRvU3RyaW5nKClcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0aW9uIChwMSwgcDIsIHAzLCBwNCkge1xuICB0aGlzLl9pbnB1dExpbmVzWzBdWzBdID0gcDE7XG4gIHRoaXMuX2lucHV0TGluZXNbMF1bMV0gPSBwMjtcbiAgdGhpcy5faW5wdXRMaW5lc1sxXVswXSA9IHAzO1xuICB0aGlzLl9pbnB1dExpbmVzWzFdWzFdID0gcDQ7XG4gIHRoaXMuX3Jlc3VsdCA9IHRoaXMuY29tcHV0ZUludGVyc2VjdChwMSwgcDIsIHAzLCBwNCk7XG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRJbnRlcnNlY3Rpb25OdW0gPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25OdW0gKCkge1xuICByZXR1cm4gdGhpcy5fcmVzdWx0XG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb21wdXRlSW50TGluZUluZGV4ID0gZnVuY3Rpb24gY29tcHV0ZUludExpbmVJbmRleCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuX2ludExpbmVJbmRleCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5faW50TGluZUluZGV4ID0gQXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJheSgyKTsgfSk7XG4gICAgICB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMCk7XG4gICAgICB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkaXN0MCA9IHRoaXMuZ2V0RWRnZURpc3RhbmNlKHNlZ21lbnRJbmRleCwgMCk7XG4gICAgdmFyIGRpc3QxID0gdGhpcy5nZXRFZGdlRGlzdGFuY2Uoc2VnbWVudEluZGV4LCAxKTtcbiAgICBpZiAoZGlzdDAgPiBkaXN0MSkge1xuICAgICAgdGhpcy5faW50TGluZUluZGV4W3NlZ21lbnRJbmRleF1bMF0gPSAwO1xuICAgICAgdGhpcy5faW50TGluZUluZGV4W3NlZ21lbnRJbmRleF1bMV0gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVswXSA9IDE7XG4gICAgICB0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVsxXSA9IDA7XG4gICAgfVxuICB9XG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc1Byb3BlciA9IGZ1bmN0aW9uIGlzUHJvcGVyICgpIHtcbiAgcmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkgJiYgdGhpcy5faXNQcm9wZXJcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLnNldFByZWNpc2lvbk1vZGVsID0gZnVuY3Rpb24gc2V0UHJlY2lzaW9uTW9kZWwgKHByZWNpc2lvbk1vZGVsKSB7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gcHJlY2lzaW9uTW9kZWw7XG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaXNJbnRlcmlvckludGVyc2VjdGlvbiAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDApKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAodGhpcy5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKDEpKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGlucHV0TGluZUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVzdWx0OyBpKyspIHtcbiAgICAgIGlmICghKHRoaXMkMS5faW50UHRbaV0uZXF1YWxzMkQodGhpcyQxLl9pbnB1dExpbmVzW2lucHV0TGluZUluZGV4XVswXSkgfHwgdGhpcyQxLl9pbnRQdFtpXS5lcXVhbHMyRCh0aGlzJDEuX2lucHV0TGluZXNbaW5wdXRMaW5lSW5kZXhdWzFdKSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbiAoaW50SW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludFB0W2ludEluZGV4XVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaXNFbmRQb2ludCA9IGZ1bmN0aW9uIGlzRW5kUG9pbnQgKCkge1xuICByZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSAmJiAhdGhpcy5faXNQcm9wZXJcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmhhc0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZXN1bHQgIT09IExpbmVJbnRlcnNlY3Rvci5OT19JTlRFUlNFQ1RJT05cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEVkZ2VEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldEVkZ2VEaXN0YW5jZSAoc2VnbWVudEluZGV4LCBpbnRJbmRleCkge1xuICB2YXIgZGlzdCA9IExpbmVJbnRlcnNlY3Rvci5jb21wdXRlRWRnZURpc3RhbmNlKHRoaXMuX2ludFB0W2ludEluZGV4XSwgdGhpcy5faW5wdXRMaW5lc1tzZWdtZW50SW5kZXhdWzBdLCB0aGlzLl9pbnB1dExpbmVzW3NlZ21lbnRJbmRleF1bMV0pO1xuICByZXR1cm4gZGlzdFxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaXNDb2xsaW5lYXIgPSBmdW5jdGlvbiBpc0NvbGxpbmVhciAoKSB7XG4gIHJldHVybiB0aGlzLl9yZXN1bHQgPT09IExpbmVJbnRlcnNlY3Rvci5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIFdLVFdyaXRlci50b0xpbmVTdHJpbmcodGhpcy5faW5wdXRMaW5lc1swXVswXSwgdGhpcy5faW5wdXRMaW5lc1swXVsxXSkgKyAnIC0gJyArIFdLVFdyaXRlci50b0xpbmVTdHJpbmcodGhpcy5faW5wdXRMaW5lc1sxXVswXSwgdGhpcy5faW5wdXRMaW5lc1sxXVsxXSkgKyB0aGlzLmdldFRvcG9sb2d5U3VtbWFyeSgpXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRFbmRwb2ludCA9IGZ1bmN0aW9uIGdldEVuZHBvaW50IChzZWdtZW50SW5kZXgsIHB0SW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2lucHV0TGluZXNbc2VnbWVudEluZGV4XVtwdEluZGV4XVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpc0ludGVyc2VjdGlvbiAocHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jlc3VsdDsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5faW50UHRbaV0uZXF1YWxzMkQocHQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEludGVyc2VjdGlvbkFsb25nU2VnbWVudCA9IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbkFsb25nU2VnbWVudCAoc2VnbWVudEluZGV4LCBpbnRJbmRleCkge1xuICB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKTtcbiAgcmV0dXJuIHRoaXMuX2ludFB0W3RoaXMuX2ludExpbmVJbmRleFtzZWdtZW50SW5kZXhdW2ludEluZGV4XV1cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGluZUludGVyc2VjdG9yXG59O1xuTGluZUludGVyc2VjdG9yLmNvbXB1dGVFZGdlRGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlRWRnZURpc3RhbmNlIChwLCBwMCwgcDEpIHtcbiAgdmFyIGR4ID0gTWF0aC5hYnMocDEueCAtIHAwLngpO1xuICB2YXIgZHkgPSBNYXRoLmFicyhwMS55IC0gcDAueSk7XG4gIHZhciBkaXN0ID0gLTEuMDtcbiAgaWYgKHAuZXF1YWxzKHAwKSkge1xuICAgIGRpc3QgPSAwLjA7XG4gIH0gZWxzZSBpZiAocC5lcXVhbHMocDEpKSB7XG4gICAgaWYgKGR4ID4gZHkpIHsgZGlzdCA9IGR4OyB9IGVsc2UgeyBkaXN0ID0gZHk7IH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcGR4ID0gTWF0aC5hYnMocC54IC0gcDAueCk7XG4gICAgdmFyIHBkeSA9IE1hdGguYWJzKHAueSAtIHAwLnkpO1xuICAgIGlmIChkeCA+IGR5KSB7IGRpc3QgPSBwZHg7IH0gZWxzZSB7IGRpc3QgPSBwZHk7IH1cbiAgICBpZiAoZGlzdCA9PT0gMC4wICYmICFwLmVxdWFscyhwMCkpIHtcbiAgICAgIGRpc3QgPSBNYXRoLm1heChwZHgsIHBkeSk7XG4gICAgfVxuICB9XG4gIEFzc2VydC5pc1RydWUoIShkaXN0ID09PSAwLjAgJiYgIXAuZXF1YWxzKHAwKSksICdCYWQgZGlzdGFuY2UgY2FsY3VsYXRpb24nKTtcbiAgcmV0dXJuIGRpc3Rcbn07XG5MaW5lSW50ZXJzZWN0b3Iubm9uUm9idXN0Q29tcHV0ZUVkZ2VEaXN0YW5jZSA9IGZ1bmN0aW9uIG5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2UgKHAsIHAxLCBwMikge1xuICB2YXIgZHggPSBwLnggLSBwMS54O1xuICB2YXIgZHkgPSBwLnkgLSBwMS55O1xuICB2YXIgZGlzdCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIEFzc2VydC5pc1RydWUoIShkaXN0ID09PSAwLjAgJiYgIXAuZXF1YWxzKHAxKSksICdJbnZhbGlkIGRpc3RhbmNlIGNhbGN1bGF0aW9uJyk7XG4gIHJldHVybiBkaXN0XG59O1xuc3RhdGljQWNjZXNzb3JzJDEwLkRPTlRfSU5URVJTRUNULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMC5ET19JTlRFUlNFQ1QuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDEwLkNPTExJTkVBUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuTk9fSU5URVJTRUNUSU9OLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMC5QT0lOVF9JTlRFUlNFQ1RJT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDEwLkNPTExJTkVBUl9JTlRFUlNFQ1RJT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGluZUludGVyc2VjdG9yLCBzdGF0aWNBY2Nlc3NvcnMkMTAgKTtcblxudmFyIFJvYnVzdExpbmVJbnRlcnNlY3RvciA9IChmdW5jdGlvbiAoTGluZUludGVyc2VjdG9yJCQxKSB7XG4gIGZ1bmN0aW9uIFJvYnVzdExpbmVJbnRlcnNlY3RvciAoKSB7XG4gICAgTGluZUludGVyc2VjdG9yJCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIExpbmVJbnRlcnNlY3RvciQkMSApIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5fX3Byb3RvX18gPSBMaW5lSW50ZXJzZWN0b3IkJDE7XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lSW50ZXJzZWN0b3IkJDEgJiYgTGluZUludGVyc2VjdG9yJCQxLnByb3RvdHlwZSApO1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm9idXN0TGluZUludGVyc2VjdG9yO1xuXG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaXNJblNlZ21lbnRFbnZlbG9wZXMgPSBmdW5jdGlvbiBpc0luU2VnbWVudEVudmVsb3BlcyAoaW50UHQpIHtcbiAgICB2YXIgZW52MCA9IG5ldyBFbnZlbG9wZSh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLCB0aGlzLl9pbnB1dExpbmVzWzBdWzFdKTtcbiAgICB2YXIgZW52MSA9IG5ldyBFbnZlbG9wZSh0aGlzLl9pbnB1dExpbmVzWzFdWzBdLCB0aGlzLl9pbnB1dExpbmVzWzFdWzFdKTtcbiAgICByZXR1cm4gZW52MC5jb250YWlucyhpbnRQdCkgJiYgZW52MS5jb250YWlucyhpbnRQdClcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHAyID0gYXJndW1lbnRzWzJdO1xuICAgICAgdGhpcy5faXNQcm9wZXIgPSBmYWxzZTtcbiAgICAgIGlmIChFbnZlbG9wZS5pbnRlcnNlY3RzKHAxLCBwMiwgcCkpIHtcbiAgICAgICAgaWYgKENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHAxLCBwMiwgcCkgPT09IDAgJiYgQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocDIsIHAxLCBwKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2lzUHJvcGVyID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocC5lcXVhbHMocDEpIHx8IHAuZXF1YWxzKHAyKSkge1xuICAgICAgICAgICAgdGhpcy5faXNQcm9wZXIgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcmVzdWx0ID0gTGluZUludGVyc2VjdG9yJCQxLlBPSU5UX0lOVEVSU0VDVElPTjtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXN1bHQgPSBMaW5lSW50ZXJzZWN0b3IkJDEuTk9fSU5URVJTRUNUSU9OO1xuICAgIH0gZWxzZSB7IHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUubm9ybWFsaXplVG9NaW5pbXVtID0gZnVuY3Rpb24gbm9ybWFsaXplVG9NaW5pbXVtIChuMSwgbjIsIG4zLCBuNCwgbm9ybVB0KSB7XG4gICAgbm9ybVB0LnggPSB0aGlzLnNtYWxsZXN0SW5BYnNWYWx1ZShuMS54LCBuMi54LCBuMy54LCBuNC54KTtcbiAgICBub3JtUHQueSA9IHRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKG4xLnksIG4yLnksIG4zLnksIG40LnkpO1xuICAgIG4xLnggLT0gbm9ybVB0Lng7XG4gICAgbjEueSAtPSBub3JtUHQueTtcbiAgICBuMi54IC09IG5vcm1QdC54O1xuICAgIG4yLnkgLT0gbm9ybVB0Lnk7XG4gICAgbjMueCAtPSBub3JtUHQueDtcbiAgICBuMy55IC09IG5vcm1QdC55O1xuICAgIG40LnggLT0gbm9ybVB0Lng7XG4gICAgbjQueSAtPSBub3JtUHQueTtcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5zYWZlSENvb3JkaW5hdGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBzYWZlSENvb3JkaW5hdGVJbnRlcnNlY3Rpb24gKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgdmFyIGludFB0ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgaW50UHQgPSBIQ29vcmRpbmF0ZS5pbnRlcnNlY3Rpb24ocDEsIHAyLCBxMSwgcTIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbikge1xuICAgICAgICBpbnRQdCA9IFJvYnVzdExpbmVJbnRlcnNlY3Rvci5uZWFyZXN0RW5kcG9pbnQocDEsIHAyLCBxMSwgcTIpO1xuICAgICAgfSBlbHNlIHsgdGhyb3cgZSB9XG4gICAgfSBmaW5hbGx5IHt9XG4gICAgcmV0dXJuIGludFB0XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciBpbnRQdCA9IHRoaXMuaW50ZXJzZWN0aW9uV2l0aE5vcm1hbGl6YXRpb24ocDEsIHAyLCBxMSwgcTIpO1xuICAgIGlmICghdGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhpbnRQdCkpIHtcbiAgICAgIGludFB0ID0gbmV3IENvb3JkaW5hdGUoUm9idXN0TGluZUludGVyc2VjdG9yLm5lYXJlc3RFbmRwb2ludChwMSwgcDIsIHExLCBxMikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcHJlY2lzaW9uTW9kZWwgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3ByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGludFB0KTtcbiAgICB9XG4gICAgcmV0dXJuIGludFB0XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuc21hbGxlc3RJbkFic1ZhbHVlID0gZnVuY3Rpb24gc21hbGxlc3RJbkFic1ZhbHVlICh4MSwgeDIsIHgzLCB4NCkge1xuICAgIHZhciB4ID0geDE7XG4gICAgdmFyIHhhYnMgPSBNYXRoLmFicyh4KTtcbiAgICBpZiAoTWF0aC5hYnMoeDIpIDwgeGFicykge1xuICAgICAgeCA9IHgyO1xuICAgICAgeGFicyA9IE1hdGguYWJzKHgyKTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHgzKSA8IHhhYnMpIHtcbiAgICAgIHggPSB4MztcbiAgICAgIHhhYnMgPSBNYXRoLmFicyh4Myk7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyh4NCkgPCB4YWJzKSB7XG4gICAgICB4ID0geDQ7XG4gICAgfVxuICAgIHJldHVybiB4XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY2hlY2tERCA9IGZ1bmN0aW9uIGNoZWNrREQgKHAxLCBwMiwgcTEsIHEyLCBpbnRQdCkge1xuICAgIHZhciBpbnRQdEREID0gQ0dBbGdvcml0aG1zREQuaW50ZXJzZWN0aW9uKHAxLCBwMiwgcTEsIHEyKTtcbiAgICB2YXIgaXNJbiA9IHRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMoaW50UHRERCk7XG4gICAgU3lzdGVtLm91dC5wcmludGxuKCdERCBpbiBlbnYgPSAnICsgaXNJbiArICcgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLSAnICsgaW50UHRERCk7XG4gICAgaWYgKGludFB0LmRpc3RhbmNlKGludFB0REQpID4gMC4wMDAxKSB7XG4gICAgICBTeXN0ZW0ub3V0LnByaW50bG4oJ0Rpc3RhbmNlID0gJyArIGludFB0LmRpc3RhbmNlKGludFB0REQpKTtcbiAgICB9XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJzZWN0aW9uV2l0aE5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbiAocDEsIHAyLCBxMSwgcTIpIHtcbiAgICB2YXIgbjEgPSBuZXcgQ29vcmRpbmF0ZShwMSk7XG4gICAgdmFyIG4yID0gbmV3IENvb3JkaW5hdGUocDIpO1xuICAgIHZhciBuMyA9IG5ldyBDb29yZGluYXRlKHExKTtcbiAgICB2YXIgbjQgPSBuZXcgQ29vcmRpbmF0ZShxMik7XG4gICAgdmFyIG5vcm1QdCA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgdGhpcy5ub3JtYWxpemVUb0VudkNlbnRyZShuMSwgbjIsIG4zLCBuNCwgbm9ybVB0KTtcbiAgICB2YXIgaW50UHQgPSB0aGlzLnNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbihuMSwgbjIsIG4zLCBuNCk7XG4gICAgaW50UHQueCArPSBub3JtUHQueDtcbiAgICBpbnRQdC55ICs9IG5vcm1QdC55O1xuICAgIHJldHVybiBpbnRQdFxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBjb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uIChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciBwMXExcDIgPSBFbnZlbG9wZS5pbnRlcnNlY3RzKHAxLCBwMiwgcTEpO1xuICAgIHZhciBwMXEycDIgPSBFbnZlbG9wZS5pbnRlcnNlY3RzKHAxLCBwMiwgcTIpO1xuICAgIHZhciBxMXAxcTIgPSBFbnZlbG9wZS5pbnRlcnNlY3RzKHExLCBxMiwgcDEpO1xuICAgIHZhciBxMXAycTIgPSBFbnZlbG9wZS5pbnRlcnNlY3RzKHExLCBxMiwgcDIpO1xuICAgIGlmIChwMXExcDIgJiYgcDFxMnAyKSB7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHExO1xuICAgICAgdGhpcy5faW50UHRbMV0gPSBxMjtcbiAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuQ09MTElORUFSX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICBpZiAocTFwMXEyICYmIHExcDJxMikge1xuICAgICAgdGhpcy5faW50UHRbMF0gPSBwMTtcbiAgICAgIHRoaXMuX2ludFB0WzFdID0gcDI7XG4gICAgICByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgaWYgKHAxcTFwMiAmJiBxMXAxcTIpIHtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gcTE7XG4gICAgICB0aGlzLl9pbnRQdFsxXSA9IHAxO1xuICAgICAgcmV0dXJuIHExLmVxdWFscyhwMSkgJiYgIXAxcTJwMiAmJiAhcTFwMnEyID8gTGluZUludGVyc2VjdG9yJCQxLlBPSU5UX0lOVEVSU0VDVElPTiA6IExpbmVJbnRlcnNlY3RvciQkMS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIGlmIChwMXExcDIgJiYgcTFwMnEyKSB7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHExO1xuICAgICAgdGhpcy5faW50UHRbMV0gPSBwMjtcbiAgICAgIHJldHVybiBxMS5lcXVhbHMocDIpICYmICFwMXEycDIgJiYgIXExcDFxMiA/IExpbmVJbnRlcnNlY3RvciQkMS5QT0lOVF9JTlRFUlNFQ1RJT04gOiBMaW5lSW50ZXJzZWN0b3IkJDEuQ09MTElORUFSX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICBpZiAocDFxMnAyICYmIHExcDFxMikge1xuICAgICAgdGhpcy5faW50UHRbMF0gPSBxMjtcbiAgICAgIHRoaXMuX2ludFB0WzFdID0gcDE7XG4gICAgICByZXR1cm4gcTIuZXF1YWxzKHAxKSAmJiAhcDFxMXAyICYmICFxMXAycTIgPyBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OIDogTGluZUludGVyc2VjdG9yJCQxLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgaWYgKHAxcTJwMiAmJiBxMXAycTIpIHtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gcTI7XG4gICAgICB0aGlzLl9pbnRQdFsxXSA9IHAyO1xuICAgICAgcmV0dXJuIHEyLmVxdWFscyhwMikgJiYgIXAxcTFwMiAmJiAhcTFwMXEyID8gTGluZUludGVyc2VjdG9yJCQxLlBPSU5UX0lOVEVSU0VDVElPTiA6IExpbmVJbnRlcnNlY3RvciQkMS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuTk9fSU5URVJTRUNUSU9OXG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUubm9ybWFsaXplVG9FbnZDZW50cmUgPSBmdW5jdGlvbiBub3JtYWxpemVUb0VudkNlbnRyZSAobjAwLCBuMDEsIG4xMCwgbjExLCBub3JtUHQpIHtcbiAgICB2YXIgbWluWDAgPSBuMDAueCA8IG4wMS54ID8gbjAwLnggOiBuMDEueDtcbiAgICB2YXIgbWluWTAgPSBuMDAueSA8IG4wMS55ID8gbjAwLnkgOiBuMDEueTtcbiAgICB2YXIgbWF4WDAgPSBuMDAueCA+IG4wMS54ID8gbjAwLnggOiBuMDEueDtcbiAgICB2YXIgbWF4WTAgPSBuMDAueSA+IG4wMS55ID8gbjAwLnkgOiBuMDEueTtcbiAgICB2YXIgbWluWDEgPSBuMTAueCA8IG4xMS54ID8gbjEwLnggOiBuMTEueDtcbiAgICB2YXIgbWluWTEgPSBuMTAueSA8IG4xMS55ID8gbjEwLnkgOiBuMTEueTtcbiAgICB2YXIgbWF4WDEgPSBuMTAueCA+IG4xMS54ID8gbjEwLnggOiBuMTEueDtcbiAgICB2YXIgbWF4WTEgPSBuMTAueSA+IG4xMS55ID8gbjEwLnkgOiBuMTEueTtcbiAgICB2YXIgaW50TWluWCA9IG1pblgwID4gbWluWDEgPyBtaW5YMCA6IG1pblgxO1xuICAgIHZhciBpbnRNYXhYID0gbWF4WDAgPCBtYXhYMSA/IG1heFgwIDogbWF4WDE7XG4gICAgdmFyIGludE1pblkgPSBtaW5ZMCA+IG1pblkxID8gbWluWTAgOiBtaW5ZMTtcbiAgICB2YXIgaW50TWF4WSA9IG1heFkwIDwgbWF4WTEgPyBtYXhZMCA6IG1heFkxO1xuICAgIHZhciBpbnRNaWRYID0gKGludE1pblggKyBpbnRNYXhYKSAvIDIuMDtcbiAgICB2YXIgaW50TWlkWSA9IChpbnRNaW5ZICsgaW50TWF4WSkgLyAyLjA7XG4gICAgbm9ybVB0LnggPSBpbnRNaWRYO1xuICAgIG5vcm1QdC55ID0gaW50TWlkWTtcbiAgICBuMDAueCAtPSBub3JtUHQueDtcbiAgICBuMDAueSAtPSBub3JtUHQueTtcbiAgICBuMDEueCAtPSBub3JtUHQueDtcbiAgICBuMDEueSAtPSBub3JtUHQueTtcbiAgICBuMTAueCAtPSBub3JtUHQueDtcbiAgICBuMTAueSAtPSBub3JtUHQueTtcbiAgICBuMTEueCAtPSBub3JtUHQueDtcbiAgICBuMTEueSAtPSBub3JtUHQueTtcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0ID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdCAocDEsIHAyLCBxMSwgcTIpIHtcbiAgICB0aGlzLl9pc1Byb3BlciA9IGZhbHNlO1xuICAgIGlmICghRW52ZWxvcGUuaW50ZXJzZWN0cyhwMSwgcDIsIHExLCBxMikpIHsgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5OT19JTlRFUlNFQ1RJT04gfVxuICAgIHZhciBQcTEgPSBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChwMSwgcDIsIHExKTtcbiAgICB2YXIgUHEyID0gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocDEsIHAyLCBxMik7XG4gICAgaWYgKChQcTEgPiAwICYmIFBxMiA+IDApIHx8IChQcTEgPCAwICYmIFBxMiA8IDApKSB7XG4gICAgICByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLk5PX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICB2YXIgUXAxID0gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocTEsIHEyLCBwMSk7XG4gICAgdmFyIFFwMiA9IENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHExLCBxMiwgcDIpO1xuICAgIGlmICgoUXAxID4gMCAmJiBRcDIgPiAwKSB8fCAoUXAxIDwgMCAmJiBRcDIgPCAwKSkge1xuICAgICAgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5OT19JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgdmFyIGNvbGxpbmVhciA9IFBxMSA9PT0gMCAmJiBQcTIgPT09IDAgJiYgUXAxID09PSAwICYmIFFwMiA9PT0gMDtcbiAgICBpZiAoY29sbGluZWFyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uKHAxLCBwMiwgcTEsIHEyKVxuICAgIH1cbiAgICBpZiAoUHExID09PSAwIHx8IFBxMiA9PT0gMCB8fCBRcDEgPT09IDAgfHwgUXAyID09PSAwKSB7XG4gICAgICB0aGlzLl9pc1Byb3BlciA9IGZhbHNlO1xuICAgICAgaWYgKHAxLmVxdWFsczJEKHExKSB8fCBwMS5lcXVhbHMyRChxMikpIHtcbiAgICAgICAgdGhpcy5faW50UHRbMF0gPSBwMTtcbiAgICAgIH0gZWxzZSBpZiAocDIuZXF1YWxzMkQocTEpIHx8IHAyLmVxdWFsczJEKHEyKSkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IHAyO1xuICAgICAgfSBlbHNlIGlmIChQcTEgPT09IDApIHtcbiAgICAgICAgdGhpcy5faW50UHRbMF0gPSBuZXcgQ29vcmRpbmF0ZShxMSk7XG4gICAgICB9IGVsc2UgaWYgKFBxMiA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IG5ldyBDb29yZGluYXRlKHEyKTtcbiAgICAgIH0gZWxzZSBpZiAoUXAxID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2ludFB0WzBdID0gbmV3IENvb3JkaW5hdGUocDEpO1xuICAgICAgfSBlbHNlIGlmIChRcDIgPT09IDApIHtcbiAgICAgICAgdGhpcy5faW50UHRbMF0gPSBuZXcgQ29vcmRpbmF0ZShwMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzUHJvcGVyID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gdGhpcy5pbnRlcnNlY3Rpb24ocDEsIHAyLCBxMSwgcTIpO1xuICAgIH1cbiAgICByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLlBPSU5UX0lOVEVSU0VDVElPTlxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBSb2J1c3RMaW5lSW50ZXJzZWN0b3JcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLm5lYXJlc3RFbmRwb2ludCA9IGZ1bmN0aW9uIG5lYXJlc3RFbmRwb2ludCAocDEsIHAyLCBxMSwgcTIpIHtcbiAgICB2YXIgbmVhcmVzdFB0ID0gcDE7XG4gICAgdmFyIG1pbkRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocDEsIHExLCBxMik7XG4gICAgdmFyIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocDIsIHExLCBxMik7XG4gICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgIG5lYXJlc3RQdCA9IHAyO1xuICAgIH1cbiAgICBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHExLCBwMSwgcDIpO1xuICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICBuZWFyZXN0UHQgPSBxMTtcbiAgICB9XG4gICAgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShxMiwgcDEsIHAyKTtcbiAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgbmVhcmVzdFB0ID0gcTI7XG4gICAgfVxuICAgIHJldHVybiBuZWFyZXN0UHRcbiAgfTtcblxuICByZXR1cm4gUm9idXN0TGluZUludGVyc2VjdG9yO1xufShMaW5lSW50ZXJzZWN0b3IpKTtcblxudmFyIFJvYnVzdERldGVybWluYW50ID0gZnVuY3Rpb24gUm9idXN0RGV0ZXJtaW5hbnQgKCkge307XG5cblJvYnVzdERldGVybWluYW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUm9idXN0RGV0ZXJtaW5hbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUm9idXN0RGV0ZXJtaW5hbnRcbn07XG5Sb2J1c3REZXRlcm1pbmFudC5vcmllbnRhdGlvbkluZGV4ID0gZnVuY3Rpb24gb3JpZW50YXRpb25JbmRleCAocDEsIHAyLCBxKSB7XG4gIHZhciBkeDEgPSBwMi54IC0gcDEueDtcbiAgdmFyIGR5MSA9IHAyLnkgLSBwMS55O1xuICB2YXIgZHgyID0gcS54IC0gcDIueDtcbiAgdmFyIGR5MiA9IHEueSAtIHAyLnk7XG4gIHJldHVybiBSb2J1c3REZXRlcm1pbmFudC5zaWduT2ZEZXQyeDIoZHgxLCBkeTEsIGR4MiwgZHkyKVxufTtcblJvYnVzdERldGVybWluYW50LnNpZ25PZkRldDJ4MiA9IGZ1bmN0aW9uIHNpZ25PZkRldDJ4MiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIHNpZ24gPSBudWxsO1xuICB2YXIgc3dhcCA9IG51bGw7XG4gIHZhciBrID0gbnVsbDtcbiAgc2lnbiA9IDE7XG4gIGlmICh4MSA9PT0gMC4wIHx8IHkyID09PSAwLjApIHtcbiAgICBpZiAoeTEgPT09IDAuMCB8fCB4MiA9PT0gMC4wKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoeTEgPiAwKSB7XG4gICAgICBpZiAoeDIgPiAwKSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHgyID4gMCkge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh5MSA9PT0gMC4wIHx8IHgyID09PSAwLjApIHtcbiAgICBpZiAoeTIgPiAwKSB7XG4gICAgICBpZiAoeDEgPiAwKSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHgxID4gMCkge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh5MSA+IDAuMCkge1xuICAgIGlmICh5MiA+IDAuMCkge1xuICAgICAgaWYgKHkxIDw9IHkyKSB7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgICBzd2FwID0geDE7XG4gICAgICAgIHgxID0geDI7XG4gICAgICAgIHgyID0gc3dhcDtcbiAgICAgICAgc3dhcCA9IHkxO1xuICAgICAgICB5MSA9IHkyO1xuICAgICAgICB5MiA9IHN3YXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh5MSA8PSAteTIpIHtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgICB4MiA9IC14MjtcbiAgICAgICAgeTIgPSAteTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2FwID0geDE7XG4gICAgICAgIHgxID0gLXgyO1xuICAgICAgICB4MiA9IHN3YXA7XG4gICAgICAgIHN3YXAgPSB5MTtcbiAgICAgICAgeTEgPSAteTI7XG4gICAgICAgIHkyID0gc3dhcDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHkyID4gMC4wKSB7XG4gICAgICBpZiAoLXkxIDw9IHkyKSB7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgICAgeDEgPSAteDE7XG4gICAgICAgIHkxID0gLXkxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dhcCA9IC14MTtcbiAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgeDIgPSBzd2FwO1xuICAgICAgICBzd2FwID0gLXkxO1xuICAgICAgICB5MSA9IHkyO1xuICAgICAgICB5MiA9IHN3YXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh5MSA+PSB5Mikge1xuICAgICAgICB4MSA9IC14MTtcbiAgICAgICAgeTEgPSAteTE7XG4gICAgICAgIHgyID0gLXgyO1xuICAgICAgICB5MiA9IC15MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgICAgc3dhcCA9IC14MTtcbiAgICAgICAgeDEgPSAteDI7XG4gICAgICAgIHgyID0gc3dhcDtcbiAgICAgICAgc3dhcCA9IC15MTtcbiAgICAgICAgeTEgPSAteTI7XG4gICAgICAgIHkyID0gc3dhcDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHgxID4gMC4wKSB7XG4gICAgaWYgKHgyID4gMC4wKSB7XG4gICAgICBpZiAoeDEgPD0geDIpIHtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2lnblxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoeDIgPiAwLjApIHtcbiAgICAgIHJldHVybiAtc2lnblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeDEgPj0geDIpIHtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgICB4MSA9IC14MTtcbiAgICAgICAgeDIgPSAteDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBrID0gTWF0aC5mbG9vcih4MiAvIHgxKTtcbiAgICB4MiA9IHgyIC0gayAqIHgxO1xuICAgIHkyID0geTIgLSBrICogeTE7XG4gICAgaWYgKHkyIDwgMC4wKSB7XG4gICAgICByZXR1cm4gLXNpZ25cbiAgICB9XG4gICAgaWYgKHkyID4geTEpIHtcbiAgICAgIHJldHVybiBzaWduXG4gICAgfVxuICAgIGlmICh4MSA+IHgyICsgeDIpIHtcbiAgICAgIGlmICh5MSA8IHkyICsgeTIpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHkxID4geTIgKyB5Mikge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0geDEgLSB4MjtcbiAgICAgICAgeTIgPSB5MSAtIHkyO1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh5MiA9PT0gMC4wKSB7XG4gICAgICBpZiAoeDIgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh4MiA9PT0gMC4wKSB7XG4gICAgICByZXR1cm4gc2lnblxuICAgIH1cbiAgICBrID0gTWF0aC5mbG9vcih4MSAvIHgyKTtcbiAgICB4MSA9IHgxIC0gayAqIHgyO1xuICAgIHkxID0geTEgLSBrICogeTI7XG4gICAgaWYgKHkxIDwgMC4wKSB7XG4gICAgICByZXR1cm4gc2lnblxuICAgIH1cbiAgICBpZiAoeTEgPiB5Mikge1xuICAgICAgcmV0dXJuIC1zaWduXG4gICAgfVxuICAgIGlmICh4MiA+IHgxICsgeDEpIHtcbiAgICAgIGlmICh5MiA8IHkxICsgeTEpIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh5MiA+IHkxICsgeTEpIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0geDIgLSB4MTtcbiAgICAgICAgeTEgPSB5MiAtIHkxO1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh5MSA9PT0gMC4wKSB7XG4gICAgICBpZiAoeDEgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHgxID09PSAwLjApIHtcbiAgICAgIHJldHVybiAtc2lnblxuICAgIH1cbiAgfVxufTtcblxudmFyIFJheUNyb3NzaW5nQ291bnRlciA9IGZ1bmN0aW9uIFJheUNyb3NzaW5nQ291bnRlciAoKSB7XG4gIHRoaXMuX3AgPSBudWxsO1xuICB0aGlzLl9jcm9zc2luZ0NvdW50ID0gMDtcbiAgdGhpcy5faXNQb2ludE9uU2VnbWVudCA9IGZhbHNlO1xuICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fcCA9IHA7XG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLnByb3RvdHlwZS5jb3VudFNlZ21lbnQgPSBmdW5jdGlvbiBjb3VudFNlZ21lbnQgKHAxLCBwMikge1xuICBpZiAocDEueCA8IHRoaXMuX3AueCAmJiBwMi54IDwgdGhpcy5fcC54KSB7IHJldHVybiBudWxsIH1cbiAgaWYgKHRoaXMuX3AueCA9PT0gcDIueCAmJiB0aGlzLl9wLnkgPT09IHAyLnkpIHtcbiAgICB0aGlzLl9pc1BvaW50T25TZWdtZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChwMS55ID09PSB0aGlzLl9wLnkgJiYgcDIueSA9PT0gdGhpcy5fcC55KSB7XG4gICAgdmFyIG1pbnggPSBwMS54O1xuICAgIHZhciBtYXh4ID0gcDIueDtcbiAgICBpZiAobWlueCA+IG1heHgpIHtcbiAgICAgIG1pbnggPSBwMi54O1xuICAgICAgbWF4eCA9IHAxLng7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wLnggPj0gbWlueCAmJiB0aGlzLl9wLnggPD0gbWF4eCkge1xuICAgICAgdGhpcy5faXNQb2ludE9uU2VnbWVudCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKChwMS55ID4gdGhpcy5fcC55ICYmIHAyLnkgPD0gdGhpcy5fcC55KSB8fCAocDIueSA+IHRoaXMuX3AueSAmJiBwMS55IDw9IHRoaXMuX3AueSkpIHtcbiAgICB2YXIgeDEgPSBwMS54IC0gdGhpcy5fcC54O1xuICAgIHZhciB5MSA9IHAxLnkgLSB0aGlzLl9wLnk7XG4gICAgdmFyIHgyID0gcDIueCAtIHRoaXMuX3AueDtcbiAgICB2YXIgeTIgPSBwMi55IC0gdGhpcy5fcC55O1xuICAgIHZhciB4SW50U2lnbiA9IFJvYnVzdERldGVybWluYW50LnNpZ25PZkRldDJ4Mih4MSwgeTEsIHgyLCB5Mik7XG4gICAgaWYgKHhJbnRTaWduID09PSAwLjApIHtcbiAgICAgIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgaWYgKHkyIDwgeTEpIHsgeEludFNpZ24gPSAteEludFNpZ247IH1cbiAgICBpZiAoeEludFNpZ24gPiAwLjApIHtcbiAgICAgIHRoaXMuX2Nyb3NzaW5nQ291bnQrKztcbiAgICB9XG4gIH1cbn07XG5SYXlDcm9zc2luZ0NvdW50ZXIucHJvdG90eXBlLmlzUG9pbnRJblBvbHlnb24gPSBmdW5jdGlvbiBpc1BvaW50SW5Qb2x5Z29uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKSAhPT0gTG9jYXRpb24uRVhURVJJT1Jcbn07XG5SYXlDcm9zc2luZ0NvdW50ZXIucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0TG9jYXRpb24gKCkge1xuICBpZiAodGhpcy5faXNQb2ludE9uU2VnbWVudCkgeyByZXR1cm4gTG9jYXRpb24uQk9VTkRBUlkgfVxuICBpZiAodGhpcy5fY3Jvc3NpbmdDb3VudCAlIDIgPT09IDEpIHtcbiAgICByZXR1cm4gTG9jYXRpb24uSU5URVJJT1JcbiAgfVxuICByZXR1cm4gTG9jYXRpb24uRVhURVJJT1Jcbn07XG5SYXlDcm9zc2luZ0NvdW50ZXIucHJvdG90eXBlLmlzT25TZWdtZW50ID0gZnVuY3Rpb24gaXNPblNlZ21lbnQgKCkge1xuICByZXR1cm4gdGhpcy5faXNQb2ludE9uU2VnbWVudFxufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBSYXlDcm9zc2luZ0NvdW50ZXJcbn07XG5SYXlDcm9zc2luZ0NvdW50ZXIubG9jYXRlUG9pbnRJblJpbmcgPSBmdW5jdGlvbiBsb2NhdGVQb2ludEluUmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcmluZyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgY291bnRlciA9IG5ldyBSYXlDcm9zc2luZ0NvdW50ZXIocCk7XG4gICAgdmFyIHAxID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB2YXIgcDIgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmluZy5zaXplKCk7IGkrKykge1xuICAgICAgcmluZy5nZXRDb29yZGluYXRlKGksIHAxKTtcbiAgICAgIHJpbmcuZ2V0Q29vcmRpbmF0ZShpIC0gMSwgcDIpO1xuICAgICAgY291bnRlci5jb3VudFNlZ21lbnQocDEsIHAyKTtcbiAgICAgIGlmIChjb3VudGVyLmlzT25TZWdtZW50KCkpIHsgcmV0dXJuIGNvdW50ZXIuZ2V0TG9jYXRpb24oKSB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVyLmdldExvY2F0aW9uKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIHAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcmluZyQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBjb3VudGVyJDEgPSBuZXcgUmF5Q3Jvc3NpbmdDb3VudGVyKHAkMSk7XG4gICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgcmluZyQxLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIHZhciBwMSQxID0gcmluZyQxW2kkMV07XG4gICAgICB2YXIgcDIkMSA9IHJpbmckMVtpJDEgLSAxXTtcbiAgICAgIGNvdW50ZXIkMS5jb3VudFNlZ21lbnQocDEkMSwgcDIkMSk7XG4gICAgICBpZiAoY291bnRlciQxLmlzT25TZWdtZW50KCkpIHsgcmV0dXJuIGNvdW50ZXIkMS5nZXRMb2NhdGlvbigpIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXIkMS5nZXRMb2NhdGlvbigpXG4gIH1cbn07XG5cbnZhciBDR0FsZ29yaXRobXMgPSBmdW5jdGlvbiBDR0FsZ29yaXRobXMgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMyA9IHsgQ0xPQ0tXSVNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFJJR0hUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENPVU5URVJDTE9DS1dJU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTEVGVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDT0xMSU5FQVI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1RSQUlHSFQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuQ0dBbGdvcml0aG1zLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ0dBbGdvcml0aG1zLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtc1xufTtcbkNHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4ID0gZnVuY3Rpb24gb3JpZW50YXRpb25JbmRleCAocDEsIHAyLCBxKSB7XG4gIHJldHVybiBDR0FsZ29yaXRobXNERC5vcmllbnRhdGlvbkluZGV4KHAxLCBwMiwgcSlcbn07XG5DR0FsZ29yaXRobXMuc2lnbmVkQXJlYSA9IGZ1bmN0aW9uIHNpZ25lZEFyZWEgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgcmluZyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAocmluZy5sZW5ndGggPCAzKSB7IHJldHVybiAwLjAgfVxuICAgIHZhciBzdW0gPSAwLjA7XG4gICAgdmFyIHgwID0gcmluZ1swXS54O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcmluZy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciB4ID0gcmluZ1tpXS54IC0geDA7XG4gICAgICB2YXIgeTEgPSByaW5nW2kgKyAxXS55O1xuICAgICAgdmFyIHkyID0gcmluZ1tpIC0gMV0ueTtcbiAgICAgIHN1bSArPSB4ICogKHkyIC0geTEpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtIC8gMi4wXG4gIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgIHZhciByaW5nJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG4gPSByaW5nJDEuc2l6ZSgpO1xuICAgIGlmIChuIDwgMykgeyByZXR1cm4gMC4wIH1cbiAgICB2YXIgcDAgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHZhciBwMSA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgdmFyIHAyID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICByaW5nJDEuZ2V0Q29vcmRpbmF0ZSgwLCBwMSk7XG4gICAgcmluZyQxLmdldENvb3JkaW5hdGUoMSwgcDIpO1xuICAgIHZhciB4MCQxID0gcDEueDtcbiAgICBwMi54IC09IHgwJDE7XG4gICAgdmFyIHN1bSQxID0gMC4wO1xuICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IG4gLSAxOyBpJDErKykge1xuICAgICAgcDAueSA9IHAxLnk7XG4gICAgICBwMS54ID0gcDIueDtcbiAgICAgIHAxLnkgPSBwMi55O1xuICAgICAgcmluZyQxLmdldENvb3JkaW5hdGUoaSQxICsgMSwgcDIpO1xuICAgICAgcDIueCAtPSB4MCQxO1xuICAgICAgc3VtJDEgKz0gcDEueCAqIChwMC55IC0gcDIueSk7XG4gICAgfVxuICAgIHJldHVybiBzdW0kMSAvIDIuMFxuICB9XG59O1xuQ0dBbGdvcml0aG1zLmRpc3RhbmNlTGluZUxpbmUgPSBmdW5jdGlvbiBkaXN0YW5jZUxpbmVMaW5lIChBLCBCLCBDLCBEKSB7XG4gIGlmIChBLmVxdWFscyhCKSkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKEEsIEMsIEQpIH1cbiAgaWYgKEMuZXF1YWxzKEQpKSB7IHJldHVybiBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoRCwgQSwgQikgfVxuICB2YXIgbm9JbnRlcnNlY3Rpb24gPSBmYWxzZTtcbiAgaWYgKCFFbnZlbG9wZS5pbnRlcnNlY3RzKEEsIEIsIEMsIEQpKSB7XG4gICAgbm9JbnRlcnNlY3Rpb24gPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZW5vbSA9IChCLnggLSBBLngpICogKEQueSAtIEMueSkgLSAoQi55IC0gQS55KSAqIChELnggLSBDLngpO1xuICAgIGlmIChkZW5vbSA9PT0gMCkge1xuICAgICAgbm9JbnRlcnNlY3Rpb24gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgck51bWIgPSAoQS55IC0gQy55KSAqIChELnggLSBDLngpIC0gKEEueCAtIEMueCkgKiAoRC55IC0gQy55KTtcbiAgICAgIHZhciBzTnVtID0gKEEueSAtIEMueSkgKiAoQi54IC0gQS54KSAtIChBLnggLSBDLngpICogKEIueSAtIEEueSk7XG4gICAgICB2YXIgcyA9IHNOdW0gLyBkZW5vbTtcbiAgICAgIHZhciByID0gck51bWIgLyBkZW5vbTtcbiAgICAgIGlmIChyIDwgMCB8fCByID4gMSB8fCBzIDwgMCB8fCBzID4gMSkge1xuICAgICAgICBub0ludGVyc2VjdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChub0ludGVyc2VjdGlvbikge1xuICAgIHJldHVybiBNYXRoVXRpbC5taW4oQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKEEsIEMsIEQpLCBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoQiwgQywgRCksIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShDLCBBLCBCKSwgQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKEQsIEEsIEIpKVxuICB9XG4gIHJldHVybiAwLjBcbn07XG5DR0FsZ29yaXRobXMuaXNQb2ludEluUmluZyA9IGZ1bmN0aW9uIGlzUG9pbnRJblJpbmcgKHAsIHJpbmcpIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtcy5sb2NhdGVQb2ludEluUmluZyhwLCByaW5nKSAhPT0gTG9jYXRpb24uRVhURVJJT1Jcbn07XG5DR0FsZ29yaXRobXMuY29tcHV0ZUxlbmd0aCA9IGZ1bmN0aW9uIGNvbXB1dGVMZW5ndGggKHB0cykge1xuICB2YXIgbiA9IHB0cy5zaXplKCk7XG4gIGlmIChuIDw9IDEpIHsgcmV0dXJuIDAuMCB9XG4gIHZhciBsZW4gPSAwLjA7XG4gIHZhciBwID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgcHRzLmdldENvb3JkaW5hdGUoMCwgcCk7XG4gIHZhciB4MCA9IHAueDtcbiAgdmFyIHkwID0gcC55O1xuICBmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuICAgIHB0cy5nZXRDb29yZGluYXRlKGksIHApO1xuICAgIHZhciB4MSA9IHAueDtcbiAgICB2YXIgeTEgPSBwLnk7XG4gICAgdmFyIGR4ID0geDEgLSB4MDtcbiAgICB2YXIgZHkgPSB5MSAtIHkwO1xuICAgIGxlbiArPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIHgwID0geDE7XG4gICAgeTAgPSB5MTtcbiAgfVxuICByZXR1cm4gbGVuXG59O1xuQ0dBbGdvcml0aG1zLmlzQ0NXID0gZnVuY3Rpb24gaXNDQ1cgKHJpbmcpIHtcbiAgdmFyIG5QdHMgPSByaW5nLmxlbmd0aCAtIDE7XG4gIGlmIChuUHRzIDwgMykgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZCcpIH1cbiAgdmFyIGhpUHQgPSByaW5nWzBdO1xuICB2YXIgaGlJbmRleCA9IDA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IG5QdHM7IGkrKykge1xuICAgIHZhciBwID0gcmluZ1tpXTtcbiAgICBpZiAocC55ID4gaGlQdC55KSB7XG4gICAgICBoaVB0ID0gcDtcbiAgICAgIGhpSW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICB2YXIgaVByZXYgPSBoaUluZGV4O1xuICBkbyB7XG4gICAgaVByZXYgPSBpUHJldiAtIDE7XG4gICAgaWYgKGlQcmV2IDwgMCkgeyBpUHJldiA9IG5QdHM7IH1cbiAgfSB3aGlsZSAocmluZ1tpUHJldl0uZXF1YWxzMkQoaGlQdCkgJiYgaVByZXYgIT09IGhpSW5kZXgpXG4gIHZhciBpTmV4dCA9IGhpSW5kZXg7XG4gIGRvIHtcbiAgICBpTmV4dCA9IChpTmV4dCArIDEpICUgblB0cztcbiAgfSB3aGlsZSAocmluZ1tpTmV4dF0uZXF1YWxzMkQoaGlQdCkgJiYgaU5leHQgIT09IGhpSW5kZXgpXG4gIHZhciBwcmV2ID0gcmluZ1tpUHJldl07XG4gIHZhciBuZXh0ID0gcmluZ1tpTmV4dF07XG4gIGlmIChwcmV2LmVxdWFsczJEKGhpUHQpIHx8IG5leHQuZXF1YWxzMkQoaGlQdCkgfHwgcHJldi5lcXVhbHMyRChuZXh0KSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgZGlzYyA9IENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24ocHJldiwgaGlQdCwgbmV4dCk7XG4gIHZhciBpc0NDVyA9IGZhbHNlO1xuICBpZiAoZGlzYyA9PT0gMCkge1xuICAgIGlzQ0NXID0gcHJldi54ID4gbmV4dC54O1xuICB9IGVsc2Uge1xuICAgIGlzQ0NXID0gZGlzYyA+IDA7XG4gIH1cbiAgcmV0dXJuIGlzQ0NXXG59O1xuQ0dBbGdvcml0aG1zLmxvY2F0ZVBvaW50SW5SaW5nID0gZnVuY3Rpb24gbG9jYXRlUG9pbnRJblJpbmcgKHAsIHJpbmcpIHtcbiAgcmV0dXJuIFJheUNyb3NzaW5nQ291bnRlci5sb2NhdGVQb2ludEluUmluZyhwLCByaW5nKVxufTtcbkNHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXIgPSBmdW5jdGlvbiBkaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXIgKHAsIEEsIEIpIHtcbiAgdmFyIGxlbjIgPSAoQi54IC0gQS54KSAqIChCLnggLSBBLngpICsgKEIueSAtIEEueSkgKiAoQi55IC0gQS55KTtcbiAgdmFyIHMgPSAoKEEueSAtIHAueSkgKiAoQi54IC0gQS54KSAtIChBLnggLSBwLngpICogKEIueSAtIEEueSkpIC8gbGVuMjtcbiAgcmV0dXJuIE1hdGguYWJzKHMpICogTWF0aC5zcXJ0KGxlbjIpXG59O1xuQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVPcmllbnRhdGlvbiAocDEsIHAyLCBxKSB7XG4gIHJldHVybiBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChwMSwgcDIsIHEpXG59O1xuQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lID0gZnVuY3Rpb24gZGlzdGFuY2VQb2ludExpbmUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsaW5lID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4JykgfVxuICAgIHZhciBtaW5EaXN0YW5jZSA9IHAuZGlzdGFuY2UobGluZVswXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocCwgbGluZVtpXSwgbGluZVtpICsgMV0pO1xuICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5EaXN0YW5jZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgcCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBBID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBCID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChBLnggPT09IEIueCAmJiBBLnkgPT09IEIueSkgeyByZXR1cm4gcCQxLmRpc3RhbmNlKEEpIH1cbiAgICB2YXIgbGVuMiA9IChCLnggLSBBLngpICogKEIueCAtIEEueCkgKyAoQi55IC0gQS55KSAqIChCLnkgLSBBLnkpO1xuICAgIHZhciByID0gKChwJDEueCAtIEEueCkgKiAoQi54IC0gQS54KSArIChwJDEueSAtIEEueSkgKiAoQi55IC0gQS55KSkgLyBsZW4yO1xuICAgIGlmIChyIDw9IDAuMCkgeyByZXR1cm4gcCQxLmRpc3RhbmNlKEEpIH1cbiAgICBpZiAociA+PSAxLjApIHsgcmV0dXJuIHAkMS5kaXN0YW5jZShCKSB9XG4gICAgdmFyIHMgPSAoKEEueSAtIHAkMS55KSAqIChCLnggLSBBLngpIC0gKEEueCAtIHAkMS54KSAqIChCLnkgLSBBLnkpKSAvIGxlbjI7XG4gICAgcmV0dXJuIE1hdGguYWJzKHMpICogTWF0aC5zcXJ0KGxlbjIpXG4gIH1cbn07XG5DR0FsZ29yaXRobXMuaXNPbkxpbmUgPSBmdW5jdGlvbiBpc09uTGluZSAocCwgcHQpIHtcbiAgdmFyIGxpbmVJbnRlcnNlY3RvciA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwMCA9IHB0W2kgLSAxXTtcbiAgICB2YXIgcDEgPSBwdFtpXTtcbiAgICBsaW5lSW50ZXJzZWN0b3IuY29tcHV0ZUludGVyc2VjdGlvbihwLCBwMCwgcDEpO1xuICAgIGlmIChsaW5lSW50ZXJzZWN0b3IuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQzLkNMT0NLV0lTRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMSB9O1xuc3RhdGljQWNjZXNzb3JzJDMuUklHSFQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSB9O1xuc3RhdGljQWNjZXNzb3JzJDMuQ09VTlRFUkNMT0NLV0lTRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMy5MRUZULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5DT1VOVEVSQ0xPQ0tXSVNFIH07XG5zdGF0aWNBY2Nlc3NvcnMkMy5DT0xMSU5FQVIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDMuU1RSQUlHSFQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLkNPTExJTkVBUiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ0dBbGdvcml0aG1zLCBzdGF0aWNBY2Nlc3NvcnMkMyApO1xuXG52YXIgR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIgPSBmdW5jdGlvbiBHZW9tZXRyeUNvbXBvbmVudEZpbHRlciAoKSB7fTtcblxuR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZ2VvbSkge307XG5HZW9tZXRyeUNvbXBvbmVudEZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5Q29tcG9uZW50RmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyXG59O1xuXG52YXIgR2VvbWV0cnkgPSBmdW5jdGlvbiBHZW9tZXRyeSAoKSB7XG4gIHZhciBmYWN0b3J5ID0gYXJndW1lbnRzWzBdO1xuXG4gIHRoaXMuX2VudmVsb3BlID0gbnVsbDtcbiAgdGhpcy5fZmFjdG9yeSA9IG51bGw7XG4gIHRoaXMuX1NSSUQgPSBudWxsO1xuICB0aGlzLl91c2VyRGF0YSA9IG51bGw7XG4gIHRoaXMuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuICB0aGlzLl9TUklEID0gZmFjdG9yeS5nZXRTUklEKCk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDExID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9QT0lOVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfTVVMVElQT0lOVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfTElORVNUUklORzogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfTElORUFSUklORzogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9QT0xZR09OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9NVUxUSVBPTFlHT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxnZW9tZXRyeUNoYW5nZWRGaWx0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkdlb21ldHJ5LnByb3RvdHlwZS5pc0dlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDb2xsZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkgPT09IEdlb21ldHJ5LlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT05cbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0RmFjdG9yeSA9IGZ1bmN0aW9uIGdldEZhY3RvcnkgKCkge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRHZW9tZXRyeU4gPSBmdW5jdGlvbiBnZXRHZW9tZXRyeU4gKG4pIHtcbiAgcmV0dXJuIHRoaXNcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uIGdldEFyZWEgKCkge1xuICByZXR1cm4gMC4wXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmlzUmVjdGFuZ2xlID0gZnVuY3Rpb24gaXNSZWN0YW5nbGUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5KSB7XG4gICAgdmFyIGckMSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoZyQxID09PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzVG9wbyhnJDEpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgdmFyIG8gPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKCEobyBpbnN0YW5jZW9mIEdlb21ldHJ5KSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBnID0gbztcbiAgICByZXR1cm4gdGhpcy5lcXVhbHNFeGFjdChnKVxuICB9XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKG90aGVyKSB7XG4gIHJldHVybiB0aGlzID09PSBvdGhlciB8fCB0aGlzLmVxdWFsc0V4YWN0KG90aGVyLCAwKVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZW9tZXRyeUNoYW5nZWQgPSBmdW5jdGlvbiBnZW9tZXRyeUNoYW5nZWQgKCkge1xuICB0aGlzLmFwcGx5KEdlb21ldHJ5Lmdlb21ldHJ5Q2hhbmdlZEZpbHRlcik7XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdlb21ldHJ5Q2hhbmdlZEFjdGlvbiA9IGZ1bmN0aW9uIGdlb21ldHJ5Q2hhbmdlZEFjdGlvbiAoKSB7XG4gIHRoaXMuX2VudmVsb3BlID0gbnVsbDtcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZXF1YWxzTm9ybSA9IGZ1bmN0aW9uIGVxdWFsc05vcm0gKGcpIHtcbiAgaWYgKGcgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRoaXMubm9ybSgpLmVxdWFsc0V4YWN0KGcubm9ybSgpKVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICByZXR1cm4gMC4wXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldE51bUdlb21ldHJpZXMgPSBmdW5jdGlvbiBnZXROdW1HZW9tZXRyaWVzICgpIHtcbiAgcmV0dXJuIDFcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb3RoZXIgPSBvO1xuICAgIGlmICh0aGlzLmdldFNvcnRJbmRleCgpICE9PSBvdGhlci5nZXRTb3J0SW5kZXgoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkgLSBvdGhlci5nZXRTb3J0SW5kZXgoKVxuICAgIH1cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkgJiYgb3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICBpZiAob3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG9TYW1lQ2xhc3MobylcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIG90aGVyJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvbXAgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuZ2V0U29ydEluZGV4KCkgIT09IG90aGVyJDEuZ2V0U29ydEluZGV4KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvcnRJbmRleCgpIC0gb3RoZXIkMS5nZXRTb3J0SW5kZXgoKVxuICAgIH1cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkgJiYgb3RoZXIkMS5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGlmIChvdGhlciQxLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKG90aGVyJDEsIGNvbXApXG4gIH1cbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0VXNlckRhdGEgPSBmdW5jdGlvbiBnZXRVc2VyRGF0YSAoKSB7XG4gIHJldHVybiB0aGlzLl91c2VyRGF0YVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRTUklEID0gZnVuY3Rpb24gZ2V0U1JJRCAoKSB7XG4gIHJldHVybiB0aGlzLl9TUklEXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldEVudmVsb3BlID0gZnVuY3Rpb24gZ2V0RW52ZWxvcGUgKCkge1xuICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeSh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKSlcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbiAoZykge1xuICBpZiAoZy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTikge1xuICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1RoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50cycpXG4gIH1cbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbCAoYSwgYiwgdG9sZXJhbmNlKSB7XG4gIGlmICh0b2xlcmFuY2UgPT09IDApIHtcbiAgICByZXR1cm4gYS5lcXVhbHMoYilcbiAgfVxuICByZXR1cm4gYS5kaXN0YW5jZShiKSA8PSB0b2xlcmFuY2Vcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUubm9ybSA9IGZ1bmN0aW9uIG5vcm0gKCkge1xuICB2YXIgY29weSA9IHRoaXMuY29weSgpO1xuICBjb3B5Lm5vcm1hbGl6ZSgpO1xuICByZXR1cm4gY29weVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRQcmVjaXNpb25Nb2RlbCA9IGZ1bmN0aW9uIGdldFByZWNpc2lvbk1vZGVsICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRFbnZlbG9wZUludGVybmFsID0gZnVuY3Rpb24gZ2V0RW52ZWxvcGVJbnRlcm5hbCAoKSB7XG4gIGlmICh0aGlzLl9lbnZlbG9wZSA9PT0gbnVsbCkge1xuICAgIHRoaXMuX2VudmVsb3BlID0gdGhpcy5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCgpO1xuICB9XG4gIHJldHVybiBuZXcgRW52ZWxvcGUodGhpcy5fZW52ZWxvcGUpXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLnNldFNSSUQgPSBmdW5jdGlvbiBzZXRTUklEIChTUklEKSB7XG4gIHRoaXMuX1NSSUQgPSBTUklEO1xufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5zZXRVc2VyRGF0YSA9IGZ1bmN0aW9uIHNldFVzZXJEYXRhICh1c2VyRGF0YSkge1xuICB0aGlzLl91c2VyRGF0YSA9IHVzZXJEYXRhO1xufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICB2YXIgaSA9IGEuaXRlcmF0b3IoKTtcbiAgdmFyIGogPSBiLml0ZXJhdG9yKCk7XG4gIHdoaWxlIChpLmhhc05leHQoKSAmJiBqLmhhc05leHQoKSkge1xuICAgIHZhciBhRWxlbWVudCA9IGkubmV4dCgpO1xuICAgIHZhciBiRWxlbWVudCA9IGoubmV4dCgpO1xuICAgIHZhciBjb21wYXJpc29uID0gYUVsZW1lbnQuY29tcGFyZVRvKGJFbGVtZW50KTtcbiAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuIGNvbXBhcmlzb25cbiAgICB9XG4gIH1cbiAgaWYgKGkuaGFzTmV4dCgpKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICBpZiAoai5oYXNOZXh0KCkpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICByZXR1cm4gMFxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmhhc2hDb2RlKClcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuaXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQgPSBmdW5jdGlvbiBpc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZCAoKSB7XG4gIGlmICh0aGlzLmdldFNvcnRJbmRleCgpID09PSBHZW9tZXRyeS5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OIHx8IHRoaXMuZ2V0U29ydEluZGV4KCkgPT09IEdlb21ldHJ5LlNPUlRJTkRFWF9NVUxUSVBPSU5UIHx8IHRoaXMuZ2V0U29ydEluZGV4KCkgPT09IEdlb21ldHJ5LlNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkcgfHwgdGhpcy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX01VTFRJUE9MWUdPTikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nsb25hYmxlLCBDb21wYXJhYmxlLCBTZXJpYWxpemFibGVdXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlcbn07XG5HZW9tZXRyeS5oYXNOb25FbXB0eUVsZW1lbnRzID0gZnVuY3Rpb24gaGFzTm9uRW1wdHlFbGVtZW50cyAoZ2VvbWV0cmllcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWdlb21ldHJpZXNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5HZW9tZXRyeS5oYXNOdWxsRWxlbWVudHMgPSBmdW5jdGlvbiBoYXNOdWxsRWxlbWVudHMgKGFycmF5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDg3NjM2MjI2NzkxODczNzY3MDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfUE9JTlQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9NVUxUSVBPSU5ULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfTElORVNUUklORy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX0xJTkVBUlJJTkcuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMyB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkcuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNCB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9QT0xZR09OLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDUgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfTVVMVElQT0xZR09OLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDYgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDcgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeSwgc3RhdGljQWNjZXNzb3JzJDExICk7XG5cbnZhciBnZW9tZXRyeUNoYW5nZWRGaWx0ZXIgPSBmdW5jdGlvbiBnZW9tZXRyeUNoYW5nZWRGaWx0ZXIgKCkge307XG5cbmdlb21ldHJ5Q2hhbmdlZEZpbHRlci5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUNvbXBvbmVudEZpbHRlcl1cbn07XG5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7XG4gIGdlb20uZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCk7XG59O1xuXG52YXIgQ29vcmRpbmF0ZUZpbHRlciA9IGZ1bmN0aW9uIENvb3JkaW5hdGVGaWx0ZXIgKCkge307XG5cbkNvb3JkaW5hdGVGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoY29vcmQpIHt9O1xuQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvb3JkaW5hdGVGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZUZpbHRlclxufTtcblxudmFyIEJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBCb3VuZGFyeU5vZGVSdWxlICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDEyID0geyBNb2QyQm91bmRhcnlOb2RlUnVsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNT0QyX0JPVU5EQVJZX1JVTEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRU5EUE9JTlRfQk9VTkRBUllfUlVMRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1PTk9WQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxPR0NfU0ZTX0JPVU5EQVJZX1JVTEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuQm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaXNJbkJvdW5kYXJ5ID0gZnVuY3Rpb24gaXNJbkJvdW5kYXJ5IChib3VuZGFyeUNvdW50KSB7fTtcbkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Cb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJvdW5kYXJ5Tm9kZVJ1bGVcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5NT0QyX0JPVU5EQVJZX1JVTEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1vZDJCb3VuZGFyeU5vZGVSdWxlKCkgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5FTkRQT0lOVF9CT1VOREFSWV9SVUxFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUoKSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk1VTFRJVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlKCkgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5NT05PVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUoKSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk9HQ19TRlNfQk9VTkRBUllfUlVMRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBCb3VuZGFyeU5vZGVSdWxlLk1PRDJfQk9VTkRBUllfUlVMRSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQm91bmRhcnlOb2RlUnVsZSwgc3RhdGljQWNjZXNzb3JzJDEyICk7XG5cbnZhciBNb2QyQm91bmRhcnlOb2RlUnVsZSA9IGZ1bmN0aW9uIE1vZDJCb3VuZGFyeU5vZGVSdWxlICgpIHt9O1xuXG5Nb2QyQm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaXNJbkJvdW5kYXJ5ID0gZnVuY3Rpb24gaXNJbkJvdW5kYXJ5IChib3VuZGFyeUNvdW50KSB7XG4gIHJldHVybiBib3VuZGFyeUNvdW50ICUgMiA9PT0gMVxufTtcbk1vZDJCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFyeU5vZGVSdWxlXVxufTtcbk1vZDJCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vZDJCb3VuZGFyeU5vZGVSdWxlXG59O1xuXG52YXIgRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlID0gZnVuY3Rpb24gRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlICgpIHt9O1xuXG5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmlzSW5Cb3VuZGFyeSA9IGZ1bmN0aW9uIGlzSW5Cb3VuZGFyeSAoYm91bmRhcnlDb3VudCkge1xuICByZXR1cm4gYm91bmRhcnlDb3VudCA+IDBcbn07XG5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0JvdW5kYXJ5Tm9kZVJ1bGVdXG59O1xuRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZVxufTtcblxudmFyIE11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlID0gZnVuY3Rpb24gTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgKCkge307XG5cbk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pc0luQm91bmRhcnkgPSBmdW5jdGlvbiBpc0luQm91bmRhcnkgKGJvdW5kYXJ5Q291bnQpIHtcbiAgcmV0dXJuIGJvdW5kYXJ5Q291bnQgPiAxXG59O1xuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0JvdW5kYXJ5Tm9kZVJ1bGVdXG59O1xuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGVcbn07XG5cbnZhciBNb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlID0gZnVuY3Rpb24gTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSAoKSB7fTtcblxuTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaXNJbkJvdW5kYXJ5ID0gZnVuY3Rpb24gaXNJbkJvdW5kYXJ5IChib3VuZGFyeUNvdW50KSB7XG4gIHJldHVybiBib3VuZGFyeUNvdW50ID09PSAxXG59O1xuTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQm91bmRhcnlOb2RlUnVsZV1cbn07XG5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGVcbn07XG5cbi8vIGltcG9ydCBJdGVyYXRvciBmcm9tICcuL0l0ZXJhdG9yJ1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0NvbGxlY3Rpb24uaHRtbFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIENvbGxlY3Rpb24gPSBmdW5jdGlvbiBDb2xsZWN0aW9uICgpIHt9O1xuXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKCkge307XG5cbi8qKlxuICogQXBwZW5kcyBhbGwgb2YgdGhlIGVsZW1lbnRzIGluIHRoZSBzcGVjaWZpZWQgY29sbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoaXNcbiAqIGxpc3QsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXJlIHJldHVybmVkIGJ5IHRoZSBzcGVjaWZpZWQgY29sbGVjdGlvbidzXG4gKiBpdGVyYXRvciAob3B0aW9uYWwgb3BlcmF0aW9uKS5cbiAqIEBwYXJhbSB7amF2YXNjcmlwdC51dGlsLkNvbGxlY3Rpb259IGNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIGFkZEFsbCAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIGVsZW1lbnRzLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge307XG5cbi8qKlxuICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24uXG4gKiBAcmV0dXJuIHtqYXZhc2NyaXB0LnV0aWwuSXRlcmF0b3J9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge307XG5cbi8qKlxuICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24uXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlIGVsZW1lbnRzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoKSB7fTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgc2luZ2xlIGluc3RhbmNlIG9mIHRoZSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgY29sbGVjdGlvbiBpZiBpdFxuICogaXMgcHJlc2VudC4gKG9wdGlvbmFsKVxuICogQHBhcmFtIHtPYmplY3R9IGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZVxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG59XG5JbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ucHJvdG90eXBlLm5hbWUgPSAnSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbic7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvSXRlcmF0b3IuaHRtbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSXRlcmF0b3IgPSBmdW5jdGlvbiBJdGVyYXRvciAoKSB7fTtcblxuSXRlcmF0b3IucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiBoYXNOZXh0ICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgZWxlbWVudCBpbiB0aGUgaXRlcmF0aW9uLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5JdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKCkge307XG5cbi8qKlxuICogUmVtb3ZlcyBmcm9tIHRoZSB1bmRlcmx5aW5nIGNvbGxlY3Rpb24gdGhlIGxhc3QgZWxlbWVudCByZXR1cm5lZCBieSB0aGVcbiAqIGl0ZXJhdG9yIChvcHRpb25hbCBvcGVyYXRpb24pLlxuICovXG5JdGVyYXRvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHt9O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0xpc3QuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtqYXZhc2NyaXB0LnV0aWwuQ29sbGVjdGlvbn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIExpc3QgPSAoZnVuY3Rpb24gKENvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gTGlzdCAoKSB7XG4gICAgQ29sbGVjdGlvbiQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBDb2xsZWN0aW9uJCQxICkgTGlzdC5fX3Byb3RvX18gPSBDb2xsZWN0aW9uJCQxO1xuICBMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENvbGxlY3Rpb24kJDEgJiYgQ29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaXN0O1xuXG4gIExpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7IH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gaW4gdGhpcyBsaXN0IHdpdGggdGhlXG4gICAqIHNwZWNpZmllZCBlbGVtZW50IChvcHRpb25hbCBvcGVyYXRpb24pLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R9IGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgTGlzdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICgpIHsgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29sbGVjdGlvbiBjb250YWlucyBubyBlbGVtZW50cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIExpc3QucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHsgfTtcblxuICByZXR1cm4gTGlzdDtcbn0oQ29sbGVjdGlvbikpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIE5vU3VjaEVsZW1lbnRFeGNlcHRpb24gKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbn1cbk5vU3VjaEVsZW1lbnRFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuTm9TdWNoRWxlbWVudEV4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdOb1N1Y2hFbGVtZW50RXhjZXB0aW9uJztcblxuLy8gaW1wb3J0IE9wZXJhdGlvbk5vdFN1cHBvcnRlZCBmcm9tICcuL09wZXJhdGlvbk5vdFN1cHBvcnRlZCdcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9BcnJheUxpc3QuaHRtbFxuICpcbiAqIEBleHRlbmRzIExpc3RcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBBcnJheUxpc3QgPSAoZnVuY3Rpb24gKExpc3QkJDEpIHtcbiAgZnVuY3Rpb24gQXJyYXlMaXN0ICgpIHtcbiAgICBMaXN0JCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5hcnJheV8gPSBbXTtcblxuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICggTGlzdCQkMSApIEFycmF5TGlzdC5fX3Byb3RvX18gPSBMaXN0JCQxO1xuICBBcnJheUxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGlzdCQkMSAmJiBMaXN0JCQxLnByb3RvdHlwZSApO1xuICBBcnJheUxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJyYXlMaXN0O1xuXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuZW5zdXJlQ2FwYWNpdHkgPSBmdW5jdGlvbiBlbnN1cmVDYXBhY2l0eSAoKSB7fTtcbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHsgcmV0dXJuIFtMaXN0JCQxLCBDb2xsZWN0aW9uXSB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuYXJyYXlfLnB1c2goZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXJyYXlfLnNwbGljZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICB0aGlzLmFycmF5XyA9IFtdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsIChjKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gYy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHRoaXMkMS5hZGQoaS5uZXh0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChpbmRleCwgZWxlbWVudCkge1xuICAgIHZhciBvbGRFbGVtZW50ID0gdGhpcy5hcnJheV9baW5kZXhdO1xuICAgIHRoaXMuYXJyYXlfW2luZGV4XSA9IGVsZW1lbnQ7XG4gICAgcmV0dXJuIG9sZEVsZW1lbnRcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3JfKHRoaXMpXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnNpemUoKSkge1xuICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFycmF5X1tpbmRleF1cbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoID09PSAwXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2godGhpcyQxLmFycmF5X1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKG8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcyQxLmFycmF5X1tpXSA9PT0gbykge1xuICAgICAgICB0aGlzJDEuYXJyYXlfLnNwbGljZShpLCAxKTtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmb3VuZFxuICB9O1xuXG4gIHJldHVybiBBcnJheUxpc3Q7XG59KExpc3QpKTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7SXRlcmF0b3J9XG4gKiBAcGFyYW0ge0FycmF5TGlzdH0gYXJyYXlMaXN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJdGVyYXRvcl8gPSAoZnVuY3Rpb24gKEl0ZXJhdG9yJCQxKSB7XG4gIGZ1bmN0aW9uIEl0ZXJhdG9yXyAoYXJyYXlMaXN0KSB7XG4gICAgSXRlcmF0b3IkJDEuY2FsbCh0aGlzKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXlMaXN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLmFycmF5TGlzdF8gPSBhcnJheUxpc3Q7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5wb3NpdGlvbl8gPSAwO1xuICB9XG5cbiAgaWYgKCBJdGVyYXRvciQkMSApIEl0ZXJhdG9yXy5fX3Byb3RvX18gPSBJdGVyYXRvciQkMTtcbiAgSXRlcmF0b3JfLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZXJhdG9yJCQxICYmIEl0ZXJhdG9yJCQxLnByb3RvdHlwZSApO1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSXRlcmF0b3JfO1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIGlmICh0aGlzLnBvc2l0aW9uXyA9PT0gdGhpcy5hcnJheUxpc3RfLnNpemUoKSkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaEVsZW1lbnRFeGNlcHRpb24oKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXysrKVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uIGhhc05leHQgKCkge1xuICAgIGlmICh0aGlzLnBvc2l0aW9uXyA8IHRoaXMuYXJyYXlMaXN0Xy5zaXplKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogVE9ETzogc2hvdWxkIGJlIGluIExpc3RJdGVyYXRvclxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlMaXN0Xy5zZXQodGhpcy5wb3NpdGlvbl8gLSAxLCBlbGVtZW50KVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICB0aGlzLmFycmF5TGlzdF8ucmVtb3ZlKHRoaXMuYXJyYXlMaXN0Xy5nZXQodGhpcy5wb3NpdGlvbl8pKTtcbiAgfTtcblxuICByZXR1cm4gSXRlcmF0b3JfO1xufShJdGVyYXRvcikpO1xuXG52YXIgQ29vcmRpbmF0ZUxpc3QgPSAoZnVuY3Rpb24gKEFycmF5TGlzdCQkMSkge1xuICBmdW5jdGlvbiBDb29yZGluYXRlTGlzdCAoKSB7XG4gICAgQXJyYXlMaXN0JCQxLmNhbGwodGhpcyk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkoY29vcmQubGVuZ3RoKTtcbiAgICAgIHRoaXMuYWRkKGNvb3JkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBjb29yZCQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGFsbG93UmVwZWF0ZWQgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KGNvb3JkJDEubGVuZ3RoKTtcbiAgICAgIHRoaXMuYWRkKGNvb3JkJDEsIGFsbG93UmVwZWF0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICggQXJyYXlMaXN0JCQxICkgQ29vcmRpbmF0ZUxpc3QuX19wcm90b19fID0gQXJyYXlMaXN0JCQxO1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBcnJheUxpc3QkJDEgJiYgQXJyYXlMaXN0JCQxLnByb3RvdHlwZSApO1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb29yZGluYXRlTGlzdDtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBjb29yZEFycmF5VHlwZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuY29vcmRBcnJheVR5cGUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFycmF5KDApLmZpbGwobnVsbCkgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KGkpXG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiBhZGRBbGwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBjb2xsID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGFsbG93UmVwZWF0ZWQgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgaXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gY29sbC5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgICAgdGhpcyQxLmFkZChpLm5leHQoKSwgYWxsb3dSZXBlYXRlZCk7XG4gICAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNDaGFuZ2VkXG4gICAgfSBlbHNlIHsgcmV0dXJuIEFycmF5TGlzdCQkMS5wcm90b3R5cGUuYWRkQWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2xvbmUgPSBBcnJheUxpc3QkJDEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNpemUoKTsgaSsrKSB7XG4gICAgICBjbG9uZS5hZGQoaSwgdGhpcyQxLmdldChpKS5jb3B5KCkpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVcbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLnRvQ29vcmRpbmF0ZUFycmF5ID0gZnVuY3Rpb24gdG9Db29yZGluYXRlQXJyYXkgKCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoQ29vcmRpbmF0ZUxpc3QuY29vcmRBcnJheVR5cGUpXG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIEFycmF5TGlzdCQkMS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgY29vcmQpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdib29sZWFuJykge1xuICAgICAgICB2YXIgY29vcmQkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGFsbG93UmVwZWF0ZWQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHRoaXMuYWRkKGNvb3JkJDEsIGFsbG93UmVwZWF0ZWQsIHRydWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdib29sZWFuJykge1xuICAgICAgICB2YXIgY29vcmQkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGFsbG93UmVwZWF0ZWQkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgaWYgKCFhbGxvd1JlcGVhdGVkJDEpIHtcbiAgICAgICAgICBpZiAodGhpcy5zaXplKCkgPj0gMSkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLmdldCh0aGlzLnNpemUoKSAtIDEpO1xuICAgICAgICAgICAgaWYgKGxhc3QuZXF1YWxzMkQoY29vcmQkMikpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBcnJheUxpc3QkJDEucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGNvb3JkJDIpO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBhbGxvd1JlcGVhdGVkJDIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHRoaXMuYWRkKG9iaiwgYWxsb3dSZXBlYXRlZCQyKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnYm9vbGVhbicgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgdmFyIGNvb3JkJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBhbGxvd1JlcGVhdGVkJDMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjb29yZCQzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIHRoaXMkMS5hZGQoY29vcmQkM1tpJDFdLCBhbGxvd1JlcGVhdGVkJDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpJDIgPSBjb29yZCQzLmxlbmd0aCAtIDE7IGkkMiA+PSAwOyBpJDItLSkge1xuICAgICAgICAgICAgdGhpcyQxLmFkZChjb29yZCQzW2kkMl0sIGFsbG93UmVwZWF0ZWQkMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdib29sZWFuJyAmJiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgICAgIHZhciBpJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBjb29yZCQ0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgYWxsb3dSZXBlYXRlZCQ0ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAoIWFsbG93UmVwZWF0ZWQkNCkge1xuICAgICAgICAgIHZhciBzaXplID0gdGhpcy5zaXplKCk7XG4gICAgICAgICAgaWYgKHNpemUgPiAwKSB7XG4gICAgICAgICAgICBpZiAoaSQzID4gMCkge1xuICAgICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMuZ2V0KGkkMyAtIDEpO1xuICAgICAgICAgICAgICBpZiAocHJldi5lcXVhbHMyRChjb29yZCQ0KSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSQzIDwgc2l6ZSkge1xuICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0KGkkMyk7XG4gICAgICAgICAgICAgIGlmIChuZXh0LmVxdWFsczJEKGNvb3JkJDQpKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXlMaXN0JCQxLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBpJDMsIGNvb3JkJDQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIGNvb3JkJDUgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgYWxsb3dSZXBlYXRlZCQ1ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGVuZCA9IGFyZ3VtZW50c1szXTtcbiAgICAgIHZhciBpbmMgPSAxO1xuICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7IGluYyA9IC0xOyB9XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgIT09IGVuZDsgaSArPSBpbmMpIHtcbiAgICAgICAgdGhpcyQxLmFkZChjb29yZCQ1W2ldLCBhbGxvd1JlcGVhdGVkJDUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5jbG9zZVJpbmcgPSBmdW5jdGlvbiBjbG9zZVJpbmcgKCkge1xuICAgIGlmICh0aGlzLnNpemUoKSA+IDApIHsgdGhpcy5hZGQobmV3IENvb3JkaW5hdGUodGhpcy5nZXQoMCkpLCBmYWxzZSk7IH1cbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIENvb3JkaW5hdGVMaXN0XG4gIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvb3JkaW5hdGVMaXN0LCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gQ29vcmRpbmF0ZUxpc3Q7XG59KEFycmF5TGlzdCkpO1xuXG52YXIgQ29vcmRpbmF0ZUFycmF5cyA9IGZ1bmN0aW9uIENvb3JkaW5hdGVBcnJheXMgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTMgPSB7IEZvcndhcmRDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEJpZGlyZWN0aW9uYWxDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGNvb3JkQXJyYXlUeXBlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnN0YXRpY0FjY2Vzc29ycyQxMy5Gb3J3YXJkQ29tcGFyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBGb3J3YXJkQ29tcGFyYXRvciB9O1xuc3RhdGljQWNjZXNzb3JzJDEzLkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZGlyZWN0aW9uYWxDb21wYXJhdG9yIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTMuY29vcmRBcnJheVR5cGUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFycmF5KDApLmZpbGwobnVsbCkgfTtcblxuQ29vcmRpbmF0ZUFycmF5cy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvb3JkaW5hdGVBcnJheXMucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5c1xufTtcbkNvb3JkaW5hdGVBcnJheXMuaXNSaW5nID0gZnVuY3Rpb24gaXNSaW5nIChwdHMpIHtcbiAgaWYgKHB0cy5sZW5ndGggPCA0KSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICghcHRzWzBdLmVxdWFsczJEKHB0c1twdHMubGVuZ3RoIC0gMV0pKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0cnVlXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5wdE5vdEluTGlzdCA9IGZ1bmN0aW9uIHB0Tm90SW5MaXN0ICh0ZXN0UHRzLCBwdHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXN0UHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRlc3RQdCA9IHRlc3RQdHNbaV07XG4gICAgaWYgKENvb3JkaW5hdGVBcnJheXMuaW5kZXhPZih0ZXN0UHQsIHB0cykgPCAwKSB7IHJldHVybiB0ZXN0UHQgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5zY3JvbGwgPSBmdW5jdGlvbiBzY3JvbGwgKGNvb3JkaW5hdGVzLCBmaXJzdENvb3JkaW5hdGUpIHtcbiAgdmFyIGkgPSBDb29yZGluYXRlQXJyYXlzLmluZGV4T2YoZmlyc3RDb29yZGluYXRlLCBjb29yZGluYXRlcyk7XG4gIGlmIChpIDwgMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBuZXdDb29yZGluYXRlcyA9IG5ldyBBcnJheShjb29yZGluYXRlcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gIFN5c3RlbS5hcnJheWNvcHkoY29vcmRpbmF0ZXMsIGksIG5ld0Nvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcy5sZW5ndGggLSBpKTtcbiAgU3lzdGVtLmFycmF5Y29weShjb29yZGluYXRlcywgMCwgbmV3Q29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzLmxlbmd0aCAtIGksIGkpO1xuICBTeXN0ZW0uYXJyYXljb3B5KG5ld0Nvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMubGVuZ3RoKTtcbn07XG5Db29yZGluYXRlQXJyYXlzLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGNvb3JkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29vcmQyID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChjb29yZDEgPT09IGNvb3JkMikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvb3JkMSA9PT0gbnVsbCB8fCBjb29yZDIgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoY29vcmQxLmxlbmd0aCAhPT0gY29vcmQyLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmQxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWNvb3JkMVtpXS5lcXVhbHMoY29vcmQyW2ldKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgY29vcmQxJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvb3JkMiQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBjb29yZGluYXRlQ29tcGFyYXRvciA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoY29vcmQxJDEgPT09IGNvb3JkMiQxKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29vcmQxJDEgPT09IG51bGwgfHwgY29vcmQyJDEgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoY29vcmQxJDEubGVuZ3RoICE9PSBjb29yZDIkMS5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjb29yZDEkMS5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICBpZiAoY29vcmRpbmF0ZUNvbXBhcmF0b3IuY29tcGFyZShjb29yZDEkMVtpJDFdLCBjb29yZDIkMVtpJDFdKSAhPT0gMCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5cy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKGNvb3JkaW5hdGVzLCBlbnYpIHtcbiAgdmFyIGNvb3JkTGlzdCA9IG5ldyBDb29yZGluYXRlTGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGVudi5pbnRlcnNlY3RzKGNvb3JkaW5hdGVzW2ldKSkgeyBjb29yZExpc3QuYWRkKGNvb3JkaW5hdGVzW2ldLCB0cnVlKTsgfVxuICB9XG4gIHJldHVybiBjb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKVxufTtcbkNvb3JkaW5hdGVBcnJheXMuaGFzUmVwZWF0ZWRQb2ludHMgPSBmdW5jdGlvbiBoYXNSZXBlYXRlZFBvaW50cyAoY29vcmQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb29yZFtpIC0gMV0uZXF1YWxzKGNvb3JkW2ldKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVSZXBlYXRlZFBvaW50cyA9IGZ1bmN0aW9uIHJlbW92ZVJlcGVhdGVkUG9pbnRzIChjb29yZCkge1xuICBpZiAoIUNvb3JkaW5hdGVBcnJheXMuaGFzUmVwZWF0ZWRQb2ludHMoY29vcmQpKSB7IHJldHVybiBjb29yZCB9XG4gIHZhciBjb29yZExpc3QgPSBuZXcgQ29vcmRpbmF0ZUxpc3QoY29vcmQsIGZhbHNlKTtcbiAgcmV0dXJuIGNvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoY29vcmQpIHtcbiAgdmFyIGxhc3QgPSBjb29yZC5sZW5ndGggLSAxO1xuICB2YXIgbWlkID0gTWF0aC50cnVuYyhsYXN0IC8gMik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG1pZDsgaSsrKSB7XG4gICAgdmFyIHRtcCA9IGNvb3JkW2ldO1xuICAgIGNvb3JkW2ldID0gY29vcmRbbGFzdCAtIGldO1xuICAgIGNvb3JkW2xhc3QgLSBpXSA9IHRtcDtcbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheXMucmVtb3ZlTnVsbCA9IGZ1bmN0aW9uIHJlbW92ZU51bGwgKGNvb3JkKSB7XG4gIHZhciBub25OdWxsID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb29yZFtpXSAhPT0gbnVsbCkgeyBub25OdWxsKys7IH1cbiAgfVxuICB2YXIgbmV3Q29vcmQgPSBuZXcgQXJyYXkobm9uTnVsbCkuZmlsbChudWxsKTtcbiAgaWYgKG5vbk51bGwgPT09IDApIHsgcmV0dXJuIG5ld0Nvb3JkIH1cbiAgdmFyIGogPSAwO1xuICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjb29yZC5sZW5ndGg7IGkkMSsrKSB7XG4gICAgaWYgKGNvb3JkW2kkMV0gIT09IG51bGwpIHsgbmV3Q29vcmRbaisrXSA9IGNvb3JkW2kkMV07IH1cbiAgfVxuICByZXR1cm4gbmV3Q29vcmRcbn07XG5Db29yZGluYXRlQXJyYXlzLmNvcHlEZWVwID0gZnVuY3Rpb24gY29weURlZXAgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29weSA9IG5ldyBBcnJheShjb29yZGluYXRlcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29weVtpXSA9IG5ldyBDb29yZGluYXRlKGNvb3JkaW5hdGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgdmFyIHNyYyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc3JjU3RhcnQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRlc3QgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGRlc3RTdGFydCA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzWzRdO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxlbmd0aDsgaSQxKyspIHtcbiAgICAgIGRlc3RbZGVzdFN0YXJ0ICsgaSQxXSA9IG5ldyBDb29yZGluYXRlKHNyY1tzcmNTdGFydCArIGkkMV0pO1xuICAgIH1cbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheXMuaXNFcXVhbFJldmVyc2VkID0gZnVuY3Rpb24gaXNFcXVhbFJldmVyc2VkIChwdHMxLCBwdHMyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzMS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwMSA9IHB0czFbaV07XG4gICAgdmFyIHAyID0gcHRzMltwdHMxLmxlbmd0aCAtIGkgLSAxXTtcbiAgICBpZiAocDEuY29tcGFyZVRvKHAyKSAhPT0gMCkgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5lbnZlbG9wZSA9IGZ1bmN0aW9uIGVudmVsb3BlIChjb29yZGluYXRlcykge1xuICB2YXIgZW52ID0gbmV3IEVudmVsb3BlKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbnYuZXhwYW5kVG9JbmNsdWRlKGNvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZW52XG59O1xuQ29vcmRpbmF0ZUFycmF5cy50b0Nvb3JkaW5hdGVBcnJheSA9IGZ1bmN0aW9uIHRvQ29vcmRpbmF0ZUFycmF5IChjb29yZExpc3QpIHtcbiAgcmV0dXJuIGNvb3JkTGlzdC50b0FycmF5KENvb3JkaW5hdGVBcnJheXMuY29vcmRBcnJheVR5cGUpXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5hdExlYXN0TkNvb3JkaW5hdGVzT3JOb3RoaW5nID0gZnVuY3Rpb24gYXRMZWFzdE5Db29yZGluYXRlc09yTm90aGluZyAobiwgYykge1xuICByZXR1cm4gYy5sZW5ndGggPj0gbiA/IGMgOiBbXVxufTtcbkNvb3JkaW5hdGVBcnJheXMuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKGNvb3JkaW5hdGUsIGNvb3JkaW5hdGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29vcmRpbmF0ZS5lcXVhbHMoY29vcmRpbmF0ZXNbaV0pKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn07XG5Db29yZGluYXRlQXJyYXlzLmluY3JlYXNpbmdEaXJlY3Rpb24gPSBmdW5jdGlvbiBpbmNyZWFzaW5nRGlyZWN0aW9uIChwdHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLnRydW5jKHB0cy5sZW5ndGggLyAyKTsgaSsrKSB7XG4gICAgdmFyIGogPSBwdHMubGVuZ3RoIC0gMSAtIGk7XG4gICAgdmFyIGNvbXAgPSBwdHNbaV0uY29tcGFyZVRvKHB0c1tqXSk7XG4gICAgaWYgKGNvbXAgIT09IDApIHsgcmV0dXJuIGNvbXAgfVxuICB9XG4gIHJldHVybiAxXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAocHRzMSwgcHRzMikge1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgcHRzMS5sZW5ndGggJiYgaSA8IHB0czIubGVuZ3RoKSB7XG4gICAgdmFyIGNvbXBhcmUgPSBwdHMxW2ldLmNvbXBhcmVUbyhwdHMyW2ldKTtcbiAgICBpZiAoY29tcGFyZSAhPT0gMCkgeyByZXR1cm4gY29tcGFyZSB9XG4gICAgaSsrO1xuICB9XG4gIGlmIChpIDwgcHRzMi5sZW5ndGgpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKGkgPCBwdHMxLmxlbmd0aCkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5taW5Db29yZGluYXRlID0gZnVuY3Rpb24gbWluQ29vcmRpbmF0ZSAoY29vcmRpbmF0ZXMpIHtcbiAgdmFyIG1pbkNvb3JkID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtaW5Db29yZCA9PT0gbnVsbCB8fCBtaW5Db29yZC5jb21wYXJlVG8oY29vcmRpbmF0ZXNbaV0pID4gMCkge1xuICAgICAgbWluQ29vcmQgPSBjb29yZGluYXRlc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbkNvb3JkXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5leHRyYWN0ID0gZnVuY3Rpb24gZXh0cmFjdCAocHRzLCBzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gTWF0aFV0aWwuY2xhbXAoc3RhcnQsIDAsIHB0cy5sZW5ndGgpO1xuICBlbmQgPSBNYXRoVXRpbC5jbGFtcChlbmQsIC0xLCBwdHMubGVuZ3RoKTtcbiAgdmFyIG5wdHMgPSBlbmQgLSBzdGFydCArIDE7XG4gIGlmIChlbmQgPCAwKSB7IG5wdHMgPSAwOyB9XG4gIGlmIChzdGFydCA+PSBwdHMubGVuZ3RoKSB7IG5wdHMgPSAwOyB9XG4gIGlmIChlbmQgPCBzdGFydCkgeyBucHRzID0gMDsgfVxuICB2YXIgZXh0cmFjdFB0cyA9IG5ldyBBcnJheShucHRzKS5maWxsKG51bGwpO1xuICBpZiAobnB0cyA9PT0gMCkgeyByZXR1cm4gZXh0cmFjdFB0cyB9XG4gIHZhciBpUHRzID0gMDtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgZXh0cmFjdFB0c1tpUHRzKytdID0gcHRzW2ldO1xuICB9XG4gIHJldHVybiBleHRyYWN0UHRzXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZUFycmF5cywgc3RhdGljQWNjZXNzb3JzJDEzICk7XG5cbnZhciBGb3J3YXJkQ29tcGFyYXRvciA9IGZ1bmN0aW9uIEZvcndhcmRDb21wYXJhdG9yICgpIHt9O1xuXG5Gb3J3YXJkQ29tcGFyYXRvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKG8xLCBvMikge1xuICB2YXIgcHRzMSA9IG8xO1xuICB2YXIgcHRzMiA9IG8yO1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5cy5jb21wYXJlKHB0czEsIHB0czIpXG59O1xuRm9yd2FyZENvbXBhcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmF0b3JdXG59O1xuRm9yd2FyZENvbXBhcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRm9yd2FyZENvbXBhcmF0b3Jcbn07XG5cbnZhciBCaWRpcmVjdGlvbmFsQ29tcGFyYXRvciA9IGZ1bmN0aW9uIEJpZGlyZWN0aW9uYWxDb21wYXJhdG9yICgpIHt9O1xuXG5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKG8xLCBvMikge1xuICB2YXIgcHRzMSA9IG8xO1xuICB2YXIgcHRzMiA9IG8yO1xuICBpZiAocHRzMS5sZW5ndGggPCBwdHMyLmxlbmd0aCkgeyByZXR1cm4gLTEgfVxuICBpZiAocHRzMS5sZW5ndGggPiBwdHMyLmxlbmd0aCkgeyByZXR1cm4gMSB9XG4gIGlmIChwdHMxLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gMCB9XG4gIHZhciBmb3J3YXJkQ29tcCA9IENvb3JkaW5hdGVBcnJheXMuY29tcGFyZShwdHMxLCBwdHMyKTtcbiAgdmFyIGlzRXF1YWxSZXYgPSBDb29yZGluYXRlQXJyYXlzLmlzRXF1YWxSZXZlcnNlZChwdHMxLCBwdHMyKTtcbiAgaWYgKGlzRXF1YWxSZXYpIHsgcmV0dXJuIDAgfVxuICByZXR1cm4gZm9yd2FyZENvbXBcbn07XG5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuT0xEY29tcGFyZSA9IGZ1bmN0aW9uIE9MRGNvbXBhcmUgKG8xLCBvMikge1xuICB2YXIgcHRzMSA9IG8xO1xuICB2YXIgcHRzMiA9IG8yO1xuICBpZiAocHRzMS5sZW5ndGggPCBwdHMyLmxlbmd0aCkgeyByZXR1cm4gLTEgfVxuICBpZiAocHRzMS5sZW5ndGggPiBwdHMyLmxlbmd0aCkgeyByZXR1cm4gMSB9XG4gIGlmIChwdHMxLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gMCB9XG4gIHZhciBkaXIxID0gQ29vcmRpbmF0ZUFycmF5cy5pbmNyZWFzaW5nRGlyZWN0aW9uKHB0czEpO1xuICB2YXIgZGlyMiA9IENvb3JkaW5hdGVBcnJheXMuaW5jcmVhc2luZ0RpcmVjdGlvbihwdHMyKTtcbiAgdmFyIGkxID0gZGlyMSA+IDAgPyAwIDogcHRzMS5sZW5ndGggLSAxO1xuICB2YXIgaTIgPSBkaXIyID4gMCA/IDAgOiBwdHMxLmxlbmd0aCAtIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzMS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wYXJlUHQgPSBwdHMxW2kxXS5jb21wYXJlVG8ocHRzMltpMl0pO1xuICAgIGlmIChjb21wYXJlUHQgIT09IDApIHsgcmV0dXJuIGNvbXBhcmVQdCB9XG4gICAgaTEgKz0gZGlyMTtcbiAgICBpMiArPSBkaXIyO1xuICB9XG4gIHJldHVybiAwXG59O1xuQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmF0b3JdXG59O1xuQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQmlkaXJlY3Rpb25hbENvbXBhcmF0b3Jcbn07XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvTWFwLmh0bWxcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBNYXAkMSA9IGZ1bmN0aW9uIE1hcCAoKSB7fTtcblxuTWFwJDEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7fTtcbi8qKlxuICogQXNzb2NpYXRlcyB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgaW4gdGhpcyBtYXAgKG9wdGlvbmFsXG4gKiBvcGVyYXRpb24pLlxuICogQHBhcmFtIHtPYmplY3R9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1hcCQxLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBwdXQgKCkge307XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGtleS12YWx1ZSBtYXBwaW5ncyBpbiB0aGlzIG1hcC5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuTWFwJDEucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgYSBDb2xsZWN0aW9uIHZpZXcgb2YgdGhlIHZhbHVlcyBjb250YWluZWQgaW4gdGhpcyBtYXAuXG4gKiBAcmV0dXJuIHtqYXZhc2NyaXB0LnV0aWwuQ29sbGVjdGlvbn1cbiAqL1xuTWFwJDEucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcyAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGEge0BsaW5rIFNldH0gdmlldyBvZiB0aGUgbWFwcGluZ3MgY29udGFpbmVkIGluIHRoaXMgbWFwLlxuICogVGhlIHNldCBpcyBiYWNrZWQgYnkgdGhlIG1hcCwgc28gY2hhbmdlcyB0byB0aGUgbWFwIGFyZVxuICogcmVmbGVjdGVkIGluIHRoZSBzZXQsIGFuZCB2aWNlLXZlcnNhLklmIHRoZSBtYXAgaXMgbW9kaWZpZWRcbiAqIHdoaWxlIGFuIGl0ZXJhdGlvbiBvdmVyIHRoZSBzZXQgaXMgaW4gcHJvZ3Jlc3MgKGV4Y2VwdCB0aHJvdWdoXG4gKiB0aGUgaXRlcmF0b3IncyBvd24gPHR0PnJlbW92ZTwvdHQ+IG9wZXJhdGlvbiwgb3IgdGhyb3VnaCB0aGVcbiAqIDx0dD5zZXRWYWx1ZTwvdHQ+IG9wZXJhdGlvbiBvbiBhIG1hcCBlbnRyeSByZXR1cm5lZCBieSB0aGVcbiAqIGl0ZXJhdG9yKSB0aGUgcmVzdWx0cyBvZiB0aGUgaXRlcmF0aW9uIGFyZSB1bmRlZmluZWQuVGhlIHNldFxuICogc3VwcG9ydHMgZWxlbWVudCByZW1vdmFsLCB3aGljaCByZW1vdmVzIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBtYXBwaW5nIGZyb20gdGhlIG1hcCwgdmlhIHRoZSA8dHQ+SXRlcmF0b3IucmVtb3ZlPC90dD4sXG4gKiA8dHQ+U2V0LnJlbW92ZTwvdHQ+LCA8dHQ+cmVtb3ZlQWxsPC90dD4sIDx0dD5yZXRhaW5BbGw8L3R0PiBhbmRcbiAqIDx0dD5jbGVhcjwvdHQ+IG9wZXJhdGlvbnMuSXQgZG9lcyBub3Qgc3VwcG9ydCB0aGVcbiAqIDx0dD5hZGQ8L3R0PiBvciA8dHQ+YWRkQWxsPC90dD4gb3BlcmF0aW9ucy5cbiAqXG4gKiBAcmV0dXJuIHtTZXR9IGEgc2V0IHZpZXcgb2YgdGhlIG1hcHBpbmdzIGNvbnRhaW5lZCBpbiB0aGlzIG1hcFxuICovXG5NYXAkMS5wcm90b3R5cGUuZW50cnlTZXQgPSBmdW5jdGlvbiBlbnRyeVNldCAoKSB7fTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9Tb3J0ZWRNYXAuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtNYXB9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBTb3J0ZWRNYXAgPSAoZnVuY3Rpb24gKE1hcCkge1xuXHRmdW5jdGlvbiBTb3J0ZWRNYXAgKCkge1xuXHRcdE1hcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9aWYgKCBNYXAgKSBTb3J0ZWRNYXAuX19wcm90b19fID0gTWFwO1xuXHRTb3J0ZWRNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwICYmIE1hcC5wcm90b3R5cGUgKTtcblx0U29ydGVkTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvcnRlZE1hcDtcblxuXHRcblxuXHRyZXR1cm4gU29ydGVkTWFwO1xufShNYXAkMSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIE9wZXJhdGlvbk5vdFN1cHBvcnRlZCAobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xufVxuT3BlcmF0aW9uTm90U3VwcG9ydGVkLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbk9wZXJhdGlvbk5vdFN1cHBvcnRlZC5wcm90b3R5cGUubmFtZSA9ICdPcGVyYXRpb25Ob3RTdXBwb3J0ZWQnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL1NldC5odG1sXG4gKlxuICogQGV4dGVuZHMge0NvbGxlY3Rpb259XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFNldCgpIHt9XG5TZXQucHJvdG90eXBlID0gbmV3IENvbGxlY3Rpb24oKTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNldCBjb250YWlucyB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuIE1vcmUgZm9ybWFsbHksXG4gKiByZXR1cm5zIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgY29udGFpbnMgYW4gZWxlbWVudCBlIHN1Y2ggdGhhdCAobz09bnVsbCA/XG4gKiBlPT1udWxsIDogby5lcXVhbHMoZSkpLlxuICogQHBhcmFtIHtPYmplY3R9IGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbigpIHt9O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2RvY3Mub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvSGFzaFNldC5odG1sXG4gKlxuICogQGV4dGVuZHMge2phdmFzY3JpcHQudXRpbC5TZXR9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBIYXNoU2V0ID0gKGZ1bmN0aW9uIChTZXQkJDEpIHtcbiAgZnVuY3Rpb24gSGFzaFNldCAoKSB7XG4gICAgU2V0JCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5hcnJheV8gPSBbXTtcblxuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICggU2V0JCQxICkgSGFzaFNldC5fX3Byb3RvX18gPSBTZXQkJDE7XG4gIEhhc2hTZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2V0JCQxICYmIFNldCQkMS5wcm90b3R5cGUgKTtcbiAgSGFzaFNldC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoU2V0O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMgKG8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGUgPSB0aGlzJDEuYXJyYXlfW2ldO1xuICAgICAgaWYgKGUgPT09IG8pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChvKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnMobykpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHRoaXMuYXJyYXlfLnB1c2gobyk7XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIGFkZEFsbCAoYykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IGMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB0aGlzJDEuYWRkKGkubmV4dCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKG8pIHtcbiAgICAvLyB0aHJvdyBuZXcgamF2YXNjcmlwdC51dGlsLk9wZXJhdGlvbk5vdFN1cHBvcnRlZCgpXG4gICAgdGhyb3cgbmV3IEVycm9yKClcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoID09PSAwXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2godGhpcyQxLmFycmF5X1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcl8kMSh0aGlzKVxuICB9O1xuXG4gIHJldHVybiBIYXNoU2V0O1xufShTZXQpKTtcblxuLyoqXG4gICAqIEBleHRlbmRzIHtJdGVyYXRvcn1cbiAgICogQHBhcmFtIHtIYXNoU2V0fSBoYXNoU2V0XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbnZhciBJdGVyYXRvcl8kMSA9IChmdW5jdGlvbiAoSXRlcmF0b3IkJDEpIHtcbiAgZnVuY3Rpb24gSXRlcmF0b3JfIChoYXNoU2V0KSB7XG4gICAgSXRlcmF0b3IkJDEuY2FsbCh0aGlzKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SGFzaFNldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaGFzaFNldF8gPSBoYXNoU2V0O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uXyA9IDA7XG4gIH1cblxuICBpZiAoIEl0ZXJhdG9yJCQxICkgSXRlcmF0b3JfLl9fcHJvdG9fXyA9IEl0ZXJhdG9yJCQxO1xuICBJdGVyYXRvcl8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlcmF0b3IkJDEgJiYgSXRlcmF0b3IkJDEucHJvdG90eXBlICk7XG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJdGVyYXRvcl87XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgaWYgKHRoaXMucG9zaXRpb25fID09PSB0aGlzLmhhc2hTZXRfLnNpemUoKSkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaEVsZW1lbnRFeGNlcHRpb24oKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYXNoU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK11cbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiBoYXNOZXh0ICgpIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvbl8gPCB0aGlzLmhhc2hTZXRfLnNpemUoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICB0aHJvdyBuZXcgT3BlcmF0aW9uTm90U3VwcG9ydGVkKClcbiAgfTtcblxuICByZXR1cm4gSXRlcmF0b3JfO1xufShJdGVyYXRvcikpO1xuXG52YXIgQkxBQ0sgPSAwO1xudmFyIFJFRCA9IDE7XG5mdW5jdGlvbiBjb2xvck9mIChwKSB7IHJldHVybiAocCA9PT0gbnVsbCA/IEJMQUNLIDogcC5jb2xvcikgfVxuZnVuY3Rpb24gcGFyZW50T2YgKHApIHsgcmV0dXJuIChwID09PSBudWxsID8gbnVsbCA6IHAucGFyZW50KSB9XG5mdW5jdGlvbiBzZXRDb2xvciAocCwgYykgeyBpZiAocCAhPT0gbnVsbCkgeyBwLmNvbG9yID0gYzsgfSB9XG5mdW5jdGlvbiBsZWZ0T2YgKHApIHsgcmV0dXJuIChwID09PSBudWxsID8gbnVsbCA6IHAubGVmdCkgfVxuZnVuY3Rpb24gcmlnaHRPZiAocCkgeyByZXR1cm4gKHAgPT09IG51bGwgPyBudWxsIDogcC5yaWdodCkgfVxuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL1RyZWVNYXAuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtTb3J0ZWRNYXB9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRyZWVNYXAgKCkge1xuICAvKipcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucm9vdF8gPSBudWxsO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgKi9cbiAgdGhpcy5zaXplXyA9IDA7XG59XG5UcmVlTWFwLnByb3RvdHlwZSA9IG5ldyBTb3J0ZWRNYXAoKTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgcCA9IHRoaXMucm9vdF87XG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgdmFyIGNtcCA9IGtleVsnY29tcGFyZVRvJ10ocC5rZXkpO1xuICAgIGlmIChjbXAgPCAwKSB7IHAgPSBwLmxlZnQ7IH1cbiAgICBlbHNlIGlmIChjbXAgPiAwKSB7IHAgPSBwLnJpZ2h0OyB9XG4gICAgZWxzZSB7IHJldHVybiBwLnZhbHVlIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgaWYgKHRoaXMucm9vdF8gPT09IG51bGwpIHtcbiAgICB0aGlzLnJvb3RfID0ge1xuICAgICAga2V5OiBrZXksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBsZWZ0OiBudWxsLFxuICAgICAgcmlnaHQ6IG51bGwsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBjb2xvcjogQkxBQ0ssXG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUgKCkgeyByZXR1cm4gdGhpcy52YWx1ZSB9LFxuICAgICAgZ2V0S2V5OiBmdW5jdGlvbiBnZXRLZXkgKCkgeyByZXR1cm4gdGhpcy5rZXkgfVxuICAgIH07XG4gICAgdGhpcy5zaXplXyA9IDE7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgdCA9IHRoaXMucm9vdF87XG4gIHZhciBwYXJlbnQ7XG4gIHZhciBjbXA7XG4gIGRvIHtcbiAgICBwYXJlbnQgPSB0O1xuICAgIGNtcCA9IGtleVsnY29tcGFyZVRvJ10odC5rZXkpO1xuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICB0ID0gdC5sZWZ0O1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgdCA9IHQucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHQudmFsdWU7XG4gICAgICB0LnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gb2xkVmFsdWVcbiAgICB9XG4gIH0gd2hpbGUgKHQgIT09IG51bGwpXG4gIHZhciBlID0ge1xuICAgIGtleToga2V5LFxuICAgIGxlZnQ6IG51bGwsXG4gICAgcmlnaHQ6IG51bGwsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGNvbG9yOiBCTEFDSyxcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUgKCkgeyByZXR1cm4gdGhpcy52YWx1ZSB9LFxuICAgIGdldEtleTogZnVuY3Rpb24gZ2V0S2V5ICgpIHsgcmV0dXJuIHRoaXMua2V5IH1cbiAgfTtcbiAgaWYgKGNtcCA8IDApIHtcbiAgICBwYXJlbnQubGVmdCA9IGU7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LnJpZ2h0ID0gZTtcbiAgfVxuICB0aGlzLmZpeEFmdGVySW5zZXJ0aW9uKGUpO1xuICB0aGlzLnNpemVfKys7XG4gIHJldHVybiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSB4XG4gKi9cblRyZWVNYXAucHJvdG90eXBlLmZpeEFmdGVySW5zZXJ0aW9uID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgeC5jb2xvciA9IFJFRDtcbiAgd2hpbGUgKHggIT0gbnVsbCAmJiB4ICE9PSB0aGlzLnJvb3RfICYmIHgucGFyZW50LmNvbG9yID09PSBSRUQpIHtcbiAgICBpZiAocGFyZW50T2YoeCkgPT09IGxlZnRPZihwYXJlbnRPZihwYXJlbnRPZih4KSkpKSB7XG4gICAgICB2YXIgeSA9IHJpZ2h0T2YocGFyZW50T2YocGFyZW50T2YoeCkpKTtcbiAgICAgIGlmIChjb2xvck9mKHkpID09PSBSRUQpIHtcbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YoeCksIEJMQUNLKTtcbiAgICAgICAgc2V0Q29sb3IoeSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZihwYXJlbnRPZih4KSksIFJFRCk7XG4gICAgICAgIHggPSBwYXJlbnRPZihwYXJlbnRPZih4KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeCA9PT0gcmlnaHRPZihwYXJlbnRPZih4KSkpIHtcbiAgICAgICAgICB4ID0gcGFyZW50T2YoeCk7XG4gICAgICAgICAgdGhpcyQxLnJvdGF0ZUxlZnQoeCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YoeCksIEJMQUNLKTtcbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YocGFyZW50T2YoeCkpLCBSRUQpO1xuICAgICAgICB0aGlzJDEucm90YXRlUmlnaHQocGFyZW50T2YocGFyZW50T2YoeCkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHkkMSA9IGxlZnRPZihwYXJlbnRPZihwYXJlbnRPZih4KSkpO1xuICAgICAgaWYgKGNvbG9yT2YoeSQxKSA9PT0gUkVEKSB7XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHgpLCBCTEFDSyk7XG4gICAgICAgIHNldENvbG9yKHkkMSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZihwYXJlbnRPZih4KSksIFJFRCk7XG4gICAgICAgIHggPSBwYXJlbnRPZihwYXJlbnRPZih4KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeCA9PT0gbGVmdE9mKHBhcmVudE9mKHgpKSkge1xuICAgICAgICAgIHggPSBwYXJlbnRPZih4KTtcbiAgICAgICAgICB0aGlzJDEucm90YXRlUmlnaHQoeCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YoeCksIEJMQUNLKTtcbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YocGFyZW50T2YoeCkpLCBSRUQpO1xuICAgICAgICB0aGlzJDEucm90YXRlTGVmdChwYXJlbnRPZihwYXJlbnRPZih4KSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnJvb3RfLmNvbG9yID0gQkxBQ0s7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBwID0gdGhpcy5nZXRGaXJzdEVudHJ5KCk7XG4gIGlmIChwICE9PSBudWxsKSB7XG4gICAgYXJyYXlMaXN0LmFkZChwLnZhbHVlKTtcbiAgICB3aGlsZSAoKHAgPSBUcmVlTWFwLnN1Y2Nlc3NvcihwKSkgIT09IG51bGwpIHtcbiAgICAgIGFycmF5TGlzdC5hZGQocC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheUxpc3Rcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLmVudHJ5U2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaGFzaFNldCA9IG5ldyBIYXNoU2V0KCk7XG4gIHZhciBwID0gdGhpcy5nZXRGaXJzdEVudHJ5KCk7XG4gIGlmIChwICE9PSBudWxsKSB7XG4gICAgaGFzaFNldC5hZGQocCk7XG4gICAgd2hpbGUgKChwID0gVHJlZU1hcC5zdWNjZXNzb3IocCkpICE9PSBudWxsKSB7XG4gICAgICBoYXNoU2V0LmFkZChwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc2hTZXRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHBcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUucm90YXRlTGVmdCA9IGZ1bmN0aW9uIChwKSB7XG4gIGlmIChwICE9IG51bGwpIHtcbiAgICB2YXIgciA9IHAucmlnaHQ7XG4gICAgcC5yaWdodCA9IHIubGVmdDtcbiAgICBpZiAoci5sZWZ0ICE9IG51bGwpIHsgci5sZWZ0LnBhcmVudCA9IHA7IH1cbiAgICByLnBhcmVudCA9IHAucGFyZW50O1xuICAgIGlmIChwLnBhcmVudCA9PT0gbnVsbCkgeyB0aGlzLnJvb3RfID0gcjsgfSBlbHNlIGlmIChwLnBhcmVudC5sZWZ0ID09PSBwKSB7IHAucGFyZW50LmxlZnQgPSByOyB9IGVsc2UgeyBwLnBhcmVudC5yaWdodCA9IHI7IH1cbiAgICByLmxlZnQgPSBwO1xuICAgIHAucGFyZW50ID0gcjtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcFxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5yb3RhdGVSaWdodCA9IGZ1bmN0aW9uIChwKSB7XG4gIGlmIChwICE9IG51bGwpIHtcbiAgICB2YXIgbCA9IHAubGVmdDtcbiAgICBwLmxlZnQgPSBsLnJpZ2h0O1xuICAgIGlmIChsLnJpZ2h0ICE9IG51bGwpIHsgbC5yaWdodC5wYXJlbnQgPSBwOyB9XG4gICAgbC5wYXJlbnQgPSBwLnBhcmVudDtcbiAgICBpZiAocC5wYXJlbnQgPT09IG51bGwpIHsgdGhpcy5yb290XyA9IGw7IH0gZWxzZSBpZiAocC5wYXJlbnQucmlnaHQgPT09IHApIHsgcC5wYXJlbnQucmlnaHQgPSBsOyB9IGVsc2UgeyBwLnBhcmVudC5sZWZ0ID0gbDsgfVxuICAgIGwucmlnaHQgPSBwO1xuICAgIHAucGFyZW50ID0gbDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblRyZWVNYXAucHJvdG90eXBlLmdldEZpcnN0RW50cnkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwID0gdGhpcy5yb290XztcbiAgaWYgKHAgIT0gbnVsbCkge1xuICAgIHdoaWxlIChwLmxlZnQgIT0gbnVsbCkge1xuICAgICAgcCA9IHAubGVmdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHRcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblRyZWVNYXAuc3VjY2Vzc29yID0gZnVuY3Rpb24gKHQpIHtcbiAgaWYgKHQgPT09IG51bGwpIHsgcmV0dXJuIG51bGwgfSBlbHNlIGlmICh0LnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgdmFyIHAgPSB0LnJpZ2h0O1xuICAgIHdoaWxlIChwLmxlZnQgIT09IG51bGwpIHtcbiAgICAgIHAgPSBwLmxlZnQ7XG4gICAgfVxuICAgIHJldHVybiBwXG4gIH0gZWxzZSB7XG4gICAgdmFyIHAkMSA9IHQucGFyZW50O1xuICAgIHZhciBjaCA9IHQ7XG4gICAgd2hpbGUgKHAkMSAhPT0gbnVsbCAmJiBjaCA9PT0gcCQxLnJpZ2h0KSB7XG4gICAgICBjaCA9IHAkMTtcbiAgICAgIHAkMSA9IHAkMS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBwJDFcbiAgfVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2l6ZV9cbn07XG5cbnZhciBMaW5lYWwgPSBmdW5jdGlvbiBMaW5lYWwgKCkge307XG5cbkxpbmVhbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxpbmVhbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMaW5lYWxcbn07XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvU29ydGVkU2V0Lmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7U2V0fVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTb3J0ZWRTZXQgKCkge31cblNvcnRlZFNldC5wcm90b3R5cGUgPSBuZXcgU2V0KCk7XG5cbi8vIGltcG9ydCBJdGVyYXRvciBmcm9tICcuL0l0ZXJhdG9yJ1xuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9UcmVlU2V0Lmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7U29ydGVkU2V0fVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBUcmVlU2V0ICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgKi9cbiAgdGhpcy5hcnJheV8gPSBbXTtcblxuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgIHRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSk7XG4gIH1cbn1cblRyZWVTZXQucHJvdG90eXBlID0gbmV3IFNvcnRlZFNldCgpO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChvKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gdGhpcyQxLmFycmF5X1tpXTtcbiAgICBpZiAoZVsnY29tcGFyZVRvJ10obykgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG8pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuY29udGFpbnMobykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlID0gdGhpcyQxLmFycmF5X1tpXTtcbiAgICBpZiAoZVsnY29tcGFyZVRvJ10obykgPT09IDEpIHtcbiAgICAgIHRoaXMkMS5hcnJheV8uc3BsaWNlKGksIDAsIG8pO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICB0aGlzLmFycmF5Xy5wdXNoKG8pO1xuXG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiAoYykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gYy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB0aGlzJDEuYWRkKGkubmV4dCgpKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZVNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgdGhyb3cgbmV3IE9wZXJhdGlvbk5vdFN1cHBvcnRlZCgpXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoID09PSAwXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgYXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnJheS5wdXNoKHRoaXMkMS5hcnJheV9baV0pO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBJdGVyYXRvcl8kMih0aGlzKVxufTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7amF2YXNjcmlwdC51dGlsLkl0ZXJhdG9yfVxuICogQHBhcmFtIHtqYXZhc2NyaXB0LnV0aWwuVHJlZVNldH0gdHJlZVNldFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSXRlcmF0b3JfJDIgPSBmdW5jdGlvbiAodHJlZVNldCkge1xuICAvKipcbiAgICogQHR5cGUge2phdmFzY3JpcHQudXRpbC5UcmVlU2V0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy50cmVlU2V0XyA9IHRyZWVTZXQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5wb3NpdGlvbl8gPSAwO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuSXRlcmF0b3JfJDIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBvc2l0aW9uXyA9PT0gdGhpcy50cmVlU2V0Xy5zaXplKCkpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbigpXG4gIH1cbiAgcmV0dXJuIHRoaXMudHJlZVNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5JdGVyYXRvcl8kMi5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucG9zaXRpb25fIDwgdGhpcy50cmVlU2V0Xy5zaXplKCkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5JdGVyYXRvcl8kMi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgT3BlcmF0aW9uTm90U3VwcG9ydGVkKClcbn07XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvQXJyYXlzLmh0bWxcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBBcnJheXMgPSBmdW5jdGlvbiBBcnJheXMgKCkge307XG5cbkFycmF5cy5zb3J0ID0gZnVuY3Rpb24gc29ydCAoKSB7XG4gIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICB2YXIgaTtcbiAgdmFyIHQ7XG4gIHZhciBjb21wYXJhdG9yO1xuICB2YXIgY29tcGFyZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBjb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLmNvbXBhcmVUbyhiKVxuICAgIH07XG4gICAgYS5zb3J0KGNvbXBhcmUpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBjb21wYXJhdG9yID0gYXJndW1lbnRzWzFdO1xuICAgIGNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGNvbXBhcmF0b3JbJ2NvbXBhcmUnXShhLCBiKVxuICAgIH07XG4gICAgYS5zb3J0KGNvbXBhcmUpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB0ID0gYS5zbGljZShhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgdC5zb3J0KCk7XG4gICAgdmFyIHIgPSBhLnNsaWNlKDAsIGFyZ3VtZW50c1sxXSkuY29uY2F0KHQsIGEuc2xpY2UoYXJndW1lbnRzWzJdLCBhLmxlbmd0aCkpO1xuICAgIGEuc3BsaWNlKDAsIGEubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgICAgYS5wdXNoKHJbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdCA9IGEuc2xpY2UoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgIGNvbXBhcmF0b3IgPSBhcmd1bWVudHNbM107XG4gICAgY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gY29tcGFyYXRvclsnY29tcGFyZSddKGEsIGIpXG4gICAgfTtcbiAgICB0LnNvcnQoY29tcGFyZSk7XG4gICAgciA9IGEuc2xpY2UoMCwgYXJndW1lbnRzWzFdKS5jb25jYXQodCwgYS5zbGljZShhcmd1bWVudHNbMl0sIGEubGVuZ3RoKSk7XG4gICAgYS5zcGxpY2UoMCwgYS5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhLnB1c2gocltpXSk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICogQHJldHVybiB7QXJyYXlMaXN0fVxuICovXG5BcnJheXMuYXNMaXN0ID0gZnVuY3Rpb24gYXNMaXN0IChhcnJheSkge1xuICB2YXIgYXJyYXlMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnJheUxpc3QuYWRkKGFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gYXJyYXlMaXN0XG59O1xuXG52YXIgRGltZW5zaW9uID0gZnVuY3Rpb24gRGltZW5zaW9uICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDE0ID0geyBQOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEw6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQTogeyBjb25maWd1cmFibGU6IHRydWUgfSxGQUxTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxUUlVFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERPTlRDQVJFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNZTV9GQUxTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fVFJVRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fRE9OVENBUkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1lNX1A6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1lNX0w6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1lNX0E6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuc3RhdGljQWNjZXNzb3JzJDE0LlAuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LkwuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LkEuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LkZBTFNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuVFJVRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMiB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LkRPTlRDQVJFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0zIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuU1lNX0ZBTFNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdGJyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9UUlVFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdUJyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9ET05UQ0FSRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnKicgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5TWU1fUC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnMCcgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5TWU1fTC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnMScgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5TWU1fQS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnMicgfTtcblxuRGltZW5zaW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRGltZW5zaW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERpbWVuc2lvblxufTtcbkRpbWVuc2lvbi50b0RpbWVuc2lvblN5bWJvbCA9IGZ1bmN0aW9uIHRvRGltZW5zaW9uU3ltYm9sIChkaW1lbnNpb25WYWx1ZSkge1xuICBzd2l0Y2ggKGRpbWVuc2lvblZhbHVlKSB7XG4gICAgY2FzZSBEaW1lbnNpb24uRkFMU0U6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlNZTV9GQUxTRVxuICAgIGNhc2UgRGltZW5zaW9uLlRSVUU6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlNZTV9UUlVFXG4gICAgY2FzZSBEaW1lbnNpb24uRE9OVENBUkU6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlNZTV9ET05UQ0FSRVxuICAgIGNhc2UgRGltZW5zaW9uLlA6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlNZTV9QXG4gICAgY2FzZSBEaW1lbnNpb24uTDpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX0xcbiAgICBjYXNlIERpbWVuc2lvbi5BOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5TWU1fQVxuICAgIGRlZmF1bHQ6XG4gIH1cbiAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5rbm93biBkaW1lbnNpb24gdmFsdWU6ICcgKyBkaW1lbnNpb25WYWx1ZSlcbn07XG5EaW1lbnNpb24udG9EaW1lbnNpb25WYWx1ZSA9IGZ1bmN0aW9uIHRvRGltZW5zaW9uVmFsdWUgKGRpbWVuc2lvblN5bWJvbCkge1xuICBzd2l0Y2ggKENoYXJhY3Rlci50b1VwcGVyQ2FzZShkaW1lbnNpb25TeW1ib2wpKSB7XG4gICAgY2FzZSBEaW1lbnNpb24uU1lNX0ZBTFNFOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5GQUxTRVxuICAgIGNhc2UgRGltZW5zaW9uLlNZTV9UUlVFOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5UUlVFXG4gICAgY2FzZSBEaW1lbnNpb24uU1lNX0RPTlRDQVJFOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5ET05UQ0FSRVxuICAgIGNhc2UgRGltZW5zaW9uLlNZTV9QOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5QXG4gICAgY2FzZSBEaW1lbnNpb24uU1lNX0w6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkxcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fQTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uQVxuICAgIGRlZmF1bHQ6XG4gIH1cbiAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5rbm93biBkaW1lbnNpb24gc3ltYm9sOiAnICsgZGltZW5zaW9uU3ltYm9sKVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERpbWVuc2lvbiwgc3RhdGljQWNjZXNzb3JzJDE0ICk7XG5cbnZhciBHZW9tZXRyeUZpbHRlciA9IGZ1bmN0aW9uIEdlb21ldHJ5RmlsdGVyICgpIHt9O1xuXG5HZW9tZXRyeUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7fTtcbkdlb21ldHJ5RmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlGaWx0ZXJcbn07XG5cbnZhciBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXIgPSBmdW5jdGlvbiBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXIgKCkge307XG5cbkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChzZXEsIGkpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2VGaWx0ZXIucHJvdG90eXBlLmlzR2VvbWV0cnlDaGFuZ2VkID0gZnVuY3Rpb24gaXNHZW9tZXRyeUNoYW5nZWQgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2VGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db29yZGluYXRlU2VxdWVuY2VGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyXG59O1xuXG52YXIgR2VvbWV0cnlDb2xsZWN0aW9uID0gKGZ1bmN0aW9uIChHZW9tZXRyeSQkMSkge1xuICBmdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb24gKGdlb21ldHJpZXMsIGZhY3RvcnkpIHtcbiAgICBHZW9tZXRyeSQkMS5jYWxsKHRoaXMsIGZhY3RvcnkpO1xuICAgIHRoaXMuX2dlb21ldHJpZXMgPSBnZW9tZXRyaWVzIHx8IFtdO1xuXG4gICAgaWYgKEdlb21ldHJ5JCQxLmhhc051bGxFbGVtZW50cyh0aGlzLl9nZW9tZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignZ2VvbWV0cmllcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHMnKVxuICAgIH1cbiAgfVxuXG4gIGlmICggR2VvbWV0cnkkJDEgKSBHZW9tZXRyeUNvbGxlY3Rpb24uX19wcm90b19fID0gR2VvbWV0cnkkJDE7XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeSQkMSAmJiBHZW9tZXRyeSQkMS5wcm90b3R5cGUgKTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlb21ldHJ5Q29sbGVjdGlvbjtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgPSBmdW5jdGlvbiBjb21wdXRlRW52ZWxvcGVJbnRlcm5hbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZW52ZWxvcGUgPSBuZXcgRW52ZWxvcGUoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVudmVsb3BlLmV4cGFuZFRvSW5jbHVkZSh0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudmVsb3BlXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0R2VvbWV0cnlOID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlOIChuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbbl1cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeSQkMS5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtcbiAgICB2YXIgayA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkQ29vcmRpbmF0ZXMgPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGRDb29yZGluYXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBrKys7XG4gICAgICAgIGNvb3JkaW5hdGVzW2tdID0gY2hpbGRDb29yZGluYXRlc1tqXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uIGdldEFyZWEgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFyZWEgPSAwLjA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmVhICs9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXRBcmVhKCk7XG4gICAgfVxuICAgIHJldHVybiBhcmVhXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICghdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyhvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB2YXIgb3RoZXJDb2xsZWN0aW9uID0gb3RoZXI7XG4gICAgICBpZiAodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGggIT09IG90aGVyQ29sbGVjdGlvbi5fZ2VvbWV0cmllcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzJDEuX2dlb21ldHJpZXNbaV0uZXF1YWxzRXhhY3Qob3RoZXJDb2xsZWN0aW9uLl9nZW9tZXRyaWVzW2ldLCB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5JCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzJDEuX2dlb21ldHJpZXNbaV0ubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIEFycmF5cy5zb3J0KHRoaXMuX2dlb21ldHJpZXMpO1xuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyaWVzWzBdLmdldENvb3JkaW5hdGUoKVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGRpbWVuc2lvbiA9IERpbWVuc2lvbi5GQUxTRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRpbWVuc2lvbiA9IE1hdGgubWF4KGRpbWVuc2lvbiwgdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBkaW1lbnNpb24gPSBEaW1lbnNpb24uRkFMU0U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkaW1lbnNpb24gPSBNYXRoLm1heChkaW1lbnNpb24sIHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXREaW1lbnNpb24oKSk7XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb25cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN1bSA9IDAuMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1bSArPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW1cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROdW1Qb2ludHMgPSBmdW5jdGlvbiBnZXROdW1Qb2ludHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG51bVBvaW50cyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBudW1Qb2ludHMgKz0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldE51bVBvaW50cygpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtUG9pbnRzXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TnVtR2VvbWV0cmllcyA9IGZ1bmN0aW9uIGdldE51bUdlb21ldHJpZXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aFxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBuID0gdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgdmFyIHJldkdlb21zID0gbmV3IEFycmF5KG4pLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXZHZW9tc1tpXSA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24ocmV2R2VvbXMpXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuY29tcGFyZVRvU2FtZUNsYXNzID0gZnVuY3Rpb24gY29tcGFyZVRvU2FtZUNsYXNzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0aGVzZUVsZW1lbnRzID0gbmV3IFRyZWVTZXQoQXJyYXlzLmFzTGlzdCh0aGlzLl9nZW9tZXRyaWVzKSk7XG4gICAgICB2YXIgb3RoZXJFbGVtZW50cyA9IG5ldyBUcmVlU2V0KEFycmF5cy5hc0xpc3Qoby5fZ2VvbWV0cmllcykpO1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZSh0aGVzZUVsZW1lbnRzLCBvdGhlckVsZW1lbnRzKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG8kMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGdjID0gbyQxO1xuICAgICAgdmFyIG4xID0gdGhpcy5nZXROdW1HZW9tZXRyaWVzKCk7XG4gICAgICB2YXIgbjIgPSBnYy5nZXROdW1HZW9tZXRyaWVzKCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IG4xICYmIGkgPCBuMikge1xuICAgICAgICB2YXIgdGhpc0dlb20gPSB0aGlzJDEuZ2V0R2VvbWV0cnlOKGkpO1xuICAgICAgICB2YXIgb3RoZXJHZW9tID0gZ2MuZ2V0R2VvbWV0cnlOKGkpO1xuICAgICAgICB2YXIgaG9sZUNvbXAgPSB0aGlzR2VvbS5jb21wYXJlVG9TYW1lQ2xhc3Mob3RoZXJHZW9tLCBjb21wKTtcbiAgICAgICAgaWYgKGhvbGVDb21wICE9PSAwKSB7IHJldHVybiBob2xlQ29tcCB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgbjEpIHsgcmV0dXJuIDEgfVxuICAgICAgaWYgKGkgPCBuMikgeyByZXR1cm4gLTEgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmFwcGx5KGZpbHRlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGggPT09IDApIHsgcmV0dXJuIG51bGwgfVxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHRoaXMkMS5fZ2VvbWV0cmllc1tpJDFdLmFwcGx5KGZpbHRlciQxKTtcbiAgICAgICAgaWYgKGZpbHRlciQxLmlzRG9uZSgpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbHRlciQxLmlzR2VvbWV0cnlDaGFuZ2VkKCkpIHsgdGhpcy5nZW9tZXRyeUNoYW5nZWQoKTsgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgR2VvbWV0cnlGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmaWx0ZXIkMi5maWx0ZXIodGhpcyk7XG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgdGhpcyQxLl9nZW9tZXRyaWVzW2kkMl0uYXBwbHkoZmlsdGVyJDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmaWx0ZXIkMy5maWx0ZXIodGhpcyk7XG4gICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSQzKyspIHtcbiAgICAgICAgdGhpcyQxLl9nZW9tZXRyaWVzW2kkM10uYXBwbHkoZmlsdGVyJDMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICB0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpO1xuICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgpO1xuICAgIHJldHVybiBudWxsXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZ2MgPSBHZW9tZXRyeSQkMS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBnYy5fZ2VvbWV0cmllcyA9IG5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdjLl9nZW9tZXRyaWVzW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBnY1xuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdHZW9tZXRyeUNvbGxlY3Rpb24nXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSBuZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnZW9tZXRyaWVzW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC01Njk0NzI3NzI2Mzk1MDIxNDY3IH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdlb21ldHJ5Q29sbGVjdGlvbiwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbjtcbn0oR2VvbWV0cnkpKTtcblxudmFyIE11bHRpTGluZVN0cmluZyA9IChmdW5jdGlvbiAoR2VvbWV0cnlDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIE11bHRpTGluZVN0cmluZyAoKSB7XG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uJCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5Q29sbGVjdGlvbiQkMSApIE11bHRpTGluZVN0cmluZy5fX3Byb3RvX18gPSBHZW9tZXRyeUNvbGxlY3Rpb24kJDE7XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeUNvbGxlY3Rpb24kJDEgJiYgR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlMaW5lU3RyaW5nO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5LlNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkdcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICghdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyhvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsIG90aGVyLCB0b2xlcmFuY2UpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgcmV0dXJuIERpbWVuc2lvbi5GQUxTRVxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMkMS5fZ2VvbWV0cmllc1tpXS5pc0Nsb3NlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbkxpbmVzID0gdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgdmFyIHJldkxpbmVzID0gbmV3IEFycmF5KG5MaW5lcykuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldkxpbmVzW25MaW5lcyAtIDEgLSBpXSA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcocmV2TGluZXMpXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGFyeU9wKHRoaXMpLmdldEJvdW5kYXJ5KClcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnTXVsdGlMaW5lU3RyaW5nJ1xuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsaW5lU3RyaW5ncyA9IG5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaW5lU3RyaW5nc1tpXSA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5jb3B5KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKGxpbmVTdHJpbmdzLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbTGluZWFsXVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBNdWx0aUxpbmVTdHJpbmdcbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gODE2NjY2NTEzMjQ0NTQzMzc0MSB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNdWx0aUxpbmVTdHJpbmcsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBNdWx0aUxpbmVTdHJpbmc7XG59KEdlb21ldHJ5Q29sbGVjdGlvbikpO1xuXG52YXIgQm91bmRhcnlPcCA9IGZ1bmN0aW9uIEJvdW5kYXJ5T3AgKCkge1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdGhpcy5fZ2VvbUZhY3QgPSBudWxsO1xuICB0aGlzLl9iblJ1bGUgPSBudWxsO1xuICB0aGlzLl9lbmRwb2ludE1hcCA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJuUnVsZSA9IEJvdW5kYXJ5Tm9kZVJ1bGUuTU9EMl9CT1VOREFSWV9SVUxFO1xuICAgIHRoaXMuX2dlb20gPSBnZW9tO1xuICAgIHRoaXMuX2dlb21GYWN0ID0gZ2VvbS5nZXRGYWN0b3J5KCk7XG4gICAgdGhpcy5fYm5SdWxlID0gYm5SdWxlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBiblJ1bGUkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9nZW9tID0gZ2VvbSQxO1xuICAgIHRoaXMuX2dlb21GYWN0ID0gZ2VvbSQxLmdldEZhY3RvcnkoKTtcbiAgICB0aGlzLl9iblJ1bGUgPSBiblJ1bGUkMTtcbiAgfVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcgKG1MaW5lKSB7XG4gIGlmICh0aGlzLl9nZW9tLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpXG4gIH1cbiAgdmFyIGJkeVB0cyA9IHRoaXMuY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXMobUxpbmUpO1xuICBpZiAoYmR5UHRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2ludChiZHlQdHNbMF0pXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKGJkeVB0cylcbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgaWYgKHRoaXMuX2dlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7IHJldHVybiB0aGlzLmJvdW5kYXJ5TGluZVN0cmluZyh0aGlzLl9nZW9tKSB9XG4gIGlmICh0aGlzLl9nZW9tIGluc3RhbmNlb2YgTXVsdGlMaW5lU3RyaW5nKSB7IHJldHVybiB0aGlzLmJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nKHRoaXMuX2dlb20pIH1cbiAgcmV0dXJuIHRoaXMuX2dlb20uZ2V0Qm91bmRhcnkoKVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmJvdW5kYXJ5TGluZVN0cmluZyA9IGZ1bmN0aW9uIGJvdW5kYXJ5TGluZVN0cmluZyAobGluZSkge1xuICBpZiAodGhpcy5fZ2VvbS5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKVxuICB9XG4gIGlmIChsaW5lLmlzQ2xvc2VkKCkpIHtcbiAgICB2YXIgY2xvc2VkRW5kcG9pbnRPbkJvdW5kYXJ5ID0gdGhpcy5fYm5SdWxlLmlzSW5Cb3VuZGFyeSgyKTtcbiAgICBpZiAoY2xvc2VkRW5kcG9pbnRPbkJvdW5kYXJ5KSB7XG4gICAgICByZXR1cm4gbGluZS5nZXRTdGFydFBvaW50KClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludChbbGluZS5nZXRTdGFydFBvaW50KCksIGxpbmUuZ2V0RW5kUG9pbnQoKV0pXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuZ2V0RW1wdHlNdWx0aVBvaW50ID0gZnVuY3Rpb24gZ2V0RW1wdHlNdWx0aVBvaW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXMgKG1MaW5lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGJkeVB0cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fZW5kcG9pbnRNYXAgPSBuZXcgVHJlZU1hcCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1MaW5lLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBtTGluZS5nZXRHZW9tZXRyeU4oaSk7XG4gICAgaWYgKGxpbmUuZ2V0TnVtUG9pbnRzKCkgPT09IDApIHsgY29udGludWUgfVxuICAgIHRoaXMkMS5hZGRFbmRwb2ludChsaW5lLmdldENvb3JkaW5hdGVOKDApKTtcbiAgICB0aGlzJDEuYWRkRW5kcG9pbnQobGluZS5nZXRDb29yZGluYXRlTihsaW5lLmdldE51bVBvaW50cygpIC0gMSkpO1xuICB9XG4gIGZvciAodmFyIGl0ID0gdGhpcy5fZW5kcG9pbnRNYXAuZW50cnlTZXQoKS5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVudHJ5ID0gaXQubmV4dCgpO1xuICAgIHZhciBjb3VudGVyID0gZW50cnkuZ2V0VmFsdWUoKTtcbiAgICB2YXIgdmFsZW5jZSA9IGNvdW50ZXIuY291bnQ7XG4gICAgaWYgKHRoaXMkMS5fYm5SdWxlLmlzSW5Cb3VuZGFyeSh2YWxlbmNlKSkge1xuICAgICAgYmR5UHRzLmFkZChlbnRyeS5nZXRLZXkoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlzLnRvQ29vcmRpbmF0ZUFycmF5KGJkeVB0cylcbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5hZGRFbmRwb2ludCA9IGZ1bmN0aW9uIGFkZEVuZHBvaW50IChwdCkge1xuICB2YXIgY291bnRlciA9IHRoaXMuX2VuZHBvaW50TWFwLmdldChwdCk7XG4gIGlmIChjb3VudGVyID09PSBudWxsKSB7XG4gICAgY291bnRlciA9IG5ldyBDb3VudGVyKCk7XG4gICAgdGhpcy5fZW5kcG9pbnRNYXAucHV0KHB0LCBjb3VudGVyKTtcbiAgfVxuICBjb3VudGVyLmNvdW50Kys7XG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQm91bmRhcnlPcFxufTtcbkJvdW5kYXJ5T3AuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJvcCA9IG5ldyBCb3VuZGFyeU9wKGcpO1xuICAgIHJldHVybiBib3AuZ2V0Qm91bmRhcnkoKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBiblJ1bGUgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGJvcCQxID0gbmV3IEJvdW5kYXJ5T3AoZyQxLCBiblJ1bGUpO1xuICAgIHJldHVybiBib3AkMS5nZXRCb3VuZGFyeSgpXG4gIH1cbn07XG5cbnZhciBDb3VudGVyID0gZnVuY3Rpb24gQ291bnRlciAoKSB7XG4gIHRoaXMuY291bnQgPSBudWxsO1xufTtcbkNvdW50ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db3VudGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvdW50ZXJcbn07XG5cbi8vIGJvdW5kYXJ5XG5cbmZ1bmN0aW9uIFByaW50U3RyZWFtICgpIHt9XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlciAoKSB7fVxuXG52YXIgRGVjaW1hbEZvcm1hdCA9IGZ1bmN0aW9uIERlY2ltYWxGb3JtYXQgKCkge307XG5cbmZ1bmN0aW9uIEJ5dGVBcnJheU91dHB1dFN0cmVhbSAoKSB7fVxuXG5mdW5jdGlvbiBJT0V4Y2VwdGlvbiAoKSB7fVxuXG5mdW5jdGlvbiBMaW5lTnVtYmVyUmVhZGVyICgpIHt9XG5cbnZhciBTdHJpbmdVdGlsID0gZnVuY3Rpb24gU3RyaW5nVXRpbCAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxNSA9IHsgTkVXTElORTogeyBjb25maWd1cmFibGU6IHRydWUgfSxTSU1QTEVfT1JESU5BVEVfRk9STUFUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblN0cmluZ1V0aWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TdHJpbmdVdGlsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFN0cmluZ1V0aWxcbn07XG5TdHJpbmdVdGlsLmNoYXJzID0gZnVuY3Rpb24gY2hhcnMgKGMsIG4pIHtcbiAgdmFyIGNoID0gbmV3IEFycmF5KG4pLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgY2hbaV0gPSBjO1xuICB9XG4gIHJldHVybiBTdHJpbmcoY2gpXG59O1xuU3RyaW5nVXRpbC5nZXRTdGFja1RyYWNlID0gZnVuY3Rpb24gZ2V0U3RhY2tUcmFjZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9zID0gbmV3IEJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xuICAgIHZhciBwcyA9IG5ldyBQcmludFN0cmVhbShvcyk7XG4gICAgdC5wcmludFN0YWNrVHJhY2UocHMpO1xuICAgIHJldHVybiBvcy50b1N0cmluZygpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB0JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGRlcHRoID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBzdGFja1RyYWNlID0gJyc7XG4gICAgdmFyIHN0cmluZ1JlYWRlciA9IG5ldyBTdHJpbmdSZWFkZXIoU3RyaW5nVXRpbC5nZXRTdGFja1RyYWNlKHQkMSkpO1xuICAgIHZhciBsaW5lTnVtYmVyUmVhZGVyID0gbmV3IExpbmVOdW1iZXJSZWFkZXIoc3RyaW5nUmVhZGVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcHRoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YWNrVHJhY2UgKz0gbGluZU51bWJlclJlYWRlci5yZWFkTGluZSgpICsgU3RyaW5nVXRpbC5ORVdMSU5FO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIElPRXhjZXB0aW9uKSB7XG4gICAgICAgICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCk7XG4gICAgICAgIH0gZWxzZSB7IHRocm93IGUgfVxuICAgICAgfSBmaW5hbGx5IHt9XG4gICAgfVxuICAgIHJldHVybiBzdGFja1RyYWNlXG4gIH1cbn07XG5TdHJpbmdVdGlsLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKHMsIHNlcGFyYXRvcikge1xuICB2YXIgc2VwYXJhdG9ybGVuID0gc2VwYXJhdG9yLmxlbmd0aDtcbiAgdmFyIHRva2VuTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIHRtcFN0cmluZyA9ICcnICsgcztcbiAgdmFyIHBvcyA9IHRtcFN0cmluZy5pbmRleE9mKHNlcGFyYXRvcik7XG4gIHdoaWxlIChwb3MgPj0gMCkge1xuICAgIHZhciB0b2tlbiA9IHRtcFN0cmluZy5zdWJzdHJpbmcoMCwgcG9zKTtcbiAgICB0b2tlbkxpc3QuYWRkKHRva2VuKTtcbiAgICB0bXBTdHJpbmcgPSB0bXBTdHJpbmcuc3Vic3RyaW5nKHBvcyArIHNlcGFyYXRvcmxlbik7XG4gICAgcG9zID0gdG1wU3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgfVxuICBpZiAodG1wU3RyaW5nLmxlbmd0aCA+IDApIHsgdG9rZW5MaXN0LmFkZCh0bXBTdHJpbmcpOyB9XG4gIHZhciByZXMgPSBuZXcgQXJyYXkodG9rZW5MaXN0LnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbaV0gPSB0b2tlbkxpc3QuZ2V0KGkpO1xuICB9XG4gIHJldHVybiByZXNcbn07XG5TdHJpbmdVdGlsLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBkID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBTdHJpbmdVdGlsLlNJTVBMRV9PUkRJTkFURV9GT1JNQVQuZm9ybWF0KGQpXG4gIH1cbn07XG5TdHJpbmdVdGlsLnNwYWNlcyA9IGZ1bmN0aW9uIHNwYWNlcyAobikge1xuICByZXR1cm4gU3RyaW5nVXRpbC5jaGFycygnICcsIG4pXG59O1xuc3RhdGljQWNjZXNzb3JzJDE1Lk5FV0xJTkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gU3lzdGVtLmdldFByb3BlcnR5KCdsaW5lLnNlcGFyYXRvcicpIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTUuU0lNUExFX09SRElOQVRFX0ZPUk1BVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRGVjaW1hbEZvcm1hdCgnMC4jJykgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFN0cmluZ1V0aWwsIHN0YXRpY0FjY2Vzc29ycyQxNSApO1xuXG52YXIgQ29vcmRpbmF0ZVNlcXVlbmNlcyA9IGZ1bmN0aW9uIENvb3JkaW5hdGVTZXF1ZW5jZXMgKCkge307XG5cbkNvb3JkaW5hdGVTZXF1ZW5jZXMucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZXNcbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmNvcHlDb29yZCA9IGZ1bmN0aW9uIGNvcHlDb29yZCAoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MpIHtcbiAgdmFyIG1pbkRpbSA9IE1hdGgubWluKHNyYy5nZXREaW1lbnNpb24oKSwgZGVzdC5nZXREaW1lbnNpb24oKSk7XG4gIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IG1pbkRpbTsgZGltKyspIHtcbiAgICBkZXN0LnNldE9yZGluYXRlKGRlc3RQb3MsIGRpbSwgc3JjLmdldE9yZGluYXRlKHNyY1BvcywgZGltKSk7XG4gIH1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmlzUmluZyA9IGZ1bmN0aW9uIGlzUmluZyAoc2VxKSB7XG4gIHZhciBuID0gc2VxLnNpemUoKTtcbiAgaWYgKG4gPT09IDApIHsgcmV0dXJuIHRydWUgfVxuICBpZiAobiA8PSAzKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBzZXEuZ2V0T3JkaW5hdGUoMCwgQ29vcmRpbmF0ZVNlcXVlbmNlLlgpID09PSBzZXEuZ2V0T3JkaW5hdGUobiAtIDEsIENvb3JkaW5hdGVTZXF1ZW5jZS5YKSAmJiBzZXEuZ2V0T3JkaW5hdGUoMCwgQ29vcmRpbmF0ZVNlcXVlbmNlLlkpID09PSBzZXEuZ2V0T3JkaW5hdGUobiAtIDEsIENvb3JkaW5hdGVTZXF1ZW5jZS5ZKVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwgKGNzMSwgY3MyKSB7XG4gIHZhciBjczFTaXplID0gY3MxLnNpemUoKTtcbiAgdmFyIGNzMlNpemUgPSBjczIuc2l6ZSgpO1xuICBpZiAoY3MxU2l6ZSAhPT0gY3MyU2l6ZSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgZGltID0gTWF0aC5taW4oY3MxLmdldERpbWVuc2lvbigpLCBjczIuZ2V0RGltZW5zaW9uKCkpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNzMVNpemU7IGkrKykge1xuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHtcbiAgICAgIHZhciB2MSA9IGNzMS5nZXRPcmRpbmF0ZShpLCBkKTtcbiAgICAgIHZhciB2MiA9IGNzMi5nZXRPcmRpbmF0ZShpLCBkKTtcbiAgICAgIGlmIChjczEuZ2V0T3JkaW5hdGUoaSwgZCkgPT09IGNzMi5nZXRPcmRpbmF0ZShpLCBkKSkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoRG91YmxlLmlzTmFOKHYxKSAmJiBEb3VibGUuaXNOYU4odjIpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kIChmYWN0LCBzZXEsIHNpemUpIHtcbiAgdmFyIG5ld3NlcSA9IGZhY3QuY3JlYXRlKHNpemUsIHNlcS5nZXREaW1lbnNpb24oKSk7XG4gIHZhciBuID0gc2VxLnNpemUoKTtcbiAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5KHNlcSwgMCwgbmV3c2VxLCAwLCBuKTtcbiAgaWYgKG4gPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IG47IGkgPCBzaXplOyBpKyspIHsgQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5KHNlcSwgbiAtIDEsIG5ld3NlcSwgaSwgMSk7IH1cbiAgfVxuICByZXR1cm4gbmV3c2VxXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoc2VxKSB7XG4gIHZhciBsYXN0ID0gc2VxLnNpemUoKSAtIDE7XG4gIHZhciBtaWQgPSBNYXRoLnRydW5jKGxhc3QgLyAyKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWlkOyBpKyspIHtcbiAgICBDb29yZGluYXRlU2VxdWVuY2VzLnN3YXAoc2VxLCBpLCBsYXN0IC0gaSk7XG4gIH1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLnN3YXAgPSBmdW5jdGlvbiBzd2FwIChzZXEsIGksIGopIHtcbiAgaWYgKGkgPT09IGopIHsgcmV0dXJuIG51bGwgfVxuICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBzZXEuZ2V0RGltZW5zaW9uKCk7IGRpbSsrKSB7XG4gICAgdmFyIHRtcCA9IHNlcS5nZXRPcmRpbmF0ZShpLCBkaW0pO1xuICAgIHNlcS5zZXRPcmRpbmF0ZShpLCBkaW0sIHNlcS5nZXRPcmRpbmF0ZShqLCBkaW0pKTtcbiAgICBzZXEuc2V0T3JkaW5hdGUoaiwgZGltLCB0bXApO1xuICB9XG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5ID0gZnVuY3Rpb24gY29weSAoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5Q29vcmQoc3JjLCBzcmNQb3MgKyBpLCBkZXN0LCBkZXN0UG9zICsgaSk7XG4gIH1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBjcyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2l6ZSA9IGNzLnNpemUoKTtcbiAgICBpZiAoc2l6ZSA9PT0gMCkgeyByZXR1cm4gJygpJyB9XG4gICAgdmFyIGRpbSA9IGNzLmdldERpbWVuc2lvbigpO1xuICAgIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gICAgYnVmLmFwcGVuZCgnKCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHsgYnVmLmFwcGVuZCgnICcpOyB9XG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSB7XG4gICAgICAgIGlmIChkID4gMCkgeyBidWYuYXBwZW5kKCcsJyk7IH1cbiAgICAgICAgYnVmLmFwcGVuZChTdHJpbmdVdGlsLnRvU3RyaW5nKGNzLmdldE9yZGluYXRlKGksIGQpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1Zi5hcHBlbmQoJyknKTtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKClcbiAgfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuZW5zdXJlVmFsaWRSaW5nID0gZnVuY3Rpb24gZW5zdXJlVmFsaWRSaW5nIChmYWN0LCBzZXEpIHtcbiAgdmFyIG4gPSBzZXEuc2l6ZSgpO1xuICBpZiAobiA9PT0gMCkgeyByZXR1cm4gc2VxIH1cbiAgaWYgKG4gPD0gMykgeyByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlcy5jcmVhdGVDbG9zZWRSaW5nKGZhY3QsIHNlcSwgNCkgfVxuICB2YXIgaXNDbG9zZWQgPSBzZXEuZ2V0T3JkaW5hdGUoMCwgQ29vcmRpbmF0ZVNlcXVlbmNlLlgpID09PSBzZXEuZ2V0T3JkaW5hdGUobiAtIDEsIENvb3JkaW5hdGVTZXF1ZW5jZS5YKSAmJiBzZXEuZ2V0T3JkaW5hdGUoMCwgQ29vcmRpbmF0ZVNlcXVlbmNlLlkpID09PSBzZXEuZ2V0T3JkaW5hdGUobiAtIDEsIENvb3JkaW5hdGVTZXF1ZW5jZS5ZKTtcbiAgaWYgKGlzQ2xvc2VkKSB7IHJldHVybiBzZXEgfVxuICByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlcy5jcmVhdGVDbG9zZWRSaW5nKGZhY3QsIHNlcSwgbiArIDEpXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5jcmVhdGVDbG9zZWRSaW5nID0gZnVuY3Rpb24gY3JlYXRlQ2xvc2VkUmluZyAoZmFjdCwgc2VxLCBzaXplKSB7XG4gIHZhciBuZXdzZXEgPSBmYWN0LmNyZWF0ZShzaXplLCBzZXEuZ2V0RGltZW5zaW9uKCkpO1xuICB2YXIgbiA9IHNlcS5zaXplKCk7XG4gIENvb3JkaW5hdGVTZXF1ZW5jZXMuY29weShzZXEsIDAsIG5ld3NlcSwgMCwgbik7XG4gIGZvciAodmFyIGkgPSBuOyBpIDwgc2l6ZTsgaSsrKSB7IENvb3JkaW5hdGVTZXF1ZW5jZXMuY29weShzZXEsIDAsIG5ld3NlcSwgaSwgMSk7IH1cbiAgcmV0dXJuIG5ld3NlcVxufTtcblxudmFyIExpbmVTdHJpbmcgPSAoZnVuY3Rpb24gKEdlb21ldHJ5JCQxKSB7XG4gIGZ1bmN0aW9uIExpbmVTdHJpbmcgKHBvaW50cywgZmFjdG9yeSkge1xuICAgIEdlb21ldHJ5JCQxLmNhbGwodGhpcywgZmFjdG9yeSk7XG4gICAgdGhpcy5fcG9pbnRzID0gbnVsbDtcbiAgICB0aGlzLmluaXQocG9pbnRzKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnkkJDEgKSBMaW5lU3RyaW5nLl9fcHJvdG9fXyA9IEdlb21ldHJ5JCQxO1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5JCQxICYmIEdlb21ldHJ5JCQxLnByb3RvdHlwZSApO1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVTdHJpbmc7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGNvbXB1dGVFbnZlbG9wZUludGVybmFsICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBuZXcgRW52ZWxvcGUoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzLmV4cGFuZEVudmVsb3BlKG5ldyBFbnZlbG9wZSgpKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pc1JpbmcgPSBmdW5jdGlvbiBpc1JpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ2xvc2VkKCkgJiYgdGhpcy5pc1NpbXBsZSgpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5JCQxLlNPUlRJTkRFWF9MSU5FU1RSSU5HXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHMudG9Db29yZGluYXRlQXJyYXkoKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHZhciBvdGhlckxpbmVTdHJpbmcgPSBvdGhlcjtcbiAgICAgIGlmICh0aGlzLl9wb2ludHMuc2l6ZSgpICE9PSBvdGhlckxpbmVTdHJpbmcuX3BvaW50cy5zaXplKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BvaW50cy5zaXplKCk7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMkMS5lcXVhbCh0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpLCBvdGhlckxpbmVTdHJpbmcuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpLCB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5JCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC50cnVuYyh0aGlzLl9wb2ludHMuc2l6ZSgpIC8gMik7IGkrKykge1xuICAgICAgdmFyIGogPSB0aGlzJDEuX3BvaW50cy5zaXplKCkgLSAxIC0gaTtcbiAgICAgIGlmICghdGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKS5lcXVhbHModGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShqKSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSkuY29tcGFyZVRvKHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaikpID4gMCkge1xuICAgICAgICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMucmV2ZXJzZSh0aGlzJDEuX3BvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiB0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZSgwKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gICAgfVxuICAgIHJldHVybiAwXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGVOKDApLmVxdWFsczJEKHRoaXMuZ2V0Q29vcmRpbmF0ZU4odGhpcy5nZXROdW1Qb2ludHMoKSAtIDEpKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRFbmRQb2ludCA9IGZ1bmN0aW9uIGdldEVuZFBvaW50ICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBvaW50Tih0aGlzLmdldE51bVBvaW50cygpIC0gMSlcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiBDR0FsZ29yaXRobXMuY29tcHV0ZUxlbmd0aCh0aGlzLl9wb2ludHMpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy5zaXplKClcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciBzZXEgPSB0aGlzLl9wb2ludHMuY29weSgpO1xuICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMucmV2ZXJzZShzZXEpO1xuICAgIHZhciByZXZMaW5lID0gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhzZXEpO1xuICAgIHJldHVybiByZXZMaW5lXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNvbXBhcmVUb1NhbWVDbGFzcyA9IGZ1bmN0aW9uIGNvbXBhcmVUb1NhbWVDbGFzcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGluZSA9IG87XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB3aGlsZSAoaSA8IHRoaXMuX3BvaW50cy5zaXplKCkgJiYgaiA8IGxpbmUuX3BvaW50cy5zaXplKCkpIHtcbiAgICAgICAgdmFyIGNvbXBhcmlzb24gPSB0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpLmNvbXBhcmVUbyhsaW5lLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShqKSk7XG4gICAgICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBhcmlzb25cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgdGhpcy5fcG9pbnRzLnNpemUoKSkge1xuICAgICAgICByZXR1cm4gMVxuICAgICAgfVxuICAgICAgaWYgKGogPCBsaW5lLl9wb2ludHMuc2l6ZSgpKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY29tcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsaW5lJDEgPSBvJDE7XG4gICAgICByZXR1cm4gY29tcC5jb21wYXJlKHRoaXMuX3BvaW50cywgbGluZSQxLl9wb2ludHMpXG4gICAgfVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlRmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9pbnRzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgIGZpbHRlci5maWx0ZXIodGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLnNpemUoKSA9PT0gMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLl9wb2ludHMuc2l6ZSgpOyBpJDErKykge1xuICAgICAgICBmaWx0ZXIkMS5maWx0ZXIodGhpcyQxLl9wb2ludHMsIGkkMSk7XG4gICAgICAgIGlmIChmaWx0ZXIkMS5pc0RvbmUoKSkgeyBicmVhayB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyJDEuaXNHZW9tZXRyeUNoYW5nZWQoKSkgeyB0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpOyB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQyLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZmlsdGVyJDMuZmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGFyeU9wKHRoaXMpLmdldEJvdW5kYXJ5KClcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaXNFcXVpdmFsZW50Q2xhc3MgPSBmdW5jdGlvbiBpc0VxdWl2YWxlbnRDbGFzcyAob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBMaW5lU3RyaW5nXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBscyA9IEdlb21ldHJ5JCQxLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGxzLl9wb2ludHMgPSB0aGlzLl9wb2ludHMuY2xvbmUoKTtcbiAgICByZXR1cm4gbHNcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZU4gPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlTiAobikge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShuKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnTGluZVN0cmluZydcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgTGluZVN0cmluZyh0aGlzLl9wb2ludHMuY29weSgpLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlU2VxdWVuY2UgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlU2VxdWVuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHNcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHMuc2l6ZSgpID09PSAwXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChwb2ludHMpIHtcbiAgICBpZiAocG9pbnRzID09PSBudWxsKSB7XG4gICAgICBwb2ludHMgPSB0aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKTtcbiAgICB9XG4gICAgaWYgKHBvaW50cy5zaXplKCkgPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lU3RyaW5nIChmb3VuZCAnICsgcG9pbnRzLnNpemUoKSArICcgLSBtdXN0IGJlIDAgb3IgPj0gMiknKVxuICAgIH1cbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmlzQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGlzQ29vcmRpbmF0ZSAocHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9pbnRzLnNpemUoKTsgaSsrKSB7XG4gICAgICBpZiAodGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKS5lcXVhbHMocHQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRTdGFydFBvaW50ID0gZnVuY3Rpb24gZ2V0U3RhcnRQb2ludCAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludE4oMClcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0UG9pbnROID0gZnVuY3Rpb24gZ2V0UG9pbnROIChuKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKG4pKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW0xpbmVhbF1cbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIExpbmVTdHJpbmdcbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMzExMDY2OTgyODA2NTM2NTU2MCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaW5lU3RyaW5nLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTGluZVN0cmluZztcbn0oR2VvbWV0cnkpKTtcblxudmFyIFB1bnRhbCA9IGZ1bmN0aW9uIFB1bnRhbCAoKSB7fTtcblxuUHVudGFsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUHVudGFsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFB1bnRhbFxufTtcblxudmFyIFBvaW50ID0gKGZ1bmN0aW9uIChHZW9tZXRyeSQkMSkge1xuICBmdW5jdGlvbiBQb2ludCAoY29vcmRpbmF0ZXMsIGZhY3RvcnkpIHtcbiAgICBHZW9tZXRyeSQkMS5jYWxsKHRoaXMsIGZhY3RvcnkpO1xuICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXMgfHwgbnVsbDtcbiAgICB0aGlzLmluaXQodGhpcy5fY29vcmRpbmF0ZXMpO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeSQkMSApIFBvaW50Ll9fcHJvdG9fXyA9IEdlb21ldHJ5JCQxO1xuICBQb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeSQkMSAmJiBHZW9tZXRyeSQkMS5wcm90b3R5cGUgKTtcbiAgUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnQ7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBQb2ludC5wcm90b3R5cGUuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgPSBmdW5jdGlvbiBjb21wdXRlRW52ZWxvcGVJbnRlcm5hbCAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbmV3IEVudmVsb3BlKClcbiAgICB9XG4gICAgdmFyIGVudiA9IG5ldyBFbnZlbG9wZSgpO1xuICAgIGVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5fY29vcmRpbmF0ZXMuZ2V0WCgwKSwgdGhpcy5fY29vcmRpbmF0ZXMuZ2V0WSgwKSk7XG4gICAgcmV0dXJuIGVudlxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkkJDEuU09SVElOREVYX1BPSU5UXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyBbXSA6IFt0aGlzLmdldENvb3JkaW5hdGUoKV1cbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSAmJiBvdGhlci5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSAhPT0gb3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZXF1YWwob3RoZXIuZ2V0Q29vcmRpbmF0ZSgpLCB0aGlzLmdldENvb3JkaW5hdGUoKSwgdG9sZXJhbmNlKVxuICAgIH0gZWxzZSB7IHJldHVybiBHZW9tZXRyeSQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKCkge307XG4gIFBvaW50LnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKSAhPT0gMCA/IHRoaXMuX2Nvb3JkaW5hdGVzLmdldENvb3JkaW5hdGUoMCkgOiBudWxsXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAwXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXROdW1Qb2ludHMgPSBmdW5jdGlvbiBnZXROdW1Qb2ludHMgKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IDAgOiAxXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29weSgpXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCAoKSB7XG4gICAgaWYgKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFggY2FsbGVkIG9uIGVtcHR5IFBvaW50JylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnhcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmNvbXBhcmVUb1NhbWVDbGFzcyA9IGZ1bmN0aW9uIGNvbXBhcmVUb1NhbWVDbGFzcyAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwb2ludCQxID0gb3RoZXI7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHBvaW50JDEuZ2V0Q29vcmRpbmF0ZSgpKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY29tcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBwb2ludCA9IG90aGVyJDE7XG4gICAgICByZXR1cm4gY29tcC5jb21wYXJlKHRoaXMuX2Nvb3JkaW5hdGVzLCBwb2ludC5fY29vcmRpbmF0ZXMpXG4gICAgfVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBmaWx0ZXIuZmlsdGVyKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBmaWx0ZXIkMS5maWx0ZXIodGhpcy5fY29vcmRpbmF0ZXMsIDApO1xuICAgICAgaWYgKGZpbHRlciQxLmlzR2VvbWV0cnlDaGFuZ2VkKCkpIHsgdGhpcy5nZW9tZXRyeUNoYW5nZWQoKTsgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgR2VvbWV0cnlGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmaWx0ZXIkMi5maWx0ZXIodGhpcyk7XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUNvbXBvbmVudEZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQzLmZpbHRlcih0aGlzKTtcbiAgICB9XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgcCA9IEdlb21ldHJ5JCQxLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIHAuX2Nvb3JkaW5hdGVzID0gdGhpcy5fY29vcmRpbmF0ZXMuY2xvbmUoKTtcbiAgICByZXR1cm4gcFxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ1BvaW50J1xuICB9O1xuICBQb2ludC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5fY29vcmRpbmF0ZXMuY29weSgpLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZICgpIHtcbiAgICBpZiAodGhpcy5nZXRDb29yZGluYXRlKCkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0WSBjYWxsZWQgb24gZW1wdHkgUG9pbnQnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlcy5zaXplKCkgPT09IDBcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChjb29yZGluYXRlcykge1xuICAgIGlmIChjb29yZGluYXRlcyA9PT0gbnVsbCkge1xuICAgICAgY29vcmRpbmF0ZXMgPSB0aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKTtcbiAgICB9XG4gICAgQXNzZXJ0LmlzVHJ1ZShjb29yZGluYXRlcy5zaXplKCkgPD0gMSk7XG4gICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmlzU2ltcGxlID0gZnVuY3Rpb24gaXNTaW1wbGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW1B1bnRhbF1cbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBQb2ludFxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0OTAyMDIyNzAyNzQ2NjE0NTcwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBvaW50LCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gUG9pbnQ7XG59KEdlb21ldHJ5KSk7XG5cbnZhciBQb2x5Z29uYWwgPSBmdW5jdGlvbiBQb2x5Z29uYWwgKCkge307XG5cblBvbHlnb25hbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvbHlnb25hbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2x5Z29uYWxcbn07XG5cbnZhciBQb2x5Z29uID0gKGZ1bmN0aW9uIChHZW9tZXRyeSQkMSkge1xuICBmdW5jdGlvbiBQb2x5Z29uIChzaGVsbCwgaG9sZXMsIGZhY3RvcnkpIHtcbiAgICBHZW9tZXRyeSQkMS5jYWxsKHRoaXMsIGZhY3RvcnkpO1xuICAgIHRoaXMuX3NoZWxsID0gbnVsbDtcbiAgICB0aGlzLl9ob2xlcyA9IG51bGw7XG4gICAgaWYgKHNoZWxsID09PSBudWxsKSB7XG4gICAgICBzaGVsbCA9IHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGhvbGVzID09PSBudWxsKSB7XG4gICAgICBob2xlcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoR2VvbWV0cnkkJDEuaGFzTnVsbEVsZW1lbnRzKGhvbGVzKSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignaG9sZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzJylcbiAgICB9XG4gICAgaWYgKHNoZWxsLmlzRW1wdHkoKSAmJiBHZW9tZXRyeSQkMS5oYXNOb25FbXB0eUVsZW1lbnRzKGhvbGVzKSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignc2hlbGwgaXMgZW1wdHkgYnV0IGhvbGVzIGFyZSBub3QnKVxuICAgIH1cbiAgICB0aGlzLl9zaGVsbCA9IHNoZWxsO1xuICAgIHRoaXMuX2hvbGVzID0gaG9sZXM7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5JCQxICkgUG9seWdvbi5fX3Byb3RvX18gPSBHZW9tZXRyeSQkMTtcbiAgUG9seWdvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeSQkMSAmJiBHZW9tZXRyeSQkMS5wcm90b3R5cGUgKTtcbiAgUG9seWdvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5Z29uO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgPSBmdW5jdGlvbiBjb21wdXRlRW52ZWxvcGVJbnRlcm5hbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NoZWxsLmdldEVudmVsb3BlSW50ZXJuYWwoKVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeSQkMS5TT1JUSU5ERVhfUE9MWUdPTlxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIHZhciBjb29yZGluYXRlcyA9IG5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO1xuICAgIHZhciBrID0gLTE7XG4gICAgdmFyIHNoZWxsQ29vcmRpbmF0ZXMgPSB0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgc2hlbGxDb29yZGluYXRlcy5sZW5ndGg7IHgrKykge1xuICAgICAgaysrO1xuICAgICAgY29vcmRpbmF0ZXNba10gPSBzaGVsbENvb3JkaW5hdGVzW3hdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGRDb29yZGluYXRlcyA9IHRoaXMkMS5faG9sZXNbaV0uZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGRDb29yZGluYXRlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBrKys7XG4gICAgICAgIGNvb3JkaW5hdGVzW2tdID0gY2hpbGRDb29yZGluYXRlc1tqXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcmVhID0gMC4wO1xuICAgIGFyZWEgKz0gTWF0aC5hYnMoQ0dBbGdvcml0aG1zLnNpZ25lZEFyZWEodGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmVhIC09IE1hdGguYWJzKENHQWxnb3JpdGhtcy5zaWduZWRBcmVhKHRoaXMkMS5faG9sZXNbaV0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZWFcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuaXNSZWN0YW5nbGUgPSBmdW5jdGlvbiBpc1JlY3RhbmdsZSAoKSB7XG4gICAgaWYgKHRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCkgIT09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodGhpcy5fc2hlbGwgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodGhpcy5fc2hlbGwuZ2V0TnVtUG9pbnRzKCkgIT09IDUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgc2VxID0gdGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7XG4gICAgdmFyIGVudiA9IHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICB2YXIgeCA9IHNlcS5nZXRYKGkpO1xuICAgICAgaWYgKCEoeCA9PT0gZW52LmdldE1pblgoKSB8fCB4ID09PSBlbnYuZ2V0TWF4WCgpKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgdmFyIHkgPSBzZXEuZ2V0WShpKTtcbiAgICAgIGlmICghKHkgPT09IGVudi5nZXRNaW5ZKCkgfHwgeSA9PT0gZW52LmdldE1heFkoKSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgdmFyIHByZXZYID0gc2VxLmdldFgoMCk7XG4gICAgdmFyIHByZXZZID0gc2VxLmdldFkoMCk7XG4gICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDw9IDQ7IGkkMSsrKSB7XG4gICAgICB2YXIgeCQxID0gc2VxLmdldFgoaSQxKTtcbiAgICAgIHZhciB5JDEgPSBzZXEuZ2V0WShpJDEpO1xuICAgICAgdmFyIHhDaGFuZ2VkID0geCQxICE9PSBwcmV2WDtcbiAgICAgIHZhciB5Q2hhbmdlZCA9IHkkMSAhPT0gcHJldlk7XG4gICAgICBpZiAoeENoYW5nZWQgPT09IHlDaGFuZ2VkKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBwcmV2WCA9IHgkMTtcbiAgICAgIHByZXZZID0geSQxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHZhciBvdGhlclBvbHlnb24gPSBvdGhlcjtcbiAgICAgIHZhciB0aGlzU2hlbGwgPSB0aGlzLl9zaGVsbDtcbiAgICAgIHZhciBvdGhlclBvbHlnb25TaGVsbCA9IG90aGVyUG9seWdvbi5fc2hlbGw7XG4gICAgICBpZiAoIXRoaXNTaGVsbC5lcXVhbHNFeGFjdChvdGhlclBvbHlnb25TaGVsbCwgdG9sZXJhbmNlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9ob2xlcy5sZW5ndGggIT09IG90aGVyUG9seWdvbi5faG9sZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMkMS5faG9sZXNbaV0uZXF1YWxzRXhhY3Qob3RoZXJQb2x5Z29uLl9ob2xlc1tpXSwgdG9sZXJhbmNlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7IHJldHVybiBHZW9tZXRyeSQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5ub3JtYWxpemUodGhpcy5fc2hlbGwsIHRydWUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzJDEubm9ybWFsaXplKHRoaXMkMS5faG9sZXNbaV0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIEFycmF5cy5zb3J0KHRoaXMuX2hvbGVzKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciByaW5nID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNsb2Nrd2lzZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChyaW5nLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgdmFyIHVuaXF1ZUNvb3JkaW5hdGVzID0gbmV3IEFycmF5KHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGggLSAxKS5maWxsKG51bGwpO1xuICAgICAgU3lzdGVtLmFycmF5Y29weShyaW5nLmdldENvb3JkaW5hdGVzKCksIDAsIHVuaXF1ZUNvb3JkaW5hdGVzLCAwLCB1bmlxdWVDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgICAgdmFyIG1pbkNvb3JkaW5hdGUgPSBDb29yZGluYXRlQXJyYXlzLm1pbkNvb3JkaW5hdGUocmluZy5nZXRDb29yZGluYXRlcygpKTtcbiAgICAgIENvb3JkaW5hdGVBcnJheXMuc2Nyb2xsKHVuaXF1ZUNvb3JkaW5hdGVzLCBtaW5Db29yZGluYXRlKTtcbiAgICAgIFN5c3RlbS5hcnJheWNvcHkodW5pcXVlQ29vcmRpbmF0ZXMsIDAsIHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSwgMCwgdW5pcXVlQ29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICAgIHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKVt1bmlxdWVDb29yZGluYXRlcy5sZW5ndGhdID0gdW5pcXVlQ29vcmRpbmF0ZXNbMF07XG4gICAgICBpZiAoQ0dBbGdvcml0aG1zLmlzQ0NXKHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSkgPT09IGNsb2Nrd2lzZSkge1xuICAgICAgICBDb29yZGluYXRlQXJyYXlzLnJldmVyc2UocmluZy5nZXRDb29yZGluYXRlcygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZSgpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldE51bUludGVyaW9yUmluZyA9IGZ1bmN0aW9uIGdldE51bUludGVyaW9yUmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvbGVzLmxlbmd0aFxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAyXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbGVuID0gMC4wO1xuICAgIGxlbiArPSB0aGlzLl9zaGVsbC5nZXRMZW5ndGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW4gKz0gdGhpcyQxLl9ob2xlc1tpXS5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlblxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXROdW1Qb2ludHMgPSBmdW5jdGlvbiBnZXROdW1Qb2ludHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG51bVBvaW50cyA9IHRoaXMuX3NoZWxsLmdldE51bVBvaW50cygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG51bVBvaW50cyArPSB0aGlzJDEuX2hvbGVzW2ldLmdldE51bVBvaW50cygpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtUG9pbnRzXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwb2x5ID0gdGhpcy5jb3B5KCk7XG4gICAgcG9seS5fc2hlbGwgPSB0aGlzLl9zaGVsbC5jb3B5KCkucmV2ZXJzZSgpO1xuICAgIHBvbHkuX2hvbGVzID0gbmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb2x5Ll9ob2xlc1tpXSA9IHRoaXMkMS5faG9sZXNbaV0uY29weSgpLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuY29udmV4SHVsbCA9IGZ1bmN0aW9uIGNvbnZleEh1bGwgKCkge1xuICAgIHJldHVybiB0aGlzLmdldEV4dGVyaW9yUmluZygpLmNvbnZleEh1bGwoKVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb21wYXJlVG9TYW1lQ2xhc3MgPSBmdW5jdGlvbiBjb21wYXJlVG9TYW1lQ2xhc3MgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBvID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRoaXNTaGVsbCA9IHRoaXMuX3NoZWxsO1xuICAgICAgdmFyIG90aGVyU2hlbGwgPSBvLl9zaGVsbDtcbiAgICAgIHJldHVybiB0aGlzU2hlbGwuY29tcGFyZVRvU2FtZUNsYXNzKG90aGVyU2hlbGwpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvbXAgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgcG9seSA9IG8kMTtcbiAgICAgIHZhciB0aGlzU2hlbGwkMSA9IHRoaXMuX3NoZWxsO1xuICAgICAgdmFyIG90aGVyU2hlbGwkMSA9IHBvbHkuX3NoZWxsO1xuICAgICAgdmFyIHNoZWxsQ29tcCA9IHRoaXNTaGVsbCQxLmNvbXBhcmVUb1NhbWVDbGFzcyhvdGhlclNoZWxsJDEsIGNvbXApO1xuICAgICAgaWYgKHNoZWxsQ29tcCAhPT0gMCkgeyByZXR1cm4gc2hlbGxDb21wIH1cbiAgICAgIHZhciBuSG9sZTEgPSB0aGlzLmdldE51bUludGVyaW9yUmluZygpO1xuICAgICAgdmFyIG5Ib2xlMiA9IHBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IG5Ib2xlMSAmJiBpIDwgbkhvbGUyKSB7XG4gICAgICAgIHZhciB0aGlzSG9sZSA9IHRoaXMkMS5nZXRJbnRlcmlvclJpbmdOKGkpO1xuICAgICAgICB2YXIgb3RoZXJIb2xlID0gcG9seS5nZXRJbnRlcmlvclJpbmdOKGkpO1xuICAgICAgICB2YXIgaG9sZUNvbXAgPSB0aGlzSG9sZS5jb21wYXJlVG9TYW1lQ2xhc3Mob3RoZXJIb2xlLCBjb21wKTtcbiAgICAgICAgaWYgKGhvbGVDb21wICE9PSAwKSB7IHJldHVybiBob2xlQ29tcCB9XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgbkhvbGUxKSB7IHJldHVybiAxIH1cbiAgICAgIGlmIChpIDwgbkhvbGUyKSB7IHJldHVybiAtMSB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoZmlsdGVyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoaGFzSW50ZXJmYWNlKGZpbHRlciwgQ29vcmRpbmF0ZUZpbHRlcikpIHtcbiAgICAgIHRoaXMuX3NoZWxsLmFwcGx5KGZpbHRlcik7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHRoaXMkMS5faG9sZXNbaSQxXS5hcHBseShmaWx0ZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGZpbHRlciwgQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyKSkge1xuICAgICAgdGhpcy5fc2hlbGwuYXBwbHkoZmlsdGVyKTtcbiAgICAgIGlmICghZmlsdGVyLmlzRG9uZSgpKSB7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICB0aGlzJDEuX2hvbGVzW2kkMl0uYXBwbHkoZmlsdGVyKTtcbiAgICAgICAgICBpZiAoZmlsdGVyLmlzRG9uZSgpKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbHRlci5pc0dlb21ldHJ5Q2hhbmdlZCgpKSB7IHRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCk7IH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShmaWx0ZXIsIEdlb21ldHJ5RmlsdGVyKSkge1xuICAgICAgZmlsdGVyLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShmaWx0ZXIsIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyKSkge1xuICAgICAgZmlsdGVyLmZpbHRlcih0aGlzKTtcbiAgICAgIHRoaXMuX3NoZWxsLmFwcGx5KGZpbHRlcik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS5faG9sZXNbaV0uYXBwbHkoZmlsdGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKClcbiAgICB9XG4gICAgdmFyIHJpbmdzID0gbmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCArIDEpLmZpbGwobnVsbCk7XG4gICAgcmluZ3NbMF0gPSB0aGlzLl9zaGVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByaW5nc1tpICsgMV0gPSB0aGlzJDEuX2hvbGVzW2ldO1xuICAgIH1cbiAgICBpZiAocmluZ3MubGVuZ3RoIDw9IDEpIHsgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcocmluZ3NbMF0uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHJpbmdzKVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwb2x5ID0gR2VvbWV0cnkkJDEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgcG9seS5fc2hlbGwgPSB0aGlzLl9zaGVsbC5jbG9uZSgpO1xuICAgIHBvbHkuX2hvbGVzID0gbmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb2x5Ll9ob2xlc1tpXSA9IHRoaXMkMS5faG9sZXNbaV0uY2xvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvbHlcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ1BvbHlnb24nXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzaGVsbCA9IHRoaXMuX3NoZWxsLmNvcHkoKTtcbiAgICB2YXIgaG9sZXMgPSBuZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhvbGVzW2ldID0gdGhpcyQxLl9ob2xlc1tpXS5jb3B5KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUG9seWdvbihzaGVsbCwgaG9sZXMsIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEV4dGVyaW9yUmluZyA9IGZ1bmN0aW9uIGdldEV4dGVyaW9yUmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NoZWxsXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hlbGwuaXNFbXB0eSgpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEludGVyaW9yUmluZ04gPSBmdW5jdGlvbiBnZXRJbnRlcmlvclJpbmdOIChuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hvbGVzW25dXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbUG9seWdvbmFsXVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gUG9seWdvblxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMzQ5NDc5MjIwMDgyMTc2NDUzMyB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQb2x5Z29uLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gUG9seWdvbjtcbn0oR2VvbWV0cnkpKTtcblxudmFyIE11bHRpUG9pbnQgPSAoZnVuY3Rpb24gKEdlb21ldHJ5Q29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBNdWx0aVBvaW50ICgpIHtcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb24kJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnlDb2xsZWN0aW9uJCQxICkgTXVsdGlQb2ludC5fX3Byb3RvX18gPSBHZW9tZXRyeUNvbGxlY3Rpb24kJDE7XG4gIE11bHRpUG9pbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnlDb2xsZWN0aW9uJCQxICYmIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aVBvaW50O1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeS5TT1JUSU5ERVhfTVVMVElQT0lOVFxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLCBvdGhlciwgdG9sZXJhbmNlKVxuICAgIH0gZWxzZSB7IHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbbl0uZ2V0Q29vcmRpbmF0ZSgpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIERpbWVuc2lvbi5GQUxTRVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAwXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbClcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ011bHRpUG9pbnQnXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwb2ludHMgPSBuZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvaW50c1tpXSA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5jb3B5KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTXVsdGlQb2ludChwb2ludHMsIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbUHVudGFsXVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTXVsdGlQb2ludFxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtODA0ODQ3NDg3NDE3NTM1NTQ0OSB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNdWx0aVBvaW50LCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTXVsdGlQb2ludDtcbn0oR2VvbWV0cnlDb2xsZWN0aW9uKSk7XG5cbnZhciBMaW5lYXJSaW5nID0gKGZ1bmN0aW9uIChMaW5lU3RyaW5nJCQxKSB7XG4gIGZ1bmN0aW9uIExpbmVhclJpbmcgKHBvaW50cywgZmFjdG9yeSkge1xuICAgIGlmIChwb2ludHMgaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGZhY3RvcnkgaW5zdGFuY2VvZiBHZW9tZXRyeUZhY3RvcnkpIHtcbiAgICAgIHBvaW50cyA9IGZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShwb2ludHMpO1xuICAgIH1cbiAgICBMaW5lU3RyaW5nJCQxLmNhbGwodGhpcywgcG9pbnRzLCBmYWN0b3J5KTtcbiAgICB0aGlzLnZhbGlkYXRlQ29uc3RydWN0aW9uKCk7XG4gIH1cblxuICBpZiAoIExpbmVTdHJpbmckJDEgKSBMaW5lYXJSaW5nLl9fcHJvdG9fXyA9IExpbmVTdHJpbmckJDE7XG4gIExpbmVhclJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVN0cmluZyQkMSAmJiBMaW5lU3RyaW5nJCQxLnByb3RvdHlwZSApO1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVhclJpbmc7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgTUlOSU1VTV9WQUxJRF9TSVpFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkuU09SVElOREVYX0xJTkVBUlJJTkdcbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIERpbWVuc2lvbi5GQUxTRVxuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBMaW5lU3RyaW5nJCQxLnByb3RvdHlwZS5pc0Nsb3NlZC5jYWxsKHRoaXMpXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICB2YXIgc2VxID0gdGhpcy5fcG9pbnRzLmNvcHkoKTtcbiAgICBDb29yZGluYXRlU2VxdWVuY2VzLnJldmVyc2Uoc2VxKTtcbiAgICB2YXIgcmV2ID0gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhzZXEpO1xuICAgIHJldHVybiByZXZcbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUudmFsaWRhdGVDb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cnVjdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSAmJiAhTGluZVN0cmluZyQkMS5wcm90b3R5cGUuaXNDbG9zZWQuY2FsbCh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUG9pbnRzIG9mIExpbmVhclJpbmcgZG8gbm90IGZvcm0gYSBjbG9zZWQgbGluZXN0cmluZycpXG4gICAgfVxuICAgIGlmICh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKSA+PSAxICYmIHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpIDwgTGluZWFyUmluZy5NSU5JTVVNX1ZBTElEX1NJWkUpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lYXJSaW5nIChmb3VuZCAnICsgdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkgKyAnIC0gbXVzdCBiZSAwIG9yID49IDQpJylcbiAgICB9XG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdMaW5lYXJSaW5nJ1xuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKHRoaXMuX3BvaW50cy5jb3B5KCksIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTGluZWFyUmluZ1xuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuTUlOSU1VTV9WQUxJRF9TSVpFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTQyNjExNDIwODQwODU4NTE4MjkgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGluZWFyUmluZywgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIExpbmVhclJpbmc7XG59KExpbmVTdHJpbmcpKTtcblxudmFyIE11bHRpUG9seWdvbiA9IChmdW5jdGlvbiAoR2VvbWV0cnlDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIE11bHRpUG9seWdvbiAoKSB7XG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uJCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5Q29sbGVjdGlvbiQkMSApIE11bHRpUG9seWdvbi5fX3Byb3RvX18gPSBHZW9tZXRyeUNvbGxlY3Rpb24kJDE7XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeUNvbGxlY3Rpb24kJDEgJiYgR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlQb2x5Z29uO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5LlNPUlRJTkRFWF9NVUxUSVBPTFlHT05cbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICghdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyhvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsIG90aGVyLCB0b2xlcmFuY2UpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAyXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG4gPSB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB2YXIgcmV2R2VvbXMgPSBuZXcgQXJyYXkobikuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldkdlb21zW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihyZXZHZW9tcylcbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpXG4gICAgfVxuICAgIHZhciBhbGxSaW5ncyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb2x5Z29uID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIHJpbmdzID0gcG9seWdvbi5nZXRCb3VuZGFyeSgpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5ncy5nZXROdW1HZW9tZXRyaWVzKCk7IGorKykge1xuICAgICAgICBhbGxSaW5ncy5hZGQocmluZ3MuZ2V0R2VvbWV0cnlOKGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFsbFJpbmdzQXJyYXkgPSBuZXcgQXJyYXkoYWxsUmluZ3Muc2l6ZSgpKS5maWxsKG51bGwpO1xuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoYWxsUmluZ3MudG9BcnJheShhbGxSaW5nc0FycmF5KSlcbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnTXVsdGlQb2x5Z29uJ1xuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwb2x5Z29ucyA9IG5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb2x5Z29uc1tpXSA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5jb3B5KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTXVsdGlQb2x5Z29uKHBvbHlnb25zLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbUG9seWdvbmFsXVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBNdWx0aVBvbHlnb25cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTU1MTAzMzUyOTc2Njk3NTg3NSB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNdWx0aVBvbHlnb24sIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBNdWx0aVBvbHlnb247XG59KEdlb21ldHJ5Q29sbGVjdGlvbikpO1xuXG52YXIgR2VvbWV0cnlFZGl0b3IgPSBmdW5jdGlvbiBHZW9tZXRyeUVkaXRvciAoZmFjdG9yeSkge1xuICB0aGlzLl9mYWN0b3J5ID0gZmFjdG9yeSB8fCBudWxsO1xuICB0aGlzLl9pc1VzZXJEYXRhQ29waWVkID0gZmFsc2U7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDE2ID0geyBOb09wR2VvbWV0cnlPcGVyYXRpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ29vcmRpbmF0ZU9wZXJhdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxDb29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkdlb21ldHJ5RWRpdG9yLnByb3RvdHlwZS5zZXRDb3B5VXNlckRhdGEgPSBmdW5jdGlvbiBzZXRDb3B5VXNlckRhdGEgKGlzVXNlckRhdGFDb3BpZWQpIHtcbiAgdGhpcy5faXNVc2VyRGF0YUNvcGllZCA9IGlzVXNlckRhdGFDb3BpZWQ7XG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmVkaXQgPSBmdW5jdGlvbiBlZGl0IChnZW9tZXRyeSwgb3BlcmF0aW9uKSB7XG4gIGlmIChnZW9tZXRyeSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciByZXN1bHQgPSB0aGlzLmVkaXRJbnRlcm5hbChnZW9tZXRyeSwgb3BlcmF0aW9uKTtcbiAgaWYgKHRoaXMuX2lzVXNlckRhdGFDb3BpZWQpIHtcbiAgICByZXN1bHQuc2V0VXNlckRhdGEoZ2VvbWV0cnkuZ2V0VXNlckRhdGEoKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcbkdlb21ldHJ5RWRpdG9yLnByb3RvdHlwZS5lZGl0SW50ZXJuYWwgPSBmdW5jdGlvbiBlZGl0SW50ZXJuYWwgKGdlb21ldHJ5LCBvcGVyYXRpb24pIHtcbiAgaWYgKHRoaXMuX2ZhY3RvcnkgPT09IG51bGwpIHsgdGhpcy5fZmFjdG9yeSA9IGdlb21ldHJ5LmdldEZhY3RvcnkoKTsgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0R2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJ5LCBvcGVyYXRpb24pXG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHJldHVybiB0aGlzLmVkaXRQb2x5Z29uKGdlb21ldHJ5LCBvcGVyYXRpb24pXG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICByZXR1cm4gb3BlcmF0aW9uLmVkaXQoZ2VvbWV0cnksIHRoaXMuX2ZhY3RvcnkpXG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgIHJldHVybiBvcGVyYXRpb24uZWRpdChnZW9tZXRyeSwgdGhpcy5fZmFjdG9yeSlcbiAgfVxuICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoJ1Vuc3VwcG9ydGVkIEdlb21ldHJ5IGNsYXNzOiAnICsgZ2VvbWV0cnkuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO1xuICByZXR1cm4gbnVsbFxufTtcbkdlb21ldHJ5RWRpdG9yLnByb3RvdHlwZS5lZGl0R2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gZWRpdEdlb21ldHJ5Q29sbGVjdGlvbiAoY29sbGVjdGlvbiwgb3BlcmF0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvbGxlY3Rpb25Gb3JUeXBlID0gb3BlcmF0aW9uLmVkaXQoY29sbGVjdGlvbiwgdGhpcy5fZmFjdG9yeSk7XG4gIHZhciBnZW9tZXRyaWVzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb25Gb3JUeXBlLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcyQxLmVkaXQoY29sbGVjdGlvbkZvclR5cGUuZ2V0R2VvbWV0cnlOKGkpLCBvcGVyYXRpb24pO1xuICAgIGlmIChnZW9tZXRyeSA9PT0gbnVsbCB8fCBnZW9tZXRyeS5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGdlb21ldHJpZXMuYWRkKGdlb21ldHJ5KTtcbiAgfVxuICBpZiAoY29sbGVjdGlvbkZvclR5cGUuZ2V0Q2xhc3MoKSA9PT0gTXVsdGlQb2ludCkge1xuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZ2VvbWV0cmllcy50b0FycmF5KFtdKSlcbiAgfVxuICBpZiAoY29sbGVjdGlvbkZvclR5cGUuZ2V0Q2xhc3MoKSA9PT0gTXVsdGlMaW5lU3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGdlb21ldHJpZXMudG9BcnJheShbXSkpXG4gIH1cbiAgaWYgKGNvbGxlY3Rpb25Gb3JUeXBlLmdldENsYXNzKCkgPT09IE11bHRpUG9seWdvbikge1xuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihnZW9tZXRyaWVzLnRvQXJyYXkoW10pKVxuICB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLnRvQXJyYXkoW10pKVxufTtcbkdlb21ldHJ5RWRpdG9yLnByb3RvdHlwZS5lZGl0UG9seWdvbiA9IGZ1bmN0aW9uIGVkaXRQb2x5Z29uIChwb2x5Z29uLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbmV3UG9seWdvbiA9IG9wZXJhdGlvbi5lZGl0KHBvbHlnb24sIHRoaXMuX2ZhY3RvcnkpO1xuICBpZiAobmV3UG9seWdvbiA9PT0gbnVsbCkgeyBuZXdQb2x5Z29uID0gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKG51bGwpOyB9XG4gIGlmIChuZXdQb2x5Z29uLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiBuZXdQb2x5Z29uXG4gIH1cbiAgdmFyIHNoZWxsID0gdGhpcy5lZGl0KG5ld1BvbHlnb24uZ2V0RXh0ZXJpb3JSaW5nKCksIG9wZXJhdGlvbik7XG4gIGlmIChzaGVsbCA9PT0gbnVsbCB8fCBzaGVsbC5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKClcbiAgfVxuICB2YXIgaG9sZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UG9seWdvbi5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgdmFyIGhvbGUgPSB0aGlzJDEuZWRpdChuZXdQb2x5Z29uLmdldEludGVyaW9yUmluZ04oaSksIG9wZXJhdGlvbik7XG4gICAgaWYgKGhvbGUgPT09IG51bGwgfHwgaG9sZS5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGhvbGVzLmFkZChob2xlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHNoZWxsLCBob2xlcy50b0FycmF5KFtdKSlcbn07XG5HZW9tZXRyeUVkaXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5RWRpdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5RWRpdG9yXG59O1xuR2VvbWV0cnlFZGl0b3IuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb24gPSBmdW5jdGlvbiBHZW9tZXRyeUVkaXRvck9wZXJhdGlvbiAoKSB7fTtcbnN0YXRpY0FjY2Vzc29ycyQxNi5Ob09wR2VvbWV0cnlPcGVyYXRpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTm9PcEdlb21ldHJ5T3BlcmF0aW9uIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTYuQ29vcmRpbmF0ZU9wZXJhdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDb29yZGluYXRlT3BlcmF0aW9uIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTYuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggR2VvbWV0cnlFZGl0b3IsIHN0YXRpY0FjY2Vzc29ycyQxNiApO1xuXG52YXIgTm9PcEdlb21ldHJ5T3BlcmF0aW9uID0gZnVuY3Rpb24gTm9PcEdlb21ldHJ5T3BlcmF0aW9uICgpIHt9O1xuXG5Ob09wR2VvbWV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmVkaXQgPSBmdW5jdGlvbiBlZGl0IChnZW9tZXRyeSwgZmFjdG9yeSkge1xuICByZXR1cm4gZ2VvbWV0cnlcbn07XG5Ob09wR2VvbWV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5RWRpdG9yLkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uXVxufTtcbk5vT3BHZW9tZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOb09wR2VvbWV0cnlPcGVyYXRpb25cbn07XG5cbnZhciBDb29yZGluYXRlT3BlcmF0aW9uID0gZnVuY3Rpb24gQ29vcmRpbmF0ZU9wZXJhdGlvbiAoKSB7fTtcblxuQ29vcmRpbmF0ZU9wZXJhdGlvbi5wcm90b3R5cGUuZWRpdCA9IGZ1bmN0aW9uIGVkaXQgKGdlb21ldHJ5LCBmYWN0b3J5KSB7XG4gIHZhciBjb29yZHMgPSB0aGlzLmVkaXRDb29yZGluYXRlcyhnZW9tZXRyeS5nZXRDb29yZGluYXRlcygpLCBnZW9tZXRyeSk7XG4gIGlmIChjb29yZHMgPT09IG51bGwpIHsgcmV0dXJuIGdlb21ldHJ5IH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGluZWFyUmluZykge1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoY29vcmRzKVxuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGNvb3JkcylcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgIGlmIChjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUG9pbnQoY29vcmRzWzBdKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQb2ludCgpXG4gICAgfVxuICB9XG4gIHJldHVybiBnZW9tZXRyeVxufTtcbkNvb3JkaW5hdGVPcGVyYXRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5RWRpdG9yLkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uXVxufTtcbkNvb3JkaW5hdGVPcGVyYXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZU9wZXJhdGlvblxufTtcblxudmFyIENvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbiA9IGZ1bmN0aW9uIENvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbiAoKSB7fTtcblxuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uLnByb3RvdHlwZS5lZGl0ID0gZnVuY3Rpb24gZWRpdCAoZ2VvbWV0cnksIGZhY3RvcnkpIHtcbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGluZWFyUmluZykge1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodGhpcy5lZGl0KGdlb21ldHJ5LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLCBnZW9tZXRyeSkpXG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5lZGl0KGdlb21ldHJ5LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLCBnZW9tZXRyeSkpXG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLmVkaXQoZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb21ldHJ5KSlcbiAgfVxuICByZXR1cm4gZ2VvbWV0cnlcbn07XG5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5RWRpdG9yLkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uXVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb25cbn07XG5cbnZhciBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZSA9IGZ1bmN0aW9uIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlICgpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fZGltZW5zaW9uID0gMztcbiAgdGhpcy5fY29vcmRpbmF0ZXMgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9kaW1lbnNpb24gPSAzO1xuICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKSB7XG4gICAgICB2YXIgc2l6ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KHNpemUpLmZpbGwobnVsbCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICB0aGlzJDEuX2Nvb3JkaW5hdGVzW2ldID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZFNlcSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmIChjb29yZFNlcSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jb29yZGluYXRlcyA9IG5ldyBBcnJheSgwKS5maWxsKG51bGwpO1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgdGhpcy5fZGltZW5zaW9uID0gY29vcmRTZXEuZ2V0RGltZW5zaW9uKCk7XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IG5ldyBBcnJheShjb29yZFNlcS5zaXplKCkpLmZpbGwobnVsbCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHRoaXMkMS5fY29vcmRpbmF0ZXNbaSQxXSA9IGNvb3JkU2VxLmdldENvb3JkaW5hdGVDb3B5KGkkMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGltZW5zaW9uID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcbiAgICAgIHRoaXMuX2RpbWVuc2lvbiA9IGRpbWVuc2lvbjtcbiAgICAgIGlmIChjb29yZGluYXRlcyA9PT0gbnVsbCkgeyB0aGlzLl9jb29yZGluYXRlcyA9IG5ldyBBcnJheSgwKS5maWxsKG51bGwpOyB9XG4gICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkgJiYgTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKSB7XG4gICAgICB2YXIgc2l6ZSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRpbWVuc2lvbiQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoc2l6ZSQxKS5maWxsKG51bGwpO1xuICAgICAgdGhpcy5fZGltZW5zaW9uID0gZGltZW5zaW9uJDE7XG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBzaXplJDE7IGkkMisrKSB7XG4gICAgICAgIHRoaXMkMS5fY29vcmRpbmF0ZXNbaSQyXSA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDE4ID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuc2V0T3JkaW5hdGUgPSBmdW5jdGlvbiBzZXRPcmRpbmF0ZSAoaW5kZXgsIG9yZGluYXRlSW5kZXgsIHZhbHVlKSB7XG4gIHN3aXRjaCAob3JkaW5hdGVJbmRleCkge1xuICAgIGNhc2UgQ29vcmRpbmF0ZVNlcXVlbmNlLlg6XG4gICAgICB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueCA9IHZhbHVlO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIENvb3JkaW5hdGVTZXF1ZW5jZS5ZOlxuICAgICAgdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnkgPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBDb29yZGluYXRlU2VxdWVuY2UuWjpcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS56ID0gdmFsdWU7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdpbnZhbGlkIG9yZGluYXRlSW5kZXgnKVxuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aFxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXRPcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldE9yZGluYXRlIChpbmRleCwgb3JkaW5hdGVJbmRleCkge1xuICBzd2l0Y2ggKG9yZGluYXRlSW5kZXgpIHtcbiAgICBjYXNlIENvb3JkaW5hdGVTZXF1ZW5jZS5YOlxuICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS54XG4gICAgY2FzZSBDb29yZGluYXRlU2VxdWVuY2UuWTpcbiAgICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueVxuICAgIGNhc2UgQ29vcmRpbmF0ZVNlcXVlbmNlLlo6XG4gICAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnpcbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiBEb3VibGUuTmFOXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgaSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbaV1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1sxXTtcbiAgICBjb29yZC54ID0gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLng7XG4gICAgY29vcmQueSA9IHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS55O1xuICAgIGNvb3JkLnogPSB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0uejtcbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlQ29weSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVDb3B5IChpKSB7XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9jb29yZGluYXRlc1tpXSlcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RpbWVuc2lvblxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS54XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjbG9uZUNvb3JkaW5hdGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2xvbmVDb29yZGluYXRlc1tpXSA9IHRoaXMkMS5fY29vcmRpbmF0ZXNbaV0uY2xvbmUoKTtcbiAgfVxuICByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKGNsb25lQ29vcmRpbmF0ZXMsIHRoaXMuX2RpbWVuc2lvbilcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZXhwYW5kRW52ZWxvcGUgPSBmdW5jdGlvbiBleHBhbmRFbnZlbG9wZSAoZW52KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGVudi5leHBhbmRUb0luY2x1ZGUodGhpcyQxLl9jb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGVudlxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNsb25lQ29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjbG9uZUNvb3JkaW5hdGVzW2ldID0gdGhpcyQxLl9jb29yZGluYXRlc1tpXS5jb3B5KCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZShjbG9uZUNvb3JkaW5hdGVzLCB0aGlzLl9kaW1lbnNpb24pXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLl9jb29yZGluYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHN0ckJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoMTcgKiB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHN0ckJ1Zi5hcHBlbmQoJygnKTtcbiAgICBzdHJCdWYuYXBwZW5kKHRoaXMuX2Nvb3JkaW5hdGVzWzBdKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdHJCdWYuYXBwZW5kKCcsICcpO1xuICAgICAgc3RyQnVmLmFwcGVuZCh0aGlzJDEuX2Nvb3JkaW5hdGVzW2ldKTtcbiAgICB9XG4gICAgc3RyQnVmLmFwcGVuZCgnKScpO1xuICAgIHJldHVybiBzdHJCdWYudG9TdHJpbmcoKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAnKCknXG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkgKGluZGV4KSB7XG4gIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS50b0Nvb3JkaW5hdGVBcnJheSA9IGZ1bmN0aW9uIHRvQ29vcmRpbmF0ZUFycmF5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nvb3JkaW5hdGVTZXF1ZW5jZSwgU2VyaWFsaXphYmxlXVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlXG59O1xuc3RhdGljQWNjZXNzb3JzJDE4LnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTkxNTQzODUwMTYwMTg0MDY1MCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UsIHN0YXRpY0FjY2Vzc29ycyQxOCApO1xuXG52YXIgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5ID0gZnVuY3Rpb24gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5ICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDE3ID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGluc3RhbmNlT2JqZWN0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUucmVhZFJlc29sdmUgPSBmdW5jdGlvbiByZWFkUmVzb2x2ZSAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkuaW5zdGFuY2UoKVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UoY29vcmRpbmF0ZXMpXG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgICB2YXIgY29vcmRTZXEgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKGNvb3JkU2VxKVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHNpemUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGRpbWVuc2lvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZGltZW5zaW9uID4gMykgeyBkaW1lbnNpb24gPSAzOyB9XG4gICAgaWYgKGRpbWVuc2lvbiA8IDIpIHsgcmV0dXJuIG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZShzaXplKSB9XG4gICAgcmV0dXJuIG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZShzaXplLCBkaW1lbnNpb24pXG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnksIFNlcmlhbGl6YWJsZV1cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5Lmluc3RhbmNlID0gZnVuY3Rpb24gaW5zdGFuY2UgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5Lmluc3RhbmNlT2JqZWN0XG59O1xuXG5zdGF0aWNBY2Nlc3NvcnMkMTcuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNDA5OTU3NzA5OTYwNzU1MTY1NyB9O1xuc3RhdGljQWNjZXNzb3JzJDE3Lmluc3RhbmNlT2JqZWN0LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkoKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5LCBzdGF0aWNBY2Nlc3NvcnMkMTcgKTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9IYXNoTWFwLmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7amF2YXNjcmlwdC51dGlsLk1hcH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEhhc2hNYXAgPSAoZnVuY3Rpb24gKE1hcEludGVyZmFjZSkge1xuICBmdW5jdGlvbiBIYXNoTWFwICgpIHtcbiAgICBNYXBJbnRlcmZhY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1hcF8gPSBuZXcgTWFwKCk7XG4gIH1cblxuICBpZiAoIE1hcEludGVyZmFjZSApIEhhc2hNYXAuX19wcm90b19fID0gTWFwSW50ZXJmYWNlO1xuICBIYXNoTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcEludGVyZmFjZSAmJiBNYXBJbnRlcmZhY2UucHJvdG90eXBlICk7XG4gIEhhc2hNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaE1hcDtcbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfLmdldChrZXkpIHx8IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiBwdXQgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcF8uc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcyAoKSB7XG4gICAgdmFyIGFycmF5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB2YXIgaXQgPSB0aGlzLm1hcF8udmFsdWVzKCk7XG4gICAgdmFyIG8gPSBpdC5uZXh0KCk7XG4gICAgd2hpbGUgKCFvLmRvbmUpIHtcbiAgICAgIGFycmF5TGlzdC5hZGQoby52YWx1ZSk7XG4gICAgICBvID0gaXQubmV4dCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlMaXN0XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaE1hcC5wcm90b3R5cGUuZW50cnlTZXQgPSBmdW5jdGlvbiBlbnRyeVNldCAoKSB7XG4gICAgdmFyIGhhc2hTZXQgPSBuZXcgSGFzaFNldCgpO1xuICAgIHRoaXMubWFwXy5lbnRyaWVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGhhc2hTZXQuYWRkKGVudHJ5KTsgfSk7XG4gICAgcmV0dXJuIGhhc2hTZXRcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoTWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXy5zaXplKClcbiAgfTtcblxuICByZXR1cm4gSGFzaE1hcDtcbn0oTWFwJDEpKTtcblxudmFyIFByZWNpc2lvbk1vZGVsID0gZnVuY3Rpb24gUHJlY2lzaW9uTW9kZWwgKCkge1xuICB0aGlzLl9tb2RlbFR5cGUgPSBudWxsO1xuICB0aGlzLl9zY2FsZSA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fbW9kZWxUeXBlID0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkc7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICB2YXIgbW9kZWxUeXBlID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5fbW9kZWxUeXBlID0gbW9kZWxUeXBlO1xuICAgICAgaWYgKG1vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRklYRUQpIHtcbiAgICAgICAgdGhpcy5zZXRTY2FsZSgxLjApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBzY2FsZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX21vZGVsVHlwZSA9IFByZWNpc2lvbk1vZGVsLkZJWEVEO1xuICAgICAgdGhpcy5zZXRTY2FsZShzY2FsZSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBQcmVjaXNpb25Nb2RlbCkge1xuICAgICAgdmFyIHBtID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5fbW9kZWxUeXBlID0gcG0uX21vZGVsVHlwZTtcbiAgICAgIHRoaXMuX3NjYWxlID0gcG0uX3NjYWxlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxOSA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSxtYXhpbXVtUHJlY2lzZVZhbHVlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFByZWNpc2lvbk1vZGVsKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBvdGhlclByZWNpc2lvbk1vZGVsID0gb3RoZXI7XG4gIHJldHVybiB0aGlzLl9tb2RlbFR5cGUgPT09IG90aGVyUHJlY2lzaW9uTW9kZWwuX21vZGVsVHlwZSAmJiB0aGlzLl9zY2FsZSA9PT0gb3RoZXJQcmVjaXNpb25Nb2RlbC5fc2NhbGVcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBvdGhlciA9IG87XG4gIHZhciBzaWdEaWdpdHMgPSB0aGlzLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpO1xuICB2YXIgb3RoZXJTaWdEaWdpdHMgPSBvdGhlci5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKTtcbiAgcmV0dXJuIG5ldyBJbnRlZ2VyKHNpZ0RpZ2l0cykuY29tcGFyZVRvKG5ldyBJbnRlZ2VyKG90aGVyU2lnRGlnaXRzKSlcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZSAoKSB7XG4gIHJldHVybiB0aGlzLl9zY2FsZVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5pc0Zsb2F0aW5nID0gZnVuY3Rpb24gaXNGbG9hdGluZyAoKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HIHx8IHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkdfU0lOR0xFXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlICgpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGVsVHlwZVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGRlc2NyaXB0aW9uID0gJ1VOS05PV04nO1xuICBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElORykge1xuICAgIGRlc2NyaXB0aW9uID0gJ0Zsb2F0aW5nJztcbiAgfSBlbHNlIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HX1NJTkdMRSkge1xuICAgIGRlc2NyaXB0aW9uID0gJ0Zsb2F0aW5nLVNpbmdsZSc7XG4gIH0gZWxzZSBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgIGRlc2NyaXB0aW9uID0gJ0ZpeGVkIChTY2FsZT0nICsgdGhpcy5nZXRTY2FsZSgpICsgJyknO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdGlvblxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5tYWtlUHJlY2lzZSA9IGZ1bmN0aW9uIG1ha2VQcmVjaXNlICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHZhbCA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoRG91YmxlLmlzTmFOKHZhbCkpIHsgcmV0dXJuIHZhbCB9XG4gICAgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkdfU0lOR0xFKSB7XG4gICAgICB2YXIgZmxvYXRTaW5nbGVWYWwgPSB2YWw7XG4gICAgICByZXR1cm4gZmxvYXRTaW5nbGVWYWxcbiAgICB9XG4gICAgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRklYRUQpIHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIHRoaXMuX3NjYWxlKSAvIHRoaXMuX3NjYWxlXG4gICAgfVxuICAgIHJldHVybiB2YWxcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HKSB7IHJldHVybiBudWxsIH1cbiAgICBjb29yZC54ID0gdGhpcy5tYWtlUHJlY2lzZShjb29yZC54KTtcbiAgICBjb29yZC55ID0gdGhpcy5tYWtlUHJlY2lzZShjb29yZC55KTtcbiAgfVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBmdW5jdGlvbiBnZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgKCkge1xuICB2YXIgbWF4U2lnRGlnaXRzID0gMTY7XG4gIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HKSB7XG4gICAgbWF4U2lnRGlnaXRzID0gMTY7XG4gIH0gZWxzZSBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElOR19TSU5HTEUpIHtcbiAgICBtYXhTaWdEaWdpdHMgPSA2O1xuICB9IGVsc2UgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRklYRUQpIHtcbiAgICBtYXhTaWdEaWdpdHMgPSAxICsgTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5sb2codGhpcy5nZXRTY2FsZSgpKSAvIE1hdGgubG9nKDEwKSkpO1xuICB9XG4gIHJldHVybiBtYXhTaWdEaWdpdHNcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbiBzZXRTY2FsZSAoc2NhbGUpIHtcbiAgdGhpcy5fc2NhbGUgPSBNYXRoLmFicyhzY2FsZSk7XG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlcmlhbGl6YWJsZSwgQ29tcGFyYWJsZV1cbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQcmVjaXNpb25Nb2RlbFxufTtcblByZWNpc2lvbk1vZGVsLm1vc3RQcmVjaXNlID0gZnVuY3Rpb24gbW9zdFByZWNpc2UgKHBtMSwgcG0yKSB7XG4gIGlmIChwbTEuY29tcGFyZVRvKHBtMikgPj0gMCkgeyByZXR1cm4gcG0xIH1cbiAgcmV0dXJuIHBtMlxufTtcbnN0YXRpY0FjY2Vzc29ycyQxOS5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc3NzcyNjM1Nzg3Nzc4MDM4MzUgfTtcbnN0YXRpY0FjY2Vzc29ycyQxOS5tYXhpbXVtUHJlY2lzZVZhbHVlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDkwMDcxOTkyNTQ3NDA5OTIuMCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUHJlY2lzaW9uTW9kZWwsIHN0YXRpY0FjY2Vzc29ycyQxOSApO1xuXG52YXIgVHlwZSA9IGZ1bmN0aW9uIFR5cGUgKG5hbWUpIHtcbiAgdGhpcy5fbmFtZSA9IG5hbWUgfHwgbnVsbDtcbiAgVHlwZS5uYW1lVG9UeXBlTWFwLnB1dChuYW1lLCB0aGlzKTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMSQxID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LG5hbWVUb1R5cGVNYXA6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblR5cGUucHJvdG90eXBlLnJlYWRSZXNvbHZlID0gZnVuY3Rpb24gcmVhZFJlc29sdmUgKCkge1xuICByZXR1cm4gVHlwZS5uYW1lVG9UeXBlTWFwLmdldCh0aGlzLl9uYW1lKVxufTtcblR5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gdGhpcy5fbmFtZVxufTtcblR5cGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlcmlhbGl6YWJsZV1cbn07XG5UeXBlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFR5cGVcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMSQxLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTU1Mjg2MDI2MzE3MzE1ODk4MjIgfTtcbnN0YXRpY0FjY2Vzc29ycyQxJDEubmFtZVRvVHlwZU1hcC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSGFzaE1hcCgpIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUeXBlLCBzdGF0aWNBY2Nlc3NvcnMkMSQxICk7XG5cblByZWNpc2lvbk1vZGVsLlR5cGUgPSBUeXBlO1xuUHJlY2lzaW9uTW9kZWwuRklYRUQgPSBuZXcgVHlwZSgnRklYRUQnKTtcblByZWNpc2lvbk1vZGVsLkZMT0FUSU5HID0gbmV3IFR5cGUoJ0ZMT0FUSU5HJyk7XG5QcmVjaXNpb25Nb2RlbC5GTE9BVElOR19TSU5HTEUgPSBuZXcgVHlwZSgnRkxPQVRJTkcgU0lOR0xFJyk7XG5cbnZhciBHZW9tZXRyeUZhY3RvcnkgPSBmdW5jdGlvbiBHZW9tZXRyeUZhY3RvcnkgKCkge1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IG5ldyBQcmVjaXNpb25Nb2RlbCgpO1xuICB0aGlzLl9TUklEID0gMDtcbiAgdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSA9IEdlb21ldHJ5RmFjdG9yeS5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KSkge1xuICAgICAgdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSA9IGFyZ3VtZW50c1swXTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFByZWNpc2lvbk1vZGVsKSB7XG4gICAgICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX1NSSUQgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX1NSSUQgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSA9IGFyZ3VtZW50c1syXTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLnRvR2VvbWV0cnkgPSBmdW5jdGlvbiB0b0dlb21ldHJ5IChlbnZlbG9wZSkge1xuICBpZiAoZW52ZWxvcGUuaXNOdWxsKCkpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2ludChudWxsKVxuICB9XG4gIGlmIChlbnZlbG9wZS5nZXRNaW5YKCkgPT09IGVudmVsb3BlLmdldE1heFgoKSAmJiBlbnZlbG9wZS5nZXRNaW5ZKCkgPT09IGVudmVsb3BlLmdldE1heFkoKSkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvaW50KG5ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1pblgoKSwgZW52ZWxvcGUuZ2V0TWluWSgpKSlcbiAgfVxuICBpZiAoZW52ZWxvcGUuZ2V0TWluWCgpID09PSBlbnZlbG9wZS5nZXRNYXhYKCkgfHwgZW52ZWxvcGUuZ2V0TWluWSgpID09PSBlbnZlbG9wZS5nZXRNYXhZKCkpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNaW5YKCksIGVudmVsb3BlLmdldE1pblkoKSksIG5ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1heFgoKSwgZW52ZWxvcGUuZ2V0TWF4WSgpKV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoW25ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1pblgoKSwgZW52ZWxvcGUuZ2V0TWluWSgpKSwgbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWluWCgpLCBlbnZlbG9wZS5nZXRNYXhZKCkpLCBuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNYXhYKCksIGVudmVsb3BlLmdldE1heFkoKSksIG5ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1heFgoKSwgZW52ZWxvcGUuZ2V0TWluWSgpKSwgbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWluWCgpLCBlbnZlbG9wZS5nZXRNaW5ZKCkpXSksIG51bGwpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVMaW5lU3RyaW5nID0gZnVuY3Rpb24gY3JlYXRlTGluZVN0cmluZyAoY29vcmRpbmF0ZXMpIHtcbiAgaWYgKCFjb29yZGluYXRlcykgeyByZXR1cm4gbmV3IExpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSwgdGhpcykgfVxuICBlbHNlIGlmIChjb29yZGluYXRlcyBpbnN0YW5jZW9mIEFycmF5KSB7IHJldHVybiBuZXcgTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoY29vcmRpbmF0ZXMpLCB0aGlzKSB9XG4gIGVsc2UgaWYgKGhhc0ludGVyZmFjZShjb29yZGluYXRlcywgQ29vcmRpbmF0ZVNlcXVlbmNlKSkgeyByZXR1cm4gbmV3IExpbmVTdHJpbmcoY29vcmRpbmF0ZXMsIHRoaXMpIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU11bHRpTGluZVN0cmluZyA9IGZ1bmN0aW9uIGNyZWF0ZU11bHRpTGluZVN0cmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcobnVsbCwgdGhpcylcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxpbmVTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKGxpbmVTdHJpbmdzLCB0aGlzKVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5idWlsZEdlb21ldHJ5ID0gZnVuY3Rpb24gYnVpbGRHZW9tZXRyeSAoZ2VvbUxpc3QpIHtcbiAgdmFyIGdlb21DbGFzcyA9IG51bGw7XG4gIHZhciBpc0hldGVyb2dlbmVvdXMgPSBmYWxzZTtcbiAgdmFyIGhhc0dlb21ldHJ5Q29sbGVjdGlvbiA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZ2VvbUxpc3QuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGdlb20gPSBpLm5leHQoKTtcbiAgICB2YXIgcGFydENsYXNzID0gZ2VvbS5nZXRDbGFzcygpO1xuICAgIGlmIChnZW9tQ2xhc3MgPT09IG51bGwpIHtcbiAgICAgIGdlb21DbGFzcyA9IHBhcnRDbGFzcztcbiAgICB9XG4gICAgaWYgKHBhcnRDbGFzcyAhPT0gZ2VvbUNsYXNzKSB7XG4gICAgICBpc0hldGVyb2dlbmVvdXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZ2VvbS5pc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZCgpKSB7IGhhc0dlb21ldHJ5Q29sbGVjdGlvbiA9IHRydWU7IH1cbiAgfVxuICBpZiAoZ2VvbUNsYXNzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKClcbiAgfVxuICBpZiAoaXNIZXRlcm9nZW5lb3VzIHx8IGhhc0dlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihHZW9tZXRyeUZhY3RvcnkudG9HZW9tZXRyeUFycmF5KGdlb21MaXN0KSlcbiAgfVxuICB2YXIgZ2VvbTAgPSBnZW9tTGlzdC5pdGVyYXRvcigpLm5leHQoKTtcbiAgdmFyIGlzQ29sbGVjdGlvbiA9IGdlb21MaXN0LnNpemUoKSA+IDE7XG4gIGlmIChpc0NvbGxlY3Rpb24pIHtcbiAgICBpZiAoZ2VvbTAgaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvbHlnb24oR2VvbWV0cnlGYWN0b3J5LnRvUG9seWdvbkFycmF5KGdlb21MaXN0KSlcbiAgICB9IGVsc2UgaWYgKGdlb20wIGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKEdlb21ldHJ5RmFjdG9yeS50b0xpbmVTdHJpbmdBcnJheShnZW9tTGlzdCkpXG4gICAgfSBlbHNlIGlmIChnZW9tMCBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KEdlb21ldHJ5RmFjdG9yeS50b1BvaW50QXJyYXkoZ2VvbUxpc3QpKVxuICAgIH1cbiAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoJ1VuaGFuZGxlZCBjbGFzczogJyArIGdlb20wLmdldENsYXNzKCkuZ2V0TmFtZSgpKTtcbiAgfVxuICByZXR1cm4gZ2VvbTBcbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzID0gZnVuY3Rpb24gY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMgKGNvb3JkaW5hdGVzKSB7XG4gIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoY29vcmRpbmF0ZXMgIT09IG51bGwgPyB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoY29vcmRpbmF0ZXMpIDogbnVsbClcbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVBvaW50ID0gZnVuY3Rpb24gY3JlYXRlUG9pbnQgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvaW50KHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvaW50KGNvb3JkaW5hdGUgIT09IG51bGwgPyB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW2Nvb3JkaW5hdGVdKSA6IG51bGwpXG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gbmV3IFBvaW50KGNvb3JkaW5hdGVzLCB0aGlzKVxuICAgIH1cbiAgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgKCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlUG9seWdvbiA9IGZ1bmN0aW9uIGNyZWF0ZVBvbHlnb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgUG9seWdvbihudWxsLCBudWxsLCB0aGlzKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoY29vcmRpbmF0ZXMpKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoY29vcmRpbmF0ZXMkMSkpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7XG4gICAgICB2YXIgc2hlbGwgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHNoZWxsLCBudWxsKVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHNoZWxsJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGhvbGVzID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiBuZXcgUG9seWdvbihzaGVsbCQxLCBob2xlcywgdGhpcylcbiAgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuZ2V0U1JJRCA9IGZ1bmN0aW9uIGdldFNSSUQgKCkge1xuICByZXR1cm4gdGhpcy5fU1JJRFxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihudWxsLCB0aGlzKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCB0aGlzKVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeSA9IGZ1bmN0aW9uIGNyZWF0ZUdlb21ldHJ5IChnKSB7XG4gIHZhciBlZGl0b3IgPSBuZXcgR2VvbWV0cnlFZGl0b3IodGhpcyk7XG4gIHJldHVybiBlZGl0b3IuZWRpdChnLCB7XG4gICAgZWRpdDogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIGNvb3JkU2VxID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAvLyBjb25zdCBnZW9tZXRyeSA9IGFyZ3VtZW50c1sxXVxuICAgICAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5jcmVhdGUoY29vcmRTZXEpXG4gICAgICB9XG4gICAgfVxuICB9KVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuZ2V0UHJlY2lzaW9uTW9kZWwgPSBmdW5jdGlvbiBnZXRQcmVjaXNpb25Nb2RlbCAoKSB7XG4gIHJldHVybiB0aGlzLl9wcmVjaXNpb25Nb2RlbFxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTGluZWFyUmluZyA9IGZ1bmN0aW9uIGNyZWF0ZUxpbmVhclJpbmcgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKGNvb3JkaW5hdGVzICE9PSBudWxsID8gdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGNvb3JkaW5hdGVzKSA6IG51bGwpXG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBuZXcgTGluZWFyUmluZyhjb29yZGluYXRlcyQxLCB0aGlzKVxuICAgIH1cbiAgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gY3JlYXRlTXVsdGlQb2x5Z29uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihudWxsLCB0aGlzKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcG9seWdvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbnMsIHRoaXMpXG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU11bHRpUG9pbnQgPSBmdW5jdGlvbiBjcmVhdGVNdWx0aVBvaW50ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2ludChudWxsLCB0aGlzKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBwb2ludCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBuZXcgTXVsdGlQb2ludChwb2ludCwgdGhpcylcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGNvb3JkaW5hdGVzICE9PSBudWxsID8gdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGNvb3JkaW5hdGVzKSA6IG51bGwpXG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmIChjb29yZGluYXRlcyQxID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobmV3IEFycmF5KDApLmZpbGwobnVsbCkpXG4gICAgICB9XG4gICAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KGNvb3JkaW5hdGVzJDEuc2l6ZSgpKS5maWxsKG51bGwpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcyQxLnNpemUoKTsgaSsrKSB7XG4gICAgICAgIHZhciBwdFNlcSA9IHRoaXMkMS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKDEsIGNvb3JkaW5hdGVzJDEuZ2V0RGltZW5zaW9uKCkpO1xuICAgICAgICBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHkoY29vcmRpbmF0ZXMkMSwgaSwgcHRTZXEsIDAsIDEpO1xuICAgICAgICBwb2ludHNbaV0gPSB0aGlzJDEuY3JlYXRlUG9pbnQocHRTZXEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChwb2ludHMpXG4gICAgfVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZXJpYWxpemFibGVdXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5RmFjdG9yeVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b011bHRpUG9seWdvbkFycmF5ID0gZnVuY3Rpb24gdG9NdWx0aVBvbHlnb25BcnJheSAobXVsdGlQb2x5Z29ucykge1xuICB2YXIgbXVsdGlQb2x5Z29uQXJyYXkgPSBuZXcgQXJyYXkobXVsdGlQb2x5Z29ucy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBtdWx0aVBvbHlnb25zLnRvQXJyYXkobXVsdGlQb2x5Z29uQXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvR2VvbWV0cnlBcnJheSA9IGZ1bmN0aW9uIHRvR2VvbWV0cnlBcnJheSAoZ2VvbWV0cmllcykge1xuICBpZiAoZ2VvbWV0cmllcyA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBnZW9tZXRyeUFycmF5ID0gbmV3IEFycmF5KGdlb21ldHJpZXMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gZ2VvbWV0cmllcy50b0FycmF5KGdlb21ldHJ5QXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5Lmluc3RhbmNlKClcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9NdWx0aUxpbmVTdHJpbmdBcnJheSA9IGZ1bmN0aW9uIHRvTXVsdGlMaW5lU3RyaW5nQXJyYXkgKG11bHRpTGluZVN0cmluZ3MpIHtcbiAgdmFyIG11bHRpTGluZVN0cmluZ0FycmF5ID0gbmV3IEFycmF5KG11bHRpTGluZVN0cmluZ3Muc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gbXVsdGlMaW5lU3RyaW5ncy50b0FycmF5KG11bHRpTGluZVN0cmluZ0FycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b0xpbmVTdHJpbmdBcnJheSA9IGZ1bmN0aW9uIHRvTGluZVN0cmluZ0FycmF5IChsaW5lU3RyaW5ncykge1xuICB2YXIgbGluZVN0cmluZ0FycmF5ID0gbmV3IEFycmF5KGxpbmVTdHJpbmdzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIGxpbmVTdHJpbmdzLnRvQXJyYXkobGluZVN0cmluZ0FycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b011bHRpUG9pbnRBcnJheSA9IGZ1bmN0aW9uIHRvTXVsdGlQb2ludEFycmF5IChtdWx0aVBvaW50cykge1xuICB2YXIgbXVsdGlQb2ludEFycmF5ID0gbmV3IEFycmF5KG11bHRpUG9pbnRzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIG11bHRpUG9pbnRzLnRvQXJyYXkobXVsdGlQb2ludEFycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b0xpbmVhclJpbmdBcnJheSA9IGZ1bmN0aW9uIHRvTGluZWFyUmluZ0FycmF5IChsaW5lYXJSaW5ncykge1xuICB2YXIgbGluZWFyUmluZ0FycmF5ID0gbmV3IEFycmF5KGxpbmVhclJpbmdzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIGxpbmVhclJpbmdzLnRvQXJyYXkobGluZWFyUmluZ0FycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b1BvaW50QXJyYXkgPSBmdW5jdGlvbiB0b1BvaW50QXJyYXkgKHBvaW50cykge1xuICB2YXIgcG9pbnRBcnJheSA9IG5ldyBBcnJheShwb2ludHMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gcG9pbnRzLnRvQXJyYXkocG9pbnRBcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9Qb2x5Z29uQXJyYXkgPSBmdW5jdGlvbiB0b1BvbHlnb25BcnJheSAocG9seWdvbnMpIHtcbiAgdmFyIHBvbHlnb25BcnJheSA9IG5ldyBBcnJheShwb2x5Z29ucy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBwb2x5Z29ucy50b0FycmF5KHBvbHlnb25BcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCA9IGZ1bmN0aW9uIGNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQgKGNvb3JkLCBleGVtcGxhcikge1xuICBleGVtcGxhci5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKGNvb3JkKTtcbiAgcmV0dXJuIGV4ZW1wbGFyLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludChjb29yZClcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMi5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC02ODIwNTI0NzUzMDk0MDk1NjM1IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeUZhY3RvcnksIHN0YXRpY0FjY2Vzc29ycyQyICk7XG5cbnZhciBnZW9tZXRyeVR5cGVzID0gWydQb2ludCcsICdNdWx0aVBvaW50JywgJ0xpbmVTdHJpbmcnLCAnTXVsdGlMaW5lU3RyaW5nJywgJ1BvbHlnb24nLCAnTXVsdGlQb2x5Z29uJ107XG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgV2VsbC1Lbm93biBUZXh0LkNyZWF0ZSBhIG5ldyBwYXJzZXIgZm9yIEdlb0pTT05cbiAqIE5PVEU6IEFkYXB0ZWQgZnJvbSBPcGVuTGF5ZXJzIDIuMTEgaW1wbGVtZW50YXRpb24uXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcGFyc2VyIGZvciBHZW9KU09OXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeUZhY3Rvcnl9IGdlb21ldHJ5RmFjdG9yeVxuICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBHZW9Kc29uUGFyc2VyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgR2VvSlNPTlBhcnNlciA9IGZ1bmN0aW9uIEdlb0pTT05QYXJzZXIgKGdlb21ldHJ5RmFjdG9yeSkge1xuICB0aGlzLmdlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeSB8fCBuZXcgR2VvbWV0cnlGYWN0b3J5KCk7XG59O1xuLyoqXG4gKiBEZXNlcmlhbGl6ZSBhIEdlb0pTT04gb2JqZWN0IGFuZCByZXR1cm4gdGhlIEdlb21ldHJ5IG9yIEZlYXR1cmUoQ29sbGVjdGlvbikgd2l0aCBKU1RTIEdlb21ldHJpZXNcbiAqXG4gKiBAcGFyYW0ge31cbiAqICAgICAgICBBIEdlb0pTT04gb2JqZWN0LlxuICogQHJldHVybiB7fSBBIEdlb21ldHJ5IGluc3RhbmNlIG9yIG9iamVjdCByZXByZXNlbnRpbmcgYSBGZWF0dXJlKENvbGxlY3Rpb24pIHdpdGggR2VvbWV0cnkgaW5zdGFuY2VzLlxuICogQHByaXZhdGVcbiAqL1xuR2VvSlNPTlBhcnNlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIHJlYWQgKGpzb24pIHtcbiAgdmFyIG9iajtcbiAgaWYgKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJykge1xuICAgIG9iaiA9IEpTT04ucGFyc2UoanNvbik7XG4gIH0gZWxzZSB7XG4gICAgb2JqID0ganNvbjtcbiAgfVxuXG4gIHZhciB0eXBlID0gb2JqLnR5cGU7XG5cbiAgaWYgKCFwYXJzZVt0eXBlXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBHZW9KU09OIHR5cGU6ICcgKyBvYmoudHlwZSlcbiAgfVxuXG4gIGlmIChnZW9tZXRyeVR5cGVzLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG4gICAgcmV0dXJuIHBhcnNlW3R5cGVdLmFwcGx5KHRoaXMsIFtvYmouY29vcmRpbmF0ZXNdKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgcmV0dXJuIHBhcnNlW3R5cGVdLmFwcGx5KHRoaXMsIFtvYmouZ2VvbWV0cmllc10pXG4gIH1cblxuICAvLyBmZWF0dXJlIG9yIGZlYXR1cmUgY29sbGVjdGlvblxuICByZXR1cm4gcGFyc2VbdHlwZV0uYXBwbHkodGhpcywgW29ial0pXG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSBhIEdlb21ldHJ5IG9iamVjdCBpbnRvIEdlb0pTT05cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5fVxuICogICAgICAgIGdlb21ldHJ5IEEgR2VvbWV0cnkgb3IgYXJyYXkgb2YgR2VvbWV0cmllcy5cbiAqIEByZXR1cm4ge09iamVjdH0gQSBHZW9KU09OIG9iamVjdCByZXByZXN0aW5nIHRoZSBpbnB1dCBHZW9tZXRyeS9HZW9tZXRyaWVzLlxuICogQHByaXZhdGVcbiAqL1xuR2VvSlNPTlBhcnNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoZ2VvbWV0cnkpIHtcbiAgdmFyIHR5cGUgPSBnZW9tZXRyeS5nZXRHZW9tZXRyeVR5cGUoKTtcblxuICBpZiAoIWV4dHJhY3RbdHlwZV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlb21ldHJ5IGlzIG5vdCBzdXBwb3J0ZWQnKVxuICB9XG5cbiAgcmV0dXJuIGV4dHJhY3RbdHlwZV0uYXBwbHkodGhpcywgW2dlb21ldHJ5XSlcbn07XG5cbnZhciBwYXJzZSA9IHtcbiAgLyoqXG4gICAqIFBhcnNlIGEgR2VvSlNPTiBGZWF0dXJlIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH1cbiAgICogICAgICAgICAgb2JqIE9iamVjdCB0byBwYXJzZS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBGZWF0dXJlIHdpdGggZ2VvbWV0cnkvYmJveCBjb252ZXJ0ZWQgdG8gSlNUUyBHZW9tZXRyaWVzLlxuICAgKi9cbiAgRmVhdHVyZTogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBmZWF0dXJlID0ge307XG5cbiAgICAvLyBjb3B5IGZlYXR1cmVzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgZmVhdHVyZVtrZXldID0gb2JqW2tleV07XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgZ2VvbWV0cnlcbiAgICBpZiAob2JqLmdlb21ldHJ5KSB7XG4gICAgICB2YXIgdHlwZSA9IG9iai5nZW9tZXRyeS50eXBlO1xuICAgICAgaWYgKCFwYXJzZVt0eXBlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gR2VvSlNPTiB0eXBlOiAnICsgb2JqLnR5cGUpXG4gICAgICB9XG4gICAgICBmZWF0dXJlLmdlb21ldHJ5ID0gdGhpcy5yZWFkKG9iai5nZW9tZXRyeSk7XG4gICAgfVxuXG4gICAgLy8gYmJveFxuICAgIGlmIChvYmouYmJveCkge1xuICAgICAgZmVhdHVyZS5iYm94ID0gcGFyc2UuYmJveC5hcHBseSh0aGlzLCBbb2JqLmJib3hdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmVhdHVyZVxuICB9LFxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIEdlb0pTT04gRmVhdHVyZUNvbGxlY3Rpb24gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fVxuICAgKiAgICAgICAgICBvYmogT2JqZWN0IHRvIHBhcnNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEZlYXR1cmVDb2xsZWN0aW9uIHdpdGggZ2VvbWV0cnkvYmJveCBjb252ZXJ0ZWQgdG8gSlNUUyBHZW9tZXRyaWVzLlxuICAgKi9cbiAgRmVhdHVyZUNvbGxlY3Rpb246IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IHt9O1xuXG4gICAgaWYgKG9iai5mZWF0dXJlcykge1xuICAgICAgZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmouZmVhdHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMucHVzaCh0aGlzJDEucmVhZChvYmouZmVhdHVyZXNbaV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2JqLmJib3gpIHtcbiAgICAgIGZlYXR1cmVDb2xsZWN0aW9uLmJib3ggPSB0aGlzLnBhcnNlLmJib3guYXBwbHkodGhpcywgW29iai5iYm94XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIG9yZGluYXRlcyBpbiBhbiBhcnJheSB0byBhbiBhcnJheSBvZiBDb29yZGluYXRlc1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIHtOdW1iZXJ9cy5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHdpdGggQ29vcmRpbmF0ZXMuXG4gICAqL1xuICBjb29yZGluYXRlczogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHN1YiA9IGFycmF5W2ldO1xuICAgICAgY29vcmRpbmF0ZXMucHVzaChuZXcgQ29vcmRpbmF0ZShzdWJbMF0sIHN1YlsxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZXNcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgYmJveCB0byBhIExpbmVhclJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgd2l0aCBbeE1pbiwgeU1pbiwgeE1heCwgeU1heF0uXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSB3aXRoIENvb3JkaW5hdGVzLlxuICAgKi9cbiAgYmJveDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoW1xuICAgICAgbmV3IENvb3JkaW5hdGUoYXJyYXlbMF0sIGFycmF5WzFdKSxcbiAgICAgIG5ldyBDb29yZGluYXRlKGFycmF5WzJdLCBhcnJheVsxXSksXG4gICAgICBuZXcgQ29vcmRpbmF0ZShhcnJheVsyXSwgYXJyYXlbM10pLFxuICAgICAgbmV3IENvb3JkaW5hdGUoYXJyYXlbMF0sIGFycmF5WzNdKSxcbiAgICAgIG5ldyBDb29yZGluYXRlKGFycmF5WzBdLCBhcnJheVsxXSlcbiAgICBdKVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5IHdpdGggb3JkaW5hdGVzIHRvIGEgUG9pbnRcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgd2l0aCBvcmRpbmF0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge1BvaW50fSBQb2ludC5cbiAgICovXG4gIFBvaW50OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZSA9IG5ldyBDb29yZGluYXRlKGFycmF5WzBdLCBhcnJheVsxXSk7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGNvb3JkaW5hdGUpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgd2l0aCBjb29yZGluYXRlcyB0byBhIE11bHRpUG9pbnRcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgd2l0aCBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7TXVsdGlQb2ludH0gTXVsdGlQb2ludC5cbiAgICovXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHBvaW50cy5wdXNoKHBhcnNlLlBvaW50LmFwcGx5KHRoaXMkMSwgW2FycmF5W2ldXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChwb2ludHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgd2l0aCBjb29yZGluYXRlcyB0byBhIExpbmVTdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgd2l0aCBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7TGluZVN0cmluZ30gTGluZVN0cmluZy5cbiAgICovXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IHBhcnNlLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsIFthcnJheV0pO1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGNvb3JkaW5hdGVzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5IHdpdGggY29vcmRpbmF0ZXMgdG8gYSBNdWx0aUxpbmVTdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgd2l0aCBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7TXVsdGlMaW5lU3RyaW5nfSBNdWx0aUxpbmVTdHJpbmcuXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGxpbmVTdHJpbmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgbGluZVN0cmluZ3MucHVzaChwYXJzZS5MaW5lU3RyaW5nLmFwcGx5KHRoaXMkMSwgW2FycmF5W2ldXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGxpbmVTdHJpbmdzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5IHRvIGEgUG9seWdvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIHNoZWxsIGFuZCBob2xlcy5cbiAgICpcbiAgICogQHJldHVybiB7UG9seWdvbn0gUG9seWdvbi5cbiAgICovXG4gIFBvbHlnb246IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNoZWxsQ29vcmRpbmF0ZXMgPSBwYXJzZS5jb29yZGluYXRlcy5hcHBseSh0aGlzLCBbYXJyYXlbMF1dKTtcbiAgICB2YXIgc2hlbGwgPSB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHNoZWxsQ29vcmRpbmF0ZXMpO1xuICAgIHZhciBob2xlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBob2xlID0gYXJyYXlbaV07XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBwYXJzZS5jb29yZGluYXRlcy5hcHBseSh0aGlzJDEsIFtob2xlXSk7XG4gICAgICB2YXIgbGluZWFyUmluZyA9IHRoaXMkMS5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhjb29yZGluYXRlcyk7XG4gICAgICBob2xlcy5wdXNoKGxpbmVhclJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihzaGVsbCwgaG9sZXMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgdG8gYSBNdWx0aVBvbHlnb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgb2YgYXJyYXlzIHdpdGggc2hlbGwgYW5kIHJpbmdzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNdWx0aVBvbHlnb259IE11bHRpUG9seWdvbi5cbiAgICovXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9seWdvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcG9seWdvbiA9IGFycmF5W2ldO1xuICAgICAgcG9seWdvbnMucHVzaChwYXJzZS5Qb2x5Z29uLmFwcGx5KHRoaXMkMSwgW3BvbHlnb25dKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24ocG9seWdvbnMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgdG8gYSBHZW9tZXRyeUNvbGxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgb2YgR2VvSlNPTiBnZW9tZXRyaWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHZW9tZXRyeUNvbGxlY3Rpb259IEdlb21ldHJ5Q29sbGVjdGlvbi5cbiAgICovXG4gIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IGFycmF5W2ldO1xuICAgICAgZ2VvbWV0cmllcy5wdXNoKHRoaXMkMS5yZWFkKGdlb21ldHJ5KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcylcbiAgfVxufTtcblxudmFyIGV4dHJhY3QgPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgQ29vcmRpbmF0ZSB0byBhbiBBcnJheVxuICAgKlxuICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGV9XG4gICAqICAgICAgICAgIGNvb3JkaW5hdGUgQ29vcmRpbmF0ZSB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2Ygb3JkaW5hdGVzLlxuICAgKi9cbiAgY29vcmRpbmF0ZTogZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcbiAgICByZXR1cm4gW2Nvb3JkaW5hdGUueCwgY29vcmRpbmF0ZS55XVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgUG9pbnQgdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge1BvaW50fVxuICAgKiAgICAgICAgICBwb2ludCBQb2ludCB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgMiBvcmRpbmF0ZXMgKHBhaXJlZCB0byBhIGNvb3JkaW5hdGUpLlxuICAgKi9cbiAgUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHZhciBhcnJheSA9IGV4dHJhY3QuY29vcmRpbmF0ZS5hcHBseSh0aGlzLCBbcG9pbnQuZ2V0Q29vcmRpbmF0ZSgpXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICBjb29yZGluYXRlczogYXJyYXlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBNdWx0aVBvaW50IHRvIGEgR2VvSlNPTiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aVBvaW50fVxuICAgKiAgICAgICAgICBtdWx0aXBvaW50IE11bHRpUG9pbnQgdG8gY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgTXVsdGlQb2ludDogZnVuY3Rpb24gKG11bHRpcG9pbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlwb2ludC5fZ2VvbWV0cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBvaW50ID0gbXVsdGlwb2ludC5fZ2VvbWV0cmllc1tpXTtcbiAgICAgIHZhciBnZW9Kc29uID0gZXh0cmFjdC5Qb2ludC5hcHBseSh0aGlzJDEsIFtwb2ludF0pO1xuICAgICAgYXJyYXkucHVzaChnZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdNdWx0aVBvaW50JyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIExpbmVTdHJpbmcgdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge0xpbmVTdHJpbmd9XG4gICAqICAgICAgICAgIGxpbmVzdHJpbmcgTGluZVN0cmluZyB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBMaW5lU3RyaW5nOiBmdW5jdGlvbiAobGluZXN0cmluZykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gbGluZXN0cmluZy5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV07XG4gICAgICBhcnJheS5wdXNoKGV4dHJhY3QuY29vcmRpbmF0ZS5hcHBseSh0aGlzJDEsIFtjb29yZGluYXRlXSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgY29vcmRpbmF0ZXM6IGFycmF5XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgTXVsdGlMaW5lU3RyaW5nIHRvIGEgR2VvSlNPTiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aUxpbmVTdHJpbmd9XG4gICAqICAgICAgICAgIG11bHRpbGluZXN0cmluZyBNdWx0aUxpbmVTdHJpbmcgdG8gY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIEFycmF5IG9mIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbiAobXVsdGlsaW5lc3RyaW5nKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpbGluZXN0cmluZy5fZ2VvbWV0cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmVzdHJpbmcgPSBtdWx0aWxpbmVzdHJpbmcuX2dlb21ldHJpZXNbaV07XG4gICAgICB2YXIgZ2VvSnNvbiA9IGV4dHJhY3QuTGluZVN0cmluZy5hcHBseSh0aGlzJDEsIFtsaW5lc3RyaW5nXSk7XG4gICAgICBhcnJheS5wdXNoKGdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011bHRpTGluZVN0cmluZycsXG4gICAgICBjb29yZGluYXRlczogYXJyYXlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBQb2x5Z29uIHRvIGEgR2VvSlNPTiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5Z29ufVxuICAgKiAgICAgICAgICBwb2x5Z29uIFBvbHlnb24gdG8gY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHdpdGggc2hlbGwsIGhvbGVzLlxuICAgKi9cbiAgUG9seWdvbjogZnVuY3Rpb24gKHBvbHlnb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBzaGVsbEdlb0pzb24gPSBleHRyYWN0LkxpbmVTdHJpbmcuYXBwbHkodGhpcywgW3BvbHlnb24uX3NoZWxsXSk7XG4gICAgYXJyYXkucHVzaChzaGVsbEdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5faG9sZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBob2xlID0gcG9seWdvbi5faG9sZXNbaV07XG4gICAgICB2YXIgaG9sZUdlb0pzb24gPSBleHRyYWN0LkxpbmVTdHJpbmcuYXBwbHkodGhpcyQxLCBbaG9sZV0pO1xuICAgICAgYXJyYXkucHVzaChob2xlR2VvSnNvbi5jb29yZGluYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnUG9seWdvbicsXG4gICAgICBjb29yZGluYXRlczogYXJyYXlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBNdWx0aVBvbHlnb24gdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpUG9seWdvbn1cbiAgICogICAgICAgICAgbXVsdGlwb2x5Z29uIE11bHRpUG9seWdvbiB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgcG9seWdvbnMuXG4gICAqL1xuICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uIChtdWx0aXBvbHlnb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlwb2x5Z29uLl9nZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcG9seWdvbiA9IG11bHRpcG9seWdvbi5fZ2VvbWV0cmllc1tpXTtcbiAgICAgIHZhciBnZW9Kc29uID0gZXh0cmFjdC5Qb2x5Z29uLmFwcGx5KHRoaXMkMSwgW3BvbHlnb25dKTtcbiAgICAgIGFycmF5LnB1c2goZ2VvSnNvbi5jb29yZGluYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTXVsdGlQb2x5Z29uJyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIEdlb21ldHJ5Q29sbGVjdGlvbiB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlDb2xsZWN0aW9ufVxuICAgKiAgICAgICAgICBjb2xsZWN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbiB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgZ2VvbWV0cmllcy5cbiAgICovXG4gIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5fZ2VvbWV0cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gY29sbGVjdGlvbi5fZ2VvbWV0cmllc1tpXTtcbiAgICAgIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cnlUeXBlKCk7XG4gICAgICBhcnJheS5wdXNoKGV4dHJhY3RbdHlwZV0uYXBwbHkodGhpcyQxLCBbZ2VvbWV0cnldKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcbiAgICAgIGdlb21ldHJpZXM6IGFycmF5XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZ2VvbWV0cnkgaW4gR2VvSlNPTiB0byBhIHtAbGluayBHZW9tZXRyeX0uXG4gKi9cblxuLyoqXG4gKiBBIDxjb2RlPkdlb0pTT05SZWFkZXI8L2NvZGU+IGlzIHBhcmFtZXRlcml6ZWQgYnkgYSA8Y29kZT5HZW9tZXRyeUZhY3Rvcnk8L2NvZGU+LFxuICogdG8gYWxsb3cgaXQgdG8gY3JlYXRlIDxjb2RlPkdlb21ldHJ5PC9jb2RlPiBvYmplY3RzIG9mIHRoZSBhcHByb3ByaWF0ZVxuICogaW1wbGVtZW50YXRpb24uIEluIHBhcnRpY3VsYXIsIHRoZSA8Y29kZT5HZW9tZXRyeUZhY3Rvcnk8L2NvZGU+IGRldGVybWluZXNcbiAqIHRoZSA8Y29kZT5QcmVjaXNpb25Nb2RlbDwvY29kZT4gYW5kIDxjb2RlPlNSSUQ8L2NvZGU+IHRoYXQgaXMgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5RmFjdG9yeX0gZ2VvbWV0cnlGYWN0b3J5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEdlb0pTT05SZWFkZXIgPSBmdW5jdGlvbiBHZW9KU09OUmVhZGVyIChnZW9tZXRyeUZhY3RvcnkpIHtcbiAgdGhpcy5nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3RvcnkgfHwgbmV3IEdlb21ldHJ5RmFjdG9yeSgpO1xuICB0aGlzLnByZWNpc2lvbk1vZGVsID0gdGhpcy5nZW9tZXRyeUZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKTtcbiAgdGhpcy5wYXJzZXIgPSBuZXcgR2VvSlNPTlBhcnNlcih0aGlzLmdlb21ldHJ5RmFjdG9yeSk7XG59O1xuLyoqXG4gKiBSZWFkcyBhIEdlb0pTT04gcmVwcmVzZW50YXRpb24gb2YgYSB7QGxpbmsgR2VvbWV0cnl9XG4gKlxuICogV2lsbCBhbHNvIHBhcnNlIEdlb0pTT04gRmVhdHVyZXMvRmVhdHVyZUNvbGxlY3Rpb25zIGFzIGN1c3RvbSBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZ2VvSnNvbiBhIEdlb0pTT04gT2JqZWN0IG9yIFN0cmluZy5cbiAqIEByZXR1cm4ge0dlb21ldHJ5fE9iamVjdH0gYSA8Y29kZT5HZW9tZXRyeSBvciBGZWF0dXJlL0ZlYXR1cmVDb2xsZWN0aW9uIHJlcHJlc2VudGF0aW9uLjwvY29kZT5cbiAqIEBtZW1iZXJvZiBHZW9KU09OUmVhZGVyXG4gKi9cbkdlb0pTT05SZWFkZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiByZWFkIChnZW9Kc29uKSB7XG4gIHZhciBnZW9tZXRyeSA9IHRoaXMucGFyc2VyLnJlYWQoZ2VvSnNvbik7XG5cbiAgaWYgKHRoaXMucHJlY2lzaW9uTW9kZWwuZ2V0VHlwZSgpID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgIHRoaXMucmVkdWNlUHJlY2lzaW9uKGdlb21ldHJ5KTtcbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeVxufTtcblxuLy8gTk9URTogdGhpcyBpcyBhIGhhY2tcbkdlb0pTT05SZWFkZXIucHJvdG90eXBlLnJlZHVjZVByZWNpc2lvbiA9IGZ1bmN0aW9uIHJlZHVjZVByZWNpc2lvbiAoZ2VvbWV0cnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSwgbGVuO1xuXG4gIGlmIChnZW9tZXRyeS5jb29yZGluYXRlKSB7XG4gICAgdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShnZW9tZXRyeS5jb29yZGluYXRlKTtcbiAgfSBlbHNlIGlmIChnZW9tZXRyeS5wb2ludHMpIHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5wb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMkMS5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShnZW9tZXRyeS5wb2ludHNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChnZW9tZXRyeS5nZW9tZXRyaWVzKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcyQxLnJlZHVjZVByZWNpc2lvbihnZW9tZXRyeS5nZW9tZXRyaWVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQG1vZHVsZSBHZW9KU09OV3JpdGVyXG4gKi9cblxuLyoqXG4gKiBXcml0ZXMgdGhlIEdlb0pTT04gcmVwcmVzZW50YXRpb24gb2YgYSB7QGxpbmsgR2VvbWV0cnl9LiBUaGVcbiAqIFRoZSBHZW9KU09OIGZvcm1hdCBpcyBkZWZpbmVkIDxBXG4gKiBIUkVGPVwiaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sXCI+aGVyZTwvQT4uXG4gKi9cblxuLyoqXG4gKiBUaGUgPGNvZGU+R2VvSlNPTldyaXRlcjwvY29kZT4gb3V0cHV0cyBjb29yZGluYXRlcyByb3VuZGVkIHRvIHRoZSBwcmVjaXNpb25cbiAqIG1vZGVsLiBPbmx5IHRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZVxuICogb3JkaW5hdGVzIHRvIHRoZSByZXF1aXJlZCBwcmVjaXNpb24gd2lsbCBiZSBvdXRwdXQuXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeUZhY3Rvcnl9IGdlb21ldHJ5RmFjdG9yeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBHZW9KU09OV3JpdGVyID0gZnVuY3Rpb24gR2VvSlNPTldyaXRlciAoKSB7XG4gIHRoaXMucGFyc2VyID0gbmV3IEdlb0pTT05QYXJzZXIodGhpcy5nZW9tZXRyeUZhY3RvcnkpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSA8Y29kZT5HZW9tZXRyeTwvY29kZT4gdG8gaXRzIEdlb0pTT04gcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeX1cbiAqICAgICAgICBnZW9tZXRyeSBhIDxjb2RlPkdlb21ldHJ5PC9jb2RlPiB0byBwcm9jZXNzLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgR2VvSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgR2VvbWV0cnkuXG4gKiBAbWVtYmVyb2YgR2VvSlNPTldyaXRlclxuICovXG5HZW9KU09OV3JpdGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChnZW9tZXRyeSkge1xuICByZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUoZ2VvbWV0cnkpXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG4vLyBpb1xuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbiAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyMCA9IHsgT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTEVGVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxSSUdIVDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5Qb3NpdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvc2l0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvc2l0aW9uXG59O1xuUG9zaXRpb24ub3Bwb3NpdGUgPSBmdW5jdGlvbiBvcHBvc2l0ZSAocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5MRUZUKSB7IHJldHVybiBQb3NpdGlvbi5SSUdIVCB9XG4gIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uUklHSFQpIHsgcmV0dXJuIFBvc2l0aW9uLkxFRlQgfVxuICByZXR1cm4gcG9zaXRpb25cbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjAuT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDIwLkxFRlQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDIwLlJJR0hULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBvc2l0aW9uLCBzdGF0aWNBY2Nlc3NvcnMkMjAgKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZVxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFbXB0eVN0YWNrRXhjZXB0aW9uIChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG59XG5FbXB0eVN0YWNrRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbkVtcHR5U3RhY2tFeGNlcHRpb24ucHJvdG90eXBlLm5hbWUgPSAnRW1wdHlTdGFja0V4Y2VwdGlvbic7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvU3RhY2suaHRtbFxuICpcbiAqIEBleHRlbmRzIHtMaXN0fVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTdGFjayAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLmFycmF5XyA9IFtdO1xufVxuU3RhY2sucHJvdG90eXBlID0gbmV3IExpc3QoKTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU3RhY2sucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHRoaXMuYXJyYXlfLnB1c2goZSk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5zaXplKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXJyYXlfW2luZGV4XVxufTtcblxuLyoqXG4gKiBQdXNoZXMgYW4gaXRlbSBvbnRvIHRoZSB0b3Agb2YgdGhpcyBzdGFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGUpIHtcbiAgdGhpcy5hcnJheV8ucHVzaChlKTtcbiAgcmV0dXJuIGVcbn07XG5cbi8qKlxuICogUHVzaGVzIGFuIGl0ZW0gb250byB0aGUgdG9wIG9mIHRoaXMgc3RhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5TdGFjay5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKGUpIHtcbiAgaWYgKHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFbXB0eVN0YWNrRXhjZXB0aW9uKClcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFycmF5Xy5wb3AoKVxufTtcblxuLyoqXG4gKiBMb29rcyBhdCB0aGUgb2JqZWN0IGF0IHRoZSB0b3Agb2YgdGhpcyBzdGFjayB3aXRob3V0IHJlbW92aW5nIGl0IGZyb20gdGhlXG4gKiBzdGFjay5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU3RhY2sucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFycmF5Xy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlTdGFja0V4Y2VwdGlvbigpXG4gIH1cblxuICByZXR1cm4gdGhpcy5hcnJheV9bdGhpcy5hcnJheV8ubGVuZ3RoIC0gMV1cbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhpcyBzdGFjayBpcyBlbXB0eS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYW5kIG9ubHkgaWYgdGhpcyBzdGFjayBjb250YWlucyBubyBpdGVtczsgZmFsc2VcbiAqICAgICAgICAgb3RoZXJ3aXNlLlxuICovXG5TdGFjay5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFycmF5Xy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblN0YWNrLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lbXB0eSgpXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIDEtYmFzZWQgcG9zaXRpb24gd2hlcmUgYW4gb2JqZWN0IGlzIG9uIHRoaXMgc3RhY2suIElmIHRoZSBvYmplY3RcbiAqIG8gb2NjdXJzIGFzIGFuIGl0ZW0gaW4gdGhpcyBzdGFjaywgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZGlzdGFuY2UgZnJvbSB0aGVcbiAqIHRvcCBvZiB0aGUgc3RhY2sgb2YgdGhlIG9jY3VycmVuY2UgbmVhcmVzdCB0aGUgdG9wIG9mIHRoZSBzdGFjazsgdGhlIHRvcG1vc3RcbiAqIGl0ZW0gb24gdGhlIHN0YWNrIGlzIGNvbnNpZGVyZWQgdG8gYmUgYXQgZGlzdGFuY2UgMS4gVGhlIGVxdWFscyBtZXRob2QgaXNcbiAqIHVzZWQgdG8gY29tcGFyZSBvIHRvIHRoZSBpdGVtcyBpbiB0aGlzIHN0YWNrLlxuICpcbiAqIE5PVEU6IGRvZXMgbm90IGN1cnJlbnRseSBhY3R1YWxseSB1c2UgZXF1YWxzLiAoPT09IGlzIHVzZWQpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9cbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIDEtYmFzZWQgcG9zaXRpb24gZnJvbSB0aGUgdG9wIG9mIHRoZSBzdGFjayB3aGVyZSB0aGVcbiAqICAgICAgICAgb2JqZWN0IGlzIGxvY2F0ZWQ7IHRoZSByZXR1cm4gdmFsdWUgLTEgaW5kaWNhdGVzIHRoYXQgdGhlIG9iamVjdCBpc1xuICogICAgICAgICBub3Qgb24gdGhlIHN0YWNrLlxuICovXG5TdGFjay5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKG8pIHtcbiAgcmV0dXJuIHRoaXMuYXJyYXlfLmluZGV4T2Yobylcbn07XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICogQGV4cG9ydFxuICovXG5TdGFjay5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aFxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU3RhY2sucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBhcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5LnB1c2godGhpcyQxLmFycmF5X1tpXSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXlcbn07XG5cbnZhciBSaWdodG1vc3RFZGdlRmluZGVyID0gZnVuY3Rpb24gUmlnaHRtb3N0RWRnZUZpbmRlciAoKSB7XG4gIHRoaXMuX21pbkluZGV4ID0gLTE7XG4gIHRoaXMuX21pbkNvb3JkID0gbnVsbDtcbiAgdGhpcy5fbWluRGUgPSBudWxsO1xuICB0aGlzLl9vcmllbnRlZERlID0gbnVsbDtcbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9taW5Db29yZFxufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmdldFJpZ2h0bW9zdFNpZGUgPSBmdW5jdGlvbiBnZXRSaWdodG1vc3RTaWRlIChkZSwgaW5kZXgpIHtcbiAgdmFyIHNpZGUgPSB0aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQoZGUsIGluZGV4KTtcbiAgaWYgKHNpZGUgPCAwKSB7IHNpZGUgPSB0aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQoZGUsIGluZGV4IC0gMSk7IH1cbiAgaWYgKHNpZGUgPCAwKSB7XG4gICAgdGhpcy5fbWluQ29vcmQgPSBudWxsO1xuICAgIHRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKGRlKTtcbiAgfVxuICByZXR1cm4gc2lkZVxufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXggPSBmdW5jdGlvbiBmaW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4ICgpIHtcbiAgdmFyIHB0cyA9IHRoaXMuX21pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO1xuICBBc3NlcnQuaXNUcnVlKHRoaXMuX21pbkluZGV4ID4gMCAmJiB0aGlzLl9taW5JbmRleCA8IHB0cy5sZW5ndGgsICdyaWdodG1vc3QgcG9pbnQgZXhwZWN0ZWQgdG8gYmUgaW50ZXJpb3IgdmVydGV4IG9mIGVkZ2UnKTtcbiAgdmFyIHBQcmV2ID0gcHRzW3RoaXMuX21pbkluZGV4IC0gMV07XG4gIHZhciBwTmV4dCA9IHB0c1t0aGlzLl9taW5JbmRleCArIDFdO1xuICB2YXIgb3JpZW50YXRpb24gPSBDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMuX21pbkNvb3JkLCBwTmV4dCwgcFByZXYpO1xuICB2YXIgdXNlUHJldiA9IGZhbHNlO1xuICBpZiAocFByZXYueSA8IHRoaXMuX21pbkNvb3JkLnkgJiYgcE5leHQueSA8IHRoaXMuX21pbkNvb3JkLnkgJiYgb3JpZW50YXRpb24gPT09IENHQWxnb3JpdGhtcy5DT1VOVEVSQ0xPQ0tXSVNFKSB7XG4gICAgdXNlUHJldiA9IHRydWU7XG4gIH0gZWxzZSBpZiAocFByZXYueSA+IHRoaXMuX21pbkNvb3JkLnkgJiYgcE5leHQueSA+IHRoaXMuX21pbkNvb3JkLnkgJiYgb3JpZW50YXRpb24gPT09IENHQWxnb3JpdGhtcy5DTE9DS1dJU0UpIHtcbiAgICB1c2VQcmV2ID0gdHJ1ZTtcbiAgfVxuICBpZiAodXNlUHJldikge1xuICAgIHRoaXMuX21pbkluZGV4ID0gdGhpcy5fbWluSW5kZXggLSAxO1xuICB9XG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCA9IGZ1bmN0aW9uIGdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQgKGRlLCBpKSB7XG4gIHZhciBlID0gZGUuZ2V0RWRnZSgpO1xuICB2YXIgY29vcmQgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gIGlmIChpIDwgMCB8fCBpICsgMSA+PSBjb29yZC5sZW5ndGgpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKGNvb3JkW2ldLnkgPT09IGNvb3JkW2kgKyAxXS55KSB7IHJldHVybiAtMSB9XG4gIHZhciBwb3MgPSBQb3NpdGlvbi5MRUZUO1xuICBpZiAoY29vcmRbaV0ueSA8IGNvb3JkW2kgKyAxXS55KSB7IHBvcyA9IFBvc2l0aW9uLlJJR0hUOyB9XG4gIHJldHVybiBwb3Ncbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5nZXRFZGdlID0gZnVuY3Rpb24gZ2V0RWRnZSAoKSB7XG4gIHJldHVybiB0aGlzLl9vcmllbnRlZERlXG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlID0gZnVuY3Rpb24gY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlIChkZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb29yZCA9IGRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGlmICh0aGlzJDEuX21pbkNvb3JkID09PSBudWxsIHx8IGNvb3JkW2ldLnggPiB0aGlzJDEuX21pbkNvb3JkLngpIHtcbiAgICAgIHRoaXMkMS5fbWluRGUgPSBkZTtcbiAgICAgIHRoaXMkMS5fbWluSW5kZXggPSBpO1xuICAgICAgdGhpcyQxLl9taW5Db29yZCA9IGNvb3JkW2ldO1xuICAgIH1cbiAgfVxufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmZpbmRSaWdodG1vc3RFZGdlQXROb2RlID0gZnVuY3Rpb24gZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUgKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuX21pbkRlLmdldE5vZGUoKTtcbiAgdmFyIHN0YXIgPSBub2RlLmdldEVkZ2VzKCk7XG4gIHRoaXMuX21pbkRlID0gc3Rhci5nZXRSaWdodG1vc3RFZGdlKCk7XG4gIGlmICghdGhpcy5fbWluRGUuaXNGb3J3YXJkKCkpIHtcbiAgICB0aGlzLl9taW5EZSA9IHRoaXMuX21pbkRlLmdldFN5bSgpO1xuICAgIHRoaXMuX21pbkluZGV4ID0gdGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoIC0gMTtcbiAgfVxufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmZpbmRFZGdlID0gZnVuY3Rpb24gZmluZEVkZ2UgKGRpckVkZ2VMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IGRpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGkubmV4dCgpO1xuICAgIGlmICghZGUuaXNGb3J3YXJkKCkpIHsgY29udGludWUgfVxuICAgIHRoaXMkMS5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUoZGUpO1xuICB9XG4gIEFzc2VydC5pc1RydWUodGhpcy5fbWluSW5kZXggIT09IDAgfHwgdGhpcy5fbWluQ29vcmQuZXF1YWxzKHRoaXMuX21pbkRlLmdldENvb3JkaW5hdGUoKSksICdpbmNvbnNpc3RlbmN5IGluIHJpZ2h0bW9zdCBwcm9jZXNzaW5nJyk7XG4gIGlmICh0aGlzLl9taW5JbmRleCA9PT0gMCkge1xuICAgIHRoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXgoKTtcbiAgfVxuICB0aGlzLl9vcmllbnRlZERlID0gdGhpcy5fbWluRGU7XG4gIHZhciByaWdodG1vc3RTaWRlID0gdGhpcy5nZXRSaWdodG1vc3RTaWRlKHRoaXMuX21pbkRlLCB0aGlzLl9taW5JbmRleCk7XG4gIGlmIChyaWdodG1vc3RTaWRlID09PSBQb3NpdGlvbi5MRUZUKSB7XG4gICAgdGhpcy5fb3JpZW50ZWREZSA9IHRoaXMuX21pbkRlLmdldFN5bSgpO1xuICB9XG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUmlnaHRtb3N0RWRnZUZpbmRlclxufTtcblxudmFyIFRvcG9sb2d5RXhjZXB0aW9uID0gKGZ1bmN0aW9uIChSdW50aW1lRXhjZXB0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIFRvcG9sb2d5RXhjZXB0aW9uIChtc2csIHB0KSB7XG4gICAgUnVudGltZUV4Y2VwdGlvbiQkMS5jYWxsKHRoaXMsIFRvcG9sb2d5RXhjZXB0aW9uLm1zZ1dpdGhDb29yZChtc2csIHB0KSk7XG4gICAgdGhpcy5wdCA9IHB0ID8gbmV3IENvb3JkaW5hdGUocHQpIDogbnVsbDtcbiAgICB0aGlzLm5hbWUgPSAnVG9wb2xvZ3lFeGNlcHRpb24nO1xuICB9XG5cbiAgaWYgKCBSdW50aW1lRXhjZXB0aW9uJCQxICkgVG9wb2xvZ3lFeGNlcHRpb24uX19wcm90b19fID0gUnVudGltZUV4Y2VwdGlvbiQkMTtcbiAgVG9wb2xvZ3lFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUnVudGltZUV4Y2VwdGlvbiQkMSAmJiBSdW50aW1lRXhjZXB0aW9uJCQxLnByb3RvdHlwZSApO1xuICBUb3BvbG9neUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3BvbG9neUV4Y2VwdGlvbjtcbiAgVG9wb2xvZ3lFeGNlcHRpb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdFxuICB9O1xuICBUb3BvbG9neUV4Y2VwdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIFRvcG9sb2d5RXhjZXB0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gVG9wb2xvZ3lFeGNlcHRpb25cbiAgfTtcbiAgVG9wb2xvZ3lFeGNlcHRpb24ubXNnV2l0aENvb3JkID0gZnVuY3Rpb24gbXNnV2l0aENvb3JkIChtc2csIHB0KSB7XG4gICAgaWYgKCFwdCkgeyByZXR1cm4gbXNnICsgJyBbICcgKyBwdCArICcgXScgfVxuICAgIHJldHVybiBtc2dcbiAgfTtcblxuICByZXR1cm4gVG9wb2xvZ3lFeGNlcHRpb247XG59KFJ1bnRpbWVFeGNlcHRpb24pKTtcblxudmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbiBMaW5rZWRMaXN0ICgpIHtcbiAgdGhpcy5hcnJheV8gPSBbXTtcbn07XG5MaW5rZWRMaXN0LnByb3RvdHlwZS5hZGRMYXN0ID0gZnVuY3Rpb24gYWRkTGFzdCAoZSkge1xuICB0aGlzLmFycmF5Xy5wdXNoKGUpO1xufTtcbkxpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZUZpcnN0ID0gZnVuY3Rpb24gcmVtb3ZlRmlyc3QgKCkge1xuICByZXR1cm4gdGhpcy5hcnJheV8uc2hpZnQoKVxufTtcbkxpbmtlZExpc3QucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgcmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMFxufTtcblxudmFyIEJ1ZmZlclN1YmdyYXBoID0gZnVuY3Rpb24gQnVmZmVyU3ViZ3JhcGggKCkge1xuICB0aGlzLl9maW5kZXIgPSBudWxsO1xuICB0aGlzLl9kaXJFZGdlTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fbm9kZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX3JpZ2h0TW9zdENvb3JkID0gbnVsbDtcbiAgdGhpcy5fZW52ID0gbnVsbDtcbiAgdGhpcy5fZmluZGVyID0gbmV3IFJpZ2h0bW9zdEVkZ2VGaW5kZXIoKTtcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuY2xlYXJWaXNpdGVkRWRnZXMgPSBmdW5jdGlvbiBjbGVhclZpc2l0ZWRFZGdlcyAoKSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICBkZS5zZXRWaXNpdGVkKGZhbHNlKTtcbiAgfVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5nZXRSaWdodG1vc3RDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9yaWdodE1vc3RDb29yZFxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jb21wdXRlTm9kZURlcHRoID0gZnVuY3Rpb24gY29tcHV0ZU5vZGVEZXB0aCAobikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydEVkZ2UgPSBudWxsO1xuICBmb3IgKHZhciBpID0gbi5nZXRFZGdlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGkubmV4dCgpO1xuICAgIGlmIChkZS5pc1Zpc2l0ZWQoKSB8fCBkZS5nZXRTeW0oKS5pc1Zpc2l0ZWQoKSkge1xuICAgICAgc3RhcnRFZGdlID0gZGU7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnRFZGdlID09PSBudWxsKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbigndW5hYmxlIHRvIGZpbmQgZWRnZSB0byBjb21wdXRlIGRlcHRocyBhdCAnICsgbi5nZXRDb29yZGluYXRlKCkpIH1cbiAgbi5nZXRFZGdlcygpLmNvbXB1dGVEZXB0aHMoc3RhcnRFZGdlKTtcbiAgZm9yICh2YXIgaSQxID0gbi5nZXRFZGdlcygpLml0ZXJhdG9yKCk7IGkkMS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlJDEgPSBpJDEubmV4dCgpO1xuICAgIGRlJDEuc2V0VmlzaXRlZCh0cnVlKTtcbiAgICB0aGlzJDEuY29weVN5bURlcHRocyhkZSQxKTtcbiAgfVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jb21wdXRlRGVwdGggPSBmdW5jdGlvbiBjb21wdXRlRGVwdGggKG91dHNpZGVEZXB0aCkge1xuICB0aGlzLmNsZWFyVmlzaXRlZEVkZ2VzKCk7XG4gIHZhciBkZSA9IHRoaXMuX2ZpbmRlci5nZXRFZGdlKCk7XG4gIC8vIGNvbnN0IG4gPSBkZS5nZXROb2RlKClcbiAgLy8gY29uc3QgbGFiZWwgPSBkZS5nZXRMYWJlbCgpXG4gIGRlLnNldEVkZ2VEZXB0aHMoUG9zaXRpb24uUklHSFQsIG91dHNpZGVEZXB0aCk7XG4gIHRoaXMuY29weVN5bURlcHRocyhkZSk7XG4gIHRoaXMuY29tcHV0ZURlcHRocyhkZSk7XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAobm9kZSkge1xuICB0aGlzLmFkZFJlYWNoYWJsZShub2RlKTtcbiAgdGhpcy5fZmluZGVyLmZpbmRFZGdlKHRoaXMuX2RpckVkZ2VMaXN0KTtcbiAgdGhpcy5fcmlnaHRNb3N0Q29vcmQgPSB0aGlzLl9maW5kZXIuZ2V0Q29vcmRpbmF0ZSgpO1xufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5maW5kUmVzdWx0RWRnZXMgPSBmdW5jdGlvbiBmaW5kUmVzdWx0RWRnZXMgKCkge1xuICBmb3IgKHZhciBpdCA9IHRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGRlLmdldERlcHRoKFBvc2l0aW9uLlJJR0hUKSA+PSAxICYmIGRlLmdldERlcHRoKFBvc2l0aW9uLkxFRlQpIDw9IDAgJiYgIWRlLmlzSW50ZXJpb3JBcmVhRWRnZSgpKSB7XG4gICAgICBkZS5zZXRJblJlc3VsdCh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuY29tcHV0ZURlcHRocyA9IGZ1bmN0aW9uIGNvbXB1dGVEZXB0aHMgKHN0YXJ0RWRnZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBub2Rlc1Zpc2l0ZWQgPSBuZXcgSGFzaFNldCgpO1xuICB2YXIgbm9kZVF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdmFyIHN0YXJ0Tm9kZSA9IHN0YXJ0RWRnZS5nZXROb2RlKCk7XG4gIG5vZGVRdWV1ZS5hZGRMYXN0KHN0YXJ0Tm9kZSk7XG4gIG5vZGVzVmlzaXRlZC5hZGQoc3RhcnROb2RlKTtcbiAgc3RhcnRFZGdlLnNldFZpc2l0ZWQodHJ1ZSk7XG4gIHdoaWxlICghbm9kZVF1ZXVlLmlzRW1wdHkoKSkge1xuICAgIHZhciBuID0gbm9kZVF1ZXVlLnJlbW92ZUZpcnN0KCk7XG4gICAgbm9kZXNWaXNpdGVkLmFkZChuKTtcbiAgICB0aGlzJDEuY29tcHV0ZU5vZGVEZXB0aChuKTtcbiAgICBmb3IgKHZhciBpID0gbi5nZXRFZGdlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaS5uZXh0KCk7XG4gICAgICB2YXIgc3ltID0gZGUuZ2V0U3ltKCk7XG4gICAgICBpZiAoc3ltLmlzVmlzaXRlZCgpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBhZGpOb2RlID0gc3ltLmdldE5vZGUoKTtcbiAgICAgIGlmICghbm9kZXNWaXNpdGVkLmNvbnRhaW5zKGFkak5vZGUpKSB7XG4gICAgICAgIG5vZGVRdWV1ZS5hZGRMYXN0KGFkak5vZGUpO1xuICAgICAgICBub2Rlc1Zpc2l0ZWQuYWRkKGFkak5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIGdyYXBoID0gbztcbiAgaWYgKHRoaXMuX3JpZ2h0TW9zdENvb3JkLnggPCBncmFwaC5fcmlnaHRNb3N0Q29vcmQueCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmICh0aGlzLl9yaWdodE1vc3RDb29yZC54ID4gZ3JhcGguX3JpZ2h0TW9zdENvb3JkLngpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmdldEVudmVsb3BlID0gZnVuY3Rpb24gZ2V0RW52ZWxvcGUgKCkge1xuICBpZiAodGhpcy5fZW52ID09PSBudWxsKSB7XG4gICAgdmFyIGVkZ2VFbnYgPSBuZXcgRW52ZWxvcGUoKTtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkaXJFZGdlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIHB0cyA9IGRpckVkZ2UuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgZWRnZUVudi5leHBhbmRUb0luY2x1ZGUocHRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZW52ID0gZWRnZUVudjtcbiAgfVxuICByZXR1cm4gdGhpcy5fZW52XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmFkZFJlYWNoYWJsZSA9IGZ1bmN0aW9uIGFkZFJlYWNoYWJsZSAoc3RhcnROb2RlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGVTdGFjayA9IG5ldyBTdGFjaygpO1xuICBub2RlU3RhY2suYWRkKHN0YXJ0Tm9kZSk7XG4gIHdoaWxlICghbm9kZVN0YWNrLmVtcHR5KCkpIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVTdGFjay5wb3AoKTtcbiAgICB0aGlzJDEuYWRkKG5vZGUsIG5vZGVTdGFjayk7XG4gIH1cbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuY29weVN5bURlcHRocyA9IGZ1bmN0aW9uIGNvcHlTeW1EZXB0aHMgKGRlKSB7XG4gIHZhciBzeW0gPSBkZS5nZXRTeW0oKTtcbiAgc3ltLnNldERlcHRoKFBvc2l0aW9uLkxFRlQsIGRlLmdldERlcHRoKFBvc2l0aW9uLlJJR0hUKSk7XG4gIHN5bS5zZXREZXB0aChQb3NpdGlvbi5SSUdIVCwgZGUuZ2V0RGVwdGgoUG9zaXRpb24uTEVGVCkpO1xufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG5vZGUsIG5vZGVTdGFjaykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIG5vZGUuc2V0VmlzaXRlZCh0cnVlKTtcbiAgdGhpcy5fbm9kZXMuYWRkKG5vZGUpO1xuICBmb3IgKHZhciBpID0gbm9kZS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGkubmV4dCgpO1xuICAgIHRoaXMkMS5fZGlyRWRnZUxpc3QuYWRkKGRlKTtcbiAgICB2YXIgc3ltID0gZGUuZ2V0U3ltKCk7XG4gICAgdmFyIHN5bU5vZGUgPSBzeW0uZ2V0Tm9kZSgpO1xuICAgIGlmICghc3ltTm9kZS5pc1Zpc2l0ZWQoKSkgeyBub2RlU3RhY2sucHVzaChzeW1Ob2RlKTsgfVxuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gZ2V0Tm9kZXMgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXNcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuZ2V0RGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGdldERpcmVjdGVkRWRnZXMgKCkge1xuICByZXR1cm4gdGhpcy5fZGlyRWRnZUxpc3Rcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJTdWJncmFwaFxufTtcblxudmFyIFRvcG9sb2d5TG9jYXRpb24gPSBmdW5jdGlvbiBUb3BvbG9neUxvY2F0aW9uICgpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5sb2NhdGlvbiA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQobG9jYXRpb24ubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSkge1xuICAgICAgdmFyIG9uID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KDEpO1xuICAgICAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5PTl0gPSBvbjtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFRvcG9sb2d5TG9jYXRpb24pIHtcbiAgICAgIHZhciBnbCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdChnbC5sb2NhdGlvbi5sZW5ndGgpO1xuICAgICAgaWYgKGdsICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMkMS5sb2NhdGlvbltpXSA9IGdsLmxvY2F0aW9uW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgb24kMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGVmdCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcmlnaHQgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5pbml0KDMpO1xuICAgIHRoaXMubG9jYXRpb25bUG9zaXRpb24uT05dID0gb24kMTtcbiAgICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLkxFRlRdID0gbGVmdDtcbiAgICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLlJJR0hUXSA9IHJpZ2h0O1xuICB9XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuc2V0QWxsTG9jYXRpb25zID0gZnVuY3Rpb24gc2V0QWxsTG9jYXRpb25zIChsb2NWYWx1ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMkMS5sb2NhdGlvbltpXSA9IGxvY1ZhbHVlO1xuICB9XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaXNOdWxsID0gZnVuY3Rpb24gaXNOdWxsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLmxvY2F0aW9uW2ldICE9PSBMb2NhdGlvbi5OT05FKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5zZXRBbGxMb2NhdGlvbnNJZk51bGwgPSBmdW5jdGlvbiBzZXRBbGxMb2NhdGlvbnNJZk51bGwgKGxvY1ZhbHVlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5sb2NhdGlvbltpXSA9PT0gTG9jYXRpb24uTk9ORSkgeyB0aGlzJDEubG9jYXRpb25baV0gPSBsb2NWYWx1ZTsgfVxuICB9XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaXNMaW5lID0gZnVuY3Rpb24gaXNMaW5lICgpIHtcbiAgcmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoID09PSAxXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSAoZ2wpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoZ2wubG9jYXRpb24ubGVuZ3RoID4gdGhpcy5sb2NhdGlvbi5sZW5ndGgpIHtcbiAgICB2YXIgbmV3TG9jID0gbmV3IEFycmF5KDMpLmZpbGwobnVsbCk7XG4gICAgbmV3TG9jW1Bvc2l0aW9uLk9OXSA9IHRoaXMubG9jYXRpb25bUG9zaXRpb24uT05dO1xuICAgIG5ld0xvY1tQb3NpdGlvbi5MRUZUXSA9IExvY2F0aW9uLk5PTkU7XG4gICAgbmV3TG9jW1Bvc2l0aW9uLlJJR0hUXSA9IExvY2F0aW9uLk5PTkU7XG4gICAgdGhpcy5sb2NhdGlvbiA9IG5ld0xvYztcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLmxvY2F0aW9uW2ldID09PSBMb2NhdGlvbi5OT05FICYmIGkgPCBnbC5sb2NhdGlvbi5sZW5ndGgpIHsgdGhpcyQxLmxvY2F0aW9uW2ldID0gZ2wubG9jYXRpb25baV07IH1cbiAgfVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmdldExvY2F0aW9ucyA9IGZ1bmN0aW9uIGdldExvY2F0aW9ucyAoKSB7XG4gIHJldHVybiB0aGlzLmxvY2F0aW9uXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuZmxpcCA9IGZ1bmN0aW9uIGZsaXAgKCkge1xuICBpZiAodGhpcy5sb2NhdGlvbi5sZW5ndGggPD0gMSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciB0ZW1wID0gdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5MRUZUXTtcbiAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5MRUZUXSA9IHRoaXMubG9jYXRpb25bUG9zaXRpb24uUklHSFRdO1xuICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLlJJR0hUXSA9IHRlbXA7XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gIGlmICh0aGlzLmxvY2F0aW9uLmxlbmd0aCA+IDEpIHsgYnVmLmFwcGVuZChMb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bUG9zaXRpb24uTEVGVF0pKTsgfVxuICBidWYuYXBwZW5kKExvY2F0aW9uLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltQb3NpdGlvbi5PTl0pKTtcbiAgaWYgKHRoaXMubG9jYXRpb24ubGVuZ3RoID4gMSkgeyBidWYuYXBwZW5kKExvY2F0aW9uLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltQb3NpdGlvbi5SSUdIVF0pKTsgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKClcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5zZXRMb2NhdGlvbnMgPSBmdW5jdGlvbiBzZXRMb2NhdGlvbnMgKG9uLCBsZWZ0LCByaWdodCkge1xuICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLk9OXSA9IG9uO1xuICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLkxFRlRdID0gbGVmdDtcbiAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5SSUdIVF0gPSByaWdodDtcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKHBvc0luZGV4KSB7XG4gIGlmIChwb3NJbmRleCA8IHRoaXMubG9jYXRpb24ubGVuZ3RoKSB7IHJldHVybiB0aGlzLmxvY2F0aW9uW3Bvc0luZGV4XSB9XG4gIHJldHVybiBMb2NhdGlvbi5OT05FXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaXNBcmVhID0gZnVuY3Rpb24gaXNBcmVhICgpIHtcbiAgcmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoID4gMVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmlzQW55TnVsbCA9IGZ1bmN0aW9uIGlzQW55TnVsbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5sb2NhdGlvbltpXSA9PT0gTG9jYXRpb24uTk9ORSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiBzZXRMb2NhdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxvY1ZhbHVlID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0TG9jYXRpb24oUG9zaXRpb24uT04sIGxvY1ZhbHVlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGxvY0luZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsb2NWYWx1ZSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMubG9jYXRpb25bbG9jSW5kZXhdID0gbG9jVmFsdWUkMTtcbiAgfVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChzaXplKSB7XG4gIHRoaXMubG9jYXRpb24gPSBuZXcgQXJyYXkoc2l6ZSkuZmlsbChudWxsKTtcbiAgdGhpcy5zZXRBbGxMb2NhdGlvbnMoTG9jYXRpb24uTk9ORSk7XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaXNFcXVhbE9uU2lkZSA9IGZ1bmN0aW9uIGlzRXF1YWxPblNpZGUgKGxlLCBsb2NJbmRleCkge1xuICByZXR1cm4gdGhpcy5sb2NhdGlvbltsb2NJbmRleF0gPT09IGxlLmxvY2F0aW9uW2xvY0luZGV4XVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmFsbFBvc2l0aW9uc0VxdWFsID0gZnVuY3Rpb24gYWxsUG9zaXRpb25zRXF1YWwgKGxvYykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzJDEubG9jYXRpb25baV0gIT09IGxvYykgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gVG9wb2xvZ3lMb2NhdGlvblxufTtcblxudmFyIExhYmVsID0gZnVuY3Rpb24gTGFiZWwgKCkge1xuICB0aGlzLmVsdCA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHZhciBvbkxvYyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuZWx0WzBdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24ob25Mb2MpO1xuICAgICAgdGhpcy5lbHRbMV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihvbkxvYyk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMYWJlbCkge1xuICAgICAgdmFyIGxibCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuZWx0WzBdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24obGJsLmVsdFswXSk7XG4gICAgICB0aGlzLmVsdFsxXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKGxibC5lbHRbMV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb25Mb2MkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmVsdFswXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKExvY2F0aW9uLk5PTkUpO1xuICAgIHRoaXMuZWx0WzFdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24oTG9jYXRpb24uTk9ORSk7XG4gICAgdGhpcy5lbHRbZ2VvbUluZGV4XS5zZXRMb2NhdGlvbihvbkxvYyQxKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIG9uTG9jJDIgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxlZnRMb2MgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHJpZ2h0TG9jID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuZWx0WzBdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24ob25Mb2MkMiwgbGVmdExvYywgcmlnaHRMb2MpO1xuICAgIHRoaXMuZWx0WzFdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24ob25Mb2MkMiwgbGVmdExvYywgcmlnaHRMb2MpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgZ2VvbUluZGV4JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9uTG9jJDMgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxlZnRMb2MkMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgcmlnaHRMb2MkMSA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLmVsdFswXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKExvY2F0aW9uLk5PTkUsIExvY2F0aW9uLk5PTkUsIExvY2F0aW9uLk5PTkUpO1xuICAgIHRoaXMuZWx0WzFdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24oTG9jYXRpb24uTk9ORSwgTG9jYXRpb24uTk9ORSwgTG9jYXRpb24uTk9ORSk7XG4gICAgdGhpcy5lbHRbZ2VvbUluZGV4JDFdLnNldExvY2F0aW9ucyhvbkxvYyQzLCBsZWZ0TG9jJDEsIHJpZ2h0TG9jJDEpO1xuICB9XG59O1xuTGFiZWwucHJvdG90eXBlLmdldEdlb21ldHJ5Q291bnQgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeUNvdW50ICgpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgaWYgKCF0aGlzLmVsdFswXS5pc051bGwoKSkgeyBjb3VudCsrOyB9XG4gIGlmICghdGhpcy5lbHRbMV0uaXNOdWxsKCkpIHsgY291bnQrKzsgfVxuICByZXR1cm4gY291bnRcbn07XG5MYWJlbC5wcm90b3R5cGUuc2V0QWxsTG9jYXRpb25zID0gZnVuY3Rpb24gc2V0QWxsTG9jYXRpb25zIChnZW9tSW5kZXgsIGxvY2F0aW9uKSB7XG4gIHRoaXMuZWx0W2dlb21JbmRleF0uc2V0QWxsTG9jYXRpb25zKGxvY2F0aW9uKTtcbn07XG5MYWJlbC5wcm90b3R5cGUuaXNOdWxsID0gZnVuY3Rpb24gaXNOdWxsIChnZW9tSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleF0uaXNOdWxsKClcbn07XG5MYWJlbC5wcm90b3R5cGUuc2V0QWxsTG9jYXRpb25zSWZOdWxsID0gZnVuY3Rpb24gc2V0QWxsTG9jYXRpb25zSWZOdWxsICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbG9jYXRpb24gPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCwgbG9jYXRpb24pO1xuICAgIHRoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsIGxvY2F0aW9uKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG9jYXRpb24kMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmVsdFtnZW9tSW5kZXhdLnNldEFsbExvY2F0aW9uc0lmTnVsbChsb2NhdGlvbiQxKTtcbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5pc0xpbmUgPSBmdW5jdGlvbiBpc0xpbmUgKGdlb21JbmRleCkge1xuICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4XS5pc0xpbmUoKVxufTtcbkxhYmVsLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlIChsYmwpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGlmICh0aGlzJDEuZWx0W2ldID09PSBudWxsICYmIGxibC5lbHRbaV0gIT09IG51bGwpIHtcbiAgICAgIHRoaXMkMS5lbHRbaV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihsYmwuZWx0W2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcyQxLmVsdFtpXS5tZXJnZShsYmwuZWx0W2ldKTtcbiAgICB9XG4gIH1cbn07XG5MYWJlbC5wcm90b3R5cGUuZmxpcCA9IGZ1bmN0aW9uIGZsaXAgKCkge1xuICB0aGlzLmVsdFswXS5mbGlwKCk7XG4gIHRoaXMuZWx0WzFdLmZsaXAoKTtcbn07XG5MYWJlbC5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4XS5nZXQoUG9zaXRpb24uT04pXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tSW5kZXgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcG9zSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleCQxXS5nZXQocG9zSW5kZXgpXG4gIH1cbn07XG5MYWJlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gIGlmICh0aGlzLmVsdFswXSAhPT0gbnVsbCkge1xuICAgIGJ1Zi5hcHBlbmQoJ0E6Jyk7XG4gICAgYnVmLmFwcGVuZCh0aGlzLmVsdFswXS50b1N0cmluZygpKTtcbiAgfVxuICBpZiAodGhpcy5lbHRbMV0gIT09IG51bGwpIHtcbiAgICBidWYuYXBwZW5kKCcgQjonKTtcbiAgICBidWYuYXBwZW5kKHRoaXMuZWx0WzFdLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoKVxufTtcbkxhYmVsLnByb3RvdHlwZS5pc0FyZWEgPSBmdW5jdGlvbiBpc0FyZWEgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLmVsdFswXS5pc0FyZWEoKSB8fCB0aGlzLmVsdFsxXS5pc0FyZWEoKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXhdLmlzQXJlYSgpXG4gIH1cbn07XG5MYWJlbC5wcm90b3R5cGUuaXNBbnlOdWxsID0gZnVuY3Rpb24gaXNBbnlOdWxsIChnZW9tSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleF0uaXNBbnlOdWxsKClcbn07XG5MYWJlbC5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiBzZXRMb2NhdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG9jYXRpb24gPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5lbHRbZ2VvbUluZGV4XS5zZXRMb2NhdGlvbihQb3NpdGlvbi5PTiwgbG9jYXRpb24pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgZ2VvbUluZGV4JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBvc0luZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsb2NhdGlvbiQxID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuZWx0W2dlb21JbmRleCQxXS5zZXRMb2NhdGlvbihwb3NJbmRleCwgbG9jYXRpb24kMSk7XG4gIH1cbn07XG5MYWJlbC5wcm90b3R5cGUuaXNFcXVhbE9uU2lkZSA9IGZ1bmN0aW9uIGlzRXF1YWxPblNpZGUgKGxibCwgc2lkZSkge1xuICByZXR1cm4gdGhpcy5lbHRbMF0uaXNFcXVhbE9uU2lkZShsYmwuZWx0WzBdLCBzaWRlKSAmJiB0aGlzLmVsdFsxXS5pc0VxdWFsT25TaWRlKGxibC5lbHRbMV0sIHNpZGUpXG59O1xuTGFiZWwucHJvdG90eXBlLmFsbFBvc2l0aW9uc0VxdWFsID0gZnVuY3Rpb24gYWxsUG9zaXRpb25zRXF1YWwgKGdlb21JbmRleCwgbG9jKSB7XG4gIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXhdLmFsbFBvc2l0aW9uc0VxdWFsKGxvYylcbn07XG5MYWJlbC5wcm90b3R5cGUudG9MaW5lID0gZnVuY3Rpb24gdG9MaW5lIChnZW9tSW5kZXgpIHtcbiAgaWYgKHRoaXMuZWx0W2dlb21JbmRleF0uaXNBcmVhKCkpIHsgdGhpcy5lbHRbZ2VvbUluZGV4XSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKHRoaXMuZWx0W2dlb21JbmRleF0ubG9jYXRpb25bMF0pOyB9XG59O1xuTGFiZWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5MYWJlbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMYWJlbFxufTtcbkxhYmVsLnRvTGluZUxhYmVsID0gZnVuY3Rpb24gdG9MaW5lTGFiZWwgKGxhYmVsKSB7XG4gIHZhciBsaW5lTGFiZWwgPSBuZXcgTGFiZWwoTG9jYXRpb24uTk9ORSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgbGluZUxhYmVsLnNldExvY2F0aW9uKGksIGxhYmVsLmdldExvY2F0aW9uKGkpKTtcbiAgfVxuICByZXR1cm4gbGluZUxhYmVsXG59O1xuXG52YXIgRWRnZVJpbmcgPSBmdW5jdGlvbiBFZGdlUmluZyAoKSB7XG4gIHRoaXMuX3N0YXJ0RGUgPSBudWxsO1xuICB0aGlzLl9tYXhOb2RlRGVncmVlID0gLTE7XG4gIHRoaXMuX2VkZ2VzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9wdHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX2xhYmVsID0gbmV3IExhYmVsKExvY2F0aW9uLk5PTkUpO1xuICB0aGlzLl9yaW5nID0gbnVsbDtcbiAgdGhpcy5faXNIb2xlID0gbnVsbDtcbiAgdGhpcy5fc2hlbGwgPSBudWxsO1xuICB0aGlzLl9ob2xlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gbnVsbDtcbiAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZ2VvbWV0cnlGYWN0b3J5ID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3Rvcnk7XG4gIHRoaXMuY29tcHV0ZVBvaW50cyhzdGFydCk7XG4gIHRoaXMuY29tcHV0ZVJpbmcoKTtcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuY29tcHV0ZVJpbmcgPSBmdW5jdGlvbiBjb21wdXRlUmluZyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuX3JpbmcgIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgY29vcmQgPSBuZXcgQXJyYXkodGhpcy5fcHRzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wdHMuc2l6ZSgpOyBpKyspIHtcbiAgICBjb29yZFtpXSA9IHRoaXMkMS5fcHRzLmdldChpKTtcbiAgfVxuICB0aGlzLl9yaW5nID0gdGhpcy5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoY29vcmQpO1xuICB0aGlzLl9pc0hvbGUgPSBDR0FsZ29yaXRobXMuaXNDQ1codGhpcy5fcmluZy5nZXRDb29yZGluYXRlcygpKTtcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuaXNJc29sYXRlZCA9IGZ1bmN0aW9uIGlzSXNvbGF0ZWQgKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpID09PSAxXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmNvbXB1dGVQb2ludHMgPSBmdW5jdGlvbiBjb21wdXRlUG9pbnRzIChzdGFydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX3N0YXJ0RGUgPSBzdGFydDtcbiAgdmFyIGRlID0gc3RhcnQ7XG4gIHZhciBpc0ZpcnN0RWRnZSA9IHRydWU7XG4gIGRvIHtcbiAgICBpZiAoZGUgPT09IG51bGwpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdGb3VuZCBudWxsIERpcmVjdGVkRWRnZScpIH1cbiAgICBpZiAoZGUuZ2V0RWRnZVJpbmcoKSA9PT0gdGhpcyQxKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbignRGlyZWN0ZWQgRWRnZSB2aXNpdGVkIHR3aWNlIGR1cmluZyByaW5nLWJ1aWxkaW5nIGF0ICcgKyBkZS5nZXRDb29yZGluYXRlKCkpIH1cbiAgICB0aGlzJDEuX2VkZ2VzLmFkZChkZSk7XG4gICAgdmFyIGxhYmVsID0gZGUuZ2V0TGFiZWwoKTtcbiAgICBBc3NlcnQuaXNUcnVlKGxhYmVsLmlzQXJlYSgpKTtcbiAgICB0aGlzJDEubWVyZ2VMYWJlbChsYWJlbCk7XG4gICAgdGhpcyQxLmFkZFBvaW50cyhkZS5nZXRFZGdlKCksIGRlLmlzRm9yd2FyZCgpLCBpc0ZpcnN0RWRnZSk7XG4gICAgaXNGaXJzdEVkZ2UgPSBmYWxzZTtcbiAgICB0aGlzJDEuc2V0RWRnZVJpbmcoZGUsIHRoaXMkMSk7XG4gICAgZGUgPSB0aGlzJDEuZ2V0TmV4dChkZSk7XG4gIH0gd2hpbGUgKGRlICE9PSB0aGlzLl9zdGFydERlKVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRMaW5lYXJSaW5nID0gZnVuY3Rpb24gZ2V0TGluZWFyUmluZyAoKSB7XG4gIHJldHVybiB0aGlzLl9yaW5nXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7XG4gIHJldHVybiB0aGlzLl9wdHMuZ2V0KGkpXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmNvbXB1dGVNYXhOb2RlRGVncmVlID0gZnVuY3Rpb24gY29tcHV0ZU1heE5vZGVEZWdyZWUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX21heE5vZGVEZWdyZWUgPSAwO1xuICB2YXIgZGUgPSB0aGlzLl9zdGFydERlO1xuICBkbyB7XG4gICAgdmFyIG5vZGUgPSBkZS5nZXROb2RlKCk7XG4gICAgdmFyIGRlZ3JlZSA9IG5vZGUuZ2V0RWRnZXMoKS5nZXRPdXRnb2luZ0RlZ3JlZSh0aGlzJDEpO1xuICAgIGlmIChkZWdyZWUgPiB0aGlzJDEuX21heE5vZGVEZWdyZWUpIHsgdGhpcyQxLl9tYXhOb2RlRGVncmVlID0gZGVncmVlOyB9XG4gICAgZGUgPSB0aGlzJDEuZ2V0TmV4dChkZSk7XG4gIH0gd2hpbGUgKGRlICE9PSB0aGlzLl9zdGFydERlKVxuICB0aGlzLl9tYXhOb2RlRGVncmVlICo9IDI7XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmFkZFBvaW50cyA9IGZ1bmN0aW9uIGFkZFBvaW50cyAoZWRnZSwgaXNGb3J3YXJkLCBpc0ZpcnN0RWRnZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlZGdlUHRzID0gZWRnZS5nZXRDb29yZGluYXRlcygpO1xuICBpZiAoaXNGb3J3YXJkKSB7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSAxO1xuICAgIGlmIChpc0ZpcnN0RWRnZSkgeyBzdGFydEluZGV4ID0gMDsgfVxuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZWRnZVB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcyQxLl9wdHMuYWRkKGVkZ2VQdHNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RhcnRJbmRleCQxID0gZWRnZVB0cy5sZW5ndGggLSAyO1xuICAgIGlmIChpc0ZpcnN0RWRnZSkgeyBzdGFydEluZGV4JDEgPSBlZGdlUHRzLmxlbmd0aCAtIDE7IH1cbiAgICBmb3IgKHZhciBpJDEgPSBzdGFydEluZGV4JDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgdGhpcyQxLl9wdHMuYWRkKGVkZ2VQdHNbaSQxXSk7XG4gICAgfVxuICB9XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmlzSG9sZSA9IGZ1bmN0aW9uIGlzSG9sZSAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0hvbGVcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuc2V0SW5SZXN1bHQgPSBmdW5jdGlvbiBzZXRJblJlc3VsdCAoKSB7XG4gIHZhciBkZSA9IHRoaXMuX3N0YXJ0RGU7XG4gIGRvIHtcbiAgICBkZS5nZXRFZGdlKCkuc2V0SW5SZXN1bHQodHJ1ZSk7XG4gICAgZGUgPSBkZS5nZXROZXh0KCk7XG4gIH0gd2hpbGUgKGRlICE9PSB0aGlzLl9zdGFydERlKVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gY29udGFpbnNQb2ludCAocCkge1xuICB2YXIgc2hlbGwgPSB0aGlzLmdldExpbmVhclJpbmcoKTtcbiAgdmFyIGVudiA9IHNoZWxsLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgaWYgKCFlbnYuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCFDR0FsZ29yaXRobXMuaXNQb2ludEluUmluZyhwLCBzaGVsbC5nZXRDb29yZGluYXRlcygpKSkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gdGhpcy5faG9sZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGhvbGUgPSBpLm5leHQoKTtcbiAgICBpZiAoaG9sZS5jb250YWluc1BvaW50KHApKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuYWRkSG9sZSA9IGZ1bmN0aW9uIGFkZEhvbGUgKHJpbmcpIHtcbiAgdGhpcy5faG9sZXMuYWRkKHJpbmcpO1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5pc1NoZWxsID0gZnVuY3Rpb24gaXNTaGVsbCAoKSB7XG4gIHJldHVybiB0aGlzLl9zaGVsbCA9PT0gbnVsbFxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uIGdldExhYmVsICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xhYmVsXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gZ2V0RWRnZXMgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZXNcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0TWF4Tm9kZURlZ3JlZSA9IGZ1bmN0aW9uIGdldE1heE5vZGVEZWdyZWUgKCkge1xuICBpZiAodGhpcy5fbWF4Tm9kZURlZ3JlZSA8IDApIHsgdGhpcy5jb21wdXRlTWF4Tm9kZURlZ3JlZSgpOyB9XG4gIHJldHVybiB0aGlzLl9tYXhOb2RlRGVncmVlXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldFNoZWxsID0gZnVuY3Rpb24gZ2V0U2hlbGwgKCkge1xuICByZXR1cm4gdGhpcy5fc2hlbGxcbn07XG5FZGdlUmluZy5wcm90b3R5cGUubWVyZ2VMYWJlbCA9IGZ1bmN0aW9uIG1lcmdlTGFiZWwgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBkZUxhYmVsID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMubWVyZ2VMYWJlbChkZUxhYmVsLCAwKTtcbiAgICB0aGlzLm1lcmdlTGFiZWwoZGVMYWJlbCwgMSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBkZUxhYmVsJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbG9jID0gZGVMYWJlbCQxLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uUklHSFQpO1xuICAgIGlmIChsb2MgPT09IExvY2F0aW9uLk5PTkUpIHsgcmV0dXJuIG51bGwgfVxuICAgIGlmICh0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgpID09PSBMb2NhdGlvbi5OT05FKSB7XG4gICAgICB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbihnZW9tSW5kZXgsIGxvYyk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5zZXRTaGVsbCA9IGZ1bmN0aW9uIHNldFNoZWxsIChzaGVsbCkge1xuICB0aGlzLl9zaGVsbCA9IHNoZWxsO1xuICBpZiAoc2hlbGwgIT09IG51bGwpIHsgc2hlbGwuYWRkSG9sZSh0aGlzKTsgfVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS50b1BvbHlnb24gPSBmdW5jdGlvbiB0b1BvbHlnb24gKGdlb21ldHJ5RmFjdG9yeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBob2xlTFIgPSBuZXcgQXJyYXkodGhpcy5faG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLnNpemUoKTsgaSsrKSB7XG4gICAgaG9sZUxSW2ldID0gdGhpcyQxLl9ob2xlcy5nZXQoaSkuZ2V0TGluZWFyUmluZygpO1xuICB9XG4gIHZhciBwb2x5ID0gZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24odGhpcy5nZXRMaW5lYXJSaW5nKCksIGhvbGVMUik7XG4gIHJldHVybiBwb2x5XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlUmluZ1xufTtcblxudmFyIE1pbmltYWxFZGdlUmluZyA9IChmdW5jdGlvbiAoRWRnZVJpbmckJDEpIHtcbiAgZnVuY3Rpb24gTWluaW1hbEVkZ2VSaW5nICgpIHtcbiAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGdlb21ldHJ5RmFjdG9yeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBFZGdlUmluZyQkMS5jYWxsKHRoaXMsIHN0YXJ0LCBnZW9tZXRyeUZhY3RvcnkpO1xuICB9XG5cbiAgaWYgKCBFZGdlUmluZyQkMSApIE1pbmltYWxFZGdlUmluZy5fX3Byb3RvX18gPSBFZGdlUmluZyQkMTtcbiAgTWluaW1hbEVkZ2VSaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VSaW5nJCQxICYmIEVkZ2VSaW5nJCQxLnByb3RvdHlwZSApO1xuICBNaW5pbWFsRWRnZVJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWluaW1hbEVkZ2VSaW5nO1xuICBNaW5pbWFsRWRnZVJpbmcucHJvdG90eXBlLnNldEVkZ2VSaW5nID0gZnVuY3Rpb24gc2V0RWRnZVJpbmcgKGRlLCBlcikge1xuICAgIGRlLnNldE1pbkVkZ2VSaW5nKGVyKTtcbiAgfTtcbiAgTWluaW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gZ2V0TmV4dCAoZGUpIHtcbiAgICByZXR1cm4gZGUuZ2V0TmV4dE1pbigpXG4gIH07XG4gIE1pbmltYWxFZGdlUmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE1pbmltYWxFZGdlUmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE1pbmltYWxFZGdlUmluZ1xuICB9O1xuXG4gIHJldHVybiBNaW5pbWFsRWRnZVJpbmc7XG59KEVkZ2VSaW5nKSk7XG5cbnZhciBNYXhpbWFsRWRnZVJpbmcgPSAoZnVuY3Rpb24gKEVkZ2VSaW5nJCQxKSB7XG4gIGZ1bmN0aW9uIE1heGltYWxFZGdlUmluZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMV07XG4gICAgRWRnZVJpbmckJDEuY2FsbCh0aGlzLCBzdGFydCwgZ2VvbWV0cnlGYWN0b3J5KTtcbiAgfVxuXG4gIGlmICggRWRnZVJpbmckJDEgKSBNYXhpbWFsRWRnZVJpbmcuX19wcm90b19fID0gRWRnZVJpbmckJDE7XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFZGdlUmluZyQkMSAmJiBFZGdlUmluZyQkMS5wcm90b3R5cGUgKTtcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1heGltYWxFZGdlUmluZztcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5idWlsZE1pbmltYWxSaW5ncyA9IGZ1bmN0aW9uIGJ1aWxkTWluaW1hbFJpbmdzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBtaW5FZGdlUmluZ3MgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdmFyIGRlID0gdGhpcy5fc3RhcnREZTtcbiAgICBkbyB7XG4gICAgICBpZiAoZGUuZ2V0TWluRWRnZVJpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgbWluRXIgPSBuZXcgTWluaW1hbEVkZ2VSaW5nKGRlLCB0aGlzJDEuX2dlb21ldHJ5RmFjdG9yeSk7XG4gICAgICAgIG1pbkVkZ2VSaW5ncy5hZGQobWluRXIpO1xuICAgICAgfVxuICAgICAgZGUgPSBkZS5nZXROZXh0KCk7XG4gICAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG4gICAgcmV0dXJuIG1pbkVkZ2VSaW5nc1xuICB9O1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLnNldEVkZ2VSaW5nID0gZnVuY3Rpb24gc2V0RWRnZVJpbmcgKGRlLCBlcikge1xuICAgIGRlLnNldEVkZ2VSaW5nKGVyKTtcbiAgfTtcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MgPSBmdW5jdGlvbiBsaW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGRlID0gdGhpcy5fc3RhcnREZTtcbiAgICBkbyB7XG4gICAgICB2YXIgbm9kZSA9IGRlLmdldE5vZGUoKTtcbiAgICAgIG5vZGUuZ2V0RWRnZXMoKS5saW5rTWluaW1hbERpcmVjdGVkRWRnZXModGhpcyQxKTtcbiAgICAgIGRlID0gZGUuZ2V0TmV4dCgpO1xuICAgIH0gd2hpbGUgKGRlICE9PSB0aGlzLl9zdGFydERlKVxuICB9O1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiBnZXROZXh0IChkZSkge1xuICAgIHJldHVybiBkZS5nZXROZXh0KClcbiAgfTtcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTWF4aW1hbEVkZ2VSaW5nXG4gIH07XG5cbiAgcmV0dXJuIE1heGltYWxFZGdlUmluZztcbn0oRWRnZVJpbmcpKTtcblxudmFyIEdyYXBoQ29tcG9uZW50ID0gZnVuY3Rpb24gR3JhcGhDb21wb25lbnQgKCkge1xuICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gIHRoaXMuX2lzSW5SZXN1bHQgPSBmYWxzZTtcbiAgdGhpcy5faXNDb3ZlcmVkID0gZmFsc2U7XG4gIHRoaXMuX2lzQ292ZXJlZFNldCA9IGZhbHNlO1xuICB0aGlzLl9pc1Zpc2l0ZWQgPSBmYWxzZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHt9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGFiZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbiAgfVxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5zZXRWaXNpdGVkID0gZnVuY3Rpb24gc2V0VmlzaXRlZCAoaXNWaXNpdGVkKSB7XG4gIHRoaXMuX2lzVmlzaXRlZCA9IGlzVmlzaXRlZDtcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuc2V0SW5SZXN1bHQgPSBmdW5jdGlvbiBzZXRJblJlc3VsdCAoaXNJblJlc3VsdCkge1xuICB0aGlzLl9pc0luUmVzdWx0ID0gaXNJblJlc3VsdDtcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuaXNDb3ZlcmVkID0gZnVuY3Rpb24gaXNDb3ZlcmVkICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQ292ZXJlZFxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5pc0NvdmVyZWRTZXQgPSBmdW5jdGlvbiBpc0NvdmVyZWRTZXQgKCkge1xuICByZXR1cm4gdGhpcy5faXNDb3ZlcmVkU2V0XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnNldExhYmVsID0gZnVuY3Rpb24gc2V0TGFiZWwgKGxhYmVsKSB7XG4gIHRoaXMuX2xhYmVsID0gbGFiZWw7XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwgKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWxcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuc2V0Q292ZXJlZCA9IGZ1bmN0aW9uIHNldENvdmVyZWQgKGlzQ292ZXJlZCkge1xuICB0aGlzLl9pc0NvdmVyZWQgPSBpc0NvdmVyZWQ7XG4gIHRoaXMuX2lzQ292ZXJlZFNldCA9IHRydWU7XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnVwZGF0ZUlNID0gZnVuY3Rpb24gdXBkYXRlSU0gKGltKSB7XG4gIEFzc2VydC5pc1RydWUodGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpID49IDIsICdmb3VuZCBwYXJ0aWFsIGxhYmVsJyk7XG4gIHRoaXMuY29tcHV0ZUlNKGltKTtcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuaXNJblJlc3VsdCA9IGZ1bmN0aW9uIGlzSW5SZXN1bHQgKCkge1xuICByZXR1cm4gdGhpcy5faXNJblJlc3VsdFxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5pc1Zpc2l0ZWQgPSBmdW5jdGlvbiBpc1Zpc2l0ZWQgKCkge1xuICByZXR1cm4gdGhpcy5faXNWaXNpdGVkXG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHcmFwaENvbXBvbmVudFxufTtcblxudmFyIE5vZGUgPSAoZnVuY3Rpb24gKEdyYXBoQ29tcG9uZW50JCQxKSB7XG4gIGZ1bmN0aW9uIE5vZGUgKCkge1xuICAgIEdyYXBoQ29tcG9uZW50JCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fY29vcmQgPSBudWxsO1xuICAgIHRoaXMuX2VkZ2VzID0gbnVsbDtcbiAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGVkZ2VzID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2Nvb3JkID0gY29vcmQ7XG4gICAgdGhpcy5fZWRnZXMgPSBlZGdlcztcbiAgICB0aGlzLl9sYWJlbCA9IG5ldyBMYWJlbCgwLCBMb2NhdGlvbi5OT05FKTtcbiAgfVxuXG4gIGlmICggR3JhcGhDb21wb25lbnQkJDEgKSBOb2RlLl9fcHJvdG9fXyA9IEdyYXBoQ29tcG9uZW50JCQxO1xuICBOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdyYXBoQ29tcG9uZW50JCQxICYmIEdyYXBoQ29tcG9uZW50JCQxLnByb3RvdHlwZSApO1xuICBOb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE5vZGU7XG4gIE5vZGUucHJvdG90eXBlLmlzSW5jaWRlbnRFZGdlSW5SZXN1bHQgPSBmdW5jdGlvbiBpc0luY2lkZW50RWRnZUluUmVzdWx0ICgpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuZ2V0RWRnZXMoKS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkZS5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmlzSXNvbGF0ZWQgPSBmdW5jdGlvbiBpc0lzb2xhdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpID09PSAxXG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gICAgb3V0LnByaW50bG4oJ25vZGUgJyArIHRoaXMuX2Nvb3JkICsgJyBsYmw6ICcgKyB0aGlzLl9sYWJlbCk7XG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmNvbXB1dGVJTSA9IGZ1bmN0aW9uIGNvbXB1dGVJTSAoaW0pIHt9O1xuICBOb2RlLnByb3RvdHlwZS5jb21wdXRlTWVyZ2VkTG9jYXRpb24gPSBmdW5jdGlvbiBjb21wdXRlTWVyZ2VkTG9jYXRpb24gKGxhYmVsMiwgZWx0SW5kZXgpIHtcbiAgICB2YXIgbG9jID0gTG9jYXRpb24uTk9ORTtcbiAgICBsb2MgPSB0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihlbHRJbmRleCk7XG4gICAgaWYgKCFsYWJlbDIuaXNOdWxsKGVsdEluZGV4KSkge1xuICAgICAgdmFyIG5Mb2MgPSBsYWJlbDIuZ2V0TG9jYXRpb24oZWx0SW5kZXgpO1xuICAgICAgaWYgKGxvYyAhPT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgbG9jID0gbkxvYzsgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jXG4gIH07XG4gIE5vZGUucHJvdG90eXBlLnNldExhYmVsID0gZnVuY3Rpb24gc2V0TGFiZWwgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgb25Mb2NhdGlvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICh0aGlzLl9sYWJlbCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9sYWJlbCA9IG5ldyBMYWJlbChhcmdJbmRleCwgb25Mb2NhdGlvbik7XG4gICAgICB9IGVsc2UgeyB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbihhcmdJbmRleCwgb25Mb2NhdGlvbik7IH1cbiAgICB9IGVsc2UgeyByZXR1cm4gR3JhcGhDb21wb25lbnQkJDEucHJvdG90eXBlLnNldExhYmVsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBOb2RlLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uIGdldEVkZ2VzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWRnZXNcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUubWVyZ2VMYWJlbCA9IGZ1bmN0aW9uIG1lcmdlTGFiZWwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIHZhciBuID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5tZXJnZUxhYmVsKG4uX2xhYmVsKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExhYmVsKSB7XG4gICAgICB2YXIgbGFiZWwyID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgdmFyIGxvYyA9IHRoaXMkMS5jb21wdXRlTWVyZ2VkTG9jYXRpb24obGFiZWwyLCBpKTtcbiAgICAgICAgdmFyIHRoaXNMb2MgPSB0aGlzJDEuX2xhYmVsLmdldExvY2F0aW9uKGkpO1xuICAgICAgICBpZiAodGhpc0xvYyA9PT0gTG9jYXRpb24uTk9ORSkgeyB0aGlzJDEuX2xhYmVsLnNldExvY2F0aW9uKGksIGxvYyk7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZSkge1xuICAgIHRoaXMuX2VkZ2VzLmluc2VydChlKTtcbiAgICBlLnNldE5vZGUodGhpcyk7XG4gIH07XG4gIE5vZGUucHJvdG90eXBlLnNldExhYmVsQm91bmRhcnkgPSBmdW5jdGlvbiBzZXRMYWJlbEJvdW5kYXJ5IChhcmdJbmRleCkge1xuICAgIGlmICh0aGlzLl9sYWJlbCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGxvYyA9IExvY2F0aW9uLk5PTkU7XG4gICAgaWYgKHRoaXMuX2xhYmVsICE9PSBudWxsKSB7IGxvYyA9IHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGFyZ0luZGV4KTsgfVxuICAgIHZhciBuZXdMb2MgPSBudWxsO1xuICAgIHN3aXRjaCAobG9jKSB7XG4gICAgICBjYXNlIExvY2F0aW9uLkJPVU5EQVJZOlxuICAgICAgICBuZXdMb2MgPSBMb2NhdGlvbi5JTlRFUklPUjtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgTG9jYXRpb24uSU5URVJJT1I6XG4gICAgICAgIG5ld0xvYyA9IExvY2F0aW9uLkJPVU5EQVJZO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbmV3TG9jID0gTG9jYXRpb24uQk9VTkRBUlk7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGFyZ0luZGV4LCBuZXdMb2MpO1xuICB9O1xuICBOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE5vZGVcbiAgfTtcblxuICByZXR1cm4gTm9kZTtcbn0oR3JhcGhDb21wb25lbnQpKTtcblxudmFyIE5vZGVNYXAgPSBmdW5jdGlvbiBOb2RlTWFwICgpIHtcbiAgdGhpcy5ub2RlTWFwID0gbmV3IFRyZWVNYXAoKTtcbiAgdGhpcy5ub2RlRmFjdCA9IG51bGw7XG4gIHZhciBub2RlRmFjdCA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5ub2RlRmFjdCA9IG5vZGVGYWN0O1xufTtcbk5vZGVNYXAucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kIChjb29yZCkge1xuICByZXR1cm4gdGhpcy5ub2RlTWFwLmdldChjb29yZClcbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5hZGROb2RlID0gZnVuY3Rpb24gYWRkTm9kZSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlTWFwLmdldChjb29yZCk7XG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSB0aGlzLm5vZGVGYWN0LmNyZWF0ZU5vZGUoY29vcmQpO1xuICAgICAgdGhpcy5ub2RlTWFwLnB1dChjb29yZCwgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTm9kZSkge1xuICAgIHZhciBuID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBub2RlJDEgPSB0aGlzLm5vZGVNYXAuZ2V0KG4uZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICBpZiAobm9kZSQxID09PSBudWxsKSB7XG4gICAgICB0aGlzLm5vZGVNYXAucHV0KG4uZ2V0Q29vcmRpbmF0ZSgpLCBuKTtcbiAgICAgIHJldHVybiBuXG4gICAgfVxuICAgIG5vZGUkMS5tZXJnZUxhYmVsKG4pO1xuICAgIHJldHVybiBub2RlJDFcbiAgfVxufTtcbk5vZGVNYXAucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBuID0gaXQubmV4dCgpO1xuICAgIG4ucHJpbnQob3V0KTtcbiAgfVxufTtcbk5vZGVNYXAucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKClcbn07XG5Ob2RlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMgKCkge1xuICByZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpXG59O1xuTm9kZU1hcC5wcm90b3R5cGUuZ2V0Qm91bmRhcnlOb2RlcyA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5Tm9kZXMgKGdlb21JbmRleCkge1xuICB2YXIgYmR5Tm9kZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSB0aGlzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBub2RlID0gaS5uZXh0KCk7XG4gICAgaWYgKG5vZGUuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihnZW9tSW5kZXgpID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBiZHlOb2Rlcy5hZGQobm9kZSk7IH1cbiAgfVxuICByZXR1cm4gYmR5Tm9kZXNcbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGUpIHtcbiAgdmFyIHAgPSBlLmdldENvb3JkaW5hdGUoKTtcbiAgdmFyIG4gPSB0aGlzLmFkZE5vZGUocCk7XG4gIG4uYWRkKGUpO1xufTtcbk5vZGVNYXAucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGVNYXBcbn07XG5cbnZhciBRdWFkcmFudCA9IGZ1bmN0aW9uIFF1YWRyYW50ICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDIxID0geyBORTogeyBjb25maWd1cmFibGU6IHRydWUgfSxOVzogeyBjb25maWd1cmFibGU6IHRydWUgfSxTVzogeyBjb25maWd1cmFibGU6IHRydWUgfSxTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5RdWFkcmFudC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblF1YWRyYW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFF1YWRyYW50XG59O1xuUXVhZHJhbnQuaXNOb3J0aGVybiA9IGZ1bmN0aW9uIGlzTm9ydGhlcm4gKHF1YWQpIHtcbiAgcmV0dXJuIHF1YWQgPT09IFF1YWRyYW50Lk5FIHx8IHF1YWQgPT09IFF1YWRyYW50Lk5XXG59O1xuUXVhZHJhbnQuaXNPcHBvc2l0ZSA9IGZ1bmN0aW9uIGlzT3Bwb3NpdGUgKHF1YWQxLCBxdWFkMikge1xuICBpZiAocXVhZDEgPT09IHF1YWQyKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBkaWZmID0gKHF1YWQxIC0gcXVhZDIgKyA0KSAlIDQ7XG4gIGlmIChkaWZmID09PSAyKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuUXVhZHJhbnQuY29tbW9uSGFsZlBsYW5lID0gZnVuY3Rpb24gY29tbW9uSGFsZlBsYW5lIChxdWFkMSwgcXVhZDIpIHtcbiAgaWYgKHF1YWQxID09PSBxdWFkMikgeyByZXR1cm4gcXVhZDEgfVxuICB2YXIgZGlmZiA9IChxdWFkMSAtIHF1YWQyICsgNCkgJSA0O1xuICBpZiAoZGlmZiA9PT0gMikgeyByZXR1cm4gLTEgfVxuICB2YXIgbWluID0gcXVhZDEgPCBxdWFkMiA/IHF1YWQxIDogcXVhZDI7XG4gIHZhciBtYXggPSBxdWFkMSA+IHF1YWQyID8gcXVhZDEgOiBxdWFkMjtcbiAgaWYgKG1pbiA9PT0gMCAmJiBtYXggPT09IDMpIHsgcmV0dXJuIDMgfVxuICByZXR1cm4gbWluXG59O1xuUXVhZHJhbnQuaXNJbkhhbGZQbGFuZSA9IGZ1bmN0aW9uIGlzSW5IYWxmUGxhbmUgKHF1YWQsIGhhbGZQbGFuZSkge1xuICBpZiAoaGFsZlBsYW5lID09PSBRdWFkcmFudC5TRSkge1xuICAgIHJldHVybiBxdWFkID09PSBRdWFkcmFudC5TRSB8fCBxdWFkID09PSBRdWFkcmFudC5TV1xuICB9XG4gIHJldHVybiBxdWFkID09PSBoYWxmUGxhbmUgfHwgcXVhZCA9PT0gaGFsZlBsYW5lICsgMVxufTtcblF1YWRyYW50LnF1YWRyYW50ID0gZnVuY3Rpb24gcXVhZHJhbnQgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgZHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGR5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkeCA9PT0gMC4wICYmIGR5ID09PSAwLjApIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciBwb2ludCAoICcgKyBkeCArICcsICcgKyBkeSArICcgKScpIH1cbiAgICBpZiAoZHggPj0gMC4wKSB7XG4gICAgICBpZiAoZHkgPj0gMC4wKSB7IHJldHVybiBRdWFkcmFudC5ORTsgfSBlbHNlIHsgcmV0dXJuIFF1YWRyYW50LlNFIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR5ID49IDAuMCkgeyByZXR1cm4gUXVhZHJhbnQuTlc7IH0gZWxzZSB7IHJldHVybiBRdWFkcmFudC5TVyB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHAxLnggPT09IHAwLnggJiYgcDEueSA9PT0gcDAueSkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzICcgKyBwMCkgfVxuICAgIGlmIChwMS54ID49IHAwLngpIHtcbiAgICAgIGlmIChwMS55ID49IHAwLnkpIHsgcmV0dXJuIFF1YWRyYW50Lk5FOyB9IGVsc2UgeyByZXR1cm4gUXVhZHJhbnQuU0UgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocDEueSA+PSBwMC55KSB7IHJldHVybiBRdWFkcmFudC5OVzsgfSBlbHNlIHsgcmV0dXJuIFF1YWRyYW50LlNXIH1cbiAgICB9XG4gIH1cbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjEuTkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDIxLk5XLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMS5TVy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjEuU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMyB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUXVhZHJhbnQsIHN0YXRpY0FjY2Vzc29ycyQyMSApO1xuXG52YXIgRWRnZUVuZCA9IGZ1bmN0aW9uIEVkZ2VFbmQgKCkge1xuICB0aGlzLl9lZGdlID0gbnVsbDtcbiAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICB0aGlzLl9ub2RlID0gbnVsbDtcbiAgdGhpcy5fcDAgPSBudWxsO1xuICB0aGlzLl9wMSA9IG51bGw7XG4gIHRoaXMuX2R4ID0gbnVsbDtcbiAgdGhpcy5fZHkgPSBudWxsO1xuICB0aGlzLl9xdWFkcmFudCA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGVkZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fZWRnZSA9IGVkZ2U7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBlZGdlJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgbGFiZWwgPSBudWxsO1xuICAgIHRoaXMuX2VkZ2UgPSBlZGdlJDE7XG4gICAgdGhpcy5pbml0KHAwLCBwMSk7XG4gICAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIGVkZ2UkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDAkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcDEkMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgbGFiZWwkMSA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLl9lZGdlID0gZWRnZSQyO1xuICAgIHRoaXMuaW5pdChwMCQxLCBwMSQxKTtcbiAgICB0aGlzLl9sYWJlbCA9IGxhYmVsJDE7XG4gIH1cbn07XG5FZGdlRW5kLnByb3RvdHlwZS5jb21wYXJlRGlyZWN0aW9uID0gZnVuY3Rpb24gY29tcGFyZURpcmVjdGlvbiAoZSkge1xuICBpZiAodGhpcy5fZHggPT09IGUuX2R4ICYmIHRoaXMuX2R5ID09PSBlLl9keSkgeyByZXR1cm4gMCB9XG4gIGlmICh0aGlzLl9xdWFkcmFudCA+IGUuX3F1YWRyYW50KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX3F1YWRyYW50IDwgZS5fcXVhZHJhbnQpIHsgcmV0dXJuIC0xIH1cbiAgcmV0dXJuIENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24oZS5fcDAsIGUuX3AxLCB0aGlzLl9wMSlcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXREeSA9IGZ1bmN0aW9uIGdldER5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2R5XG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5fcDBcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5zZXROb2RlID0gZnVuY3Rpb24gc2V0Tm9kZSAobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih0aGlzLl9keSwgdGhpcy5fZHgpO1xuICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKTtcbiAgdmFyIGxhc3REb3RQb3MgPSBjbGFzc05hbWUubGFzdEluZGV4T2YoJy4nKTtcbiAgdmFyIG5hbWUgPSBjbGFzc05hbWUuc3Vic3RyaW5nKGxhc3REb3RQb3MgKyAxKTtcbiAgb3V0LnByaW50KCcgICcgKyBuYW1lICsgJzogJyArIHRoaXMuX3AwICsgJyAtICcgKyB0aGlzLl9wMSArICcgJyArIHRoaXMuX3F1YWRyYW50ICsgJzonICsgYW5nbGUgKyAnICAgJyArIHRoaXMuX2xhYmVsKTtcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG9iaikge1xuICB2YXIgZSA9IG9iajtcbiAgcmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldERpcmVjdGVkQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldERpcmVjdGVkQ29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9wMVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldER4ID0gZnVuY3Rpb24gZ2V0RHggKCkge1xuICByZXR1cm4gdGhpcy5fZHhcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uIGdldExhYmVsICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xhYmVsXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uIGdldEVkZ2UgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldFF1YWRyYW50ID0gZnVuY3Rpb24gZ2V0UXVhZHJhbnQgKCkge1xuICByZXR1cm4gdGhpcy5fcXVhZHJhbnRcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXROb2RlID0gZnVuY3Rpb24gZ2V0Tm9kZSAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlXG59O1xuRWRnZUVuZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIodGhpcy5fZHksIHRoaXMuX2R4KTtcbiAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCk7XG4gIHZhciBsYXN0RG90UG9zID0gY2xhc3NOYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gIHZhciBuYW1lID0gY2xhc3NOYW1lLnN1YnN0cmluZyhsYXN0RG90UG9zICsgMSk7XG4gIHJldHVybiAnICAnICsgbmFtZSArICc6ICcgKyB0aGlzLl9wMCArICcgLSAnICsgdGhpcy5fcDEgKyAnICcgKyB0aGlzLl9xdWFkcmFudCArICc6JyArIGFuZ2xlICsgJyAgICcgKyB0aGlzLl9sYWJlbFxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmNvbXB1dGVMYWJlbCA9IGZ1bmN0aW9uIGNvbXB1dGVMYWJlbCAoYm91bmRhcnlOb2RlUnVsZSkge307XG5FZGdlRW5kLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAocDAsIHAxKSB7XG4gIHRoaXMuX3AwID0gcDA7XG4gIHRoaXMuX3AxID0gcDE7XG4gIHRoaXMuX2R4ID0gcDEueCAtIHAwLng7XG4gIHRoaXMuX2R5ID0gcDEueSAtIHAwLnk7XG4gIHRoaXMuX3F1YWRyYW50ID0gUXVhZHJhbnQucXVhZHJhbnQodGhpcy5fZHgsIHRoaXMuX2R5KTtcbiAgQXNzZXJ0LmlzVHJ1ZSghKHRoaXMuX2R4ID09PSAwICYmIHRoaXMuX2R5ID09PSAwKSwgJ0VkZ2VFbmQgd2l0aCBpZGVudGljYWwgZW5kcG9pbnRzIGZvdW5kJyk7XG59O1xuRWRnZUVuZC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VFbmRcbn07XG5cbnZhciBEaXJlY3RlZEVkZ2UgPSAoZnVuY3Rpb24gKEVkZ2VFbmQkJDEpIHtcbiAgZnVuY3Rpb24gRGlyZWN0ZWRFZGdlICgpIHtcbiAgICB2YXIgZWRnZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgaXNGb3J3YXJkID0gYXJndW1lbnRzWzFdO1xuICAgIEVkZ2VFbmQkJDEuY2FsbCh0aGlzLCBlZGdlKTtcbiAgICB0aGlzLl9pc0ZvcndhcmQgPSBudWxsO1xuICAgIHRoaXMuX2lzSW5SZXN1bHQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1Zpc2l0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9zeW0gPSBudWxsO1xuICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgIHRoaXMuX25leHRNaW4gPSBudWxsO1xuICAgIHRoaXMuX2VkZ2VSaW5nID0gbnVsbDtcbiAgICB0aGlzLl9taW5FZGdlUmluZyA9IG51bGw7XG4gICAgdGhpcy5fZGVwdGggPSBbMCwgLTk5OSwgLTk5OV07XG4gICAgdGhpcy5faXNGb3J3YXJkID0gaXNGb3J3YXJkO1xuICAgIGlmIChpc0ZvcndhcmQpIHtcbiAgICAgIHRoaXMuaW5pdChlZGdlLmdldENvb3JkaW5hdGUoMCksIGVkZ2UuZ2V0Q29vcmRpbmF0ZSgxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuID0gZWRnZS5nZXROdW1Qb2ludHMoKSAtIDE7XG4gICAgICB0aGlzLmluaXQoZWRnZS5nZXRDb29yZGluYXRlKG4pLCBlZGdlLmdldENvb3JkaW5hdGUobiAtIDEpKTtcbiAgICB9XG4gICAgdGhpcy5jb21wdXRlRGlyZWN0ZWRMYWJlbCgpO1xuICB9XG5cbiAgaWYgKCBFZGdlRW5kJCQxICkgRGlyZWN0ZWRFZGdlLl9fcHJvdG9fXyA9IEVkZ2VFbmQkJDE7XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFZGdlRW5kJCQxICYmIEVkZ2VFbmQkJDEucHJvdG90eXBlICk7XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXJlY3RlZEVkZ2U7XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0TmV4dE1pbiA9IGZ1bmN0aW9uIGdldE5leHRNaW4gKCkge1xuICAgIHJldHVybiB0aGlzLl9uZXh0TWluXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0RGVwdGggPSBmdW5jdGlvbiBnZXREZXB0aCAocG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fZGVwdGhbcG9zaXRpb25dXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0VmlzaXRlZCA9IGZ1bmN0aW9uIHNldFZpc2l0ZWQgKGlzVmlzaXRlZCkge1xuICAgIHRoaXMuX2lzVmlzaXRlZCA9IGlzVmlzaXRlZDtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5jb21wdXRlRGlyZWN0ZWRMYWJlbCA9IGZ1bmN0aW9uIGNvbXB1dGVEaXJlY3RlZExhYmVsICgpIHtcbiAgICB0aGlzLl9sYWJlbCA9IG5ldyBMYWJlbCh0aGlzLl9lZGdlLmdldExhYmVsKCkpO1xuICAgIGlmICghdGhpcy5faXNGb3J3YXJkKSB7IHRoaXMuX2xhYmVsLmZsaXAoKTsgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiBnZXROZXh0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dFxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldERlcHRoID0gZnVuY3Rpb24gc2V0RGVwdGggKHBvc2l0aW9uLCBkZXB0aFZhbCkge1xuICAgIGlmICh0aGlzLl9kZXB0aFtwb3NpdGlvbl0gIT09IC05OTkpIHtcbiAgICAgIGlmICh0aGlzLl9kZXB0aFtwb3NpdGlvbl0gIT09IGRlcHRoVmFsKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbignYXNzaWduZWQgZGVwdGhzIGRvIG5vdCBtYXRjaCcsIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKSB9XG4gICAgfVxuICAgIHRoaXMuX2RlcHRoW3Bvc2l0aW9uXSA9IGRlcHRoVmFsO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmlzSW50ZXJpb3JBcmVhRWRnZSA9IGZ1bmN0aW9uIGlzSW50ZXJpb3JBcmVhRWRnZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgaXNJbnRlcmlvckFyZWFFZGdlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgaWYgKCEodGhpcyQxLl9sYWJlbC5pc0FyZWEoaSkgJiYgdGhpcyQxLl9sYWJlbC5nZXRMb2NhdGlvbihpLCBQb3NpdGlvbi5MRUZUKSA9PT0gTG9jYXRpb24uSU5URVJJT1IgJiYgdGhpcyQxLl9sYWJlbC5nZXRMb2NhdGlvbihpLCBQb3NpdGlvbi5SSUdIVCkgPT09IExvY2F0aW9uLklOVEVSSU9SKSkge1xuICAgICAgICBpc0ludGVyaW9yQXJlYUVkZ2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzSW50ZXJpb3JBcmVhRWRnZVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldE5leHRNaW4gPSBmdW5jdGlvbiBzZXROZXh0TWluIChuZXh0TWluKSB7XG4gICAgdGhpcy5fbmV4dE1pbiA9IG5leHRNaW47XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gICAgRWRnZUVuZCQkMS5wcm90b3R5cGUucHJpbnQuY2FsbCh0aGlzLCBvdXQpO1xuICAgIG91dC5wcmludCgnICcgKyB0aGlzLl9kZXB0aFtQb3NpdGlvbi5MRUZUXSArICcvJyArIHRoaXMuX2RlcHRoW1Bvc2l0aW9uLlJJR0hUXSk7XG4gICAgb3V0LnByaW50KCcgKCcgKyB0aGlzLmdldERlcHRoRGVsdGEoKSArICcpJyk7XG4gICAgaWYgKHRoaXMuX2lzSW5SZXN1bHQpIHsgb3V0LnByaW50KCcgaW5SZXN1bHQnKTsgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldE1pbkVkZ2VSaW5nID0gZnVuY3Rpb24gc2V0TWluRWRnZVJpbmcgKG1pbkVkZ2VSaW5nKSB7XG4gICAgdGhpcy5fbWluRWRnZVJpbmcgPSBtaW5FZGdlUmluZztcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5pc0xpbmVFZGdlID0gZnVuY3Rpb24gaXNMaW5lRWRnZSAoKSB7XG4gICAgdmFyIGlzTGluZSA9IHRoaXMuX2xhYmVsLmlzTGluZSgwKSB8fCB0aGlzLl9sYWJlbC5pc0xpbmUoMSk7XG4gICAgdmFyIGlzRXh0ZXJpb3JJZkFyZWEwID0gIXRoaXMuX2xhYmVsLmlzQXJlYSgwKSB8fCB0aGlzLl9sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgwLCBMb2NhdGlvbi5FWFRFUklPUik7XG4gICAgdmFyIGlzRXh0ZXJpb3JJZkFyZWExID0gIXRoaXMuX2xhYmVsLmlzQXJlYSgxKSB8fCB0aGlzLl9sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgxLCBMb2NhdGlvbi5FWFRFUklPUik7XG4gICAgcmV0dXJuIGlzTGluZSAmJiBpc0V4dGVyaW9ySWZBcmVhMCAmJiBpc0V4dGVyaW9ySWZBcmVhMVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldEVkZ2VSaW5nID0gZnVuY3Rpb24gc2V0RWRnZVJpbmcgKGVkZ2VSaW5nKSB7XG4gICAgdGhpcy5fZWRnZVJpbmcgPSBlZGdlUmluZztcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXRNaW5FZGdlUmluZyA9IGZ1bmN0aW9uIGdldE1pbkVkZ2VSaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluRWRnZVJpbmdcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXREZXB0aERlbHRhID0gZnVuY3Rpb24gZ2V0RGVwdGhEZWx0YSAoKSB7XG4gICAgdmFyIGRlcHRoRGVsdGEgPSB0aGlzLl9lZGdlLmdldERlcHRoRGVsdGEoKTtcbiAgICBpZiAoIXRoaXMuX2lzRm9yd2FyZCkgeyBkZXB0aERlbHRhID0gLWRlcHRoRGVsdGE7IH1cbiAgICByZXR1cm4gZGVwdGhEZWx0YVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldEluUmVzdWx0ID0gZnVuY3Rpb24gc2V0SW5SZXN1bHQgKGlzSW5SZXN1bHQpIHtcbiAgICB0aGlzLl9pc0luUmVzdWx0ID0gaXNJblJlc3VsdDtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXRTeW0gPSBmdW5jdGlvbiBnZXRTeW0gKCkge1xuICAgIHJldHVybiB0aGlzLl9zeW1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5pc0ZvcndhcmQgPSBmdW5jdGlvbiBpc0ZvcndhcmQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0ZvcndhcmRcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXRFZGdlID0gZnVuY3Rpb24gZ2V0RWRnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkZ2VcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5wcmludEVkZ2UgPSBmdW5jdGlvbiBwcmludEVkZ2UgKG91dCkge1xuICAgIHRoaXMucHJpbnQob3V0KTtcbiAgICBvdXQucHJpbnQoJyAnKTtcbiAgICBpZiAodGhpcy5faXNGb3J3YXJkKSB7IHRoaXMuX2VkZ2UucHJpbnQob3V0KTsgfSBlbHNlIHsgdGhpcy5fZWRnZS5wcmludFJldmVyc2Uob3V0KTsgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldFN5bSA9IGZ1bmN0aW9uIHNldFN5bSAoZGUpIHtcbiAgICB0aGlzLl9zeW0gPSBkZTtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXRWaXNpdGVkRWRnZSA9IGZ1bmN0aW9uIHNldFZpc2l0ZWRFZGdlIChpc1Zpc2l0ZWQpIHtcbiAgICB0aGlzLnNldFZpc2l0ZWQoaXNWaXNpdGVkKTtcbiAgICB0aGlzLl9zeW0uc2V0VmlzaXRlZChpc1Zpc2l0ZWQpO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldEVkZ2VEZXB0aHMgPSBmdW5jdGlvbiBzZXRFZGdlRGVwdGhzIChwb3NpdGlvbiwgZGVwdGgpIHtcbiAgICB2YXIgZGVwdGhEZWx0YSA9IHRoaXMuZ2V0RWRnZSgpLmdldERlcHRoRGVsdGEoKTtcbiAgICBpZiAoIXRoaXMuX2lzRm9yd2FyZCkgeyBkZXB0aERlbHRhID0gLWRlcHRoRGVsdGE7IH1cbiAgICB2YXIgZGlyZWN0aW9uRmFjdG9yID0gMTtcbiAgICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxFRlQpIHsgZGlyZWN0aW9uRmFjdG9yID0gLTE7IH1cbiAgICB2YXIgb3Bwb3NpdGVQb3MgPSBQb3NpdGlvbi5vcHBvc2l0ZShwb3NpdGlvbik7XG4gICAgdmFyIGRlbHRhID0gZGVwdGhEZWx0YSAqIGRpcmVjdGlvbkZhY3RvcjtcbiAgICB2YXIgb3Bwb3NpdGVEZXB0aCA9IGRlcHRoICsgZGVsdGE7XG4gICAgdGhpcy5zZXREZXB0aChwb3NpdGlvbiwgZGVwdGgpO1xuICAgIHRoaXMuc2V0RGVwdGgob3Bwb3NpdGVQb3MsIG9wcG9zaXRlRGVwdGgpO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldEVkZ2VSaW5nID0gZnVuY3Rpb24gZ2V0RWRnZVJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGdlUmluZ1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmlzSW5SZXN1bHQgPSBmdW5jdGlvbiBpc0luUmVzdWx0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNJblJlc3VsdFxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldE5leHQgPSBmdW5jdGlvbiBzZXROZXh0IChuZXh0KSB7XG4gICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuaXNWaXNpdGVkID0gZnVuY3Rpb24gaXNWaXNpdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNWaXNpdGVkXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIERpcmVjdGVkRWRnZVxuICB9O1xuICBEaXJlY3RlZEVkZ2UuZGVwdGhGYWN0b3IgPSBmdW5jdGlvbiBkZXB0aEZhY3RvciAoY3VyckxvY2F0aW9uLCBuZXh0TG9jYXRpb24pIHtcbiAgICBpZiAoY3VyckxvY2F0aW9uID09PSBMb2NhdGlvbi5FWFRFUklPUiAmJiBuZXh0TG9jYXRpb24gPT09IExvY2F0aW9uLklOVEVSSU9SKSB7IHJldHVybiAxOyB9IGVsc2UgaWYgKGN1cnJMb2NhdGlvbiA9PT0gTG9jYXRpb24uSU5URVJJT1IgJiYgbmV4dExvY2F0aW9uID09PSBMb2NhdGlvbi5FWFRFUklPUikgeyByZXR1cm4gLTEgfVxuICAgIHJldHVybiAwXG4gIH07XG5cbiAgcmV0dXJuIERpcmVjdGVkRWRnZTtcbn0oRWRnZUVuZCkpO1xuXG52YXIgTm9kZUZhY3RvcnkgPSBmdW5jdGlvbiBOb2RlRmFjdG9yeSAoKSB7fTtcblxuTm9kZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOb2RlIChjb29yZCkge1xuICByZXR1cm4gbmV3IE5vZGUoY29vcmQsIG51bGwpXG59O1xuTm9kZUZhY3RvcnkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Ob2RlRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOb2RlRmFjdG9yeVxufTtcblxudmFyIFBsYW5hckdyYXBoID0gZnVuY3Rpb24gUGxhbmFyR3JhcGggKCkge1xuICB0aGlzLl9lZGdlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fbm9kZXMgPSBudWxsO1xuICB0aGlzLl9lZGdlRW5kTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9ub2RlcyA9IG5ldyBOb2RlTWFwKG5ldyBOb2RlRmFjdG9yeSgpKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGVGYWN0ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX25vZGVzID0gbmV3IE5vZGVNYXAobm9kZUZhY3QpO1xuICB9XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLnByaW50RWRnZXMgPSBmdW5jdGlvbiBwcmludEVkZ2VzIChvdXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBvdXQucHJpbnRsbignRWRnZXM6Jyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZXMuc2l6ZSgpOyBpKyspIHtcbiAgICBvdXQucHJpbnRsbignZWRnZSAnICsgaSArICc6Jyk7XG4gICAgdmFyIGUgPSB0aGlzJDEuX2VkZ2VzLmdldChpKTtcbiAgICBlLnByaW50KG91dCk7XG4gICAgZS5laUxpc3QucHJpbnQob3V0KTtcbiAgfVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZCAoY29vcmQpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzLmZpbmQoY29vcmQpXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiBhZGROb2RlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZShub2RlKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmFkZE5vZGUoY29vcmQpXG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZUl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0Tm9kZUl0ZXJhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzLml0ZXJhdG9yKClcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiBsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyAoKSB7XG4gIGZvciAodmFyIG5vZGVpdCA9IHRoaXMuX25vZGVzLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBub2RlaXQubmV4dCgpO1xuICAgIG5vZGUuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpO1xuICB9XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmRlYnVnUHJpbnRsbiA9IGZ1bmN0aW9uIGRlYnVnUHJpbnRsbiAobykge1xuICBTeXN0ZW0ub3V0LnByaW50bG4obyk7XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmlzQm91bmRhcnlOb2RlID0gZnVuY3Rpb24gaXNCb3VuZGFyeU5vZGUgKGdlb21JbmRleCwgY29vcmQpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlcy5maW5kKGNvb3JkKTtcbiAgaWYgKG5vZGUgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGxhYmVsID0gbm9kZS5nZXRMYWJlbCgpO1xuICBpZiAobGFiZWwgIT09IG51bGwgJiYgbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4KSA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUubGlua0FsbERpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiBsaW5rQWxsRGlyZWN0ZWRFZGdlcyAoKSB7XG4gIGZvciAodmFyIG5vZGVpdCA9IHRoaXMuX25vZGVzLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBub2RlaXQubmV4dCgpO1xuICAgIG5vZGUuZ2V0RWRnZXMoKS5saW5rQWxsRGlyZWN0ZWRFZGdlcygpO1xuICB9XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLm1hdGNoSW5TYW1lRGlyZWN0aW9uID0gZnVuY3Rpb24gbWF0Y2hJblNhbWVEaXJlY3Rpb24gKHAwLCBwMSwgZXAwLCBlcDEpIHtcbiAgaWYgKCFwMC5lcXVhbHMoZXAwKSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbihwMCwgcDEsIGVwMSkgPT09IENHQWxnb3JpdGhtcy5DT0xMSU5FQVIgJiYgUXVhZHJhbnQucXVhZHJhbnQocDAsIHAxKSA9PT0gUXVhZHJhbnQucXVhZHJhbnQoZXAwLCBlcDEpKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmdldEVkZ2VFbmRzID0gZnVuY3Rpb24gZ2V0RWRnZUVuZHMgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZUVuZExpc3Rcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZGVidWdQcmludCA9IGZ1bmN0aW9uIGRlYnVnUHJpbnQgKG8pIHtcbiAgU3lzdGVtLm91dC5wcmludChvKTtcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZUl0ZXJhdG9yID0gZnVuY3Rpb24gZ2V0RWRnZUl0ZXJhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKClcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24gPSBmdW5jdGlvbiBmaW5kRWRnZUluU2FtZURpcmVjdGlvbiAocDAsIHAxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lZGdlcy5zaXplKCk7IGkrKykge1xuICAgIHZhciBlID0gdGhpcyQxLl9lZGdlcy5nZXQoaSk7XG4gICAgdmFyIGVDb29yZCA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAodGhpcyQxLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHAwLCBwMSwgZUNvb3JkWzBdLCBlQ29vcmRbMV0pKSB7IHJldHVybiBlIH1cbiAgICBpZiAodGhpcyQxLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHAwLCBwMSwgZUNvb3JkW2VDb29yZC5sZW5ndGggLSAxXSwgZUNvb3JkW2VDb29yZC5sZW5ndGggLSAyXSkpIHsgcmV0dXJuIGUgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmluc2VydEVkZ2UgPSBmdW5jdGlvbiBpbnNlcnRFZGdlIChlKSB7XG4gIHRoaXMuX2VkZ2VzLmFkZChlKTtcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZmluZEVkZ2VFbmQgPSBmdW5jdGlvbiBmaW5kRWRnZUVuZCAoZSkge1xuICBmb3IgKHZhciBpID0gdGhpcy5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBlZSA9IGkubmV4dCgpO1xuICAgIGlmIChlZS5nZXRFZGdlKCkgPT09IGUpIHsgcmV0dXJuIGVlIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5hZGRFZGdlcyA9IGZ1bmN0aW9uIGFkZEVkZ2VzIChlZGdlc1RvQWRkKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaXQgPSBlZGdlc1RvQWRkLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICB0aGlzJDEuX2VkZ2VzLmFkZChlKTtcbiAgICB2YXIgZGUxID0gbmV3IERpcmVjdGVkRWRnZShlLCB0cnVlKTtcbiAgICB2YXIgZGUyID0gbmV3IERpcmVjdGVkRWRnZShlLCBmYWxzZSk7XG4gICAgZGUxLnNldFN5bShkZTIpO1xuICAgIGRlMi5zZXRTeW0oZGUxKTtcbiAgICB0aGlzJDEuYWRkKGRlMSk7XG4gICAgdGhpcyQxLmFkZChkZTIpO1xuICB9XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZSkge1xuICB0aGlzLl9ub2Rlcy5hZGQoZSk7XG4gIHRoaXMuX2VkZ2VFbmRMaXN0LmFkZChlKTtcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiBnZXROb2RlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlcy52YWx1ZXMoKVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5maW5kRWRnZSA9IGZ1bmN0aW9uIGZpbmRFZGdlIChwMCwgcDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2VkZ2VzLnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuX2VkZ2VzLmdldChpKTtcbiAgICB2YXIgZUNvb3JkID0gZS5nZXRDb29yZGluYXRlcygpO1xuICAgIGlmIChwMC5lcXVhbHMoZUNvb3JkWzBdKSAmJiBwMS5lcXVhbHMoZUNvb3JkWzFdKSkgeyByZXR1cm4gZSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBsYW5hckdyYXBoXG59O1xuUGxhbmFyR3JhcGgubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiBsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyAobm9kZXMpIHtcbiAgZm9yICh2YXIgbm9kZWl0ID0gbm9kZXMuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgbm9kZS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCk7XG4gIH1cbn07XG5cbnZhciBQb2x5Z29uQnVpbGRlciA9IGZ1bmN0aW9uIFBvbHlnb25CdWlsZGVyICgpIHtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gbnVsbDtcbiAgdGhpcy5fc2hlbGxMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgZ2VvbWV0cnlGYWN0b3J5ID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3Rvcnk7XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLnNvcnRTaGVsbHNBbmRIb2xlcyA9IGZ1bmN0aW9uIHNvcnRTaGVsbHNBbmRIb2xlcyAoZWRnZVJpbmdzLCBzaGVsbExpc3QsIGZyZWVIb2xlTGlzdCkge1xuICBmb3IgKHZhciBpdCA9IGVkZ2VSaW5ncy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVyID0gaXQubmV4dCgpO1xuICAgIGlmIChlci5pc0hvbGUoKSkge1xuICAgICAgZnJlZUhvbGVMaXN0LmFkZChlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoZWxsTGlzdC5hZGQoZXIpO1xuICAgIH1cbiAgfVxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlUG9seWdvbnMgPSBmdW5jdGlvbiBjb21wdXRlUG9seWdvbnMgKHNoZWxsTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByZXN1bHRQb2x5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaXQgPSBzaGVsbExpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICB2YXIgcG9seSA9IGVyLnRvUG9seWdvbih0aGlzJDEuX2dlb21ldHJ5RmFjdG9yeSk7XG4gICAgcmVzdWx0UG9seUxpc3QuYWRkKHBvbHkpO1xuICB9XG4gIHJldHVybiByZXN1bHRQb2x5TGlzdFxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5wbGFjZUZyZWVIb2xlcyA9IGZ1bmN0aW9uIHBsYWNlRnJlZUhvbGVzIChzaGVsbExpc3QsIGZyZWVIb2xlTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gZnJlZUhvbGVMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgaG9sZSA9IGl0Lm5leHQoKTtcbiAgICBpZiAoaG9sZS5nZXRTaGVsbCgpID09PSBudWxsKSB7XG4gICAgICB2YXIgc2hlbGwgPSB0aGlzJDEuZmluZEVkZ2VSaW5nQ29udGFpbmluZyhob2xlLCBzaGVsbExpc3QpO1xuICAgICAgaWYgKHNoZWxsID09PSBudWxsKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbigndW5hYmxlIHRvIGFzc2lnbiBob2xlIHRvIGEgc2hlbGwnLCBob2xlLmdldENvb3JkaW5hdGUoMCkpIH1cbiAgICAgIGhvbGUuc2V0U2hlbGwoc2hlbGwpO1xuICAgIH1cbiAgfVxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZE1pbmltYWxFZGdlUmluZ3MgPSBmdW5jdGlvbiBidWlsZE1pbmltYWxFZGdlUmluZ3MgKG1heEVkZ2VSaW5ncywgc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZWRnZVJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpdCA9IG1heEVkZ2VSaW5ncy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVyID0gaXQubmV4dCgpO1xuICAgIGlmIChlci5nZXRNYXhOb2RlRGVncmVlKCkgPiAyKSB7XG4gICAgICBlci5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKTtcbiAgICAgIHZhciBtaW5FZGdlUmluZ3MgPSBlci5idWlsZE1pbmltYWxSaW5ncygpO1xuICAgICAgdmFyIHNoZWxsID0gdGhpcyQxLmZpbmRTaGVsbChtaW5FZGdlUmluZ3MpO1xuICAgICAgaWYgKHNoZWxsICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMkMS5wbGFjZVBvbHlnb25Ib2xlcyhzaGVsbCwgbWluRWRnZVJpbmdzKTtcbiAgICAgICAgc2hlbGxMaXN0LmFkZChzaGVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmVlSG9sZUxpc3QuYWRkQWxsKG1pbkVkZ2VSaW5ncyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkZ2VSaW5ncy5hZGQoZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWRnZVJpbmdzXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiBjb250YWluc1BvaW50IChwKSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5fc2hlbGxMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZXIgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGVyLmNvbnRhaW5zUG9pbnQocCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5idWlsZE1heGltYWxFZGdlUmluZ3MgPSBmdW5jdGlvbiBidWlsZE1heGltYWxFZGdlUmluZ3MgKGRpckVkZ2VzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG1heEVkZ2VSaW5ncyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaXQgPSBkaXJFZGdlcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgIGlmIChkZS5pc0luUmVzdWx0KCkgJiYgZGUuZ2V0TGFiZWwoKS5pc0FyZWEoKSkge1xuICAgICAgaWYgKGRlLmdldEVkZ2VSaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGVyID0gbmV3IE1heGltYWxFZGdlUmluZyhkZSwgdGhpcyQxLl9nZW9tZXRyeUZhY3RvcnkpO1xuICAgICAgICBtYXhFZGdlUmluZ3MuYWRkKGVyKTtcbiAgICAgICAgZXIuc2V0SW5SZXN1bHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heEVkZ2VSaW5nc1xufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5wbGFjZVBvbHlnb25Ib2xlcyA9IGZ1bmN0aW9uIHBsYWNlUG9seWdvbkhvbGVzIChzaGVsbCwgbWluRWRnZVJpbmdzKSB7XG4gIGZvciAodmFyIGl0ID0gbWluRWRnZVJpbmdzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZXIgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGVyLmlzSG9sZSgpKSB7XG4gICAgICBlci5zZXRTaGVsbChzaGVsbCk7XG4gICAgfVxuICB9XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmdldFBvbHlnb25zID0gZnVuY3Rpb24gZ2V0UG9seWdvbnMgKCkge1xuICB2YXIgcmVzdWx0UG9seUxpc3QgPSB0aGlzLmNvbXB1dGVQb2x5Z29ucyh0aGlzLl9zaGVsbExpc3QpO1xuICByZXR1cm4gcmVzdWx0UG9seUxpc3Rcbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuZmluZEVkZ2VSaW5nQ29udGFpbmluZyA9IGZ1bmN0aW9uIGZpbmRFZGdlUmluZ0NvbnRhaW5pbmcgKHRlc3RFciwgc2hlbGxMaXN0KSB7XG4gIHZhciB0ZXN0UmluZyA9IHRlc3RFci5nZXRMaW5lYXJSaW5nKCk7XG4gIHZhciB0ZXN0RW52ID0gdGVzdFJpbmcuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICB2YXIgdGVzdFB0ID0gdGVzdFJpbmcuZ2V0Q29vcmRpbmF0ZU4oMCk7XG4gIHZhciBtaW5TaGVsbCA9IG51bGw7XG4gIHZhciBtaW5FbnYgPSBudWxsO1xuICBmb3IgKHZhciBpdCA9IHNoZWxsTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHRyeVNoZWxsID0gaXQubmV4dCgpO1xuICAgIHZhciB0cnlSaW5nID0gdHJ5U2hlbGwuZ2V0TGluZWFyUmluZygpO1xuICAgIHZhciB0cnlFbnYgPSB0cnlSaW5nLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgICBpZiAobWluU2hlbGwgIT09IG51bGwpIHsgbWluRW52ID0gbWluU2hlbGwuZ2V0TGluZWFyUmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKTsgfVxuICAgIHZhciBpc0NvbnRhaW5lZCA9IGZhbHNlO1xuICAgIGlmICh0cnlFbnYuY29udGFpbnModGVzdEVudikgJiYgQ0dBbGdvcml0aG1zLmlzUG9pbnRJblJpbmcodGVzdFB0LCB0cnlSaW5nLmdldENvb3JkaW5hdGVzKCkpKSB7IGlzQ29udGFpbmVkID0gdHJ1ZTsgfVxuICAgIGlmIChpc0NvbnRhaW5lZCkge1xuICAgICAgaWYgKG1pblNoZWxsID09PSBudWxsIHx8IG1pbkVudi5jb250YWlucyh0cnlFbnYpKSB7XG4gICAgICAgIG1pblNoZWxsID0gdHJ5U2hlbGw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5TaGVsbFxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5maW5kU2hlbGwgPSBmdW5jdGlvbiBmaW5kU2hlbGwgKG1pbkVkZ2VSaW5ncykge1xuICB2YXIgc2hlbGxDb3VudCA9IDA7XG4gIHZhciBzaGVsbCA9IG51bGw7XG4gIGZvciAodmFyIGl0ID0gbWluRWRnZVJpbmdzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZXIgPSBpdC5uZXh0KCk7XG4gICAgaWYgKCFlci5pc0hvbGUoKSkge1xuICAgICAgc2hlbGwgPSBlcjtcbiAgICAgIHNoZWxsQ291bnQrKztcbiAgICB9XG4gIH1cbiAgQXNzZXJ0LmlzVHJ1ZShzaGVsbENvdW50IDw9IDEsICdmb3VuZCB0d28gc2hlbGxzIGluIE1pbmltYWxFZGdlUmluZyBsaXN0Jyk7XG4gIHJldHVybiBzaGVsbFxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBncmFwaCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLmFkZChncmFwaC5nZXRFZGdlRW5kcygpLCBncmFwaC5nZXROb2RlcygpKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGRpckVkZ2VzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBub2RlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICBQbGFuYXJHcmFwaC5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyhub2Rlcyk7XG4gICAgdmFyIG1heEVkZ2VSaW5ncyA9IHRoaXMuYnVpbGRNYXhpbWFsRWRnZVJpbmdzKGRpckVkZ2VzKTtcbiAgICB2YXIgZnJlZUhvbGVMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHZhciBlZGdlUmluZ3MgPSB0aGlzLmJ1aWxkTWluaW1hbEVkZ2VSaW5ncyhtYXhFZGdlUmluZ3MsIHRoaXMuX3NoZWxsTGlzdCwgZnJlZUhvbGVMaXN0KTtcbiAgICB0aGlzLnNvcnRTaGVsbHNBbmRIb2xlcyhlZGdlUmluZ3MsIHRoaXMuX3NoZWxsTGlzdCwgZnJlZUhvbGVMaXN0KTtcbiAgICB0aGlzLnBsYWNlRnJlZUhvbGVzKHRoaXMuX3NoZWxsTGlzdCwgZnJlZUhvbGVMaXN0KTtcbiAgfVxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9seWdvbkJ1aWxkZXJcbn07XG5cbnZhciBCb3VuZGFibGUgPSBmdW5jdGlvbiBCb3VuZGFibGUgKCkge307XG5cbkJvdW5kYWJsZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gZ2V0Qm91bmRzICgpIHt9O1xuQm91bmRhYmxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQm91bmRhYmxlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJvdW5kYWJsZVxufTtcblxudmFyIEl0ZW1Cb3VuZGFibGUgPSBmdW5jdGlvbiBJdGVtQm91bmRhYmxlICgpIHtcbiAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgdGhpcy5faXRlbSA9IG51bGw7XG4gIHZhciBib3VuZHMgPSBhcmd1bWVudHNbMF07XG4gIHZhciBpdGVtID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl9ib3VuZHMgPSBib3VuZHM7XG4gIHRoaXMuX2l0ZW0gPSBpdGVtO1xufTtcbkl0ZW1Cb3VuZGFibGUucHJvdG90eXBlLmdldEl0ZW0gPSBmdW5jdGlvbiBnZXRJdGVtICgpIHtcbiAgcmV0dXJuIHRoaXMuX2l0ZW1cbn07XG5JdGVtQm91bmRhYmxlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRCb3VuZHMgKCkge1xuICByZXR1cm4gdGhpcy5fYm91bmRzXG59O1xuSXRlbUJvdW5kYWJsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQm91bmRhYmxlLCBTZXJpYWxpemFibGVdXG59O1xuSXRlbUJvdW5kYWJsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJdGVtQm91bmRhYmxlXG59O1xuXG52YXIgUHJpb3JpdHlRdWV1ZSA9IGZ1bmN0aW9uIFByaW9yaXR5UXVldWUgKCkge1xuICB0aGlzLl9zaXplID0gbnVsbDtcbiAgdGhpcy5faXRlbXMgPSBudWxsO1xuICB0aGlzLl9zaXplID0gMDtcbiAgdGhpcy5faXRlbXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX2l0ZW1zLmFkZChudWxsKTtcbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gcG9sbCAoKSB7XG4gIGlmICh0aGlzLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBtaW5JdGVtID0gdGhpcy5faXRlbXMuZ2V0KDEpO1xuICB0aGlzLl9pdGVtcy5zZXQoMSwgdGhpcy5faXRlbXMuZ2V0KHRoaXMuX3NpemUpKTtcbiAgdGhpcy5fc2l6ZSAtPSAxO1xuICB0aGlzLnJlb3JkZXIoMSk7XG4gIHJldHVybiBtaW5JdGVtXG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZVxufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLnJlb3JkZXIgPSBmdW5jdGlvbiByZW9yZGVyIChob2xlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkID0gbnVsbDtcbiAgdmFyIHRtcCA9IHRoaXMuX2l0ZW1zLmdldChob2xlKTtcbiAgZm9yICg7IGhvbGUgKiAyIDw9IHRoaXMuX3NpemU7IGhvbGUgPSBjaGlsZCkge1xuICAgIGNoaWxkID0gaG9sZSAqIDI7XG4gICAgaWYgKGNoaWxkICE9PSB0aGlzJDEuX3NpemUgJiYgdGhpcyQxLl9pdGVtcy5nZXQoY2hpbGQgKyAxKS5jb21wYXJlVG8odGhpcyQxLl9pdGVtcy5nZXQoY2hpbGQpKSA8IDApIHsgY2hpbGQrKzsgfVxuICAgIGlmICh0aGlzJDEuX2l0ZW1zLmdldChjaGlsZCkuY29tcGFyZVRvKHRtcCkgPCAwKSB7IHRoaXMkMS5faXRlbXMuc2V0KGhvbGUsIHRoaXMkMS5faXRlbXMuZ2V0KGNoaWxkKSk7IH0gZWxzZSB7IGJyZWFrIH1cbiAgfVxuICB0aGlzLl9pdGVtcy5zZXQoaG9sZSwgdG1wKTtcbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgdGhpcy5fc2l6ZSA9IDA7XG4gIHRoaXMuX2l0ZW1zLmNsZWFyKCk7XG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICByZXR1cm4gdGhpcy5fc2l6ZSA9PT0gMFxufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoeCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX2l0ZW1zLmFkZChudWxsKTtcbiAgdGhpcy5fc2l6ZSArPSAxO1xuICB2YXIgaG9sZSA9IHRoaXMuX3NpemU7XG4gIHRoaXMuX2l0ZW1zLnNldCgwLCB4KTtcbiAgZm9yICg7IHguY29tcGFyZVRvKHRoaXMuX2l0ZW1zLmdldChNYXRoLnRydW5jKGhvbGUgLyAyKSkpIDwgMDsgaG9sZSAvPSAyKSB7XG4gICAgdGhpcyQxLl9pdGVtcy5zZXQoaG9sZSwgdGhpcyQxLl9pdGVtcy5nZXQoTWF0aC50cnVuYyhob2xlIC8gMikpKTtcbiAgfVxuICB0aGlzLl9pdGVtcy5zZXQoaG9sZSwgeCk7XG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUHJpb3JpdHlRdWV1ZVxufTtcblxudmFyIEl0ZW1WaXNpdG9yID0gZnVuY3Rpb24gSXRlbVZpc2l0b3IgKCkge307XG5cbkl0ZW1WaXNpdG9yLnByb3RvdHlwZS52aXNpdEl0ZW0gPSBmdW5jdGlvbiB2aXNpdEl0ZW0gKGl0ZW0pIHt9O1xuSXRlbVZpc2l0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5JdGVtVmlzaXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJdGVtVmlzaXRvclxufTtcblxudmFyIFNwYXRpYWxJbmRleCA9IGZ1bmN0aW9uIFNwYXRpYWxJbmRleCAoKSB7fTtcblxuU3BhdGlhbEluZGV4LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGl0ZW1FbnYsIGl0ZW0pIHt9O1xuU3BhdGlhbEluZGV4LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKGl0ZW1FbnYsIGl0ZW0pIHt9O1xuU3BhdGlhbEluZGV4LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5ICgpIHtcbiAgLy8gaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgLy8gY29uc3Qgc2VhcmNoRW52ID0gYXJndW1lbnRzWzBdXG4gIC8vIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAvLyBjb25zdCBzZWFyY2hFbnYgPSBhcmd1bWVudHNbMF1cbiAgLy8gY29uc3QgdmlzaXRvciA9IGFyZ3VtZW50c1sxXVxuICAvLyB9XG59O1xuU3BhdGlhbEluZGV4LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU3BhdGlhbEluZGV4LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNwYXRpYWxJbmRleFxufTtcblxudmFyIEFic3RyYWN0Tm9kZSA9IGZ1bmN0aW9uIEFic3RyYWN0Tm9kZSAoKSB7XG4gIHRoaXMuX2NoaWxkQm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgdGhpcy5fbGV2ZWwgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge30gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9sZXZlbCA9IGxldmVsO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDIyID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmdldExldmVsID0gZnVuY3Rpb24gZ2V0TGV2ZWwgKCkge1xuICByZXR1cm4gdGhpcy5fbGV2ZWxcbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5zaXplKClcbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmdldENoaWxkQm91bmRhYmxlcyA9IGZ1bmN0aW9uIGdldENoaWxkQm91bmRhYmxlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXNcbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmFkZENoaWxkQm91bmRhYmxlID0gZnVuY3Rpb24gYWRkQ2hpbGRCb3VuZGFibGUgKGNoaWxkQm91bmRhYmxlKSB7XG4gIEFzc2VydC5pc1RydWUodGhpcy5fYm91bmRzID09PSBudWxsKTtcbiAgdGhpcy5fY2hpbGRCb3VuZGFibGVzLmFkZChjaGlsZEJvdW5kYWJsZSk7XG59O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpXG59O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRCb3VuZHMgKCkge1xuICBpZiAodGhpcy5fYm91bmRzID09PSBudWxsKSB7XG4gICAgdGhpcy5fYm91bmRzID0gdGhpcy5jb21wdXRlQm91bmRzKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2JvdW5kc1xufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQm91bmRhYmxlLCBTZXJpYWxpemFibGVdXG59O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEFic3RyYWN0Tm9kZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyMi5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDY0OTM3MjIxODU5MDk1NzM3MDggfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEFic3RyYWN0Tm9kZSwgc3RhdGljQWNjZXNzb3JzJDIyICk7XG5cbnZhciBDb2xsZWN0aW9ucyA9IGZ1bmN0aW9uIENvbGxlY3Rpb25zICgpIHt9O1xuXG5Db2xsZWN0aW9ucy5yZXZlcnNlT3JkZXIgPSBmdW5jdGlvbiByZXZlcnNlT3JkZXIgKCkge1xuICByZXR1cm4ge1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgICAgIHJldHVybiBiLmNvbXBhcmVUbyhhKVxuICAgIH1cbiAgfVxufTtcbkNvbGxlY3Rpb25zLm1pbiA9IGZ1bmN0aW9uIG1pbiAobCkge1xuICBDb2xsZWN0aW9ucy5zb3J0KGwpO1xuICByZXR1cm4gbC5nZXQoMClcbn07XG5Db2xsZWN0aW9ucy5zb3J0ID0gZnVuY3Rpb24gc29ydCAobCwgYykge1xuICB2YXIgYSA9IGwudG9BcnJheSgpO1xuICBpZiAoYykge1xuICAgIEFycmF5cy5zb3J0KGEsIGMpO1xuICB9IGVsc2Uge1xuICAgIEFycmF5cy5zb3J0KGEpO1xuICB9XG4gIHZhciBpID0gbC5pdGVyYXRvcigpO1xuICBmb3IgKHZhciBwb3MgPSAwLCBhbGVuID0gYS5sZW5ndGg7IHBvcyA8IGFsZW47IHBvcysrKSB7XG4gICAgaS5uZXh0KCk7XG4gICAgaS5zZXQoYVtwb3NdKTtcbiAgfVxufTtcbkNvbGxlY3Rpb25zLnNpbmdsZXRvbkxpc3QgPSBmdW5jdGlvbiBzaW5nbGV0b25MaXN0IChvKSB7XG4gIHZhciBhcnJheUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGFycmF5TGlzdC5hZGQobyk7XG4gIHJldHVybiBhcnJheUxpc3Rcbn07XG5cbnZhciBCb3VuZGFibGVQYWlyID0gZnVuY3Rpb24gQm91bmRhYmxlUGFpciAoKSB7XG4gIHRoaXMuX2JvdW5kYWJsZTEgPSBudWxsO1xuICB0aGlzLl9ib3VuZGFibGUyID0gbnVsbDtcbiAgdGhpcy5fZGlzdGFuY2UgPSBudWxsO1xuICB0aGlzLl9pdGVtRGlzdGFuY2UgPSBudWxsO1xuICB2YXIgYm91bmRhYmxlMSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGJvdW5kYWJsZTIgPSBhcmd1bWVudHNbMV07XG4gIHZhciBpdGVtRGlzdGFuY2UgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuX2JvdW5kYWJsZTEgPSBib3VuZGFibGUxO1xuICB0aGlzLl9ib3VuZGFibGUyID0gYm91bmRhYmxlMjtcbiAgdGhpcy5faXRlbURpc3RhbmNlID0gaXRlbURpc3RhbmNlO1xuICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2UoKTtcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5leHBhbmRUb1F1ZXVlID0gZnVuY3Rpb24gZXhwYW5kVG9RdWV1ZSAocHJpUSwgbWluRGlzdGFuY2UpIHtcbiAgdmFyIGlzQ29tcDEgPSBCb3VuZGFibGVQYWlyLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTEpO1xuICB2YXIgaXNDb21wMiA9IEJvdW5kYWJsZVBhaXIuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMik7XG4gIGlmIChpc0NvbXAxICYmIGlzQ29tcDIpIHtcbiAgICBpZiAoQm91bmRhYmxlUGFpci5hcmVhKHRoaXMuX2JvdW5kYWJsZTEpID4gQm91bmRhYmxlUGFpci5hcmVhKHRoaXMuX2JvdW5kYWJsZTIpKSB7XG4gICAgICB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLCB0aGlzLl9ib3VuZGFibGUyLCBwcmlRLCBtaW5EaXN0YW5jZSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUyLCB0aGlzLl9ib3VuZGFibGUxLCBwcmlRLCBtaW5EaXN0YW5jZSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfSBlbHNlIGlmIChpc0NvbXAxKSB7XG4gICAgdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMSwgdGhpcy5fYm91bmRhYmxlMiwgcHJpUSwgbWluRGlzdGFuY2UpO1xuICAgIHJldHVybiBudWxsXG4gIH0gZWxzZSBpZiAoaXNDb21wMikge1xuICAgIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsIHRoaXMuX2JvdW5kYWJsZTEsIHByaVEsIG1pbkRpc3RhbmNlKTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ25laXRoZXIgYm91bmRhYmxlIGlzIGNvbXBvc2l0ZScpXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuaXNMZWF2ZXMgPSBmdW5jdGlvbiBpc0xlYXZlcyAoKSB7XG4gIHJldHVybiAhKEJvdW5kYWJsZVBhaXIuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSkgfHwgQm91bmRhYmxlUGFpci5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKSlcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIG5kID0gbztcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDwgbmQuX2Rpc3RhbmNlKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA+IG5kLl9kaXN0YW5jZSkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gZXhwYW5kIChibmRDb21wb3NpdGUsIGJuZE90aGVyLCBwcmlRLCBtaW5EaXN0YW5jZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjaGlsZHJlbiA9IGJuZENvbXBvc2l0ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtcbiAgZm9yICh2YXIgaSA9IGNoaWxkcmVuLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBjaGlsZCA9IGkubmV4dCgpO1xuICAgIHZhciBicCA9IG5ldyBCb3VuZGFibGVQYWlyKGNoaWxkLCBibmRPdGhlciwgdGhpcyQxLl9pdGVtRGlzdGFuY2UpO1xuICAgIGlmIChicC5nZXREaXN0YW5jZSgpIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIHByaVEuYWRkKGJwKTtcbiAgICB9XG4gIH1cbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5nZXRCb3VuZGFibGUgPSBmdW5jdGlvbiBnZXRCb3VuZGFibGUgKGkpIHtcbiAgaWYgKGkgPT09IDApIHsgcmV0dXJuIHRoaXMuX2JvdW5kYWJsZTEgfVxuICByZXR1cm4gdGhpcy5fYm91bmRhYmxlMlxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fZGlzdGFuY2Vcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlICgpIHtcbiAgaWYgKHRoaXMuaXNMZWF2ZXMoKSkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtRGlzdGFuY2UuZGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMSwgdGhpcy5fYm91bmRhYmxlMilcbiAgfVxuICByZXR1cm4gdGhpcy5fYm91bmRhYmxlMS5nZXRCb3VuZHMoKS5kaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUyLmdldEJvdW5kcygpKVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCb3VuZGFibGVQYWlyXG59O1xuQm91bmRhYmxlUGFpci5hcmVhID0gZnVuY3Rpb24gYXJlYSAoYikge1xuICByZXR1cm4gYi5nZXRCb3VuZHMoKS5nZXRBcmVhKClcbn07XG5Cb3VuZGFibGVQYWlyLmlzQ29tcG9zaXRlID0gZnVuY3Rpb24gaXNDb21wb3NpdGUgKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0gaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGVcbn07XG5cbnZhciBBYnN0cmFjdFNUUnRyZWUgPSBmdW5jdGlvbiBBYnN0cmFjdFNUUnRyZWUgKCkge1xuICB0aGlzLl9yb290ID0gbnVsbDtcbiAgdGhpcy5fYnVpbHQgPSBmYWxzZTtcbiAgdGhpcy5faXRlbUJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX25vZGVDYXBhY2l0eSA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIG5vZGVDYXBhY2l0eSA9IEFic3RyYWN0U1RSdHJlZS5ERUZBVUxUX05PREVfQ0FQQUNJVFk7XG4gICAgdGhpcy5fbm9kZUNhcGFjaXR5ID0gbm9kZUNhcGFjaXR5O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbm9kZUNhcGFjaXR5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgQXNzZXJ0LmlzVHJ1ZShub2RlQ2FwYWNpdHkkMSA+IDEsICdOb2RlIGNhcGFjaXR5IG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICB0aGlzLl9ub2RlQ2FwYWNpdHkgPSBub2RlQ2FwYWNpdHkkMTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyMyA9IHsgSW50ZXJzZWN0c09wOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sREVGQVVMVF9OT0RFX0NBUEFDSVRZOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmdldE5vZGVDYXBhY2l0eSA9IGZ1bmN0aW9uIGdldE5vZGVDYXBhY2l0eSAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlQ2FwYWNpdHlcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmxhc3ROb2RlID0gZnVuY3Rpb24gbGFzdE5vZGUgKG5vZGVzKSB7XG4gIHJldHVybiBub2Rlcy5nZXQobm9kZXMuc2l6ZSgpIC0gMSlcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgdGhpcy5idWlsZCgpO1xuICAgIHJldHVybiB0aGlzLnNpemUodGhpcy5fcm9vdClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGZvciAodmFyIGkgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgc2l6ZSArPSB0aGlzJDEuc2l6ZShjaGlsZEJvdW5kYWJsZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgSXRlbUJvdW5kYWJsZSkge1xuICAgICAgICBzaXplICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaXplXG4gIH1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiByZW1vdmVJdGVtIChub2RlLCBpdGVtKSB7XG4gIHZhciBjaGlsZFRvUmVtb3ZlID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgSXRlbUJvdW5kYWJsZSkge1xuICAgICAgaWYgKGNoaWxkQm91bmRhYmxlLmdldEl0ZW0oKSA9PT0gaXRlbSkgeyBjaGlsZFRvUmVtb3ZlID0gY2hpbGRCb3VuZGFibGU7IH1cbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkVG9SZW1vdmUgIT09IG51bGwpIHtcbiAgICBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShjaGlsZFRvUmVtb3ZlKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuaXRlbXNUcmVlID0gZnVuY3Rpb24gaXRlbXNUcmVlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgICB2YXIgdmFsdWVzVHJlZSA9IHRoaXMuaXRlbXNUcmVlKHRoaXMuX3Jvb3QpO1xuICAgIGlmICh2YWx1ZXNUcmVlID09PSBudWxsKSB7IHJldHVybiBuZXcgQXJyYXlMaXN0KCkgfVxuICAgIHJldHVybiB2YWx1ZXNUcmVlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBub2RlID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB2YWx1ZXNUcmVlRm9yTm9kZSA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgICAgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgIHZhciB2YWx1ZXNUcmVlRm9yQ2hpbGQgPSB0aGlzJDEuaXRlbXNUcmVlKGNoaWxkQm91bmRhYmxlKTtcbiAgICAgICAgaWYgKHZhbHVlc1RyZWVGb3JDaGlsZCAhPT0gbnVsbCkgeyB2YWx1ZXNUcmVlRm9yTm9kZS5hZGQodmFsdWVzVHJlZUZvckNoaWxkKTsgfVxuICAgICAgfSBlbHNlIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEl0ZW1Cb3VuZGFibGUpIHtcbiAgICAgICAgdmFsdWVzVHJlZUZvck5vZGUuYWRkKGNoaWxkQm91bmRhYmxlLmdldEl0ZW0oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlc1RyZWVGb3JOb2RlLnNpemUoKSA8PSAwKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gdmFsdWVzVHJlZUZvck5vZGVcbiAgfVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0IChib3VuZHMsIGl0ZW0pIHtcbiAgQXNzZXJ0LmlzVHJ1ZSghdGhpcy5fYnVpbHQsICdDYW5ub3QgaW5zZXJ0IGl0ZW1zIGludG8gYW4gU1RSIHBhY2tlZCBSLXRyZWUgYWZ0ZXIgaXQgaGFzIGJlZW4gYnVpbHQuJyk7XG4gIHRoaXMuX2l0ZW1Cb3VuZGFibGVzLmFkZChuZXcgSXRlbUJvdW5kYWJsZShib3VuZHMsIGl0ZW0pKTtcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmJvdW5kYWJsZXNBdExldmVsID0gZnVuY3Rpb24gYm91bmRhYmxlc0F0TGV2ZWwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxldmVsID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBib3VuZGFibGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHRoaXMuYm91bmRhYmxlc0F0TGV2ZWwobGV2ZWwsIHRoaXMuX3Jvb3QsIGJvdW5kYWJsZXMpO1xuICAgIHJldHVybiBib3VuZGFibGVzXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBsZXZlbCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB0b3AgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGJvdW5kYWJsZXMkMSA9IGFyZ3VtZW50c1syXTtcbiAgICBBc3NlcnQuaXNUcnVlKGxldmVsJDEgPiAtMik7XG4gICAgaWYgKHRvcC5nZXRMZXZlbCgpID09PSBsZXZlbCQxKSB7XG4gICAgICBib3VuZGFibGVzJDEuYWRkKHRvcCk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gdG9wLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgICAgaWYgKGJvdW5kYWJsZSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICB0aGlzJDEuYm91bmRhYmxlc0F0TGV2ZWwobGV2ZWwkMSwgYm91bmRhYmxlLCBib3VuZGFibGVzJDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQXNzZXJ0LmlzVHJ1ZShib3VuZGFibGUgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKTtcbiAgICAgICAgaWYgKGxldmVsJDEgPT09IC0xKSB7XG4gICAgICAgICAgYm91bmRhYmxlcyQxLmFkZChib3VuZGFibGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHNlYXJjaEJvdW5kcyA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksIHNlYXJjaEJvdW5kcykpIHtcbiAgICAgIHRoaXMucXVlcnkoc2VhcmNoQm91bmRzLCB0aGlzLl9yb290LCBtYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXNcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHNlYXJjaEJvdW5kcyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB2aXNpdG9yID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGlmICh0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSwgc2VhcmNoQm91bmRzJDEpKSB7XG4gICAgICB0aGlzLnF1ZXJ5KHNlYXJjaEJvdW5kcyQxLCB0aGlzLl9yb290LCB2aXNpdG9yKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzJdLCBJdGVtVmlzaXRvcikgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpKSB7XG4gICAgICB2YXIgc2VhcmNoQm91bmRzJDIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciB2aXNpdG9yJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGVzID0gbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRCb3VuZGFibGVzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGNoaWxkQm91bmRhYmxlcy5nZXQoaSk7XG4gICAgICAgIGlmICghdGhpcyQxLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoY2hpbGRCb3VuZGFibGUuZ2V0Qm91bmRzKCksIHNlYXJjaEJvdW5kcyQyKSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgICAgdGhpcyQxLnF1ZXJ5KHNlYXJjaEJvdW5kcyQyLCBjaGlsZEJvdW5kYWJsZSwgdmlzaXRvciQxKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEl0ZW1Cb3VuZGFibGUpIHtcbiAgICAgICAgICB2aXNpdG9yJDEudmlzaXRJdGVtKGNoaWxkQm91bmRhYmxlLmdldEl0ZW0oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMl0sIExpc3QpICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3QgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSkge1xuICAgICAgdmFyIHNlYXJjaEJvdW5kcyQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIG5vZGUkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBtYXRjaGVzJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGVzJDEgPSBub2RlJDEuZ2V0Q2hpbGRCb3VuZGFibGVzKCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZEJvdW5kYWJsZXMkMS5zaXplKCk7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSQxID0gY2hpbGRCb3VuZGFibGVzJDEuZ2V0KGkkMSk7XG4gICAgICAgIGlmICghdGhpcyQxLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoY2hpbGRCb3VuZGFibGUkMS5nZXRCb3VuZHMoKSwgc2VhcmNoQm91bmRzJDMpKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRCb3VuZGFibGUkMSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICAgIHRoaXMkMS5xdWVyeShzZWFyY2hCb3VuZHMkMywgY2hpbGRCb3VuZGFibGUkMSwgbWF0Y2hlcyQxKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZEJvdW5kYWJsZSQxIGluc3RhbmNlb2YgSXRlbUJvdW5kYWJsZSkge1xuICAgICAgICAgIG1hdGNoZXMkMS5hZGQoY2hpbGRCb3VuZGFibGUkMS5nZXRJdGVtKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIGJ1aWxkICgpIHtcbiAgaWYgKHRoaXMuX2J1aWx0KSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5fcm9vdCA9IHRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKSA/IHRoaXMuY3JlYXRlTm9kZSgwKSA6IHRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKHRoaXMuX2l0ZW1Cb3VuZGFibGVzLCAtMSk7XG4gIHRoaXMuX2l0ZW1Cb3VuZGFibGVzID0gbnVsbDtcbiAgdGhpcy5fYnVpbHQgPSB0cnVlO1xufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uIGdldFJvb3QgKCkge1xuICB0aGlzLmJ1aWxkKCk7XG4gIHJldHVybiB0aGlzLl9yb290XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHNlYXJjaEJvdW5kcyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW1vdmUoc2VhcmNoQm91bmRzLCB0aGlzLl9yb290LCBpdGVtKVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIHNlYXJjaEJvdW5kcyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBub2RlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBpdGVtJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGZvdW5kID0gdGhpcy5yZW1vdmVJdGVtKG5vZGUsIGl0ZW0kMSk7XG4gICAgaWYgKGZvdW5kKSB7IHJldHVybiB0cnVlIH1cbiAgICB2YXIgY2hpbGRUb1BydW5lID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgICAgaWYgKCF0aGlzJDEuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhjaGlsZEJvdW5kYWJsZS5nZXRCb3VuZHMoKSwgc2VhcmNoQm91bmRzJDEpKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgZm91bmQgPSB0aGlzJDEucmVtb3ZlKHNlYXJjaEJvdW5kcyQxLCBjaGlsZEJvdW5kYWJsZSwgaXRlbSQxKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgY2hpbGRUb1BydW5lID0gY2hpbGRCb3VuZGFibGU7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hpbGRUb1BydW5lICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGRUb1BydW5lLmdldENoaWxkQm91bmRhYmxlcygpLmlzRW1wdHkoKSkge1xuICAgICAgICBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShjaGlsZFRvUHJ1bmUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm91bmRcbiAgfVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuY3JlYXRlSGlnaGVyTGV2ZWxzID0gZnVuY3Rpb24gY3JlYXRlSGlnaGVyTGV2ZWxzIChib3VuZGFibGVzT2ZBTGV2ZWwsIGxldmVsKSB7XG4gIEFzc2VydC5pc1RydWUoIWJvdW5kYWJsZXNPZkFMZXZlbC5pc0VtcHR5KCkpO1xuICB2YXIgcGFyZW50Qm91bmRhYmxlcyA9IHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlcyhib3VuZGFibGVzT2ZBTGV2ZWwsIGxldmVsICsgMSk7XG4gIGlmIChwYXJlbnRCb3VuZGFibGVzLnNpemUoKSA9PT0gMSkge1xuICAgIHJldHVybiBwYXJlbnRCb3VuZGFibGVzLmdldCgwKVxuICB9XG4gIHJldHVybiB0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyhwYXJlbnRCb3VuZGFibGVzLCBsZXZlbCArIDEpXG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5kZXB0aCA9IGZ1bmN0aW9uIGRlcHRoICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgdGhpcy5idWlsZCgpO1xuICAgIHJldHVybiB0aGlzLmRlcHRoKHRoaXMuX3Jvb3QpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBub2RlID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtYXhDaGlsZERlcHRoID0gMDtcbiAgICBmb3IgKHZhciBpID0gbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgICAgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgIHZhciBjaGlsZERlcHRoID0gdGhpcyQxLmRlcHRoKGNoaWxkQm91bmRhYmxlKTtcbiAgICAgICAgaWYgKGNoaWxkRGVwdGggPiBtYXhDaGlsZERlcHRoKSB7IG1heENoaWxkRGVwdGggPSBjaGlsZERlcHRoOyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhDaGlsZERlcHRoICsgMVxuICB9XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzID0gZnVuY3Rpb24gY3JlYXRlUGFyZW50Qm91bmRhYmxlcyAoY2hpbGRCb3VuZGFibGVzLCBuZXdMZXZlbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIEFzc2VydC5pc1RydWUoIWNoaWxkQm91bmRhYmxlcy5pc0VtcHR5KCkpO1xuICB2YXIgcGFyZW50Qm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgcGFyZW50Qm91bmRhYmxlcy5hZGQodGhpcy5jcmVhdGVOb2RlKG5ld0xldmVsKSk7XG4gIHZhciBzb3J0ZWRDaGlsZEJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KGNoaWxkQm91bmRhYmxlcyk7XG4gIENvbGxlY3Rpb25zLnNvcnQoc29ydGVkQ2hpbGRCb3VuZGFibGVzLCB0aGlzLmdldENvbXBhcmF0b3IoKSk7XG4gIGZvciAodmFyIGkgPSBzb3J0ZWRDaGlsZEJvdW5kYWJsZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgaWYgKHRoaXMkMS5sYXN0Tm9kZShwYXJlbnRCb3VuZGFibGVzKS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5zaXplKCkgPT09IHRoaXMkMS5nZXROb2RlQ2FwYWNpdHkoKSkge1xuICAgICAgcGFyZW50Qm91bmRhYmxlcy5hZGQodGhpcyQxLmNyZWF0ZU5vZGUobmV3TGV2ZWwpKTtcbiAgICB9XG4gICAgdGhpcyQxLmxhc3ROb2RlKHBhcmVudEJvdW5kYWJsZXMpLmFkZENoaWxkQm91bmRhYmxlKGNoaWxkQm91bmRhYmxlKTtcbiAgfVxuICByZXR1cm4gcGFyZW50Qm91bmRhYmxlc1xufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICBpZiAoIXRoaXMuX2J1aWx0KSB7IHJldHVybiB0aGlzLl9pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCkgfVxuICByZXR1cm4gdGhpcy5fcm9vdC5pc0VtcHR5KClcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlcmlhbGl6YWJsZV1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlXG59O1xuQWJzdHJhY3RTVFJ0cmVlLmNvbXBhcmVEb3VibGVzID0gZnVuY3Rpb24gY29tcGFyZURvdWJsZXMgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwXG59O1xuc3RhdGljQWNjZXNzb3JzJDIzLkludGVyc2VjdHNPcC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBJbnRlcnNlY3RzT3AgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0zODg2NDM1ODE0MzYwMjQxMzM3IH07XG5zdGF0aWNBY2Nlc3NvcnMkMjMuREVGQVVMVF9OT0RFX0NBUEFDSVRZLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEwIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBBYnN0cmFjdFNUUnRyZWUsIHN0YXRpY0FjY2Vzc29ycyQyMyApO1xuXG52YXIgSW50ZXJzZWN0c09wID0gZnVuY3Rpb24gSW50ZXJzZWN0c09wICgpIHt9O1xuXG52YXIgSXRlbURpc3RhbmNlID0gZnVuY3Rpb24gSXRlbURpc3RhbmNlICgpIHt9O1xuXG5JdGVtRGlzdGFuY2UucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKGl0ZW0xLCBpdGVtMikge307XG5JdGVtRGlzdGFuY2UucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5JdGVtRGlzdGFuY2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSXRlbURpc3RhbmNlXG59O1xuXG52YXIgU1RSdHJlZSA9IChmdW5jdGlvbiAoQWJzdHJhY3RTVFJ0cmVlJCQxKSB7XG4gIGZ1bmN0aW9uIFNUUnRyZWUgKG5vZGVDYXBhY2l0eSkge1xuICAgIG5vZGVDYXBhY2l0eSA9IG5vZGVDYXBhY2l0eSB8fCBTVFJ0cmVlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWTtcbiAgICBBYnN0cmFjdFNUUnRyZWUkJDEuY2FsbCh0aGlzLCBub2RlQ2FwYWNpdHkpO1xuICB9XG5cbiAgaWYgKCBBYnN0cmFjdFNUUnRyZWUkJDEgKSBTVFJ0cmVlLl9fcHJvdG9fXyA9IEFic3RyYWN0U1RSdHJlZSQkMTtcbiAgU1RSdHJlZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBYnN0cmFjdFNUUnRyZWUkJDEgJiYgQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZSApO1xuICBTVFJ0cmVlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNUUnRyZWU7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgU1RSdHJlZU5vZGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSx4Q29tcGFyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSx5Q29tcGFyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbnRlcnNlY3RzT3A6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sREVGQVVMVF9OT0RFX0NBUEFDSVRZOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMgPSBmdW5jdGlvbiBjcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzICh2ZXJ0aWNhbFNsaWNlcywgbmV3TGV2ZWwpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEFzc2VydC5pc1RydWUodmVydGljYWxTbGljZXMubGVuZ3RoID4gMCk7XG4gICAgdmFyIHBhcmVudEJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNhbFNsaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcGFyZW50Qm91bmRhYmxlcy5hZGRBbGwodGhpcyQxLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSh2ZXJ0aWNhbFNsaWNlc1tpXSwgbmV3TGV2ZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudEJvdW5kYWJsZXNcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5vZGUgKGxldmVsKSB7XG4gICAgcmV0dXJuIG5ldyBTVFJ0cmVlTm9kZShsZXZlbClcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5zaXplLmNhbGwodGhpcylcbiAgICB9IGVsc2UgeyByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5zaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgaXRlbUVudiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGl0ZW1FbnYuaXNOdWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUuaW5zZXJ0LmNhbGwodGhpcywgaXRlbUVudiwgaXRlbSk7XG4gICAgfSBlbHNlIHsgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUuaW5zZXJ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5nZXRJbnRlcnNlY3RzT3AgPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3RzT3AgKCkge1xuICAgIHJldHVybiBTVFJ0cmVlLmludGVyc2VjdHNPcFxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS52ZXJ0aWNhbFNsaWNlcyA9IGZ1bmN0aW9uIHZlcnRpY2FsU2xpY2VzIChjaGlsZEJvdW5kYWJsZXMsIHNsaWNlQ291bnQpIHtcbiAgICB2YXIgc2xpY2VDYXBhY2l0eSA9IE1hdGgudHJ1bmMoTWF0aC5jZWlsKGNoaWxkQm91bmRhYmxlcy5zaXplKCkgLyBzbGljZUNvdW50KSk7XG4gICAgdmFyIHNsaWNlcyA9IG5ldyBBcnJheShzbGljZUNvdW50KS5maWxsKG51bGwpO1xuICAgIHZhciBpID0gY2hpbGRCb3VuZGFibGVzLml0ZXJhdG9yKCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzbGljZUNvdW50OyBqKyspIHtcbiAgICAgIHNsaWNlc1tqXSA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICAgIHZhciBib3VuZGFibGVzQWRkZWRUb1NsaWNlID0gMDtcbiAgICAgIHdoaWxlIChpLmhhc05leHQoKSAmJiBib3VuZGFibGVzQWRkZWRUb1NsaWNlIDwgc2xpY2VDYXBhY2l0eSkge1xuICAgICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgICAgc2xpY2VzW2pdLmFkZChjaGlsZEJvdW5kYWJsZSk7XG4gICAgICAgIGJvdW5kYWJsZXNBZGRlZFRvU2xpY2UrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsaWNlc1xuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHNlYXJjaEVudiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgc2VhcmNoRW52KVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIHNlYXJjaEVudiQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHZpc2l0b3IgPSBhcmd1bWVudHNbMV07XG4gICAgICBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgc2VhcmNoRW52JDEsIHZpc2l0b3IpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMl0sIEl0ZW1WaXNpdG9yKSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkpIHtcbiAgICAgICAgdmFyIHNlYXJjaEJvdW5kcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciB2aXNpdG9yJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBzZWFyY2hCb3VuZHMsIG5vZGUsIHZpc2l0b3IkMSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMl0sIExpc3QpICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3QgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSkge1xuICAgICAgICB2YXIgc2VhcmNoQm91bmRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBub2RlJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBtYXRjaGVzID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgc2VhcmNoQm91bmRzJDEsIG5vZGUkMSwgbWF0Y2hlcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5nZXRDb21wYXJhdG9yID0gZnVuY3Rpb24gZ2V0Q29tcGFyYXRvciAoKSB7XG4gICAgcmV0dXJuIFNUUnRyZWUueUNvbXBhcmF0b3JcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlID0gZnVuY3Rpb24gY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlIChjaGlsZEJvdW5kYWJsZXMsIG5ld0xldmVsKSB7XG4gICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlcy5jYWxsKHRoaXMsIGNoaWxkQm91bmRhYmxlcywgbmV3TGV2ZWwpXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBpdGVtRW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMV07XG4gICAgICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBpdGVtRW52LCBpdGVtKVxuICAgIH0gZWxzZSB7IHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuZGVwdGggPSBmdW5jdGlvbiBkZXB0aCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLmRlcHRoLmNhbGwodGhpcylcbiAgICB9IGVsc2UgeyByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5kZXB0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlcyA9IGZ1bmN0aW9uIGNyZWF0ZVBhcmVudEJvdW5kYWJsZXMgKGNoaWxkQm91bmRhYmxlcywgbmV3TGV2ZWwpIHtcbiAgICBBc3NlcnQuaXNUcnVlKCFjaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpKTtcbiAgICB2YXIgbWluTGVhZkNvdW50ID0gTWF0aC50cnVuYyhNYXRoLmNlaWwoY2hpbGRCb3VuZGFibGVzLnNpemUoKSAvIHRoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkpKTtcbiAgICB2YXIgc29ydGVkQ2hpbGRCb3VuZGFibGVzID0gbmV3IEFycmF5TGlzdChjaGlsZEJvdW5kYWJsZXMpO1xuICAgIENvbGxlY3Rpb25zLnNvcnQoc29ydGVkQ2hpbGRCb3VuZGFibGVzLCBTVFJ0cmVlLnhDb21wYXJhdG9yKTtcbiAgICB2YXIgdmVydGljYWxTbGljZXMgPSB0aGlzLnZlcnRpY2FsU2xpY2VzKHNvcnRlZENoaWxkQm91bmRhYmxlcywgTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5zcXJ0KG1pbkxlYWZDb3VudCkpKSk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyh2ZXJ0aWNhbFNsaWNlcywgbmV3TGV2ZWwpXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLm5lYXJlc3ROZWlnaGJvdXIgPSBmdW5jdGlvbiBuZWFyZXN0TmVpZ2hib3VyICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEl0ZW1EaXN0YW5jZSkpIHtcbiAgICAgICAgdmFyIGl0ZW1EaXN0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgYnAgPSBuZXcgQm91bmRhYmxlUGFpcih0aGlzLmdldFJvb3QoKSwgdGhpcy5nZXRSb290KCksIGl0ZW1EaXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihicClcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQm91bmRhYmxlUGFpcikge1xuICAgICAgICB2YXIgaW5pdEJuZFBhaXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoaW5pdEJuZFBhaXIsIERvdWJsZS5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBTVFJ0cmVlICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIEl0ZW1EaXN0YW5jZSkpIHtcbiAgICAgICAgdmFyIHRyZWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBpdGVtRGlzdCQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgYnAkMSA9IG5ldyBCb3VuZGFibGVQYWlyKHRoaXMuZ2V0Um9vdCgpLCB0cmVlLmdldFJvb3QoKSwgaXRlbURpc3QkMSk7XG4gICAgICAgIHJldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoYnAkMSlcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQm91bmRhYmxlUGFpciAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgaW5pdEJuZFBhaXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIG1heERpc3RhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgZGlzdGFuY2VMb3dlckJvdW5kID0gbWF4RGlzdGFuY2U7XG4gICAgICAgIHZhciBtaW5QYWlyID0gbnVsbDtcbiAgICAgICAgdmFyIHByaVEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICAgICAgICBwcmlRLmFkZChpbml0Qm5kUGFpciQxKTtcbiAgICAgICAgd2hpbGUgKCFwcmlRLmlzRW1wdHkoKSAmJiBkaXN0YW5jZUxvd2VyQm91bmQgPiAwLjApIHtcbiAgICAgICAgICB2YXIgYm5kUGFpciA9IHByaVEucG9sbCgpO1xuICAgICAgICAgIHZhciBjdXJyZW50RGlzdGFuY2UgPSBibmRQYWlyLmdldERpc3RhbmNlKCk7XG4gICAgICAgICAgaWYgKGN1cnJlbnREaXN0YW5jZSA+PSBkaXN0YW5jZUxvd2VyQm91bmQpIHsgYnJlYWsgfVxuICAgICAgICAgIGlmIChibmRQYWlyLmlzTGVhdmVzKCkpIHtcbiAgICAgICAgICAgIGRpc3RhbmNlTG93ZXJCb3VuZCA9IGN1cnJlbnREaXN0YW5jZTtcbiAgICAgICAgICAgIG1pblBhaXIgPSBibmRQYWlyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBibmRQYWlyLmV4cGFuZFRvUXVldWUocHJpUSwgZGlzdGFuY2VMb3dlckJvdW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFttaW5QYWlyLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksIG1pblBhaXIuZ2V0Qm91bmRhYmxlKDEpLmdldEl0ZW0oKV1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHZhciBlbnYgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBpdGVtRGlzdCQyID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGJuZCA9IG5ldyBJdGVtQm91bmRhYmxlKGVudiwgaXRlbSk7XG4gICAgICB2YXIgYnAkMiA9IG5ldyBCb3VuZGFibGVQYWlyKHRoaXMuZ2V0Um9vdCgpLCBibmQsIGl0ZW1EaXN0JDIpO1xuICAgICAgcmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihicCQyKVswXVxuICAgIH1cbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtTcGF0aWFsSW5kZXgsIFNlcmlhbGl6YWJsZV1cbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFNUUnRyZWVcbiAgfTtcbiAgU1RSdHJlZS5jZW50cmVYID0gZnVuY3Rpb24gY2VudHJlWCAoZSkge1xuICAgIHJldHVybiBTVFJ0cmVlLmF2ZyhlLmdldE1pblgoKSwgZS5nZXRNYXhYKCkpXG4gIH07XG4gIFNUUnRyZWUuYXZnID0gZnVuY3Rpb24gYXZnIChhLCBiKSB7XG4gICAgcmV0dXJuIChhICsgYikgLyAyXG4gIH07XG4gIFNUUnRyZWUuY2VudHJlWSA9IGZ1bmN0aW9uIGNlbnRyZVkgKGUpIHtcbiAgICByZXR1cm4gU1RSdHJlZS5hdmcoZS5nZXRNaW5ZKCksIGUuZ2V0TWF4WSgpKVxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuU1RSdHJlZU5vZGUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gU1RSdHJlZU5vZGUgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMjU5Mjc0NzAyMzY4OTU2OTAwIH07XG4gIHN0YXRpY0FjY2Vzc29ycy54Q29tcGFyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVyZmFjZXNfOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbQ29tcGFyYXRvcl1cbiAgICAgIH0sXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAobzEsIG8yKSB7XG4gICAgICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEuY29tcGFyZURvdWJsZXMoU1RSdHJlZS5jZW50cmVYKG8xLmdldEJvdW5kcygpKSwgU1RSdHJlZS5jZW50cmVYKG8yLmdldEJvdW5kcygpKSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy55Q29tcGFyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVyZmFjZXNfOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbQ29tcGFyYXRvcl1cbiAgICAgIH0sXG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAobzEsIG8yKSB7XG4gICAgICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEuY29tcGFyZURvdWJsZXMoU1RSdHJlZS5jZW50cmVZKG8xLmdldEJvdW5kcygpKSwgU1RSdHJlZS5jZW50cmVZKG8yLmdldEJvdW5kcygpKSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5pbnRlcnNlY3RzT3AuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnRlcmZhY2VzXzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW0Fic3RyYWN0U1RSdHJlZSQkMS5JbnRlcnNlY3RzT3BdXG4gICAgICB9LFxuICAgICAgaW50ZXJzZWN0czogZnVuY3Rpb24gKGFCb3VuZHMsIGJCb3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIGFCb3VuZHMuaW50ZXJzZWN0cyhiQm91bmRzKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxMCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTVFJ0cmVlLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gU1RSdHJlZTtcbn0oQWJzdHJhY3RTVFJ0cmVlKSk7XG5cbnZhciBTVFJ0cmVlTm9kZSA9IChmdW5jdGlvbiAoQWJzdHJhY3ROb2RlJCQxKSB7XG4gIGZ1bmN0aW9uIFNUUnRyZWVOb2RlICgpIHtcbiAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHNbMF07XG4gICAgQWJzdHJhY3ROb2RlJCQxLmNhbGwodGhpcywgbGV2ZWwpO1xuICB9XG5cbiAgaWYgKCBBYnN0cmFjdE5vZGUkJDEgKSBTVFJ0cmVlTm9kZS5fX3Byb3RvX18gPSBBYnN0cmFjdE5vZGUkJDE7XG4gIFNUUnRyZWVOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFic3RyYWN0Tm9kZSQkMSAmJiBBYnN0cmFjdE5vZGUkJDEucHJvdG90eXBlICk7XG4gIFNUUnRyZWVOb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNUUnRyZWVOb2RlO1xuICBTVFJ0cmVlTm9kZS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kcyA9IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZHMgKCkge1xuICAgIHZhciBib3VuZHMgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoYm91bmRzID09PSBudWxsKSB7XG4gICAgICAgIGJvdW5kcyA9IG5ldyBFbnZlbG9wZShjaGlsZEJvdW5kYWJsZS5nZXRCb3VuZHMoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZHMuZXhwYW5kVG9JbmNsdWRlKGNoaWxkQm91bmRhYmxlLmdldEJvdW5kcygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kc1xuICB9O1xuICBTVFJ0cmVlTm9kZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIFNUUnRyZWVOb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gU1RSdHJlZU5vZGVcbiAgfTtcblxuICByZXR1cm4gU1RSdHJlZU5vZGU7XG59KEFic3RyYWN0Tm9kZSkpO1xuXG52YXIgU2VnbWVudFBvaW50Q29tcGFyYXRvciA9IGZ1bmN0aW9uIFNlZ21lbnRQb2ludENvbXBhcmF0b3IgKCkge307XG5cblNlZ21lbnRQb2ludENvbXBhcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TZWdtZW50UG9pbnRDb21wYXJhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3Jcbn07XG5TZWdtZW50UG9pbnRDb21wYXJhdG9yLnJlbGF0aXZlU2lnbiA9IGZ1bmN0aW9uIHJlbGF0aXZlU2lnbiAoeDAsIHgxKSB7XG4gIGlmICh4MCA8IHgxKSB7IHJldHVybiAtMSB9XG4gIGlmICh4MCA+IHgxKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5TZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChvY3RhbnQsIHAwLCBwMSkge1xuICBpZiAocDAuZXF1YWxzMkQocDEpKSB7IHJldHVybiAwIH1cbiAgdmFyIHhTaWduID0gU2VnbWVudFBvaW50Q29tcGFyYXRvci5yZWxhdGl2ZVNpZ24ocDAueCwgcDEueCk7XG4gIHZhciB5U2lnbiA9IFNlZ21lbnRQb2ludENvbXBhcmF0b3IucmVsYXRpdmVTaWduKHAwLnksIHAxLnkpO1xuICBzd2l0Y2ggKG9jdGFudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSh4U2lnbiwgeVNpZ24pXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKHlTaWduLCB4U2lnbilcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoeVNpZ24sIC14U2lnbilcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoLXhTaWduLCB5U2lnbilcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoLXhTaWduLCAteVNpZ24pXG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKC15U2lnbiwgLXhTaWduKVxuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSgteVNpZ24sIHhTaWduKVxuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSh4U2lnbiwgLXlTaWduKVxuICAgIGRlZmF1bHQ6XG4gIH1cbiAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCdpbnZhbGlkIG9jdGFudCB2YWx1ZScpO1xuICByZXR1cm4gMFxufTtcblNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlID0gZnVuY3Rpb24gY29tcGFyZVZhbHVlIChjb21wYXJlU2lnbjAsIGNvbXBhcmVTaWduMSkge1xuICBpZiAoY29tcGFyZVNpZ24wIDwgMCkgeyByZXR1cm4gLTEgfVxuICBpZiAoY29tcGFyZVNpZ24wID4gMCkgeyByZXR1cm4gMSB9XG4gIGlmIChjb21wYXJlU2lnbjEgPCAwKSB7IHJldHVybiAtMSB9XG4gIGlmIChjb21wYXJlU2lnbjEgPiAwKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5cbnZhciBTZWdtZW50Tm9kZSA9IGZ1bmN0aW9uIFNlZ21lbnROb2RlICgpIHtcbiAgdGhpcy5fc2VnU3RyaW5nID0gbnVsbDtcbiAgdGhpcy5jb29yZCA9IG51bGw7XG4gIHRoaXMuc2VnbWVudEluZGV4ID0gbnVsbDtcbiAgdGhpcy5fc2VnbWVudE9jdGFudCA9IG51bGw7XG4gIHRoaXMuX2lzSW50ZXJpb3IgPSBudWxsO1xuICB2YXIgc2VnU3RyaW5nID0gYXJndW1lbnRzWzBdO1xuICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMV07XG4gIHZhciBzZWdtZW50SW5kZXggPSBhcmd1bWVudHNbMl07XG4gIHZhciBzZWdtZW50T2N0YW50ID0gYXJndW1lbnRzWzNdO1xuICB0aGlzLl9zZWdTdHJpbmcgPSBzZWdTdHJpbmc7XG4gIHRoaXMuY29vcmQgPSBuZXcgQ29vcmRpbmF0ZShjb29yZCk7XG4gIHRoaXMuc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4O1xuICB0aGlzLl9zZWdtZW50T2N0YW50ID0gc2VnbWVudE9jdGFudDtcbiAgdGhpcy5faXNJbnRlcmlvciA9ICFjb29yZC5lcXVhbHMyRChzZWdTdHJpbmcuZ2V0Q29vcmRpbmF0ZShzZWdtZW50SW5kZXgpKTtcbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5jb29yZFxufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgb3V0LnByaW50KHRoaXMuY29vcmQpO1xuICBvdXQucHJpbnQoJyBzZWcgIyA9ICcgKyB0aGlzLnNlZ21lbnRJbmRleCk7XG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAob2JqKSB7XG4gIHZhciBvdGhlciA9IG9iajtcbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4IDwgb3RoZXIuc2VnbWVudEluZGV4KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA+IG90aGVyLnNlZ21lbnRJbmRleCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLmNvb3JkLmVxdWFsczJEKG90aGVyLmNvb3JkKSkgeyByZXR1cm4gMCB9XG4gIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmUodGhpcy5fc2VnbWVudE9jdGFudCwgdGhpcy5jb29yZCwgb3RoZXIuY29vcmQpXG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLmlzRW5kUG9pbnQgPSBmdW5jdGlvbiBpc0VuZFBvaW50IChtYXhTZWdtZW50SW5kZXgpIHtcbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4ID09PSAwICYmICF0aGlzLl9pc0ludGVyaW9yKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4ID09PSBtYXhTZWdtZW50SW5kZXgpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUuaXNJbnRlcmlvciA9IGZ1bmN0aW9uIGlzSW50ZXJpb3IgKCkge1xuICByZXR1cm4gdGhpcy5faXNJbnRlcmlvclxufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNlZ21lbnROb2RlXG59O1xuXG4vLyBpbXBvcnQgSXRlcmF0b3IgZnJvbSAnLi4vLi4vLi4vLi4vamF2YS91dGlsL0l0ZXJhdG9yJ1xudmFyIFNlZ21lbnROb2RlTGlzdCA9IGZ1bmN0aW9uIFNlZ21lbnROb2RlTGlzdCAoKSB7XG4gIHRoaXMuX25vZGVNYXAgPSBuZXcgVHJlZU1hcCgpO1xuICB0aGlzLl9lZGdlID0gbnVsbDtcbiAgdmFyIGVkZ2UgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2VkZ2UgPSBlZGdlO1xufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuZ2V0U3BsaXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldFNwbGl0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb29yZExpc3QgPSBuZXcgQ29vcmRpbmF0ZUxpc3QoKTtcbiAgdGhpcy5hZGRFbmRwb2ludHMoKTtcbiAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpO1xuICB2YXIgZWlQcmV2ID0gaXQubmV4dCgpO1xuICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIHRoaXMkMS5hZGRFZGdlQ29vcmRpbmF0ZXMoZWlQcmV2LCBlaSwgY29vcmRMaXN0KTtcbiAgICBlaVByZXYgPSBlaTtcbiAgfVxuICByZXR1cm4gY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KClcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmFkZENvbGxhcHNlZE5vZGVzID0gZnVuY3Rpb24gYWRkQ29sbGFwc2VkTm9kZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLmZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2Rlcyhjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzKTtcbiAgdGhpcy5maW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXMoY29sbGFwc2VkVmVydGV4SW5kZXhlcyk7XG4gIGZvciAodmFyIGl0ID0gY29sbGFwc2VkVmVydGV4SW5kZXhlcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHZlcnRleEluZGV4ID0gaXQubmV4dCgpLmludFZhbHVlKCk7XG4gICAgdGhpcyQxLmFkZCh0aGlzJDEuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSh2ZXJ0ZXhJbmRleCksIHZlcnRleEluZGV4KTtcbiAgfVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gIG91dC5wcmludGxuKCdJbnRlcnNlY3Rpb25zOicpO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlaSA9IGl0Lm5leHQoKTtcbiAgICBlaS5wcmludChvdXQpO1xuICB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5maW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXMgPSBmdW5jdGlvbiBmaW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXMgKGNvbGxhcHNlZFZlcnRleEluZGV4ZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2VkZ2Uuc2l6ZSgpIC0gMjsgaSsrKSB7XG4gICAgdmFyIHAwID0gdGhpcyQxLl9lZGdlLmdldENvb3JkaW5hdGUoaSk7XG4gICAgLy8gY29uc3QgcDEgPSB0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoaSArIDEpXG4gICAgdmFyIHAyID0gdGhpcyQxLl9lZGdlLmdldENvb3JkaW5hdGUoaSArIDIpO1xuICAgIGlmIChwMC5lcXVhbHMyRChwMikpIHtcbiAgICAgIGNvbGxhcHNlZFZlcnRleEluZGV4ZXMuYWRkKG5ldyBJbnRlZ2VyKGkgKyAxKSk7XG4gICAgfVxuICB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5hZGRFZGdlQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBhZGRFZGdlQ29vcmRpbmF0ZXMgKGVpMCwgZWkxLCBjb29yZExpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBsZXQgbnB0cyA9IGVpMS5zZWdtZW50SW5kZXggLSBlaTAuc2VnbWVudEluZGV4ICsgMlxuICB2YXIgbGFzdFNlZ1N0YXJ0UHQgPSB0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZWkxLnNlZ21lbnRJbmRleCk7XG4gIHZhciB1c2VJbnRQdDEgPSBlaTEuaXNJbnRlcmlvcigpIHx8ICFlaTEuY29vcmQuZXF1YWxzMkQobGFzdFNlZ1N0YXJ0UHQpO1xuICAvLyBpZiAoIXVzZUludFB0MSkge1xuICAvLyBucHRzLS1cbiAgLy8gfVxuICAvLyBjb25zdCBpcHQgPSAwXG4gIGNvb3JkTGlzdC5hZGQobmV3IENvb3JkaW5hdGUoZWkwLmNvb3JkKSwgZmFsc2UpO1xuICBmb3IgKHZhciBpID0gZWkwLnNlZ21lbnRJbmRleCArIDE7IGkgPD0gZWkxLnNlZ21lbnRJbmRleDsgaSsrKSB7XG4gICAgY29vcmRMaXN0LmFkZCh0aGlzJDEuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShpKSk7XG4gIH1cbiAgaWYgKHVzZUludFB0MSkge1xuICAgIGNvb3JkTGlzdC5hZGQobmV3IENvb3JkaW5hdGUoZWkxLmNvb3JkKSk7XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpXG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5hZGRTcGxpdEVkZ2VzID0gZnVuY3Rpb24gYWRkU3BsaXRFZGdlcyAoZWRnZUxpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmFkZEVuZHBvaW50cygpO1xuICB0aGlzLmFkZENvbGxhcHNlZE5vZGVzKCk7XG4gIHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgdmFyIGVpUHJldiA9IGl0Lm5leHQoKTtcbiAgd2hpbGUgKGl0Lmhhc05leHQoKSkge1xuICAgIHZhciBlaSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbmV3RWRnZSA9IHRoaXMkMS5jcmVhdGVTcGxpdEVkZ2UoZWlQcmV2LCBlaSk7XG4gICAgZWRnZUxpc3QuYWRkKG5ld0VkZ2UpO1xuICAgIGVpUHJldiA9IGVpO1xuICB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5maW5kQ29sbGFwc2VJbmRleCA9IGZ1bmN0aW9uIGZpbmRDb2xsYXBzZUluZGV4IChlaTAsIGVpMSwgY29sbGFwc2VkVmVydGV4SW5kZXgpIHtcbiAgaWYgKCFlaTAuY29vcmQuZXF1YWxzMkQoZWkxLmNvb3JkKSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgbnVtVmVydGljZXNCZXR3ZWVuID0gZWkxLnNlZ21lbnRJbmRleCAtIGVpMC5zZWdtZW50SW5kZXg7XG4gIGlmICghZWkxLmlzSW50ZXJpb3IoKSkge1xuICAgIG51bVZlcnRpY2VzQmV0d2Vlbi0tO1xuICB9XG4gIGlmIChudW1WZXJ0aWNlc0JldHdlZW4gPT09IDEpIHtcbiAgICBjb2xsYXBzZWRWZXJ0ZXhJbmRleFswXSA9IGVpMC5zZWdtZW50SW5kZXggKyAxO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXMgPSBmdW5jdGlvbiBmaW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXMgKGNvbGxhcHNlZFZlcnRleEluZGV4ZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29sbGFwc2VkVmVydGV4SW5kZXggPSBuZXcgQXJyYXkoMSkuZmlsbChudWxsKTtcbiAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpO1xuICB2YXIgZWlQcmV2ID0gaXQubmV4dCgpO1xuICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIHZhciBpc0NvbGxhcHNlZCA9IHRoaXMkMS5maW5kQ29sbGFwc2VJbmRleChlaVByZXYsIGVpLCBjb2xsYXBzZWRWZXJ0ZXhJbmRleCk7XG4gICAgaWYgKGlzQ29sbGFwc2VkKSB7IGNvbGxhcHNlZFZlcnRleEluZGV4ZXMuYWRkKG5ldyBJbnRlZ2VyKGNvbGxhcHNlZFZlcnRleEluZGV4WzBdKSk7IH1cbiAgICBlaVByZXYgPSBlaTtcbiAgfVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uIGdldEVkZ2UgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuYWRkRW5kcG9pbnRzID0gZnVuY3Rpb24gYWRkRW5kcG9pbnRzICgpIHtcbiAgdmFyIG1heFNlZ0luZGV4ID0gdGhpcy5fZWRnZS5zaXplKCkgLSAxO1xuICB0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoMCksIDApO1xuICB0aGlzLmFkZCh0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUobWF4U2VnSW5kZXgpLCBtYXhTZWdJbmRleCk7XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5jcmVhdGVTcGxpdEVkZ2UgPSBmdW5jdGlvbiBjcmVhdGVTcGxpdEVkZ2UgKGVpMCwgZWkxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5wdHMgPSBlaTEuc2VnbWVudEluZGV4IC0gZWkwLnNlZ21lbnRJbmRleCArIDI7XG4gIHZhciBsYXN0U2VnU3RhcnRQdCA9IHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlaTEuc2VnbWVudEluZGV4KTtcbiAgdmFyIHVzZUludFB0MSA9IGVpMS5pc0ludGVyaW9yKCkgfHwgIWVpMS5jb29yZC5lcXVhbHMyRChsYXN0U2VnU3RhcnRQdCk7XG4gIGlmICghdXNlSW50UHQxKSB7XG4gICAgbnB0cy0tO1xuICB9XG4gIHZhciBwdHMgPSBuZXcgQXJyYXkobnB0cykuZmlsbChudWxsKTtcbiAgdmFyIGlwdCA9IDA7XG4gIHB0c1tpcHQrK10gPSBuZXcgQ29vcmRpbmF0ZShlaTAuY29vcmQpO1xuICBmb3IgKHZhciBpID0gZWkwLnNlZ21lbnRJbmRleCArIDE7IGkgPD0gZWkxLnNlZ21lbnRJbmRleDsgaSsrKSB7XG4gICAgcHRzW2lwdCsrXSA9IHRoaXMkMS5fZWRnZS5nZXRDb29yZGluYXRlKGkpO1xuICB9XG4gIGlmICh1c2VJbnRQdDEpIHsgcHRzW2lwdF0gPSBuZXcgQ29vcmRpbmF0ZShlaTEuY29vcmQpOyB9XG4gIHJldHVybiBuZXcgTm9kZWRTZWdtZW50U3RyaW5nKHB0cywgdGhpcy5fZWRnZS5nZXREYXRhKCkpXG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGludFB0LCBzZWdtZW50SW5kZXgpIHtcbiAgdmFyIGVpTmV3ID0gbmV3IFNlZ21lbnROb2RlKHRoaXMuX2VkZ2UsIGludFB0LCBzZWdtZW50SW5kZXgsIHRoaXMuX2VkZ2UuZ2V0U2VnbWVudE9jdGFudChzZWdtZW50SW5kZXgpKTtcbiAgdmFyIGVpID0gdGhpcy5fbm9kZU1hcC5nZXQoZWlOZXcpO1xuICBpZiAoZWkgIT09IG51bGwpIHtcbiAgICBBc3NlcnQuaXNUcnVlKGVpLmNvb3JkLmVxdWFsczJEKGludFB0KSwgJ0ZvdW5kIGVxdWFsIG5vZGVzIHdpdGggZGlmZmVyZW50IGNvb3JkaW5hdGVzJyk7XG4gICAgcmV0dXJuIGVpXG4gIH1cbiAgdGhpcy5fbm9kZU1hcC5wdXQoZWlOZXcsIGVpTmV3KTtcbiAgcmV0dXJuIGVpTmV3XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5jaGVja1NwbGl0RWRnZXNDb3JyZWN0bmVzcyA9IGZ1bmN0aW9uIGNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzIChzcGxpdEVkZ2VzKSB7XG4gIHZhciBlZGdlUHRzID0gdGhpcy5fZWRnZS5nZXRDb29yZGluYXRlcygpO1xuICB2YXIgc3BsaXQwID0gc3BsaXRFZGdlcy5nZXQoMCk7XG4gIHZhciBwdDAgPSBzcGxpdDAuZ2V0Q29vcmRpbmF0ZSgwKTtcbiAgaWYgKCFwdDAuZXF1YWxzMkQoZWRnZVB0c1swXSkpIHsgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ2JhZCBzcGxpdCBlZGdlIHN0YXJ0IHBvaW50IGF0ICcgKyBwdDApIH1cbiAgdmFyIHNwbGl0biA9IHNwbGl0RWRnZXMuZ2V0KHNwbGl0RWRnZXMuc2l6ZSgpIC0gMSk7XG4gIHZhciBzcGxpdG5QdHMgPSBzcGxpdG4uZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgdmFyIHB0biA9IHNwbGl0blB0c1tzcGxpdG5QdHMubGVuZ3RoIC0gMV07XG4gIGlmICghcHRuLmVxdWFsczJEKGVkZ2VQdHNbZWRnZVB0cy5sZW5ndGggLSAxXSkpIHsgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ2JhZCBzcGxpdCBlZGdlIGVuZCBwb2ludCBhdCAnICsgcHRuKSB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNlZ21lbnROb2RlTGlzdFxufTtcblxuXG5cbi8vIGNsYXNzIE5vZGVWZXJ0ZXhJdGVyYXRvciB7XG4vLyAgIGNvbnN0cnVjdG9yICgpIHtcbi8vICAgICB0aGlzLl9ub2RlTGlzdCA9IG51bGxcbi8vICAgICB0aGlzLl9lZGdlID0gbnVsbFxuLy8gICAgIHRoaXMuX25vZGVJdCA9IG51bGxcbi8vICAgICB0aGlzLl9jdXJyTm9kZSA9IG51bGxcbi8vICAgICB0aGlzLl9uZXh0Tm9kZSA9IG51bGxcbi8vICAgICB0aGlzLl9jdXJyU2VnSW5kZXggPSAwXG4vLyAgICAgbGV0IG5vZGVMaXN0ID0gYXJndW1lbnRzWzBdXG4vLyAgICAgdGhpcy5fbm9kZUxpc3QgPSBub2RlTGlzdFxuLy8gICAgIHRoaXMuX2VkZ2UgPSBub2RlTGlzdC5nZXRFZGdlKClcbi8vICAgICB0aGlzLl9ub2RlSXQgPSBub2RlTGlzdC5pdGVyYXRvcigpXG4vLyAgICAgdGhpcy5yZWFkTmV4dE5vZGUoKVxuLy8gICB9XG4vLyAgIG5leHQgKCkge1xuLy8gICAgIGlmICh0aGlzLl9jdXJyTm9kZSA9PT0gbnVsbCkge1xuLy8gICAgICAgdGhpcy5fY3Vyck5vZGUgPSB0aGlzLl9uZXh0Tm9kZVxuLy8gICAgICAgdGhpcy5fY3VyclNlZ0luZGV4ID0gdGhpcy5fY3Vyck5vZGUuc2VnbWVudEluZGV4XG4vLyAgICAgICB0aGlzLnJlYWROZXh0Tm9kZSgpXG4vLyAgICAgICByZXR1cm4gdGhpcy5fY3Vyck5vZGVcbi8vICAgICB9XG4vLyAgICAgaWYgKHRoaXMuX25leHROb2RlID09PSBudWxsKSByZXR1cm4gbnVsbFxuLy8gICAgIGlmICh0aGlzLl9uZXh0Tm9kZS5zZWdtZW50SW5kZXggPT09IHRoaXMuX2N1cnJOb2RlLnNlZ21lbnRJbmRleCkge1xuLy8gICAgICAgdGhpcy5fY3Vyck5vZGUgPSB0aGlzLl9uZXh0Tm9kZVxuLy8gICAgICAgdGhpcy5fY3VyclNlZ0luZGV4ID0gdGhpcy5fY3Vyck5vZGUuc2VnbWVudEluZGV4XG4vLyAgICAgICB0aGlzLnJlYWROZXh0Tm9kZSgpXG4vLyAgICAgICByZXR1cm4gdGhpcy5fY3Vyck5vZGVcbi8vICAgICB9XG4vLyAgICAgaWYgKHRoaXMuX25leHROb2RlLnNlZ21lbnRJbmRleCA+IHRoaXMuX2N1cnJOb2RlLnNlZ21lbnRJbmRleCkge31cbi8vICAgICByZXR1cm4gbnVsbFxuLy8gICB9XG4vLyAgIHJlbW92ZSAoKSB7XG4vLyAgICAgLy8gdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpXG4vLyAgIH1cbi8vICAgaGFzTmV4dCAoKSB7XG4vLyAgICAgaWYgKHRoaXMuX25leHROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2Vcbi8vICAgICByZXR1cm4gdHJ1ZVxuLy8gICB9XG4vLyAgIHJlYWROZXh0Tm9kZSAoKSB7XG4vLyAgICAgaWYgKHRoaXMuX25vZGVJdC5oYXNOZXh0KCkpIHRoaXMuX25leHROb2RlID0gdGhpcy5fbm9kZUl0Lm5leHQoKTsgZWxzZSB0aGlzLl9uZXh0Tm9kZSA9IG51bGxcbi8vICAgfVxuLy8gICBpbnRlcmZhY2VzXyAoKSB7XG4vLyAgICAgcmV0dXJuIFtJdGVyYXRvcl1cbi8vICAgfVxuLy8gICBnZXRDbGFzcyAoKSB7XG4vLyAgICAgcmV0dXJuIE5vZGVWZXJ0ZXhJdGVyYXRvclxuLy8gICB9XG4vLyB9XG5cbnZhciBPY3RhbnQgPSBmdW5jdGlvbiBPY3RhbnQgKCkge307XG5cbk9jdGFudC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk9jdGFudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPY3RhbnRcbn07XG5PY3RhbnQub2N0YW50ID0gZnVuY3Rpb24gb2N0YW50ICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIGR4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZHggPT09IDAuMCAmJiBkeSA9PT0gMC4wKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHBvaW50ICggJyArIGR4ICsgJywgJyArIGR5ICsgJyApJykgfVxuICAgIHZhciBhZHggPSBNYXRoLmFicyhkeCk7XG4gICAgdmFyIGFkeSA9IE1hdGguYWJzKGR5KTtcbiAgICBpZiAoZHggPj0gMCkge1xuICAgICAgaWYgKGR5ID49IDApIHtcbiAgICAgICAgaWYgKGFkeCA+PSBhZHkpIHsgcmV0dXJuIDA7IH0gZWxzZSB7IHJldHVybiAxIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhZHggPj0gYWR5KSB7IHJldHVybiA3OyB9IGVsc2UgeyByZXR1cm4gNiB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkeSA+PSAwKSB7XG4gICAgICAgIGlmIChhZHggPj0gYWR5KSB7IHJldHVybiAzOyB9IGVsc2UgeyByZXR1cm4gMiB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYWR4ID49IGFkeSkgeyByZXR1cm4gNDsgfSBlbHNlIHsgcmV0dXJuIDUgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkeCQxID0gcDEueCAtIHAwLng7XG4gICAgdmFyIGR5JDEgPSBwMS55IC0gcDAueTtcbiAgICBpZiAoZHgkMSA9PT0gMC4wICYmIGR5JDEgPT09IDAuMCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyAnICsgcDApIH1cbiAgICByZXR1cm4gT2N0YW50Lm9jdGFudChkeCQxLCBkeSQxKVxuICB9XG59O1xuXG52YXIgU2VnbWVudFN0cmluZyA9IGZ1bmN0aW9uIFNlZ21lbnRTdHJpbmcgKCkge307XG5cblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge307XG5TZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKCkge307XG5TZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YSAoZGF0YSkge307XG5TZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YSAoKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNlZ21lbnRTdHJpbmdcbn07XG5cbnZhciBOb2RhYmxlU2VnbWVudFN0cmluZyA9IGZ1bmN0aW9uIE5vZGFibGVTZWdtZW50U3RyaW5nICgpIHt9O1xuXG5Ob2RhYmxlU2VnbWVudFN0cmluZy5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gYWRkSW50ZXJzZWN0aW9uIChpbnRQdCwgc2VnbWVudEluZGV4KSB7fTtcbk5vZGFibGVTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZWdtZW50U3RyaW5nXVxufTtcbk5vZGFibGVTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGFibGVTZWdtZW50U3RyaW5nXG59O1xuXG52YXIgTm9kZWRTZWdtZW50U3RyaW5nID0gZnVuY3Rpb24gTm9kZWRTZWdtZW50U3RyaW5nICgpIHtcbiAgdGhpcy5fbm9kZUxpc3QgPSBuZXcgU2VnbWVudE5vZGVMaXN0KHRoaXMpO1xuICB0aGlzLl9wdHMgPSBudWxsO1xuICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX3B0cyA9IHB0cztcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0c1xufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICByZXR1cm4gdGhpcy5fcHRzLmxlbmd0aFxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgcmV0dXJuIHRoaXMuX3B0c1tpXVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7XG4gIHJldHVybiB0aGlzLl9wdHNbMF0uZXF1YWxzKHRoaXMuX3B0c1t0aGlzLl9wdHMubGVuZ3RoIC0gMV0pXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRTZWdtZW50T2N0YW50ID0gZnVuY3Rpb24gZ2V0U2VnbWVudE9jdGFudCAoaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSB0aGlzLl9wdHMubGVuZ3RoIC0gMSkgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gdGhpcy5zYWZlT2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZShpbmRleCksIHRoaXMuZ2V0Q29vcmRpbmF0ZShpbmRleCArIDEpKVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEgKGRhdGEpIHtcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zYWZlT2N0YW50ID0gZnVuY3Rpb24gc2FmZU9jdGFudCAocDAsIHAxKSB7XG4gIGlmIChwMC5lcXVhbHMyRChwMSkpIHsgcmV0dXJuIDAgfVxuICByZXR1cm4gT2N0YW50Lm9jdGFudChwMCwgcDEpXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YSAoKSB7XG4gIHJldHVybiB0aGlzLl9kYXRhXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBpbnRQdCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzZWdtZW50SW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5hZGRJbnRlcnNlY3Rpb25Ob2RlKGludFB0JDEsIHNlZ21lbnRJbmRleCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBsaSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2VnbWVudEluZGV4JDEgPSBhcmd1bWVudHNbMV07XG4gICAgLy8gY29uc3QgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzJdXG4gICAgdmFyIGludEluZGV4ID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBpbnRQdCA9IG5ldyBDb29yZGluYXRlKGxpLmdldEludGVyc2VjdGlvbihpbnRJbmRleCkpO1xuICAgIHRoaXMuYWRkSW50ZXJzZWN0aW9uKGludFB0LCBzZWdtZW50SW5kZXgkMSk7XG4gIH1cbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gV0tUV3JpdGVyLnRvTGluZVN0cmluZyhuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UodGhpcy5fcHRzKSlcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldE5vZGVMaXN0ID0gZnVuY3Rpb24gZ2V0Tm9kZUxpc3QgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZUxpc3Rcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmFkZEludGVyc2VjdGlvbk5vZGUgPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb25Ob2RlIChpbnRQdCwgc2VnbWVudEluZGV4KSB7XG4gIHZhciBub3JtYWxpemVkU2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4O1xuICB2YXIgbmV4dFNlZ0luZGV4ID0gbm9ybWFsaXplZFNlZ21lbnRJbmRleCArIDE7XG4gIGlmIChuZXh0U2VnSW5kZXggPCB0aGlzLl9wdHMubGVuZ3RoKSB7XG4gICAgdmFyIG5leHRQdCA9IHRoaXMuX3B0c1tuZXh0U2VnSW5kZXhdO1xuICAgIGlmIChpbnRQdC5lcXVhbHMyRChuZXh0UHQpKSB7XG4gICAgICBub3JtYWxpemVkU2VnbWVudEluZGV4ID0gbmV4dFNlZ0luZGV4O1xuICAgIH1cbiAgfVxuICB2YXIgZWkgPSB0aGlzLl9ub2RlTGlzdC5hZGQoaW50UHQsIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXgpO1xuICByZXR1cm4gZWlcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmFkZEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb25zIChsaSwgc2VnbWVudEluZGV4LCBnZW9tSW5kZXgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpLmdldEludGVyc2VjdGlvbk51bSgpOyBpKyspIHtcbiAgICB0aGlzJDEuYWRkSW50ZXJzZWN0aW9uKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCwgaSk7XG4gIH1cbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW05vZGFibGVTZWdtZW50U3RyaW5nXVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOb2RlZFNlZ21lbnRTdHJpbmdcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcuZ2V0Tm9kZWRTdWJzdHJpbmdzID0gZnVuY3Rpb24gZ2V0Tm9kZWRTdWJzdHJpbmdzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2VnU3RyaW5ncyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcmVzdWx0RWRnZWxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgTm9kZWRTZWdtZW50U3RyaW5nLmdldE5vZGVkU3Vic3RyaW5ncyhzZWdTdHJpbmdzLCByZXN1bHRFZGdlbGlzdCk7XG4gICAgcmV0dXJuIHJlc3VsdEVkZ2VsaXN0XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBzZWdTdHJpbmdzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHJlc3VsdEVkZ2VsaXN0JDEgPSBhcmd1bWVudHNbMV07XG4gICAgZm9yICh2YXIgaSA9IHNlZ1N0cmluZ3MkMS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBzcyA9IGkubmV4dCgpO1xuICAgICAgc3MuZ2V0Tm9kZUxpc3QoKS5hZGRTcGxpdEVkZ2VzKHJlc3VsdEVkZ2VsaXN0JDEpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIExpbmVTZWdtZW50ID0gZnVuY3Rpb24gTGluZVNlZ21lbnQgKCkge1xuICB0aGlzLnAwID0gbnVsbDtcbiAgdGhpcy5wMSA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5wMCA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgdGhpcy5wMSA9IG5ldyBDb29yZGluYXRlKCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBscyA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnAwID0gbmV3IENvb3JkaW5hdGUobHMucDApO1xuICAgIHRoaXMucDEgPSBuZXcgQ29vcmRpbmF0ZShscy5wMSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMucDAgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5wMSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHgwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5MCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgeDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHkxID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMucDAgPSBuZXcgQ29vcmRpbmF0ZSh4MCwgeTApO1xuICAgIHRoaXMucDEgPSBuZXcgQ29vcmRpbmF0ZSh4MSwgeTEpO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDI0ID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubWluWCA9IGZ1bmN0aW9uIG1pblggKCkge1xuICByZXR1cm4gTWF0aC5taW4odGhpcy5wMC54LCB0aGlzLnAxLngpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm9yaWVudGF0aW9uSW5kZXggPSBmdW5jdGlvbiBvcmllbnRhdGlvbkluZGV4ICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTZWdtZW50KSB7XG4gICAgdmFyIHNlZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb3JpZW50MCA9IENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsIHRoaXMucDEsIHNlZy5wMCk7XG4gICAgdmFyIG9yaWVudDEgPSBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleCh0aGlzLnAwLCB0aGlzLnAxLCBzZWcucDEpO1xuICAgIGlmIChvcmllbnQwID49IDAgJiYgb3JpZW50MSA+PSAwKSB7IHJldHVybiBNYXRoLm1heChvcmllbnQwLCBvcmllbnQxKSB9XG4gICAgaWYgKG9yaWVudDAgPD0gMCAmJiBvcmllbnQxIDw9IDApIHsgcmV0dXJuIE1hdGgubWF4KG9yaWVudDAsIG9yaWVudDEpIH1cbiAgICByZXR1cm4gMFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCwgdGhpcy5wMSwgcClcbiAgfVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS50b0dlb21ldHJ5ID0gZnVuY3Rpb24gdG9HZW9tZXRyeSAoZ2VvbUZhY3RvcnkpIHtcbiAgcmV0dXJuIGdlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMucDAsIHRoaXMucDFdKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5pc1ZlcnRpY2FsID0gZnVuY3Rpb24gaXNWZXJ0aWNhbCAoKSB7XG4gIHJldHVybiB0aGlzLnAwLnggPT09IHRoaXMucDEueFxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExpbmVTZWdtZW50KSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBvdGhlciA9IG87XG4gIHJldHVybiB0aGlzLnAwLmVxdWFscyhvdGhlci5wMCkgJiYgdGhpcy5wMS5lcXVhbHMob3RoZXIucDEpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAobGluZSkge1xuICB2YXIgbGkgPSBuZXcgUm9idXN0TGluZUludGVyc2VjdG9yKCk7XG4gIGxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCwgdGhpcy5wMSwgbGluZS5wMCwgbGluZS5wMSk7XG4gIGlmIChsaS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gbGkuZ2V0SW50ZXJzZWN0aW9uKDApIH1cbiAgcmV0dXJuIG51bGxcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uIHByb2plY3QgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChwLmVxdWFscyh0aGlzLnAwKSB8fCBwLmVxdWFscyh0aGlzLnAxKSkgeyByZXR1cm4gbmV3IENvb3JkaW5hdGUocCkgfVxuICAgIHZhciByID0gdGhpcy5wcm9qZWN0aW9uRmFjdG9yKHApO1xuICAgIHZhciBjb29yZCA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgY29vcmQueCA9IHRoaXMucDAueCArIHIgKiAodGhpcy5wMS54IC0gdGhpcy5wMC54KTtcbiAgICBjb29yZC55ID0gdGhpcy5wMC55ICsgciAqICh0aGlzLnAxLnkgLSB0aGlzLnAwLnkpO1xuICAgIHJldHVybiBjb29yZFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTZWdtZW50KSB7XG4gICAgdmFyIHNlZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcGYwID0gdGhpcy5wcm9qZWN0aW9uRmFjdG9yKHNlZy5wMCk7XG4gICAgdmFyIHBmMSA9IHRoaXMucHJvamVjdGlvbkZhY3RvcihzZWcucDEpO1xuICAgIGlmIChwZjAgPj0gMS4wICYmIHBmMSA+PSAxLjApIHsgcmV0dXJuIG51bGwgfVxuICAgIGlmIChwZjAgPD0gMC4wICYmIHBmMSA8PSAwLjApIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBuZXdwMCA9IHRoaXMucHJvamVjdChzZWcucDApO1xuICAgIGlmIChwZjAgPCAwLjApIHsgbmV3cDAgPSB0aGlzLnAwOyB9XG4gICAgaWYgKHBmMCA+IDEuMCkgeyBuZXdwMCA9IHRoaXMucDE7IH1cbiAgICB2YXIgbmV3cDEgPSB0aGlzLnByb2plY3Qoc2VnLnAxKTtcbiAgICBpZiAocGYxIDwgMC4wKSB7IG5ld3AxID0gdGhpcy5wMDsgfVxuICAgIGlmIChwZjEgPiAxLjApIHsgbmV3cDEgPSB0aGlzLnAxOyB9XG4gICAgcmV0dXJuIG5ldyBMaW5lU2VnbWVudChuZXdwMCwgbmV3cDEpXG4gIH1cbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplICgpIHtcbiAgaWYgKHRoaXMucDEuY29tcGFyZVRvKHRoaXMucDApIDwgMCkgeyB0aGlzLnJldmVyc2UoKTsgfVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5hbmdsZSA9IGZ1bmN0aW9uIGFuZ2xlICgpIHtcbiAgcmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55IC0gdGhpcy5wMC55LCB0aGlzLnAxLnggLSB0aGlzLnAwLngpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7XG4gIGlmIChpID09PSAwKSB7IHJldHVybiB0aGlzLnAwIH1cbiAgcmV0dXJuIHRoaXMucDFcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuZGlzdGFuY2VQZXJwZW5kaWN1bGFyID0gZnVuY3Rpb24gZGlzdGFuY2VQZXJwZW5kaWN1bGFyIChwKSB7XG4gIHJldHVybiBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmVQZXJwZW5kaWN1bGFyKHAsIHRoaXMucDAsIHRoaXMucDEpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm1pblkgPSBmdW5jdGlvbiBtaW5ZICgpIHtcbiAgcmV0dXJuIE1hdGgubWluKHRoaXMucDAueSwgdGhpcy5wMS55KVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5taWRQb2ludCA9IGZ1bmN0aW9uIG1pZFBvaW50ICgpIHtcbiAgcmV0dXJuIExpbmVTZWdtZW50Lm1pZFBvaW50KHRoaXMucDAsIHRoaXMucDEpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnByb2plY3Rpb25GYWN0b3IgPSBmdW5jdGlvbiBwcm9qZWN0aW9uRmFjdG9yIChwKSB7XG4gIGlmIChwLmVxdWFscyh0aGlzLnAwKSkgeyByZXR1cm4gMC4wIH1cbiAgaWYgKHAuZXF1YWxzKHRoaXMucDEpKSB7IHJldHVybiAxLjAgfVxuICB2YXIgZHggPSB0aGlzLnAxLnggLSB0aGlzLnAwLng7XG4gIHZhciBkeSA9IHRoaXMucDEueSAtIHRoaXMucDAueTtcbiAgdmFyIGxlbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICBpZiAobGVuIDw9IDAuMCkgeyByZXR1cm4gRG91YmxlLk5hTiB9XG4gIHZhciByID0gKChwLnggLSB0aGlzLnAwLngpICogZHggKyAocC55IC0gdGhpcy5wMC55KSAqIGR5KSAvIGxlbjtcbiAgcmV0dXJuIHJcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuY2xvc2VzdFBvaW50cyA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludHMgKGxpbmUpIHtcbiAgdmFyIGludFB0ID0gdGhpcy5pbnRlcnNlY3Rpb24obGluZSk7XG4gIGlmIChpbnRQdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBbaW50UHQsIGludFB0XVxuICB9XG4gIHZhciBjbG9zZXN0UHQgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgdmFyIG1pbkRpc3RhbmNlID0gRG91YmxlLk1BWF9WQUxVRTtcbiAgdmFyIGRpc3QgPSBudWxsO1xuICB2YXIgY2xvc2UwMCA9IHRoaXMuY2xvc2VzdFBvaW50KGxpbmUucDApO1xuICBtaW5EaXN0YW5jZSA9IGNsb3NlMDAuZGlzdGFuY2UobGluZS5wMCk7XG4gIGNsb3Nlc3RQdFswXSA9IGNsb3NlMDA7XG4gIGNsb3Nlc3RQdFsxXSA9IGxpbmUucDA7XG4gIHZhciBjbG9zZTAxID0gdGhpcy5jbG9zZXN0UG9pbnQobGluZS5wMSk7XG4gIGRpc3QgPSBjbG9zZTAxLmRpc3RhbmNlKGxpbmUucDEpO1xuICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgIGNsb3Nlc3RQdFswXSA9IGNsb3NlMDE7XG4gICAgY2xvc2VzdFB0WzFdID0gbGluZS5wMTtcbiAgfVxuICB2YXIgY2xvc2UxMCA9IGxpbmUuY2xvc2VzdFBvaW50KHRoaXMucDApO1xuICBkaXN0ID0gY2xvc2UxMC5kaXN0YW5jZSh0aGlzLnAwKTtcbiAgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZSkge1xuICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICBjbG9zZXN0UHRbMF0gPSB0aGlzLnAwO1xuICAgIGNsb3Nlc3RQdFsxXSA9IGNsb3NlMTA7XG4gIH1cbiAgdmFyIGNsb3NlMTEgPSBsaW5lLmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtcbiAgZGlzdCA9IGNsb3NlMTEuZGlzdGFuY2UodGhpcy5wMSk7XG4gIGlmIChkaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgICBtaW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgY2xvc2VzdFB0WzBdID0gdGhpcy5wMTtcbiAgICBjbG9zZXN0UHRbMV0gPSBjbG9zZTExO1xuICB9XG4gIHJldHVybiBjbG9zZXN0UHRcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuY2xvc2VzdFBvaW50ID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50IChwKSB7XG4gIHZhciBmYWN0b3IgPSB0aGlzLnByb2plY3Rpb25GYWN0b3IocCk7XG4gIGlmIChmYWN0b3IgPiAwICYmIGZhY3RvciA8IDEpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9qZWN0KHApXG4gIH1cbiAgdmFyIGRpc3QwID0gdGhpcy5wMC5kaXN0YW5jZShwKTtcbiAgdmFyIGRpc3QxID0gdGhpcy5wMS5kaXN0YW5jZShwKTtcbiAgaWYgKGRpc3QwIDwgZGlzdDEpIHsgcmV0dXJuIHRoaXMucDAgfVxuICByZXR1cm4gdGhpcy5wMVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5tYXhYID0gZnVuY3Rpb24gbWF4WCAoKSB7XG4gIHJldHVybiBNYXRoLm1heCh0aGlzLnAwLngsIHRoaXMucDEueClcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgcmV0dXJuIHRoaXMucDAuZGlzdGFuY2UodGhpcy5wMSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBvdGhlciA9IG87XG4gIHZhciBjb21wMCA9IHRoaXMucDAuY29tcGFyZVRvKG90aGVyLnAwKTtcbiAgaWYgKGNvbXAwICE9PSAwKSB7IHJldHVybiBjb21wMCB9XG4gIHJldHVybiB0aGlzLnAxLmNvbXBhcmVUbyhvdGhlci5wMSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICB2YXIgdGVtcCA9IHRoaXMucDA7XG4gIHRoaXMucDAgPSB0aGlzLnAxO1xuICB0aGlzLnAxID0gdGVtcDtcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuZXF1YWxzVG9wbyA9IGZ1bmN0aW9uIGVxdWFsc1RvcG8gKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLnAwLmVxdWFscyhvdGhlci5wMCkgJiZcbiAgICAgICAgKHRoaXMucDEuZXF1YWxzKG90aGVyLnAxKSB8fCB0aGlzLnAwLmVxdWFscyhvdGhlci5wMSkpICYmXG4gICAgICAgICB0aGlzLnAxLmVxdWFscyhvdGhlci5wMClcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubGluZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGxpbmVJbnRlcnNlY3Rpb24gKGxpbmUpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW50UHQgPSBIQ29vcmRpbmF0ZS5pbnRlcnNlY3Rpb24odGhpcy5wMCwgdGhpcy5wMSwgbGluZS5wMCwgbGluZS5wMSk7XG4gICAgcmV0dXJuIGludFB0XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbikge30gZWxzZSB7IHRocm93IGV4IH1cbiAgfSBmaW5hbGx5IHt9XG4gIHJldHVybiBudWxsXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm1heFkgPSBmdW5jdGlvbiBtYXhZICgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHRoaXMucDAueSwgdGhpcy5wMS55KVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5wb2ludEFsb25nT2Zmc2V0ID0gZnVuY3Rpb24gcG9pbnRBbG9uZ09mZnNldCAoc2VnbWVudExlbmd0aEZyYWN0aW9uLCBvZmZzZXREaXN0YW5jZSkge1xuICB2YXIgc2VneCA9IHRoaXMucDAueCArIHNlZ21lbnRMZW5ndGhGcmFjdGlvbiAqICh0aGlzLnAxLnggLSB0aGlzLnAwLngpO1xuICB2YXIgc2VneSA9IHRoaXMucDAueSArIHNlZ21lbnRMZW5ndGhGcmFjdGlvbiAqICh0aGlzLnAxLnkgLSB0aGlzLnAwLnkpO1xuICB2YXIgZHggPSB0aGlzLnAxLnggLSB0aGlzLnAwLng7XG4gIHZhciBkeSA9IHRoaXMucDEueSAtIHRoaXMucDAueTtcbiAgdmFyIGxlbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHZhciB1eCA9IDAuMDtcbiAgdmFyIHV5ID0gMC4wO1xuICBpZiAob2Zmc2V0RGlzdGFuY2UgIT09IDAuMCkge1xuICAgIGlmIChsZW4gPD0gMC4wKSB7IHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgb2Zmc2V0IGZyb20gemVyby1sZW5ndGggbGluZSBzZWdtZW50JykgfVxuICAgIHV4ID0gb2Zmc2V0RGlzdGFuY2UgKiBkeCAvIGxlbjtcbiAgICB1eSA9IG9mZnNldERpc3RhbmNlICogZHkgLyBsZW47XG4gIH1cbiAgdmFyIG9mZnNldHggPSBzZWd4IC0gdXk7XG4gIHZhciBvZmZzZXR5ID0gc2VneSArIHV4O1xuICB2YXIgY29vcmQgPSBuZXcgQ29vcmRpbmF0ZShvZmZzZXR4LCBvZmZzZXR5KTtcbiAgcmV0dXJuIGNvb3JkXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnNldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZXMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBscyA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldENvb3JkaW5hdGVzKGxzLnAwLCBscy5wMSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5wMC54ID0gcDAueDtcbiAgICB0aGlzLnAwLnkgPSBwMC55O1xuICAgIHRoaXMucDEueCA9IHAxLng7XG4gICAgdGhpcy5wMS55ID0gcDEueTtcbiAgfVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5zZWdtZW50RnJhY3Rpb24gPSBmdW5jdGlvbiBzZWdtZW50RnJhY3Rpb24gKGlucHV0UHQpIHtcbiAgdmFyIHNlZ0ZyYWMgPSB0aGlzLnByb2plY3Rpb25GYWN0b3IoaW5wdXRQdCk7XG4gIGlmIChzZWdGcmFjIDwgMC4wKSB7IHNlZ0ZyYWMgPSAwLjA7IH0gZWxzZSBpZiAoc2VnRnJhYyA+IDEuMCB8fCBEb3VibGUuaXNOYU4oc2VnRnJhYykpIHsgc2VnRnJhYyA9IDEuMDsgfVxuICByZXR1cm4gc2VnRnJhY1xufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuICdMSU5FU1RSSU5HKCAnICsgdGhpcy5wMC54ICsgJyAnICsgdGhpcy5wMC55ICsgJywgJyArIHRoaXMucDEueCArICcgJyArIHRoaXMucDEueSArICcpJ1xufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5pc0hvcml6b250YWwgPSBmdW5jdGlvbiBpc0hvcml6b250YWwgKCkge1xuICByZXR1cm4gdGhpcy5wMC55ID09PSB0aGlzLnAxLnlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU2VnbWVudCkge1xuICAgIHZhciBscyA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gQ0dBbGdvcml0aG1zLmRpc3RhbmNlTGluZUxpbmUodGhpcy5wMCwgdGhpcy5wMSwgbHMucDAsIGxzLnAxKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHAsIHRoaXMucDAsIHRoaXMucDEpXG4gIH1cbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUucG9pbnRBbG9uZyA9IGZ1bmN0aW9uIHBvaW50QWxvbmcgKHNlZ21lbnRMZW5ndGhGcmFjdGlvbikge1xuICB2YXIgY29vcmQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICBjb29yZC54ID0gdGhpcy5wMC54ICsgc2VnbWVudExlbmd0aEZyYWN0aW9uICogKHRoaXMucDEueCAtIHRoaXMucDAueCk7XG4gIGNvb3JkLnkgPSB0aGlzLnAwLnkgKyBzZWdtZW50TGVuZ3RoRnJhY3Rpb24gKiAodGhpcy5wMS55IC0gdGhpcy5wMC55KTtcbiAgcmV0dXJuIGNvb3JkXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICB2YXIgYml0czAgPSBEb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAwLngpO1xuICBiaXRzMCBePSBEb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAwLnkpICogMzE7XG4gIHZhciBoYXNoMCA9IE1hdGgudHJ1bmMoYml0czApIF4gTWF0aC50cnVuYyhiaXRzMCA+PiAzMik7XG4gIHZhciBiaXRzMSA9IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueCk7XG4gIGJpdHMxIF49IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueSkgKiAzMTtcbiAgdmFyIGhhc2gxID0gTWF0aC50cnVuYyhiaXRzMSkgXiBNYXRoLnRydW5jKGJpdHMxID4+IDMyKTtcbiAgcmV0dXJuIGhhc2gwIF4gaGFzaDFcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZSwgU2VyaWFsaXphYmxlXVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExpbmVTZWdtZW50XG59O1xuTGluZVNlZ21lbnQubWlkUG9pbnQgPSBmdW5jdGlvbiBtaWRQb2ludCAocDAsIHAxKSB7XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSgocDAueCArIHAxLngpIC8gMiwgKHAwLnkgKyBwMS55KSAvIDIpXG59O1xuc3RhdGljQWNjZXNzb3JzJDI0LnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMzI1MjAwNTgzMzQ2NjI1NjIyNyB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGluZVNlZ21lbnQsIHN0YXRpY0FjY2Vzc29ycyQyNCApO1xuXG52YXIgTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24gPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiAoKSB7XG4gIHRoaXMudGVtcEVudjEgPSBuZXcgRW52ZWxvcGUoKTtcbiAgdGhpcy50ZW1wRW52MiA9IG5ldyBFbnZlbG9wZSgpO1xuICB0aGlzLl9vdmVybGFwU2VnMSA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9vdmVybGFwU2VnMiA9IG5ldyBMaW5lU2VnbWVudCgpO1xufTtcbk1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uLnByb3RvdHlwZS5vdmVybGFwID0gZnVuY3Rpb24gb3ZlcmxhcCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gY29uc3Qgc2VnMSA9IGFyZ3VtZW50c1swXVxuICAgIC8vIGNvbnN0IHNlZzIgPSBhcmd1bWVudHNbMV1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIG1jMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc3RhcnQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYzIgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHN0YXJ0MiA9IGFyZ3VtZW50c1szXTtcbiAgICBtYzEuZ2V0TGluZVNlZ21lbnQoc3RhcnQxLCB0aGlzLl9vdmVybGFwU2VnMSk7XG4gICAgbWMyLmdldExpbmVTZWdtZW50KHN0YXJ0MiwgdGhpcy5fb3ZlcmxhcFNlZzIpO1xuICAgIHRoaXMub3ZlcmxhcCh0aGlzLl9vdmVybGFwU2VnMSwgdGhpcy5fb3ZlcmxhcFNlZzIpO1xuICB9XG59O1xuTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Nb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvblxufTtcblxudmFyIE1vbm90b25lQ2hhaW4gPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluICgpIHtcbiAgdGhpcy5fcHRzID0gbnVsbDtcbiAgdGhpcy5fc3RhcnQgPSBudWxsO1xuICB0aGlzLl9lbmQgPSBudWxsO1xuICB0aGlzLl9lbnYgPSBudWxsO1xuICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5faWQgPSBudWxsO1xuICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMV07XG4gIHZhciBlbmQgPSBhcmd1bWVudHNbMl07XG4gIHZhciBjb250ZXh0ID0gYXJndW1lbnRzWzNdO1xuICB0aGlzLl9wdHMgPSBwdHM7XG4gIHRoaXMuX3N0YXJ0ID0gc3RhcnQ7XG4gIHRoaXMuX2VuZCA9IGVuZDtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0TGluZVNlZ21lbnQgPSBmdW5jdGlvbiBnZXRMaW5lU2VnbWVudCAoaW5kZXgsIGxzKSB7XG4gIGxzLnAwID0gdGhpcy5fcHRzW2luZGV4XTtcbiAgbHMucDEgPSB0aGlzLl9wdHNbaW5kZXggKyAxXTtcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5jb21wdXRlU2VsZWN0ID0gZnVuY3Rpb24gY29tcHV0ZVNlbGVjdCAoc2VhcmNoRW52LCBzdGFydDAsIGVuZDAsIG1jcykge1xuICB2YXIgcDAgPSB0aGlzLl9wdHNbc3RhcnQwXTtcbiAgdmFyIHAxID0gdGhpcy5fcHRzW2VuZDBdO1xuICBtY3MudGVtcEVudjEuaW5pdChwMCwgcDEpO1xuICBpZiAoZW5kMCAtIHN0YXJ0MCA9PT0gMSkge1xuICAgIG1jcy5zZWxlY3QodGhpcywgc3RhcnQwKTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmICghc2VhcmNoRW52LmludGVyc2VjdHMobWNzLnRlbXBFbnYxKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBtaWQgPSBNYXRoLnRydW5jKChzdGFydDAgKyBlbmQwKSAvIDIpO1xuICBpZiAoc3RhcnQwIDwgbWlkKSB7XG4gICAgdGhpcy5jb21wdXRlU2VsZWN0KHNlYXJjaEVudiwgc3RhcnQwLCBtaWQsIG1jcyk7XG4gIH1cbiAgaWYgKG1pZCA8IGVuZDApIHtcbiAgICB0aGlzLmNvbXB1dGVTZWxlY3Qoc2VhcmNoRW52LCBtaWQsIGVuZDAsIG1jcyk7XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29vcmQgPSBuZXcgQXJyYXkodGhpcy5fZW5kIC0gdGhpcy5fc3RhcnQgKyAxKS5maWxsKG51bGwpO1xuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gdGhpcy5fc3RhcnQ7IGkgPD0gdGhpcy5fZW5kOyBpKyspIHtcbiAgICBjb29yZFtpbmRleCsrXSA9IHRoaXMkMS5fcHRzW2ldO1xuICB9XG4gIHJldHVybiBjb29yZFxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmNvbXB1dGVPdmVybGFwcyA9IGZ1bmN0aW9uIGNvbXB1dGVPdmVybGFwcyAobWMsIG1jbykge1xuICB0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKHRoaXMuX3N0YXJ0LCB0aGlzLl9lbmQsIG1jLCBtYy5fc3RhcnQsIG1jLl9lbmQsIG1jbyk7XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuc2V0SWQgPSBmdW5jdGlvbiBzZXRJZCAoaWQpIHtcbiAgdGhpcy5faWQgPSBpZDtcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QgKHNlYXJjaEVudiwgbWNzKSB7XG4gIHRoaXMuY29tcHV0ZVNlbGVjdChzZWFyY2hFbnYsIHRoaXMuX3N0YXJ0LCB0aGlzLl9lbmQsIG1jcyk7XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0RW52ZWxvcGUgPSBmdW5jdGlvbiBnZXRFbnZlbG9wZSAoKSB7XG4gIGlmICh0aGlzLl9lbnYgPT09IG51bGwpIHtcbiAgICB2YXIgcDAgPSB0aGlzLl9wdHNbdGhpcy5fc3RhcnRdO1xuICAgIHZhciBwMSA9IHRoaXMuX3B0c1t0aGlzLl9lbmRdO1xuICAgIHRoaXMuX2VudiA9IG5ldyBFbnZlbG9wZShwMCwgcDEpO1xuICB9XG4gIHJldHVybiB0aGlzLl9lbnZcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRFbmRJbmRleCA9IGZ1bmN0aW9uIGdldEVuZEluZGV4ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VuZFxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldFN0YXJ0SW5kZXggPSBmdW5jdGlvbiBnZXRTdGFydEluZGV4ICgpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YXJ0XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIGdldENvbnRleHQgKCkge1xuICByZXR1cm4gdGhpcy5fY29udGV4dFxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gZ2V0SWQgKCkge1xuICByZXR1cm4gdGhpcy5faWRcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCA9IGZ1bmN0aW9uIGNvbXB1dGVPdmVybGFwc0ludGVybmFsIChzdGFydDAsIGVuZDAsIG1jLCBzdGFydDEsIGVuZDEsIG1jbykge1xuICB2YXIgcDAwID0gdGhpcy5fcHRzW3N0YXJ0MF07XG4gIHZhciBwMDEgPSB0aGlzLl9wdHNbZW5kMF07XG4gIHZhciBwMTAgPSBtYy5fcHRzW3N0YXJ0MV07XG4gIHZhciBwMTEgPSBtYy5fcHRzW2VuZDFdO1xuICBpZiAoZW5kMCAtIHN0YXJ0MCA9PT0gMSAmJiBlbmQxIC0gc3RhcnQxID09PSAxKSB7XG4gICAgbWNvLm92ZXJsYXAodGhpcywgc3RhcnQwLCBtYywgc3RhcnQxKTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIG1jby50ZW1wRW52MS5pbml0KHAwMCwgcDAxKTtcbiAgbWNvLnRlbXBFbnYyLmluaXQocDEwLCBwMTEpO1xuICBpZiAoIW1jby50ZW1wRW52MS5pbnRlcnNlY3RzKG1jby50ZW1wRW52MikpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgbWlkMCA9IE1hdGgudHJ1bmMoKHN0YXJ0MCArIGVuZDApIC8gMik7XG4gIHZhciBtaWQxID0gTWF0aC50cnVuYygoc3RhcnQxICsgZW5kMSkgLyAyKTtcbiAgaWYgKHN0YXJ0MCA8IG1pZDApIHtcbiAgICBpZiAoc3RhcnQxIDwgbWlkMSkgeyB0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKHN0YXJ0MCwgbWlkMCwgbWMsIHN0YXJ0MSwgbWlkMSwgbWNvKTsgfVxuICAgIGlmIChtaWQxIDwgZW5kMSkgeyB0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKHN0YXJ0MCwgbWlkMCwgbWMsIG1pZDEsIGVuZDEsIG1jbyk7IH1cbiAgfVxuICBpZiAobWlkMCA8IGVuZDApIHtcbiAgICBpZiAoc3RhcnQxIDwgbWlkMSkgeyB0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKG1pZDAsIGVuZDAsIG1jLCBzdGFydDEsIG1pZDEsIG1jbyk7IH1cbiAgICBpZiAobWlkMSA8IGVuZDEpIHsgdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbChtaWQwLCBlbmQwLCBtYywgbWlkMSwgZW5kMSwgbWNvKTsgfVxuICB9XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpblxufTtcblxudmFyIE1vbm90b25lQ2hhaW5CdWlsZGVyID0gZnVuY3Rpb24gTW9ub3RvbmVDaGFpbkJ1aWxkZXIgKCkge307XG5cbk1vbm90b25lQ2hhaW5CdWlsZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbkJ1aWxkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpbkJ1aWxkZXJcbn07XG5Nb25vdG9uZUNoYWluQnVpbGRlci5nZXRDaGFpblN0YXJ0SW5kaWNlcyA9IGZ1bmN0aW9uIGdldENoYWluU3RhcnRJbmRpY2VzIChwdHMpIHtcbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIHN0YXJ0SW5kZXhMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBzdGFydEluZGV4TGlzdC5hZGQobmV3IEludGVnZXIoc3RhcnQpKTtcbiAgZG8ge1xuICAgIHZhciBsYXN0ID0gTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZmluZENoYWluRW5kKHB0cywgc3RhcnQpO1xuICAgIHN0YXJ0SW5kZXhMaXN0LmFkZChuZXcgSW50ZWdlcihsYXN0KSk7XG4gICAgc3RhcnQgPSBsYXN0O1xuICB9IHdoaWxlIChzdGFydCA8IHB0cy5sZW5ndGggLSAxKVxuICB2YXIgc3RhcnRJbmRleCA9IE1vbm90b25lQ2hhaW5CdWlsZGVyLnRvSW50QXJyYXkoc3RhcnRJbmRleExpc3QpO1xuICByZXR1cm4gc3RhcnRJbmRleFxufTtcbk1vbm90b25lQ2hhaW5CdWlsZGVyLmZpbmRDaGFpbkVuZCA9IGZ1bmN0aW9uIGZpbmRDaGFpbkVuZCAocHRzLCBzdGFydCkge1xuICB2YXIgc2FmZVN0YXJ0ID0gc3RhcnQ7XG4gIHdoaWxlIChzYWZlU3RhcnQgPCBwdHMubGVuZ3RoIC0gMSAmJiBwdHNbc2FmZVN0YXJ0XS5lcXVhbHMyRChwdHNbc2FmZVN0YXJ0ICsgMV0pKSB7XG4gICAgc2FmZVN0YXJ0Kys7XG4gIH1cbiAgaWYgKHNhZmVTdGFydCA+PSBwdHMubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBwdHMubGVuZ3RoIC0gMVxuICB9XG4gIHZhciBjaGFpblF1YWQgPSBRdWFkcmFudC5xdWFkcmFudChwdHNbc2FmZVN0YXJ0XSwgcHRzW3NhZmVTdGFydCArIDFdKTtcbiAgdmFyIGxhc3QgPSBzdGFydCArIDE7XG4gIHdoaWxlIChsYXN0IDwgcHRzLmxlbmd0aCkge1xuICAgIGlmICghcHRzW2xhc3QgLSAxXS5lcXVhbHMyRChwdHNbbGFzdF0pKSB7XG4gICAgICB2YXIgcXVhZCA9IFF1YWRyYW50LnF1YWRyYW50KHB0c1tsYXN0IC0gMV0sIHB0c1tsYXN0XSk7XG4gICAgICBpZiAocXVhZCAhPT0gY2hhaW5RdWFkKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgbGFzdCsrO1xuICB9XG4gIHJldHVybiBsYXN0IC0gMVxufTtcbk1vbm90b25lQ2hhaW5CdWlsZGVyLmdldENoYWlucyA9IGZ1bmN0aW9uIGdldENoYWlucyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZ2V0Q2hhaW5zKHB0cywgbnVsbClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHB0cyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb250ZXh0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtY0xpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBNb25vdG9uZUNoYWluQnVpbGRlci5nZXRDaGFpblN0YXJ0SW5kaWNlcyhwdHMkMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydEluZGV4Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIG1jID0gbmV3IE1vbm90b25lQ2hhaW4ocHRzJDEsIHN0YXJ0SW5kZXhbaV0sIHN0YXJ0SW5kZXhbaSArIDFdLCBjb250ZXh0KTtcbiAgICAgIG1jTGlzdC5hZGQobWMpO1xuICAgIH1cbiAgICByZXR1cm4gbWNMaXN0XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluQnVpbGRlci50b0ludEFycmF5ID0gZnVuY3Rpb24gdG9JbnRBcnJheSAobGlzdCkge1xuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobGlzdC5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGxpc3QuZ2V0KGkpLmludFZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIGFycmF5XG59O1xuXG52YXIgTm9kZXIgPSBmdW5jdGlvbiBOb2RlciAoKSB7fTtcblxuTm9kZXIucHJvdG90eXBlLmNvbXB1dGVOb2RlcyA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlcyAoc2VnU3RyaW5ncykge307XG5Ob2Rlci5wcm90b3R5cGUuZ2V0Tm9kZWRTdWJzdHJpbmdzID0gZnVuY3Rpb24gZ2V0Tm9kZWRTdWJzdHJpbmdzICgpIHt9O1xuTm9kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Ob2Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOb2RlclxufTtcblxudmFyIFNpbmdsZVBhc3NOb2RlciA9IGZ1bmN0aW9uIFNpbmdsZVBhc3NOb2RlciAoKSB7XG4gIHRoaXMuX3NlZ0ludCA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHNlZ0ludCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldFNlZ21lbnRJbnRlcnNlY3RvcihzZWdJbnQpO1xuICB9XG59O1xuU2luZ2xlUGFzc05vZGVyLnByb3RvdHlwZS5zZXRTZWdtZW50SW50ZXJzZWN0b3IgPSBmdW5jdGlvbiBzZXRTZWdtZW50SW50ZXJzZWN0b3IgKHNlZ0ludCkge1xuICB0aGlzLl9zZWdJbnQgPSBzZWdJbnQ7XG59O1xuU2luZ2xlUGFzc05vZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtOb2Rlcl1cbn07XG5TaW5nbGVQYXNzTm9kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2luZ2xlUGFzc05vZGVyXG59O1xuXG52YXIgTUNJbmRleE5vZGVyID0gKGZ1bmN0aW9uIChTaW5nbGVQYXNzTm9kZXIkJDEpIHtcbiAgZnVuY3Rpb24gTUNJbmRleE5vZGVyIChzaSkge1xuICAgIGlmIChzaSkgeyBTaW5nbGVQYXNzTm9kZXIkJDEuY2FsbCh0aGlzLCBzaSk7IH1cbiAgICBlbHNlIHsgU2luZ2xlUGFzc05vZGVyJCQxLmNhbGwodGhpcyk7IH1cbiAgICB0aGlzLl9tb25vQ2hhaW5zID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHRoaXMuX2luZGV4ID0gbmV3IFNUUnRyZWUoKTtcbiAgICB0aGlzLl9pZENvdW50ZXIgPSAwO1xuICAgIHRoaXMuX25vZGVkU2VnU3RyaW5ncyA9IG51bGw7XG4gICAgdGhpcy5fbk92ZXJsYXBzID0gMDtcbiAgfVxuXG4gIGlmICggU2luZ2xlUGFzc05vZGVyJCQxICkgTUNJbmRleE5vZGVyLl9fcHJvdG9fXyA9IFNpbmdsZVBhc3NOb2RlciQkMTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNpbmdsZVBhc3NOb2RlciQkMSAmJiBTaW5nbGVQYXNzTm9kZXIkJDEucHJvdG90eXBlICk7XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNQ0luZGV4Tm9kZXI7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgU2VnbWVudE92ZXJsYXBBY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5nZXRNb25vdG9uZUNoYWlucyA9IGZ1bmN0aW9uIGdldE1vbm90b25lQ2hhaW5zICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9ub0NoYWluc1xuICB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmdldE5vZGVkU3Vic3RyaW5ncyA9IGZ1bmN0aW9uIGdldE5vZGVkU3Vic3RyaW5ncyAoKSB7XG4gICAgcmV0dXJuIE5vZGVkU2VnbWVudFN0cmluZy5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5fbm9kZWRTZWdTdHJpbmdzKVxuICB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gZ2V0SW5kZXggKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmRleFxuICB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoc2VnU3RyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2VnQ2hhaW5zID0gTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZ2V0Q2hhaW5zKHNlZ1N0ci5nZXRDb29yZGluYXRlcygpLCBzZWdTdHIpO1xuICAgIGZvciAodmFyIGkgPSBzZWdDaGFpbnMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbWMgPSBpLm5leHQoKTtcbiAgICAgIG1jLnNldElkKHRoaXMkMS5faWRDb3VudGVyKyspO1xuICAgICAgdGhpcyQxLl9pbmRleC5pbnNlcnQobWMuZ2V0RW52ZWxvcGUoKSwgbWMpO1xuICAgICAgdGhpcyQxLl9tb25vQ2hhaW5zLmFkZChtYyk7XG4gICAgfVxuICB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmNvbXB1dGVOb2RlcyA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlcyAoaW5wdXRTZWdTdHJpbmdzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLl9ub2RlZFNlZ1N0cmluZ3MgPSBpbnB1dFNlZ1N0cmluZ3M7XG4gICAgZm9yICh2YXIgaSA9IGlucHV0U2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHRoaXMkMS5hZGQoaS5uZXh0KCkpO1xuICAgIH1cbiAgICB0aGlzLmludGVyc2VjdENoYWlucygpO1xuICB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmludGVyc2VjdENoYWlucyA9IGZ1bmN0aW9uIGludGVyc2VjdENoYWlucyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgb3ZlcmxhcEFjdGlvbiA9IG5ldyBTZWdtZW50T3ZlcmxhcEFjdGlvbih0aGlzLl9zZWdJbnQpO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9tb25vQ2hhaW5zLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHF1ZXJ5Q2hhaW4gPSBpLm5leHQoKTtcbiAgICAgIHZhciBvdmVybGFwQ2hhaW5zID0gdGhpcyQxLl9pbmRleC5xdWVyeShxdWVyeUNoYWluLmdldEVudmVsb3BlKCkpO1xuICAgICAgZm9yICh2YXIgaiA9IG92ZXJsYXBDaGFpbnMuaXRlcmF0b3IoKTsgai5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciB0ZXN0Q2hhaW4gPSBqLm5leHQoKTtcbiAgICAgICAgaWYgKHRlc3RDaGFpbi5nZXRJZCgpID4gcXVlcnlDaGFpbi5nZXRJZCgpKSB7XG4gICAgICAgICAgcXVlcnlDaGFpbi5jb21wdXRlT3ZlcmxhcHModGVzdENoYWluLCBvdmVybGFwQWN0aW9uKTtcbiAgICAgICAgICB0aGlzJDEuX25PdmVybGFwcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzJDEuX3NlZ0ludC5pc0RvbmUoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBNQ0luZGV4Tm9kZXJcbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLlNlZ21lbnRPdmVybGFwQWN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlZ21lbnRPdmVybGFwQWN0aW9uIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1DSW5kZXhOb2Rlciwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIE1DSW5kZXhOb2Rlcjtcbn0oU2luZ2xlUGFzc05vZGVyKSk7XG5cbnZhciBTZWdtZW50T3ZlcmxhcEFjdGlvbiA9IChmdW5jdGlvbiAoTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gU2VnbWVudE92ZXJsYXBBY3Rpb24gKCkge1xuICAgIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fc2kgPSBudWxsO1xuICAgIHZhciBzaSA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9zaSA9IHNpO1xuICB9XG5cbiAgaWYgKCBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMSApIFNlZ21lbnRPdmVybGFwQWN0aW9uLl9fcHJvdG9fXyA9IE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxO1xuICBTZWdtZW50T3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMSAmJiBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgU2VnbWVudE92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2VnbWVudE92ZXJsYXBBY3Rpb247XG4gIFNlZ21lbnRPdmVybGFwQWN0aW9uLnByb3RvdHlwZS5vdmVybGFwID0gZnVuY3Rpb24gb3ZlcmxhcCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBtYzEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgc3RhcnQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIG1jMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBzdGFydDIgPSBhcmd1bWVudHNbM107XG4gICAgICB2YXIgc3MxID0gbWMxLmdldENvbnRleHQoKTtcbiAgICAgIHZhciBzczIgPSBtYzIuZ2V0Q29udGV4dCgpO1xuICAgICAgdGhpcy5fc2kucHJvY2Vzc0ludGVyc2VjdGlvbnMoc3MxLCBzdGFydDEsIHNzMiwgc3RhcnQyKTtcbiAgICB9IGVsc2UgeyByZXR1cm4gTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDEucHJvdG90eXBlLm92ZXJsYXAuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFNlZ21lbnRPdmVybGFwQWN0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgU2VnbWVudE92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBTZWdtZW50T3ZlcmxhcEFjdGlvblxuICB9O1xuXG4gIHJldHVybiBTZWdtZW50T3ZlcmxhcEFjdGlvbjtcbn0oTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24pKTtcblxudmFyIEJ1ZmZlclBhcmFtZXRlcnMgPSBmdW5jdGlvbiBCdWZmZXJQYXJhbWV0ZXJzICgpIHtcbiAgdGhpcy5fcXVhZHJhbnRTZWdtZW50cyA9IEJ1ZmZlclBhcmFtZXRlcnMuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUztcbiAgdGhpcy5fZW5kQ2FwU3R5bGUgPSBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9ST1VORDtcbiAgdGhpcy5fam9pblN0eWxlID0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX1JPVU5EO1xuICB0aGlzLl9taXRyZUxpbWl0ID0gQnVmZmVyUGFyYW1ldGVycy5ERUZBVUxUX01JVFJFX0xJTUlUO1xuICB0aGlzLl9pc1NpbmdsZVNpZGVkID0gZmFsc2U7XG4gIHRoaXMuX3NpbXBsaWZ5RmFjdG9yID0gQnVmZmVyUGFyYW1ldGVycy5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge30gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBxdWFkcmFudFNlZ21lbnRzID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhxdWFkcmFudFNlZ21lbnRzKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHF1YWRyYW50U2VnbWVudHMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZW5kQ2FwU3R5bGUgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMkMSk7XG4gICAgdGhpcy5zZXRFbmRDYXBTdHlsZShlbmRDYXBTdHlsZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBxdWFkcmFudFNlZ21lbnRzJDIgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGVuZENhcFN0eWxlJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGpvaW5TdHlsZSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgbWl0cmVMaW1pdCA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLnNldFF1YWRyYW50U2VnbWVudHMocXVhZHJhbnRTZWdtZW50cyQyKTtcbiAgICB0aGlzLnNldEVuZENhcFN0eWxlKGVuZENhcFN0eWxlJDEpO1xuICAgIHRoaXMuc2V0Sm9pblN0eWxlKGpvaW5TdHlsZSk7XG4gICAgdGhpcy5zZXRNaXRyZUxpbWl0KG1pdHJlTGltaXQpO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDI1ID0geyBDQVBfUk9VTkQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ0FQX0ZMQVQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ0FQX1NRVUFSRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxKT0lOX1JPVU5EOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEpPSU5fTUlUUkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sSk9JTl9CRVZFTDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFRkFVTFRfTUlUUkVfTElNSVQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sREVGQVVMVF9TSU1QTElGWV9GQUNUT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmdldEVuZENhcFN0eWxlID0gZnVuY3Rpb24gZ2V0RW5kQ2FwU3R5bGUgKCkge1xuICByZXR1cm4gdGhpcy5fZW5kQ2FwU3R5bGVcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5pc1NpbmdsZVNpZGVkID0gZnVuY3Rpb24gaXNTaW5nbGVTaWRlZCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc1NpbmdsZVNpZGVkXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0UXVhZHJhbnRTZWdtZW50cyA9IGZ1bmN0aW9uIHNldFF1YWRyYW50U2VnbWVudHMgKHF1YWRTZWdzKSB7XG4gIHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPSBxdWFkU2VncztcbiAgaWYgKHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPT09IDApIHsgdGhpcy5fam9pblN0eWxlID0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX0JFVkVMOyB9XG4gIGlmICh0aGlzLl9xdWFkcmFudFNlZ21lbnRzIDwgMCkge1xuICAgIHRoaXMuX2pvaW5TdHlsZSA9IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9NSVRSRTtcbiAgICB0aGlzLl9taXRyZUxpbWl0ID0gTWF0aC5hYnModGhpcy5fcXVhZHJhbnRTZWdtZW50cyk7XG4gIH1cbiAgaWYgKHF1YWRTZWdzIDw9IDApIHtcbiAgICB0aGlzLl9xdWFkcmFudFNlZ21lbnRzID0gMTtcbiAgfVxuICBpZiAodGhpcy5fam9pblN0eWxlICE9PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fUk9VTkQpIHtcbiAgICB0aGlzLl9xdWFkcmFudFNlZ21lbnRzID0gQnVmZmVyUGFyYW1ldGVycy5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTO1xuICB9XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Sm9pblN0eWxlID0gZnVuY3Rpb24gZ2V0Sm9pblN0eWxlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2pvaW5TdHlsZVxufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLnNldEpvaW5TdHlsZSA9IGZ1bmN0aW9uIHNldEpvaW5TdHlsZSAoam9pblN0eWxlKSB7XG4gIHRoaXMuX2pvaW5TdHlsZSA9IGpvaW5TdHlsZTtcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5zZXRTaW1wbGlmeUZhY3RvciA9IGZ1bmN0aW9uIHNldFNpbXBsaWZ5RmFjdG9yIChzaW1wbGlmeUZhY3Rvcikge1xuICB0aGlzLl9zaW1wbGlmeUZhY3RvciA9IHNpbXBsaWZ5RmFjdG9yIDwgMCA/IDAgOiBzaW1wbGlmeUZhY3Rvcjtcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRTaW1wbGlmeUZhY3RvciA9IGZ1bmN0aW9uIGdldFNpbXBsaWZ5RmFjdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NpbXBsaWZ5RmFjdG9yXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0UXVhZHJhbnRTZWdtZW50cyA9IGZ1bmN0aW9uIGdldFF1YWRyYW50U2VnbWVudHMgKCkge1xuICByZXR1cm4gdGhpcy5fcXVhZHJhbnRTZWdtZW50c1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLnNldEVuZENhcFN0eWxlID0gZnVuY3Rpb24gc2V0RW5kQ2FwU3R5bGUgKGVuZENhcFN0eWxlKSB7XG4gIHRoaXMuX2VuZENhcFN0eWxlID0gZW5kQ2FwU3R5bGU7XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0TWl0cmVMaW1pdCA9IGZ1bmN0aW9uIGdldE1pdHJlTGltaXQgKCkge1xuICByZXR1cm4gdGhpcy5fbWl0cmVMaW1pdFxufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLnNldE1pdHJlTGltaXQgPSBmdW5jdGlvbiBzZXRNaXRyZUxpbWl0IChtaXRyZUxpbWl0KSB7XG4gIHRoaXMuX21pdHJlTGltaXQgPSBtaXRyZUxpbWl0O1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLnNldFNpbmdsZVNpZGVkID0gZnVuY3Rpb24gc2V0U2luZ2xlU2lkZWQgKGlzU2luZ2xlU2lkZWQpIHtcbiAgdGhpcy5faXNTaW5nbGVTaWRlZCA9IGlzU2luZ2xlU2lkZWQ7XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyUGFyYW1ldGVyc1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMuYnVmZmVyRGlzdGFuY2VFcnJvciA9IGZ1bmN0aW9uIGJ1ZmZlckRpc3RhbmNlRXJyb3IgKHF1YWRTZWdzKSB7XG4gIHZhciBhbHBoYSA9IE1hdGguUEkgLyAyLjAgLyBxdWFkU2VncztcbiAgcmV0dXJuIDEgLSBNYXRoLmNvcyhhbHBoYSAvIDIuMClcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuQ0FQX1JPVU5ELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5DQVBfRkxBVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuQ0FQX1NRVUFSRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuSk9JTl9ST1VORC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuSk9JTl9NSVRSRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuSk9JTl9CRVZFTC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA4IH07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuREVGQVVMVF9NSVRSRV9MSU1JVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA1LjAgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwLjAxIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJQYXJhbWV0ZXJzLCBzdGF0aWNBY2Nlc3NvcnMkMjUgKTtcblxudmFyIEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIgPSBmdW5jdGlvbiBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyIChpbnB1dExpbmUpIHtcbiAgdGhpcy5fZGlzdGFuY2VUb2wgPSBudWxsO1xuICB0aGlzLl9pc0RlbGV0ZWQgPSBudWxsO1xuICB0aGlzLl9hbmdsZU9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLkNPVU5URVJDTE9DS1dJU0U7XG4gIHRoaXMuX2lucHV0TGluZSA9IGlucHV0TGluZSB8fCBudWxsO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyNiA9IHsgSU5JVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUxFVEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sS0VFUDogeyBjb25maWd1cmFibGU6IHRydWUgfSxOVU1fUFRTX1RPX0NIRUNLOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5pc0RlbGV0YWJsZSA9IGZ1bmN0aW9uIGlzRGVsZXRhYmxlIChpMCwgaTEsIGkyLCBkaXN0YW5jZVRvbCkge1xuICB2YXIgcDAgPSB0aGlzLl9pbnB1dExpbmVbaTBdO1xuICB2YXIgcDEgPSB0aGlzLl9pbnB1dExpbmVbaTFdO1xuICB2YXIgcDIgPSB0aGlzLl9pbnB1dExpbmVbaTJdO1xuICBpZiAoIXRoaXMuaXNDb25jYXZlKHAwLCBwMSwgcDIpKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICghdGhpcy5pc1NoYWxsb3cocDAsIHAxLCBwMiwgZGlzdGFuY2VUb2wpKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0aGlzLmlzU2hhbGxvd1NhbXBsZWQocDAsIHAxLCBpMCwgaTIsIGRpc3RhbmNlVG9sKVxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcyA9IGZ1bmN0aW9uIGRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGluZGV4ID0gMTtcbiAgLy8gY29uc3QgbWF4SW5kZXggPSB0aGlzLl9pbnB1dExpbmUubGVuZ3RoIC0gMVxuICB2YXIgbWlkSW5kZXggPSB0aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGluZGV4KTtcbiAgdmFyIGxhc3RJbmRleCA9IHRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgobWlkSW5kZXgpO1xuICB2YXIgaXNDaGFuZ2VkID0gZmFsc2U7XG4gIHdoaWxlIChsYXN0SW5kZXggPCB0aGlzLl9pbnB1dExpbmUubGVuZ3RoKSB7XG4gICAgdmFyIGlzTWlkZGxlVmVydGV4RGVsZXRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzJDEuaXNEZWxldGFibGUoaW5kZXgsIG1pZEluZGV4LCBsYXN0SW5kZXgsIHRoaXMkMS5fZGlzdGFuY2VUb2wpKSB7XG4gICAgICB0aGlzJDEuX2lzRGVsZXRlZFttaWRJbmRleF0gPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLkRFTEVURTtcbiAgICAgIGlzTWlkZGxlVmVydGV4RGVsZXRlZCA9IHRydWU7XG4gICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNNaWRkbGVWZXJ0ZXhEZWxldGVkKSB7IGluZGV4ID0gbGFzdEluZGV4OyB9IGVsc2UgeyBpbmRleCA9IG1pZEluZGV4OyB9XG4gICAgbWlkSW5kZXggPSB0aGlzJDEuZmluZE5leHROb25EZWxldGVkSW5kZXgoaW5kZXgpO1xuICAgIGxhc3RJbmRleCA9IHRoaXMkMS5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChtaWRJbmRleCk7XG4gIH1cbiAgcmV0dXJuIGlzQ2hhbmdlZFxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmlzU2hhbGxvd0NvbmNhdml0eSA9IGZ1bmN0aW9uIGlzU2hhbGxvd0NvbmNhdml0eSAocDAsIHAxLCBwMiwgZGlzdGFuY2VUb2wpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbihwMCwgcDEsIHAyKTtcbiAgdmFyIGlzQW5nbGVUb1NpbXBsaWZ5ID0gb3JpZW50YXRpb24gPT09IHRoaXMuX2FuZ2xlT3JpZW50YXRpb247XG4gIGlmICghaXNBbmdsZVRvU2ltcGxpZnkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocDEsIHAwLCBwMik7XG4gIHJldHVybiBkaXN0IDwgZGlzdGFuY2VUb2xcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5pc1NoYWxsb3dTYW1wbGVkID0gZnVuY3Rpb24gaXNTaGFsbG93U2FtcGxlZCAocDAsIHAyLCBpMCwgaTIsIGRpc3RhbmNlVG9sKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGluYyA9IE1hdGgudHJ1bmMoKGkyIC0gaTApIC8gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5OVU1fUFRTX1RPX0NIRUNLKTtcbiAgaWYgKGluYyA8PSAwKSB7IGluYyA9IDE7IH1cbiAgZm9yICh2YXIgaSA9IGkwOyBpIDwgaTI7IGkgKz0gaW5jKSB7XG4gICAgaWYgKCF0aGlzJDEuaXNTaGFsbG93KHAwLCBwMiwgdGhpcyQxLl9pbnB1dExpbmVbaV0sIGRpc3RhbmNlVG9sKSkgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuaXNDb25jYXZlID0gZnVuY3Rpb24gaXNDb25jYXZlIChwMCwgcDEsIHAyKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24ocDAsIHAxLCBwMik7XG4gIHZhciBpc0NvbmNhdmUgPSBvcmllbnRhdGlvbiA9PT0gdGhpcy5fYW5nbGVPcmllbnRhdGlvbjtcbiAgcmV0dXJuIGlzQ29uY2F2ZVxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLnNpbXBsaWZ5ID0gZnVuY3Rpb24gc2ltcGxpZnkgKGRpc3RhbmNlVG9sKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fZGlzdGFuY2VUb2wgPSBNYXRoLmFicyhkaXN0YW5jZVRvbCk7XG4gIGlmIChkaXN0YW5jZVRvbCA8IDApIHsgdGhpcy5fYW5nbGVPcmllbnRhdGlvbiA9IENHQWxnb3JpdGhtcy5DTE9DS1dJU0U7IH1cbiAgdGhpcy5faXNEZWxldGVkID0gbmV3IEFycmF5KHRoaXMuX2lucHV0TGluZS5sZW5ndGgpLmZpbGwobnVsbCk7XG4gIHZhciBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgZG8ge1xuICAgIGlzQ2hhbmdlZCA9IHRoaXMkMS5kZWxldGVTaGFsbG93Q29uY2F2aXRpZXMoKTtcbiAgfSB3aGlsZSAoaXNDaGFuZ2VkKVxuICByZXR1cm4gdGhpcy5jb2xsYXBzZUxpbmUoKVxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4ID0gZnVuY3Rpb24gZmluZE5leHROb25EZWxldGVkSW5kZXggKGluZGV4KSB7XG4gIHZhciBuZXh0ID0gaW5kZXggKyAxO1xuICB3aGlsZSAobmV4dCA8IHRoaXMuX2lucHV0TGluZS5sZW5ndGggJiYgdGhpcy5faXNEZWxldGVkW25leHRdID09PSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLkRFTEVURSkgeyBuZXh0Kys7IH1cbiAgcmV0dXJuIG5leHRcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5pc1NoYWxsb3cgPSBmdW5jdGlvbiBpc1NoYWxsb3cgKHAwLCBwMSwgcDIsIGRpc3RhbmNlVG9sKSB7XG4gIHZhciBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHAxLCBwMCwgcDIpO1xuICByZXR1cm4gZGlzdCA8IGRpc3RhbmNlVG9sXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuY29sbGFwc2VMaW5lID0gZnVuY3Rpb24gY29sbGFwc2VMaW5lICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29vcmRMaXN0ID0gbmV3IENvb3JkaW5hdGVMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faW5wdXRMaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5faXNEZWxldGVkW2ldICE9PSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLkRFTEVURSkgeyBjb29yZExpc3QuYWRkKHRoaXMkMS5faW5wdXRMaW5lW2ldKTsgfVxuICB9XG4gIHJldHVybiBjb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKVxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXJcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5ID0gZnVuY3Rpb24gc2ltcGxpZnkgKGlucHV0TGluZSwgZGlzdGFuY2VUb2wpIHtcbiAgdmFyIHNpbXAgPSBuZXcgQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllcihpbnB1dExpbmUpO1xuICByZXR1cm4gc2ltcC5zaW1wbGlmeShkaXN0YW5jZVRvbClcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjYuSU5JVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjYuREVMRVRFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNi5LRUVQLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNi5OVU1fUFRTX1RPX0NIRUNLLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEwIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLCBzdGF0aWNBY2Nlc3NvcnMkMjYgKTtcblxudmFyIE9mZnNldFNlZ21lbnRTdHJpbmcgPSBmdW5jdGlvbiBPZmZzZXRTZWdtZW50U3RyaW5nICgpIHtcbiAgdGhpcy5fcHRMaXN0ID0gbnVsbDtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2UgPSAwLjA7XG4gIHRoaXMuX3B0TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjggPSB7IENPT1JESU5BVEVfQVJSQVlfVFlQRTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHZhciBjb29yZCA9IHRoaXMuX3B0TGlzdC50b0FycmF5KE9mZnNldFNlZ21lbnRTdHJpbmcuQ09PUkRJTkFURV9BUlJBWV9UWVBFKTtcbiAgcmV0dXJuIGNvb3JkXG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2V0UHJlY2lzaW9uTW9kZWwgPSBmdW5jdGlvbiBzZXRQcmVjaXNpb25Nb2RlbCAocHJlY2lzaW9uTW9kZWwpIHtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBwcmVjaXNpb25Nb2RlbDtcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5hZGRQdCA9IGZ1bmN0aW9uIGFkZFB0IChwdCkge1xuICB2YXIgYnVmUHQgPSBuZXcgQ29vcmRpbmF0ZShwdCk7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGJ1ZlB0KTtcbiAgaWYgKHRoaXMuaXNSZWR1bmRhbnQoYnVmUHQpKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5fcHRMaXN0LmFkZChidWZQdCk7XG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUucmV2ZXJlID0gZnVuY3Rpb24gcmV2ZXJlICgpIHt9O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuYWRkUHRzID0gZnVuY3Rpb24gYWRkUHRzIChwdCwgaXNGb3J3YXJkKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGlzRm9yd2FyZCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMkMS5hZGRQdChwdFtpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkkMSA9IHB0Lmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgdGhpcyQxLmFkZFB0KHB0W2kkMV0pO1xuICAgIH1cbiAgfVxufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmlzUmVkdW5kYW50ID0gZnVuY3Rpb24gaXNSZWR1bmRhbnQgKHB0KSB7XG4gIGlmICh0aGlzLl9wdExpc3Quc2l6ZSgpIDwgMSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgbGFzdFB0ID0gdGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpIC0gMSk7XG4gIHZhciBwdERpc3QgPSBwdC5kaXN0YW5jZShsYXN0UHQpO1xuICBpZiAocHREaXN0IDwgdGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBmYWN0ID0gbmV3IEdlb21ldHJ5RmFjdG9yeSgpO1xuICB2YXIgbGluZSA9IGZhY3QuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpO1xuICByZXR1cm4gbGluZS50b1N0cmluZygpXG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuY2xvc2VSaW5nID0gZnVuY3Rpb24gY2xvc2VSaW5nICgpIHtcbiAgaWYgKHRoaXMuX3B0TGlzdC5zaXplKCkgPCAxKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHN0YXJ0UHQgPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9wdExpc3QuZ2V0KDApKTtcbiAgdmFyIGxhc3RQdCA9IHRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKSAtIDEpO1xuICAvLyBjb25zdCBsYXN0MlB0ID0gbnVsbFxuICAvLyBpZiAodGhpcy5fcHRMaXN0LnNpemUoKSA+PSAyKSBsYXN0MlB0ID0gdGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpIC0gMilcbiAgaWYgKHN0YXJ0UHQuZXF1YWxzKGxhc3RQdCkpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9wdExpc3QuYWRkKHN0YXJ0UHQpO1xufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSA9IGZ1bmN0aW9uIHNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSAobWluaW1pbVZlcnRleERpc3RhbmNlKSB7XG4gIHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZSA9IG1pbmltaW1WZXJ0ZXhEaXN0YW5jZTtcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPZmZzZXRTZWdtZW50U3RyaW5nXG59O1xuc3RhdGljQWNjZXNzb3JzJDI4LkNPT1JESU5BVEVfQVJSQVlfVFlQRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXJyYXkoMCkuZmlsbChudWxsKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggT2Zmc2V0U2VnbWVudFN0cmluZywgc3RhdGljQWNjZXNzb3JzJDI4ICk7XG5cbnZhciBBbmdsZSA9IGZ1bmN0aW9uIEFuZ2xlICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDI5ID0geyBQSV9USU1FU18yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFBJX09WRVJfMjogeyBjb25maWd1cmFibGU6IHRydWUgfSxQSV9PVkVSXzQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ09VTlRFUkNMT0NLV0lTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxDTE9DS1dJU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTk9ORTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5BbmdsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkFuZ2xlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEFuZ2xlXG59O1xuQW5nbGUudG9EZWdyZWVzID0gZnVuY3Rpb24gdG9EZWdyZWVzIChyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogMTgwIC8gTWF0aC5QSVxufTtcbkFuZ2xlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoYW5nbGUpIHtcbiAgd2hpbGUgKGFuZ2xlID4gTWF0aC5QSSkgeyBhbmdsZSAtPSBBbmdsZS5QSV9USU1FU18yOyB9XG4gIHdoaWxlIChhbmdsZSA8PSAtTWF0aC5QSSkgeyBhbmdsZSArPSBBbmdsZS5QSV9USU1FU18yOyB9XG4gIHJldHVybiBhbmdsZVxufTtcbkFuZ2xlLmFuZ2xlID0gZnVuY3Rpb24gYW5nbGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHAueSwgcC54KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICAgIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICAgIHJldHVybiBNYXRoLmF0YW4yKGR5LCBkeClcbiAgfVxufTtcbkFuZ2xlLmlzQWN1dGUgPSBmdW5jdGlvbiBpc0FjdXRlIChwMCwgcDEsIHAyKSB7XG4gIHZhciBkeDAgPSBwMC54IC0gcDEueDtcbiAgdmFyIGR5MCA9IHAwLnkgLSBwMS55O1xuICB2YXIgZHgxID0gcDIueCAtIHAxLng7XG4gIHZhciBkeTEgPSBwMi55IC0gcDEueTtcbiAgdmFyIGRvdHByb2QgPSBkeDAgKiBkeDEgKyBkeTAgKiBkeTE7XG4gIHJldHVybiBkb3Rwcm9kID4gMFxufTtcbkFuZ2xlLmlzT2J0dXNlID0gZnVuY3Rpb24gaXNPYnR1c2UgKHAwLCBwMSwgcDIpIHtcbiAgdmFyIGR4MCA9IHAwLnggLSBwMS54O1xuICB2YXIgZHkwID0gcDAueSAtIHAxLnk7XG4gIHZhciBkeDEgPSBwMi54IC0gcDEueDtcbiAgdmFyIGR5MSA9IHAyLnkgLSBwMS55O1xuICB2YXIgZG90cHJvZCA9IGR4MCAqIGR4MSArIGR5MCAqIGR5MTtcbiAgcmV0dXJuIGRvdHByb2QgPCAwXG59O1xuQW5nbGUuaW50ZXJpb3JBbmdsZSA9IGZ1bmN0aW9uIGludGVyaW9yQW5nbGUgKHAwLCBwMSwgcDIpIHtcbiAgdmFyIGFuZ2xlUHJldiA9IEFuZ2xlLmFuZ2xlKHAxLCBwMCk7XG4gIHZhciBhbmdsZU5leHQgPSBBbmdsZS5hbmdsZShwMSwgcDIpO1xuICByZXR1cm4gTWF0aC5hYnMoYW5nbGVOZXh0IC0gYW5nbGVQcmV2KVxufTtcbkFuZ2xlLm5vcm1hbGl6ZVBvc2l0aXZlID0gZnVuY3Rpb24gbm9ybWFsaXplUG9zaXRpdmUgKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA8IDAuMCkge1xuICAgIHdoaWxlIChhbmdsZSA8IDAuMCkgeyBhbmdsZSArPSBBbmdsZS5QSV9USU1FU18yOyB9XG4gICAgaWYgKGFuZ2xlID49IEFuZ2xlLlBJX1RJTUVTXzIpIHsgYW5nbGUgPSAwLjA7IH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoYW5nbGUgPj0gQW5nbGUuUElfVElNRVNfMikgeyBhbmdsZSAtPSBBbmdsZS5QSV9USU1FU18yOyB9XG4gICAgaWYgKGFuZ2xlIDwgMC4wKSB7IGFuZ2xlID0gMC4wOyB9XG4gIH1cbiAgcmV0dXJuIGFuZ2xlXG59O1xuQW5nbGUuYW5nbGVCZXR3ZWVuID0gZnVuY3Rpb24gYW5nbGVCZXR3ZWVuICh0aXAxLCB0YWlsLCB0aXAyKSB7XG4gIHZhciBhMSA9IEFuZ2xlLmFuZ2xlKHRhaWwsIHRpcDEpO1xuICB2YXIgYTIgPSBBbmdsZS5hbmdsZSh0YWlsLCB0aXAyKTtcbiAgcmV0dXJuIEFuZ2xlLmRpZmYoYTEsIGEyKVxufTtcbkFuZ2xlLmRpZmYgPSBmdW5jdGlvbiBkaWZmIChhbmcxLCBhbmcyKSB7XG4gIHZhciBkZWxBbmdsZSA9IG51bGw7XG4gIGlmIChhbmcxIDwgYW5nMikge1xuICAgIGRlbEFuZ2xlID0gYW5nMiAtIGFuZzE7XG4gIH0gZWxzZSB7XG4gICAgZGVsQW5nbGUgPSBhbmcxIC0gYW5nMjtcbiAgfVxuICBpZiAoZGVsQW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgZGVsQW5nbGUgPSAyICogTWF0aC5QSSAtIGRlbEFuZ2xlO1xuICB9XG4gIHJldHVybiBkZWxBbmdsZVxufTtcbkFuZ2xlLnRvUmFkaWFucyA9IGZ1bmN0aW9uIHRvUmFkaWFucyAoYW5nbGVEZWdyZWVzKSB7XG4gIHJldHVybiBhbmdsZURlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjBcbn07XG5BbmdsZS5nZXRUdXJuID0gZnVuY3Rpb24gZ2V0VHVybiAoYW5nMSwgYW5nMikge1xuICB2YXIgY3Jvc3Nwcm9kdWN0ID0gTWF0aC5zaW4oYW5nMiAtIGFuZzEpO1xuICBpZiAoY3Jvc3Nwcm9kdWN0ID4gMCkge1xuICAgIHJldHVybiBBbmdsZS5DT1VOVEVSQ0xPQ0tXSVNFXG4gIH1cbiAgaWYgKGNyb3NzcHJvZHVjdCA8IDApIHtcbiAgICByZXR1cm4gQW5nbGUuQ0xPQ0tXSVNFXG4gIH1cbiAgcmV0dXJuIEFuZ2xlLk5PTkVcbn07XG5BbmdsZS5hbmdsZUJldHdlZW5PcmllbnRlZCA9IGZ1bmN0aW9uIGFuZ2xlQmV0d2Vlbk9yaWVudGVkICh0aXAxLCB0YWlsLCB0aXAyKSB7XG4gIHZhciBhMSA9IEFuZ2xlLmFuZ2xlKHRhaWwsIHRpcDEpO1xuICB2YXIgYTIgPSBBbmdsZS5hbmdsZSh0YWlsLCB0aXAyKTtcbiAgdmFyIGFuZ0RlbCA9IGEyIC0gYTE7XG4gIGlmIChhbmdEZWwgPD0gLU1hdGguUEkpIHsgcmV0dXJuIGFuZ0RlbCArIEFuZ2xlLlBJX1RJTUVTXzIgfVxuICBpZiAoYW5nRGVsID4gTWF0aC5QSSkgeyByZXR1cm4gYW5nRGVsIC0gQW5nbGUuUElfVElNRVNfMiB9XG4gIHJldHVybiBhbmdEZWxcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjkuUElfVElNRVNfMi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyLjAgKiBNYXRoLlBJIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjkuUElfT1ZFUl8yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGguUEkgLyAyLjAgfTtcbnN0YXRpY0FjY2Vzc29ycyQyOS5QSV9PVkVSXzQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5QSSAvIDQuMCB9O1xuc3RhdGljQWNjZXNzb3JzJDI5LkNPVU5URVJDTE9DS1dJU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLkNPVU5URVJDTE9DS1dJU0UgfTtcbnN0YXRpY0FjY2Vzc29ycyQyOS5DTE9DS1dJU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSB9O1xuc3RhdGljQWNjZXNzb3JzJDI5Lk5PTkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLkNPTExJTkVBUiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQW5nbGUsIHN0YXRpY0FjY2Vzc29ycyQyOSApO1xuXG52YXIgT2Zmc2V0U2VnbWVudEdlbmVyYXRvciA9IGZ1bmN0aW9uIE9mZnNldFNlZ21lbnRHZW5lcmF0b3IgKCkge1xuICB0aGlzLl9tYXhDdXJ2ZVNlZ21lbnRFcnJvciA9IDAuMDtcbiAgdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtID0gbnVsbDtcbiAgdGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciA9IDE7XG4gIHRoaXMuX3NlZ0xpc3QgPSBudWxsO1xuICB0aGlzLl9kaXN0YW5jZSA9IDAuMDtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl9idWZQYXJhbXMgPSBudWxsO1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX3MwID0gbnVsbDtcbiAgdGhpcy5fczEgPSBudWxsO1xuICB0aGlzLl9zMiA9IG51bGw7XG4gIHRoaXMuX3NlZzAgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fc2VnMSA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9vZmZzZXQwID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX29mZnNldDEgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fc2lkZSA9IDA7XG4gIHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZSA9IGZhbHNlO1xuICB2YXIgcHJlY2lzaW9uTW9kZWwgPSBhcmd1bWVudHNbMF07XG4gIHZhciBidWZQYXJhbXMgPSBhcmd1bWVudHNbMV07XG4gIHZhciBkaXN0YW5jZSA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBwcmVjaXNpb25Nb2RlbDtcbiAgdGhpcy5fYnVmUGFyYW1zID0gYnVmUGFyYW1zO1xuICB0aGlzLl9saSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtID0gTWF0aC5QSSAvIDIuMCAvIGJ1ZlBhcmFtcy5nZXRRdWFkcmFudFNlZ21lbnRzKCk7XG4gIGlmIChidWZQYXJhbXMuZ2V0UXVhZHJhbnRTZWdtZW50cygpID49IDggJiYgYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpID09PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fUk9VTkQpIHsgdGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciA9IE9mZnNldFNlZ21lbnRHZW5lcmF0b3IuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1I7IH1cbiAgdGhpcy5pbml0KGRpc3RhbmNlKTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjcgPSB7IE9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LElOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxDVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZE5leHRTZWdtZW50ID0gZnVuY3Rpb24gYWRkTmV4dFNlZ21lbnQgKHAsIGFkZFN0YXJ0UG9pbnQpIHtcbiAgdGhpcy5fczAgPSB0aGlzLl9zMTtcbiAgdGhpcy5fczEgPSB0aGlzLl9zMjtcbiAgdGhpcy5fczIgPSBwO1xuICB0aGlzLl9zZWcwLnNldENvb3JkaW5hdGVzKHRoaXMuX3MwLCB0aGlzLl9zMSk7XG4gIHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMCwgdGhpcy5fc2lkZSwgdGhpcy5fZGlzdGFuY2UsIHRoaXMuX29mZnNldDApO1xuICB0aGlzLl9zZWcxLnNldENvb3JkaW5hdGVzKHRoaXMuX3MxLCB0aGlzLl9zMik7XG4gIHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMSwgdGhpcy5fc2lkZSwgdGhpcy5fZGlzdGFuY2UsIHRoaXMuX29mZnNldDEpO1xuICBpZiAodGhpcy5fczEuZXF1YWxzKHRoaXMuX3MyKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBvcmllbnRhdGlvbiA9IENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24odGhpcy5fczAsIHRoaXMuX3MxLCB0aGlzLl9zMik7XG4gIHZhciBvdXRzaWRlVHVybiA9IChvcmllbnRhdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSAmJiB0aGlzLl9zaWRlID09PSBQb3NpdGlvbi5MRUZUKSB8fCAob3JpZW50YXRpb24gPT09IENHQWxnb3JpdGhtcy5DT1VOVEVSQ0xPQ0tXSVNFICYmIHRoaXMuX3NpZGUgPT09IFBvc2l0aW9uLlJJR0hUKTtcbiAgaWYgKG9yaWVudGF0aW9uID09PSAwKSB7XG4gICAgdGhpcy5hZGRDb2xsaW5lYXIoYWRkU3RhcnRQb2ludCk7XG4gIH0gZWxzZSBpZiAob3V0c2lkZVR1cm4pIHtcbiAgICB0aGlzLmFkZE91dHNpZGVUdXJuKG9yaWVudGF0aW9uLCBhZGRTdGFydFBvaW50KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZEluc2lkZVR1cm4ob3JpZW50YXRpb24sIGFkZFN0YXJ0UG9pbnQpO1xuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTGluZUVuZENhcCA9IGZ1bmN0aW9uIGFkZExpbmVFbmRDYXAgKHAwLCBwMSkge1xuICB2YXIgc2VnID0gbmV3IExpbmVTZWdtZW50KHAwLCBwMSk7XG4gIHZhciBvZmZzZXRMID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQoc2VnLCBQb3NpdGlvbi5MRUZULCB0aGlzLl9kaXN0YW5jZSwgb2Zmc2V0TCk7XG4gIHZhciBvZmZzZXRSID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQoc2VnLCBQb3NpdGlvbi5SSUdIVCwgdGhpcy5fZGlzdGFuY2UsIG9mZnNldFIpO1xuICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgc3dpdGNoICh0aGlzLl9idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSkge1xuICAgIGNhc2UgQnVmZmVyUGFyYW1ldGVycy5DQVBfUk9VTkQ6XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KG9mZnNldEwucDEpO1xuICAgICAgdGhpcy5hZGRGaWxsZXRBcmMocDEsIGFuZ2xlICsgTWF0aC5QSSAvIDIsIGFuZ2xlIC0gTWF0aC5QSSAvIDIsIENHQWxnb3JpdGhtcy5DTE9DS1dJU0UsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0Ui5wMSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgQnVmZmVyUGFyYW1ldGVycy5DQVBfRkxBVDpcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0TC5wMSk7XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KG9mZnNldFIucDEpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1NRVUFSRTpcbiAgICAgIHZhciBzcXVhcmVDYXBTaWRlT2Zmc2V0ID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICAgIHNxdWFyZUNhcFNpZGVPZmZzZXQueCA9IE1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHNxdWFyZUNhcFNpZGVPZmZzZXQueSA9IE1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHZhciBzcXVhcmVDYXBMT2Zmc2V0ID0gbmV3IENvb3JkaW5hdGUob2Zmc2V0TC5wMS54ICsgc3F1YXJlQ2FwU2lkZU9mZnNldC54LCBvZmZzZXRMLnAxLnkgKyBzcXVhcmVDYXBTaWRlT2Zmc2V0LnkpO1xuICAgICAgdmFyIHNxdWFyZUNhcFJPZmZzZXQgPSBuZXcgQ29vcmRpbmF0ZShvZmZzZXRSLnAxLnggKyBzcXVhcmVDYXBTaWRlT2Zmc2V0LngsIG9mZnNldFIucDEueSArIHNxdWFyZUNhcFNpZGVPZmZzZXQueSk7XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHNxdWFyZUNhcExPZmZzZXQpO1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChzcXVhcmVDYXBST2Zmc2V0KTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICB2YXIgcHRzID0gdGhpcy5fc2VnTGlzdC5nZXRDb29yZGluYXRlcygpO1xuICByZXR1cm4gcHRzXG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWl0cmVKb2luID0gZnVuY3Rpb24gYWRkTWl0cmVKb2luIChwLCBvZmZzZXQwLCBvZmZzZXQxLCBkaXN0YW5jZSkge1xuICB2YXIgaXNNaXRyZVdpdGhpbkxpbWl0ID0gdHJ1ZTtcbiAgdmFyIGludFB0ID0gbnVsbDtcbiAgdHJ5IHtcbiAgICBpbnRQdCA9IEhDb29yZGluYXRlLmludGVyc2VjdGlvbihvZmZzZXQwLnAwLCBvZmZzZXQwLnAxLCBvZmZzZXQxLnAwLCBvZmZzZXQxLnAxKTtcbiAgICB2YXIgbWl0cmVSYXRpbyA9IGRpc3RhbmNlIDw9IDAuMCA/IDEuMCA6IGludFB0LmRpc3RhbmNlKHApIC8gTWF0aC5hYnMoZGlzdGFuY2UpO1xuICAgIGlmIChtaXRyZVJhdGlvID4gdGhpcy5fYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSkgeyBpc01pdHJlV2l0aGluTGltaXQgPSBmYWxzZTsgfVxuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChleCBpbnN0YW5jZW9mIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24pIHtcbiAgICAgIGludFB0ID0gbmV3IENvb3JkaW5hdGUoMCwgMCk7XG4gICAgICBpc01pdHJlV2l0aGluTGltaXQgPSBmYWxzZTtcbiAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gIH0gZmluYWxseSB7fVxuICBpZiAoaXNNaXRyZVdpdGhpbkxpbWl0KSB7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdChpbnRQdCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRMaW1pdGVkTWl0cmVKb2luKG9mZnNldDAsIG9mZnNldDEsIGRpc3RhbmNlLCB0aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKTtcbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZEZpbGxldENvcm5lciA9IGZ1bmN0aW9uIGFkZEZpbGxldENvcm5lciAocCwgcDAsIHAxLCBkaXJlY3Rpb24sIHJhZGl1cykge1xuICB2YXIgZHgwID0gcDAueCAtIHAueDtcbiAgdmFyIGR5MCA9IHAwLnkgLSBwLnk7XG4gIHZhciBzdGFydEFuZ2xlID0gTWF0aC5hdGFuMihkeTAsIGR4MCk7XG4gIHZhciBkeDEgPSBwMS54IC0gcC54O1xuICB2YXIgZHkxID0gcDEueSAtIHAueTtcbiAgdmFyIGVuZEFuZ2xlID0gTWF0aC5hdGFuMihkeTEsIGR4MSk7XG4gIGlmIChkaXJlY3Rpb24gPT09IENHQWxnb3JpdGhtcy5DTE9DS1dJU0UpIHtcbiAgICBpZiAoc3RhcnRBbmdsZSA8PSBlbmRBbmdsZSkgeyBzdGFydEFuZ2xlICs9IDIuMCAqIE1hdGguUEk7IH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RhcnRBbmdsZSA+PSBlbmRBbmdsZSkgeyBzdGFydEFuZ2xlIC09IDIuMCAqIE1hdGguUEk7IH1cbiAgfVxuICB0aGlzLl9zZWdMaXN0LmFkZFB0KHAwKTtcbiAgdGhpcy5hZGRGaWxsZXRBcmMocCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGRpcmVjdGlvbiwgcmFkaXVzKTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChwMSk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkT3V0c2lkZVR1cm4gPSBmdW5jdGlvbiBhZGRPdXRzaWRlVHVybiAob3JpZW50YXRpb24sIGFkZFN0YXJ0UG9pbnQpIHtcbiAgaWYgKHRoaXMuX29mZnNldDAucDEuZGlzdGFuY2UodGhpcy5fb2Zmc2V0MS5wMCkgPCB0aGlzLl9kaXN0YW5jZSAqIE9mZnNldFNlZ21lbnRHZW5lcmF0b3IuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1IpIHtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKSA9PT0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX01JVFJFKSB7XG4gICAgdGhpcy5hZGRNaXRyZUpvaW4odGhpcy5fczEsIHRoaXMuX29mZnNldDAsIHRoaXMuX29mZnNldDEsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgfSBlbHNlIGlmICh0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCkgPT09IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9CRVZFTCkge1xuICAgIHRoaXMuYWRkQmV2ZWxKb2luKHRoaXMuX29mZnNldDAsIHRoaXMuX29mZnNldDEpO1xuICB9IGVsc2Uge1xuICAgIGlmIChhZGRTdGFydFBvaW50KSB7IHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7IH1cbiAgICB0aGlzLmFkZEZpbGxldENvcm5lcih0aGlzLl9zMSwgdGhpcy5fb2Zmc2V0MC5wMSwgdGhpcy5fb2Zmc2V0MS5wMCwgb3JpZW50YXRpb24sIHRoaXMuX2Rpc3RhbmNlKTtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApO1xuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuY3JlYXRlU3F1YXJlID0gZnVuY3Rpb24gY3JlYXRlU3F1YXJlIChwKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IENvb3JkaW5hdGUocC54ICsgdGhpcy5fZGlzdGFuY2UsIHAueSArIHRoaXMuX2Rpc3RhbmNlKSk7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IENvb3JkaW5hdGUocC54ICsgdGhpcy5fZGlzdGFuY2UsIHAueSAtIHRoaXMuX2Rpc3RhbmNlKSk7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IENvb3JkaW5hdGUocC54IC0gdGhpcy5fZGlzdGFuY2UsIHAueSAtIHRoaXMuX2Rpc3RhbmNlKSk7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQobmV3IENvb3JkaW5hdGUocC54IC0gdGhpcy5fZGlzdGFuY2UsIHAueSArIHRoaXMuX2Rpc3RhbmNlKSk7XG4gIHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkU2VnbWVudHMgPSBmdW5jdGlvbiBhZGRTZWdtZW50cyAocHQsIGlzRm9yd2FyZCkge1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0cyhwdCwgaXNGb3J3YXJkKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRGaXJzdFNlZ21lbnQgPSBmdW5jdGlvbiBhZGRGaXJzdFNlZ21lbnQgKCkge1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZExhc3RTZWdtZW50ID0gZnVuY3Rpb24gYWRkTGFzdFNlZ21lbnQgKCkge1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDEpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmluaXRTaWRlU2VnbWVudHMgPSBmdW5jdGlvbiBpbml0U2lkZVNlZ21lbnRzIChzMSwgczIsIHNpZGUpIHtcbiAgdGhpcy5fczEgPSBzMTtcbiAgdGhpcy5fczIgPSBzMjtcbiAgdGhpcy5fc2lkZSA9IHNpZGU7XG4gIHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXMoczEsIHMyKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLCBzaWRlLCB0aGlzLl9kaXN0YW5jZSwgdGhpcy5fb2Zmc2V0MSk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTGltaXRlZE1pdHJlSm9pbiA9IGZ1bmN0aW9uIGFkZExpbWl0ZWRNaXRyZUpvaW4gKG9mZnNldDAsIG9mZnNldDEsIGRpc3RhbmNlLCBtaXRyZUxpbWl0KSB7XG4gIHZhciBiYXNlUHQgPSB0aGlzLl9zZWcwLnAxO1xuICB2YXIgYW5nMCA9IEFuZ2xlLmFuZ2xlKGJhc2VQdCwgdGhpcy5fc2VnMC5wMCk7XG4gIC8vIGNvbnN0IGFuZzEgPSBBbmdsZS5hbmdsZShiYXNlUHQsIHRoaXMuX3NlZzEucDEpXG4gIHZhciBhbmdEaWZmID0gQW5nbGUuYW5nbGVCZXR3ZWVuT3JpZW50ZWQodGhpcy5fc2VnMC5wMCwgYmFzZVB0LCB0aGlzLl9zZWcxLnAxKTtcbiAgdmFyIGFuZ0RpZmZIYWxmID0gYW5nRGlmZiAvIDI7XG4gIHZhciBtaWRBbmcgPSBBbmdsZS5ub3JtYWxpemUoYW5nMCArIGFuZ0RpZmZIYWxmKTtcbiAgdmFyIG1pdHJlTWlkQW5nID0gQW5nbGUubm9ybWFsaXplKG1pZEFuZyArIE1hdGguUEkpO1xuICB2YXIgbWl0cmVEaXN0ID0gbWl0cmVMaW1pdCAqIGRpc3RhbmNlO1xuICB2YXIgYmV2ZWxEZWx0YSA9IG1pdHJlRGlzdCAqIE1hdGguYWJzKE1hdGguc2luKGFuZ0RpZmZIYWxmKSk7XG4gIHZhciBiZXZlbEhhbGZMZW4gPSBkaXN0YW5jZSAtIGJldmVsRGVsdGE7XG4gIHZhciBiZXZlbE1pZFggPSBiYXNlUHQueCArIG1pdHJlRGlzdCAqIE1hdGguY29zKG1pdHJlTWlkQW5nKTtcbiAgdmFyIGJldmVsTWlkWSA9IGJhc2VQdC55ICsgbWl0cmVEaXN0ICogTWF0aC5zaW4obWl0cmVNaWRBbmcpO1xuICB2YXIgYmV2ZWxNaWRQdCA9IG5ldyBDb29yZGluYXRlKGJldmVsTWlkWCwgYmV2ZWxNaWRZKTtcbiAgdmFyIG1pdHJlTWlkTGluZSA9IG5ldyBMaW5lU2VnbWVudChiYXNlUHQsIGJldmVsTWlkUHQpO1xuICB2YXIgYmV2ZWxFbmRMZWZ0ID0gbWl0cmVNaWRMaW5lLnBvaW50QWxvbmdPZmZzZXQoMS4wLCBiZXZlbEhhbGZMZW4pO1xuICB2YXIgYmV2ZWxFbmRSaWdodCA9IG1pdHJlTWlkTGluZS5wb2ludEFsb25nT2Zmc2V0KDEuMCwgLWJldmVsSGFsZkxlbik7XG4gIGlmICh0aGlzLl9zaWRlID09PSBQb3NpdGlvbi5MRUZUKSB7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdChiZXZlbEVuZExlZnQpO1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoYmV2ZWxFbmRSaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdChiZXZlbEVuZFJpZ2h0KTtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KGJldmVsRW5kTGVmdCk7XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5jb21wdXRlT2Zmc2V0U2VnbWVudCA9IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRTZWdtZW50IChzZWcsIHNpZGUsIGRpc3RhbmNlLCBvZmZzZXQpIHtcbiAgdmFyIHNpZGVTaWduID0gc2lkZSA9PT0gUG9zaXRpb24uTEVGVCA/IDEgOiAtMTtcbiAgdmFyIGR4ID0gc2VnLnAxLnggLSBzZWcucDAueDtcbiAgdmFyIGR5ID0gc2VnLnAxLnkgLSBzZWcucDAueTtcbiAgdmFyIGxlbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHZhciB1eCA9IHNpZGVTaWduICogZGlzdGFuY2UgKiBkeCAvIGxlbjtcbiAgdmFyIHV5ID0gc2lkZVNpZ24gKiBkaXN0YW5jZSAqIGR5IC8gbGVuO1xuICBvZmZzZXQucDAueCA9IHNlZy5wMC54IC0gdXk7XG4gIG9mZnNldC5wMC55ID0gc2VnLnAwLnkgKyB1eDtcbiAgb2Zmc2V0LnAxLnggPSBzZWcucDEueCAtIHV5O1xuICBvZmZzZXQucDEueSA9IHNlZy5wMS55ICsgdXg7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkRmlsbGV0QXJjID0gZnVuY3Rpb24gYWRkRmlsbGV0QXJjIChwLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlyZWN0aW9uLCByYWRpdXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZGlyZWN0aW9uRmFjdG9yID0gZGlyZWN0aW9uID09PSBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFID8gLTEgOiAxO1xuICB2YXIgdG90YWxBbmdsZSA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG4gIHZhciBuU2VncyA9IE1hdGgudHJ1bmModG90YWxBbmdsZSAvIHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bSArIDAuNSk7XG4gIGlmIChuU2VncyA8IDEpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgaW5pdEFuZ2xlID0gMC4wO1xuICB2YXIgY3VyckFuZ2xlSW5jID0gdG90YWxBbmdsZSAvIG5TZWdzO1xuICB2YXIgY3VyckFuZ2xlID0gaW5pdEFuZ2xlO1xuICB2YXIgcHQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICB3aGlsZSAoY3VyckFuZ2xlIDwgdG90YWxBbmdsZSkge1xuICAgIHZhciBhbmdsZSA9IHN0YXJ0QW5nbGUgKyBkaXJlY3Rpb25GYWN0b3IgKiBjdXJyQW5nbGU7XG4gICAgcHQueCA9IHAueCArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICBwdC55ID0gcC55ICsgcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHRoaXMkMS5fc2VnTGlzdC5hZGRQdChwdCk7XG4gICAgY3VyckFuZ2xlICs9IGN1cnJBbmdsZUluYztcbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZEluc2lkZVR1cm4gPSBmdW5jdGlvbiBhZGRJbnNpZGVUdXJuIChvcmllbnRhdGlvbiwgYWRkU3RhcnRQb2ludCkge1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX29mZnNldDAucDAsIHRoaXMuX29mZnNldDAucDEsIHRoaXMuX29mZnNldDEucDAsIHRoaXMuX29mZnNldDEucDEpO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKSA8IHRoaXMuX2Rpc3RhbmNlICogT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpIHtcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7XG4gICAgICBpZiAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciA+IDApIHtcbiAgICAgICAgdmFyIG1pZDAgPSBuZXcgQ29vcmRpbmF0ZSgodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciAqIHRoaXMuX29mZnNldDAucDEueCArIHRoaXMuX3MxLngpIC8gKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKyAxKSwgKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKiB0aGlzLl9vZmZzZXQwLnAxLnkgKyB0aGlzLl9zMS55KSAvICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICsgMSkpO1xuICAgICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KG1pZDApO1xuICAgICAgICB2YXIgbWlkMSA9IG5ldyBDb29yZGluYXRlKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICogdGhpcy5fb2Zmc2V0MS5wMC54ICsgdGhpcy5fczEueCkgLyAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciArIDEpLCAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciAqIHRoaXMuX29mZnNldDEucDAueSArIHRoaXMuX3MxLnkpIC8gKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKyAxKSk7XG4gICAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQobWlkMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX3MxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCk7XG4gICAgfVxuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuY3JlYXRlQ2lyY2xlID0gZnVuY3Rpb24gY3JlYXRlQ2lyY2xlIChwKSB7XG4gIHZhciBwdCA9IG5ldyBDb29yZGluYXRlKHAueCArIHRoaXMuX2Rpc3RhbmNlLCBwLnkpO1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KHB0KTtcbiAgdGhpcy5hZGRGaWxsZXRBcmMocCwgMC4wLCAyLjAgKiBNYXRoLlBJLCAtMSwgdGhpcy5fZGlzdGFuY2UpO1xuICB0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZEJldmVsSm9pbiA9IGZ1bmN0aW9uIGFkZEJldmVsSm9pbiAob2Zmc2V0MCwgb2Zmc2V0MSkge1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KG9mZnNldDAucDEpO1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KG9mZnNldDEucDApO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChkaXN0YW5jZSkge1xuICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICB0aGlzLl9tYXhDdXJ2ZVNlZ21lbnRFcnJvciA9IGRpc3RhbmNlICogKDEgLSBNYXRoLmNvcyh0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0gLyAyLjApKTtcbiAgdGhpcy5fc2VnTGlzdCA9IG5ldyBPZmZzZXRTZWdtZW50U3RyaW5nKCk7XG4gIHRoaXMuX3NlZ0xpc3Quc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5fcHJlY2lzaW9uTW9kZWwpO1xuICB0aGlzLl9zZWdMaXN0LnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZShkaXN0YW5jZSAqIE9mZnNldFNlZ21lbnRHZW5lcmF0b3IuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRDb2xsaW5lYXIgPSBmdW5jdGlvbiBhZGRDb2xsaW5lYXIgKGFkZFN0YXJ0UG9pbnQpIHtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLl9zMCwgdGhpcy5fczEsIHRoaXMuX3MxLCB0aGlzLl9zMik7XG4gIHZhciBudW1JbnQgPSB0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTtcbiAgaWYgKG51bUludCA+PSAyKSB7XG4gICAgaWYgKHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKSA9PT0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX0JFVkVMIHx8IHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKSA9PT0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX01JVFJFKSB7XG4gICAgICBpZiAoYWRkU3RhcnRQb2ludCkgeyB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpOyB9XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEZpbGxldENvcm5lcih0aGlzLl9zMSwgdGhpcy5fb2Zmc2V0MC5wMSwgdGhpcy5fb2Zmc2V0MS5wMCwgQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSwgdGhpcy5fZGlzdGFuY2UpO1xuICAgIH1cbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmNsb3NlUmluZyA9IGZ1bmN0aW9uIGNsb3NlUmluZyAoKSB7XG4gIHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuaGFzTmFycm93Q29uY2F2ZUFuZ2xlID0gZnVuY3Rpb24gaGFzTmFycm93Q29uY2F2ZUFuZ2xlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9mZnNldFNlZ21lbnRHZW5lcmF0b3Jcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjcuT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMS4wRS0zIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjcuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEuMEUtMyB9O1xuc3RhdGljQWNjZXNzb3JzJDI3LkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxLjBFLTYgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNy5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA4MCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggT2Zmc2V0U2VnbWVudEdlbmVyYXRvciwgc3RhdGljQWNjZXNzb3JzJDI3ICk7XG5cbnZhciBPZmZzZXRDdXJ2ZUJ1aWxkZXIgPSBmdW5jdGlvbiBPZmZzZXRDdXJ2ZUJ1aWxkZXIgKCkge1xuICB0aGlzLl9kaXN0YW5jZSA9IDAuMDtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl9idWZQYXJhbXMgPSBudWxsO1xuICB2YXIgcHJlY2lzaW9uTW9kZWwgPSBhcmd1bWVudHNbMF07XG4gIHZhciBidWZQYXJhbXMgPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gcHJlY2lzaW9uTW9kZWw7XG4gIHRoaXMuX2J1ZlBhcmFtcyA9IGJ1ZlBhcmFtcztcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmdldE9mZnNldEN1cnZlID0gZnVuY3Rpb24gZ2V0T2Zmc2V0Q3VydmUgKGlucHV0UHRzLCBkaXN0YW5jZSkge1xuICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICBpZiAoZGlzdGFuY2UgPT09IDAuMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBpc1JpZ2h0U2lkZSA9IGRpc3RhbmNlIDwgMC4wO1xuICB2YXIgcG9zRGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZSk7XG4gIHZhciBzZWdHZW4gPSB0aGlzLmdldFNlZ0dlbihwb3NEaXN0YW5jZSk7XG4gIGlmIChpbnB1dFB0cy5sZW5ndGggPD0gMSkge1xuICAgIHRoaXMuY29tcHV0ZVBvaW50Q3VydmUoaW5wdXRQdHNbMF0sIHNlZ0dlbik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jb21wdXRlT2Zmc2V0Q3VydmUoaW5wdXRQdHMsIGlzUmlnaHRTaWRlLCBzZWdHZW4pO1xuICB9XG4gIHZhciBjdXJ2ZVB0cyA9IHNlZ0dlbi5nZXRDb29yZGluYXRlcygpO1xuICBpZiAoaXNSaWdodFNpZGUpIHsgQ29vcmRpbmF0ZUFycmF5cy5yZXZlcnNlKGN1cnZlUHRzKTsgfVxuICByZXR1cm4gY3VydmVQdHNcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlID0gZnVuY3Rpb24gY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUgKGlucHV0UHRzLCBpc1JpZ2h0U2lkZSwgc2VnR2VuKSB7XG4gIHZhciBkaXN0VG9sID0gdGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7XG4gIGlmIChpc1JpZ2h0U2lkZSkge1xuICAgIHNlZ0dlbi5hZGRTZWdtZW50cyhpbnB1dFB0cywgdHJ1ZSk7XG4gICAgdmFyIHNpbXAyID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgLWRpc3RUb2wpO1xuICAgIHZhciBuMiA9IHNpbXAyLmxlbmd0aCAtIDE7XG4gICAgc2VnR2VuLmluaXRTaWRlU2VnbWVudHMoc2ltcDJbbjJdLCBzaW1wMltuMiAtIDFdLCBQb3NpdGlvbi5MRUZUKTtcbiAgICBzZWdHZW4uYWRkRmlyc3RTZWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSA9IG4yIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHNlZ0dlbi5hZGROZXh0U2VnbWVudChzaW1wMltpXSwgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlZ0dlbi5hZGRTZWdtZW50cyhpbnB1dFB0cywgZmFsc2UpO1xuICAgIHZhciBzaW1wMSA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkoaW5wdXRQdHMsIGRpc3RUb2wpO1xuICAgIHZhciBuMSA9IHNpbXAxLmxlbmd0aCAtIDE7XG4gICAgc2VnR2VuLmluaXRTaWRlU2VnbWVudHMoc2ltcDFbMF0sIHNpbXAxWzFdLCBQb3NpdGlvbi5MRUZUKTtcbiAgICBzZWdHZW4uYWRkRmlyc3RTZWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSQxID0gMjsgaSQxIDw9IG4xOyBpJDErKykge1xuICAgICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAxW2kkMV0sIHRydWUpO1xuICAgIH1cbiAgfVxuICBzZWdHZW4uYWRkTGFzdFNlZ21lbnQoKTtcbiAgc2VnR2VuLmNsb3NlUmluZygpO1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVSaW5nQnVmZmVyQ3VydmUgKGlucHV0UHRzLCBzaWRlLCBzZWdHZW4pIHtcbiAgdmFyIGRpc3RUb2wgPSB0aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtcbiAgaWYgKHNpZGUgPT09IFBvc2l0aW9uLlJJR0hUKSB7IGRpc3RUb2wgPSAtZGlzdFRvbDsgfVxuICB2YXIgc2ltcCA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkoaW5wdXRQdHMsIGRpc3RUb2wpO1xuICB2YXIgbiA9IHNpbXAubGVuZ3RoIC0gMTtcbiAgc2VnR2VuLmluaXRTaWRlU2VnbWVudHMoc2ltcFtuIC0gMV0sIHNpbXBbMF0sIHNpZGUpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyBpKyspIHtcbiAgICB2YXIgYWRkU3RhcnRQb2ludCA9IGkgIT09IDE7XG4gICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXBbaV0sIGFkZFN0YXJ0UG9pbnQpO1xuICB9XG4gIHNlZ0dlbi5jbG9zZVJpbmcoKTtcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmNvbXB1dGVMaW5lQnVmZmVyQ3VydmUgPSBmdW5jdGlvbiBjb21wdXRlTGluZUJ1ZmZlckN1cnZlIChpbnB1dFB0cywgc2VnR2VuKSB7XG4gIHZhciBkaXN0VG9sID0gdGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7XG4gIHZhciBzaW1wMSA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkoaW5wdXRQdHMsIGRpc3RUb2wpO1xuICB2YXIgbjEgPSBzaW1wMS5sZW5ndGggLSAxO1xuICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMVswXSwgc2ltcDFbMV0sIFBvc2l0aW9uLkxFRlQpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8PSBuMTsgaSsrKSB7XG4gICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAxW2ldLCB0cnVlKTtcbiAgfVxuICBzZWdHZW4uYWRkTGFzdFNlZ21lbnQoKTtcbiAgc2VnR2VuLmFkZExpbmVFbmRDYXAoc2ltcDFbbjEgLSAxXSwgc2ltcDFbbjFdKTtcbiAgdmFyIHNpbXAyID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgLWRpc3RUb2wpO1xuICB2YXIgbjIgPSBzaW1wMi5sZW5ndGggLSAxO1xuICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMltuMl0sIHNpbXAyW24yIC0gMV0sIFBvc2l0aW9uLkxFRlQpO1xuICBmb3IgKHZhciBpJDEgPSBuMiAtIDI7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgIHNlZ0dlbi5hZGROZXh0U2VnbWVudChzaW1wMltpJDFdLCB0cnVlKTtcbiAgfVxuICBzZWdHZW4uYWRkTGFzdFNlZ21lbnQoKTtcbiAgc2VnR2VuLmFkZExpbmVFbmRDYXAoc2ltcDJbMV0sIHNpbXAyWzBdKTtcbiAgc2VnR2VuLmNsb3NlUmluZygpO1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZVBvaW50Q3VydmUgPSBmdW5jdGlvbiBjb21wdXRlUG9pbnRDdXJ2ZSAocHQsIHNlZ0dlbikge1xuICBzd2l0Y2ggKHRoaXMuX2J1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKSB7XG4gICAgY2FzZSBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9ST1VORDpcbiAgICAgIHNlZ0dlbi5jcmVhdGVDaXJjbGUocHQpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1NRVUFSRTpcbiAgICAgIHNlZ0dlbi5jcmVhdGVTcXVhcmUocHQpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5nZXRMaW5lQ3VydmUgPSBmdW5jdGlvbiBnZXRMaW5lQ3VydmUgKGlucHV0UHRzLCBkaXN0YW5jZSkge1xuICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICBpZiAoZGlzdGFuY2UgPCAwLjAgJiYgIXRoaXMuX2J1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZGlzdGFuY2UgPT09IDAuMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBwb3NEaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKTtcbiAgdmFyIHNlZ0dlbiA9IHRoaXMuZ2V0U2VnR2VuKHBvc0Rpc3RhbmNlKTtcbiAgaWYgKGlucHV0UHRzLmxlbmd0aCA8PSAxKSB7XG4gICAgdGhpcy5jb21wdXRlUG9pbnRDdXJ2ZShpbnB1dFB0c1swXSwgc2VnR2VuKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5fYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSkge1xuICAgICAgdmFyIGlzUmlnaHRTaWRlID0gZGlzdGFuY2UgPCAwLjA7XG4gICAgICB0aGlzLmNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlKGlucHV0UHRzLCBpc1JpZ2h0U2lkZSwgc2VnR2VuKTtcbiAgICB9IGVsc2UgeyB0aGlzLmNvbXB1dGVMaW5lQnVmZmVyQ3VydmUoaW5wdXRQdHMsIHNlZ0dlbik7IH1cbiAgfVxuICB2YXIgbGluZUNvb3JkID0gc2VnR2VuLmdldENvb3JkaW5hdGVzKCk7XG4gIHJldHVybiBsaW5lQ29vcmRcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmdldEJ1ZmZlclBhcmFtZXRlcnMgPSBmdW5jdGlvbiBnZXRCdWZmZXJQYXJhbWV0ZXJzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2J1ZlBhcmFtc1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuc2ltcGxpZnlUb2xlcmFuY2UgPSBmdW5jdGlvbiBzaW1wbGlmeVRvbGVyYW5jZSAoYnVmRGlzdGFuY2UpIHtcbiAgcmV0dXJuIGJ1ZkRpc3RhbmNlICogdGhpcy5fYnVmUGFyYW1zLmdldFNpbXBsaWZ5RmFjdG9yKClcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmdldFJpbmdDdXJ2ZSA9IGZ1bmN0aW9uIGdldFJpbmdDdXJ2ZSAoaW5wdXRQdHMsIHNpZGUsIGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIGlmIChpbnB1dFB0cy5sZW5ndGggPD0gMikgeyByZXR1cm4gdGhpcy5nZXRMaW5lQ3VydmUoaW5wdXRQdHMsIGRpc3RhbmNlKSB9XG4gIGlmIChkaXN0YW5jZSA9PT0gMC4wKSB7XG4gICAgcmV0dXJuIE9mZnNldEN1cnZlQnVpbGRlci5jb3B5Q29vcmRpbmF0ZXMoaW5wdXRQdHMpXG4gIH1cbiAgdmFyIHNlZ0dlbiA9IHRoaXMuZ2V0U2VnR2VuKGRpc3RhbmNlKTtcbiAgdGhpcy5jb21wdXRlUmluZ0J1ZmZlckN1cnZlKGlucHV0UHRzLCBzaWRlLCBzZWdHZW4pO1xuICByZXR1cm4gc2VnR2VuLmdldENvb3JkaW5hdGVzKClcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmNvbXB1dGVPZmZzZXRDdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRDdXJ2ZSAoaW5wdXRQdHMsIGlzUmlnaHRTaWRlLCBzZWdHZW4pIHtcbiAgdmFyIGRpc3RUb2wgPSB0aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtcbiAgaWYgKGlzUmlnaHRTaWRlKSB7XG4gICAgdmFyIHNpbXAyID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgLWRpc3RUb2wpO1xuICAgIHZhciBuMiA9IHNpbXAyLmxlbmd0aCAtIDE7XG4gICAgc2VnR2VuLmluaXRTaWRlU2VnbWVudHMoc2ltcDJbbjJdLCBzaW1wMltuMiAtIDFdLCBQb3NpdGlvbi5MRUZUKTtcbiAgICBzZWdHZW4uYWRkRmlyc3RTZWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSA9IG4yIC0gMjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHNlZ0dlbi5hZGROZXh0U2VnbWVudChzaW1wMltpXSwgdHJ1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzaW1wMSA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkoaW5wdXRQdHMsIGRpc3RUb2wpO1xuICAgIHZhciBuMSA9IHNpbXAxLmxlbmd0aCAtIDE7XG4gICAgc2VnR2VuLmluaXRTaWRlU2VnbWVudHMoc2ltcDFbMF0sIHNpbXAxWzFdLCBQb3NpdGlvbi5MRUZUKTtcbiAgICBzZWdHZW4uYWRkRmlyc3RTZWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSQxID0gMjsgaSQxIDw9IG4xOyBpJDErKykge1xuICAgICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAxW2kkMV0sIHRydWUpO1xuICAgIH1cbiAgfVxuICBzZWdHZW4uYWRkTGFzdFNlZ21lbnQoKTtcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmdldFNlZ0dlbiA9IGZ1bmN0aW9uIGdldFNlZ0dlbiAoZGlzdGFuY2UpIHtcbiAgcmV0dXJuIG5ldyBPZmZzZXRTZWdtZW50R2VuZXJhdG9yKHRoaXMuX3ByZWNpc2lvbk1vZGVsLCB0aGlzLl9idWZQYXJhbXMsIGRpc3RhbmNlKVxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPZmZzZXRDdXJ2ZUJ1aWxkZXJcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIuY29weUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gY29weUNvb3JkaW5hdGVzIChwdHMpIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkocHRzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3B5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29weVtpXSA9IG5ldyBDb29yZGluYXRlKHB0c1tpXSk7XG4gIH1cbiAgcmV0dXJuIGNvcHlcbn07XG5cbnZhciBTdWJncmFwaERlcHRoTG9jYXRlciA9IGZ1bmN0aW9uIFN1YmdyYXBoRGVwdGhMb2NhdGVyICgpIHtcbiAgdGhpcy5fc3ViZ3JhcGhzID0gbnVsbDtcbiAgdGhpcy5fc2VnID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX2NnYSA9IG5ldyBDR0FsZ29yaXRobXMoKTtcbiAgdmFyIHN1YmdyYXBocyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fc3ViZ3JhcGhzID0gc3ViZ3JhcGhzO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzMCA9IHsgRGVwdGhTZWdtZW50OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5TdWJncmFwaERlcHRoTG9jYXRlci5wcm90b3R5cGUuZmluZFN0YWJiZWRTZWdtZW50cyA9IGZ1bmN0aW9uIGZpbmRTdGFiYmVkU2VnbWVudHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHN0YWJiaW5nUmF5TGVmdFB0ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzdGFiYmVkU2VnbWVudHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX3N1YmdyYXBocy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBic2cgPSBpLm5leHQoKTtcbiAgICAgIHZhciBlbnYgPSBic2cuZ2V0RW52ZWxvcGUoKTtcbiAgICAgIGlmIChzdGFiYmluZ1JheUxlZnRQdC55IDwgZW52LmdldE1pblkoKSB8fCBzdGFiYmluZ1JheUxlZnRQdC55ID4gZW52LmdldE1heFkoKSkgeyBjb250aW51ZSB9XG4gICAgICB0aGlzJDEuZmluZFN0YWJiZWRTZWdtZW50cyhzdGFiYmluZ1JheUxlZnRQdCwgYnNnLmdldERpcmVjdGVkRWRnZXMoKSwgc3RhYmJlZFNlZ21lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWJiZWRTZWdtZW50c1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgTGlzdCkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRGlyZWN0ZWRFZGdlKSkge1xuICAgICAgdmFyIHN0YWJiaW5nUmF5TGVmdFB0JDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGlyRWRnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzdGFiYmVkU2VnbWVudHMkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBwdHMgPSBkaXJFZGdlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHRzLmxlbmd0aCAtIDE7IGkkMSsrKSB7XG4gICAgICAgIHRoaXMkMS5fc2VnLnAwID0gcHRzW2kkMV07XG4gICAgICAgIHRoaXMkMS5fc2VnLnAxID0gcHRzW2kkMSArIDFdO1xuICAgICAgICBpZiAodGhpcyQxLl9zZWcucDAueSA+IHRoaXMkMS5fc2VnLnAxLnkpIHsgdGhpcyQxLl9zZWcucmV2ZXJzZSgpOyB9XG4gICAgICAgIHZhciBtYXh4ID0gTWF0aC5tYXgodGhpcyQxLl9zZWcucDAueCwgdGhpcyQxLl9zZWcucDEueCk7XG4gICAgICAgIGlmIChtYXh4IDwgc3RhYmJpbmdSYXlMZWZ0UHQkMS54KSB7IGNvbnRpbnVlIH1cbiAgICAgICAgaWYgKHRoaXMkMS5fc2VnLmlzSG9yaXpvbnRhbCgpKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgaWYgKHN0YWJiaW5nUmF5TGVmdFB0JDEueSA8IHRoaXMkMS5fc2VnLnAwLnkgfHwgc3RhYmJpbmdSYXlMZWZ0UHQkMS55ID4gdGhpcyQxLl9zZWcucDEueSkgeyBjb250aW51ZSB9XG4gICAgICAgIGlmIChDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMkMS5fc2VnLnAwLCB0aGlzJDEuX3NlZy5wMSwgc3RhYmJpbmdSYXlMZWZ0UHQkMSkgPT09IENHQWxnb3JpdGhtcy5SSUdIVCkgeyBjb250aW51ZSB9XG4gICAgICAgIHZhciBkZXB0aCA9IGRpckVkZ2UuZ2V0RGVwdGgoUG9zaXRpb24uTEVGVCk7XG4gICAgICAgIGlmICghdGhpcyQxLl9zZWcucDAuZXF1YWxzKHB0c1tpJDFdKSkgeyBkZXB0aCA9IGRpckVkZ2UuZ2V0RGVwdGgoUG9zaXRpb24uUklHSFQpOyB9XG4gICAgICAgIHZhciBkcyA9IG5ldyBEZXB0aFNlZ21lbnQodGhpcyQxLl9zZWcsIGRlcHRoKTtcbiAgICAgICAgc3RhYmJlZFNlZ21lbnRzJDEuYWRkKGRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMl0sIExpc3QpICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIExpc3QpKSkge1xuICAgICAgdmFyIHN0YWJiaW5nUmF5TGVmdFB0JDIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGlyRWRnZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgc3RhYmJlZFNlZ21lbnRzJDIgPSBhcmd1bWVudHNbMl07XG4gICAgICBmb3IgKHZhciBpJDIgPSBkaXJFZGdlcy5pdGVyYXRvcigpOyBpJDIuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZGUgPSBpJDIubmV4dCgpO1xuICAgICAgICBpZiAoIWRlLmlzRm9yd2FyZCgpKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdGhpcyQxLmZpbmRTdGFiYmVkU2VnbWVudHMoc3RhYmJpbmdSYXlMZWZ0UHQkMiwgZGUsIHN0YWJiZWRTZWdtZW50cyQyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5TdWJncmFwaERlcHRoTG9jYXRlci5wcm90b3R5cGUuZ2V0RGVwdGggPSBmdW5jdGlvbiBnZXREZXB0aCAocCkge1xuICB2YXIgc3RhYmJlZFNlZ21lbnRzID0gdGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHApO1xuICBpZiAoc3RhYmJlZFNlZ21lbnRzLnNpemUoKSA9PT0gMCkgeyByZXR1cm4gMCB9XG4gIHZhciBkcyA9IENvbGxlY3Rpb25zLm1pbihzdGFiYmVkU2VnbWVudHMpO1xuICByZXR1cm4gZHMuX2xlZnREZXB0aFxufTtcblN1YmdyYXBoRGVwdGhMb2NhdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU3ViZ3JhcGhEZXB0aExvY2F0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU3ViZ3JhcGhEZXB0aExvY2F0ZXJcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzAuRGVwdGhTZWdtZW50LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERlcHRoU2VnbWVudCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3ViZ3JhcGhEZXB0aExvY2F0ZXIsIHN0YXRpY0FjY2Vzc29ycyQzMCApO1xuXG52YXIgRGVwdGhTZWdtZW50ID0gZnVuY3Rpb24gRGVwdGhTZWdtZW50ICgpIHtcbiAgdGhpcy5fdXB3YXJkU2VnID0gbnVsbDtcbiAgdGhpcy5fbGVmdERlcHRoID0gbnVsbDtcbiAgdmFyIHNlZyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGRlcHRoID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl91cHdhcmRTZWcgPSBuZXcgTGluZVNlZ21lbnQoc2VnKTtcbiAgdGhpcy5fbGVmdERlcHRoID0gZGVwdGg7XG59O1xuRGVwdGhTZWdtZW50LnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG9iaikge1xuICB2YXIgb3RoZXIgPSBvYmo7XG4gIGlmICh0aGlzLl91cHdhcmRTZWcubWluWCgpID49IG90aGVyLl91cHdhcmRTZWcubWF4WCgpKSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX3Vwd2FyZFNlZy5tYXhYKCkgPD0gb3RoZXIuX3Vwd2FyZFNlZy5taW5YKCkpIHsgcmV0dXJuIC0xIH1cbiAgdmFyIG9yaWVudEluZGV4ID0gdGhpcy5fdXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgob3RoZXIuX3Vwd2FyZFNlZyk7XG4gIGlmIChvcmllbnRJbmRleCAhPT0gMCkgeyByZXR1cm4gb3JpZW50SW5kZXggfVxuICBvcmllbnRJbmRleCA9IC0xICogb3RoZXIuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KHRoaXMuX3Vwd2FyZFNlZyk7XG4gIGlmIChvcmllbnRJbmRleCAhPT0gMCkgeyByZXR1cm4gb3JpZW50SW5kZXggfVxuICByZXR1cm4gdGhpcy5fdXB3YXJkU2VnLmNvbXBhcmVUbyhvdGhlci5fdXB3YXJkU2VnKVxufTtcbkRlcHRoU2VnbWVudC5wcm90b3R5cGUuY29tcGFyZVggPSBmdW5jdGlvbiBjb21wYXJlWCAoc2VnMCwgc2VnMSkge1xuICB2YXIgY29tcGFyZTAgPSBzZWcwLnAwLmNvbXBhcmVUbyhzZWcxLnAwKTtcbiAgaWYgKGNvbXBhcmUwICE9PSAwKSB7IHJldHVybiBjb21wYXJlMCB9XG4gIHJldHVybiBzZWcwLnAxLmNvbXBhcmVUbyhzZWcxLnAxKVxufTtcbkRlcHRoU2VnbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiB0aGlzLl91cHdhcmRTZWcudG9TdHJpbmcoKVxufTtcbkRlcHRoU2VnbWVudC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5EZXB0aFNlZ21lbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGVwdGhTZWdtZW50XG59O1xuXG52YXIgVHJpYW5nbGUgPSBmdW5jdGlvbiBUcmlhbmdsZSAocDAsIHAxLCBwMikge1xuICB0aGlzLnAwID0gcDAgfHwgbnVsbDtcbiAgdGhpcy5wMSA9IHAxIHx8IG51bGw7XG4gIHRoaXMucDIgPSBwMiB8fCBudWxsO1xufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24gYXJlYSAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5hcmVhKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLnNpZ25lZEFyZWEgPSBmdW5jdGlvbiBzaWduZWRBcmVhICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLnNpZ25lZEFyZWEodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuaW50ZXJwb2xhdGVaID0gZnVuY3Rpb24gaW50ZXJwb2xhdGVaIChwKSB7XG4gIGlmIChwID09PSBudWxsKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1N1cHBsaWVkIHBvaW50IGlzIG51bGwuJykgfVxuICByZXR1cm4gVHJpYW5nbGUuaW50ZXJwb2xhdGVaKHAsIHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmxvbmdlc3RTaWRlTGVuZ3RoID0gZnVuY3Rpb24gbG9uZ2VzdFNpZGVMZW5ndGggKCkge1xuICByZXR1cm4gVHJpYW5nbGUubG9uZ2VzdFNpZGVMZW5ndGgodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuaXNBY3V0ZSA9IGZ1bmN0aW9uIGlzQWN1dGUgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuaXNBY3V0ZSh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5jaXJjdW1jZW50cmUgPSBmdW5jdGlvbiBjaXJjdW1jZW50cmUgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuY2lyY3VtY2VudHJlKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmFyZWEzRCA9IGZ1bmN0aW9uIGFyZWEzRCAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5hcmVhM0QodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuY2VudHJvaWQgPSBmdW5jdGlvbiBjZW50cm9pZCAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5jZW50cm9pZCh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5pbkNlbnRyZSA9IGZ1bmN0aW9uIGluQ2VudHJlICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmluQ2VudHJlKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBUcmlhbmdsZVxufTtcblRyaWFuZ2xlLmFyZWEgPSBmdW5jdGlvbiBhcmVhIChhLCBiLCBjKSB7XG4gIHJldHVybiBNYXRoLmFicygoKGMueCAtIGEueCkgKiAoYi55IC0gYS55KSAtIChiLnggLSBhLngpICogKGMueSAtIGEueSkpIC8gMilcbn07XG5UcmlhbmdsZS5zaWduZWRBcmVhID0gZnVuY3Rpb24gc2lnbmVkQXJlYSAoYSwgYiwgYykge1xuICByZXR1cm4gKChjLnggLSBhLngpICogKGIueSAtIGEueSkgLSAoYi54IC0gYS54KSAqIChjLnkgLSBhLnkpKSAvIDJcbn07XG5UcmlhbmdsZS5kZXQgPSBmdW5jdGlvbiBkZXQgKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICByZXR1cm4gbTAwICogbTExIC0gbTAxICogbTEwXG59O1xuVHJpYW5nbGUuaW50ZXJwb2xhdGVaID0gZnVuY3Rpb24gaW50ZXJwb2xhdGVaIChwLCB2MCwgdjEsIHYyKSB7XG4gIHZhciB4MCA9IHYwLng7XG4gIHZhciB5MCA9IHYwLnk7XG4gIHZhciBhID0gdjEueCAtIHgwO1xuICB2YXIgYiA9IHYyLnggLSB4MDtcbiAgdmFyIGMgPSB2MS55IC0geTA7XG4gIHZhciBkID0gdjIueSAtIHkwO1xuICB2YXIgZGV0ID0gYSAqIGQgLSBiICogYztcbiAgdmFyIGR4ID0gcC54IC0geDA7XG4gIHZhciBkeSA9IHAueSAtIHkwO1xuICB2YXIgdCA9IChkICogZHggLSBiICogZHkpIC8gZGV0O1xuICB2YXIgdSA9ICgtYyAqIGR4ICsgYSAqIGR5KSAvIGRldDtcbiAgdmFyIHogPSB2MC56ICsgdCAqICh2MS56IC0gdjAueikgKyB1ICogKHYyLnogLSB2MC56KTtcbiAgcmV0dXJuIHpcbn07XG5UcmlhbmdsZS5sb25nZXN0U2lkZUxlbmd0aCA9IGZ1bmN0aW9uIGxvbmdlc3RTaWRlTGVuZ3RoIChhLCBiLCBjKSB7XG4gIHZhciBsZW5BQiA9IGEuZGlzdGFuY2UoYik7XG4gIHZhciBsZW5CQyA9IGIuZGlzdGFuY2UoYyk7XG4gIHZhciBsZW5DQSA9IGMuZGlzdGFuY2UoYSk7XG4gIHZhciBtYXhMZW4gPSBsZW5BQjtcbiAgaWYgKGxlbkJDID4gbWF4TGVuKSB7IG1heExlbiA9IGxlbkJDOyB9XG4gIGlmIChsZW5DQSA+IG1heExlbikgeyBtYXhMZW4gPSBsZW5DQTsgfVxuICByZXR1cm4gbWF4TGVuXG59O1xuVHJpYW5nbGUuaXNBY3V0ZSA9IGZ1bmN0aW9uIGlzQWN1dGUgKGEsIGIsIGMpIHtcbiAgaWYgKCFBbmdsZS5pc0FjdXRlKGEsIGIsIGMpKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICghQW5nbGUuaXNBY3V0ZShiLCBjLCBhKSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoIUFuZ2xlLmlzQWN1dGUoYywgYSwgYikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRydWVcbn07XG5UcmlhbmdsZS5jaXJjdW1jZW50cmUgPSBmdW5jdGlvbiBjaXJjdW1jZW50cmUgKGEsIGIsIGMpIHtcbiAgdmFyIGN4ID0gYy54O1xuICB2YXIgY3kgPSBjLnk7XG4gIHZhciBheCA9IGEueCAtIGN4O1xuICB2YXIgYXkgPSBhLnkgLSBjeTtcbiAgdmFyIGJ4ID0gYi54IC0gY3g7XG4gIHZhciBieSA9IGIueSAtIGN5O1xuICB2YXIgZGVub20gPSAyICogVHJpYW5nbGUuZGV0KGF4LCBheSwgYngsIGJ5KTtcbiAgdmFyIG51bXggPSBUcmlhbmdsZS5kZXQoYXksIGF4ICogYXggKyBheSAqIGF5LCBieSwgYnggKiBieCArIGJ5ICogYnkpO1xuICB2YXIgbnVteSA9IFRyaWFuZ2xlLmRldChheCwgYXggKiBheCArIGF5ICogYXksIGJ4LCBieCAqIGJ4ICsgYnkgKiBieSk7XG4gIHZhciBjY3ggPSBjeCAtIG51bXggLyBkZW5vbTtcbiAgdmFyIGNjeSA9IGN5ICsgbnVteSAvIGRlbm9tO1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoY2N4LCBjY3kpXG59O1xuVHJpYW5nbGUucGVycGVuZGljdWxhckJpc2VjdG9yID0gZnVuY3Rpb24gcGVycGVuZGljdWxhckJpc2VjdG9yIChhLCBiKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueDtcbiAgdmFyIGR5ID0gYi55IC0gYS55O1xuICB2YXIgbDEgPSBuZXcgSENvb3JkaW5hdGUoYS54ICsgZHggLyAyLjAsIGEueSArIGR5IC8gMi4wLCAxLjApO1xuICB2YXIgbDIgPSBuZXcgSENvb3JkaW5hdGUoYS54IC0gZHkgKyBkeCAvIDIuMCwgYS55ICsgZHggKyBkeSAvIDIuMCwgMS4wKTtcbiAgcmV0dXJuIG5ldyBIQ29vcmRpbmF0ZShsMSwgbDIpXG59O1xuVHJpYW5nbGUuYW5nbGVCaXNlY3RvciA9IGZ1bmN0aW9uIGFuZ2xlQmlzZWN0b3IgKGEsIGIsIGMpIHtcbiAgdmFyIGxlbjAgPSBiLmRpc3RhbmNlKGEpO1xuICB2YXIgbGVuMiA9IGIuZGlzdGFuY2UoYyk7XG4gIHZhciBmcmFjID0gbGVuMCAvIChsZW4wICsgbGVuMik7XG4gIHZhciBkeCA9IGMueCAtIGEueDtcbiAgdmFyIGR5ID0gYy55IC0gYS55O1xuICB2YXIgc3BsaXRQdCA9IG5ldyBDb29yZGluYXRlKGEueCArIGZyYWMgKiBkeCwgYS55ICsgZnJhYyAqIGR5KTtcbiAgcmV0dXJuIHNwbGl0UHRcbn07XG5UcmlhbmdsZS5hcmVhM0QgPSBmdW5jdGlvbiBhcmVhM0QgKGEsIGIsIGMpIHtcbiAgdmFyIHV4ID0gYi54IC0gYS54O1xuICB2YXIgdXkgPSBiLnkgLSBhLnk7XG4gIHZhciB1eiA9IGIueiAtIGEuejtcbiAgdmFyIHZ4ID0gYy54IC0gYS54O1xuICB2YXIgdnkgPSBjLnkgLSBhLnk7XG4gIHZhciB2eiA9IGMueiAtIGEuejtcbiAgdmFyIGNyb3NzeCA9IHV5ICogdnogLSB1eiAqIHZ5O1xuICB2YXIgY3Jvc3N5ID0gdXogKiB2eCAtIHV4ICogdno7XG4gIHZhciBjcm9zc3ogPSB1eCAqIHZ5IC0gdXkgKiB2eDtcbiAgdmFyIGFic1NxID0gY3Jvc3N4ICogY3Jvc3N4ICsgY3Jvc3N5ICogY3Jvc3N5ICsgY3Jvc3N6ICogY3Jvc3N6O1xuICB2YXIgYXJlYTNEID0gTWF0aC5zcXJ0KGFic1NxKSAvIDI7XG4gIHJldHVybiBhcmVhM0Rcbn07XG5UcmlhbmdsZS5jZW50cm9pZCA9IGZ1bmN0aW9uIGNlbnRyb2lkIChhLCBiLCBjKSB7XG4gIHZhciB4ID0gKGEueCArIGIueCArIGMueCkgLyAzO1xuICB2YXIgeSA9IChhLnkgKyBiLnkgKyBjLnkpIC8gMztcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHgsIHkpXG59O1xuVHJpYW5nbGUuaW5DZW50cmUgPSBmdW5jdGlvbiBpbkNlbnRyZSAoYSwgYiwgYykge1xuICB2YXIgbGVuMCA9IGIuZGlzdGFuY2UoYyk7XG4gIHZhciBsZW4xID0gYS5kaXN0YW5jZShjKTtcbiAgdmFyIGxlbjIgPSBhLmRpc3RhbmNlKGIpO1xuICB2YXIgY2lyY3VtID0gbGVuMCArIGxlbjEgKyBsZW4yO1xuICB2YXIgaW5DZW50cmVYID0gKGxlbjAgKiBhLnggKyBsZW4xICogYi54ICsgbGVuMiAqIGMueCkgLyBjaXJjdW07XG4gIHZhciBpbkNlbnRyZVkgPSAobGVuMCAqIGEueSArIGxlbjEgKiBiLnkgKyBsZW4yICogYy55KSAvIGNpcmN1bTtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKGluQ2VudHJlWCwgaW5DZW50cmVZKVxufTtcblxudmFyIE9mZnNldEN1cnZlU2V0QnVpbGRlciA9IGZ1bmN0aW9uIE9mZnNldEN1cnZlU2V0QnVpbGRlciAoKSB7XG4gIHRoaXMuX2lucHV0R2VvbSA9IG51bGw7XG4gIHRoaXMuX2Rpc3RhbmNlID0gbnVsbDtcbiAgdGhpcy5fY3VydmVCdWlsZGVyID0gbnVsbDtcbiAgdGhpcy5fY3VydmVMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgaW5wdXRHZW9tID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZGlzdGFuY2UgPSBhcmd1bWVudHNbMV07XG4gIHZhciBjdXJ2ZUJ1aWxkZXIgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuX2lucHV0R2VvbSA9IGlucHV0R2VvbTtcbiAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgdGhpcy5fY3VydmVCdWlsZGVyID0gY3VydmVCdWlsZGVyO1xufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkUG9pbnQgPSBmdW5jdGlvbiBhZGRQb2ludCAocCkge1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPD0gMC4wKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGNvb3JkID0gcC5nZXRDb29yZGluYXRlcygpO1xuICB2YXIgY3VydmUgPSB0aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGNvb3JkLCB0aGlzLl9kaXN0YW5jZSk7XG4gIHRoaXMuYWRkQ3VydmUoY3VydmUsIExvY2F0aW9uLkVYVEVSSU9SLCBMb2NhdGlvbi5JTlRFUklPUik7XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRQb2x5Z29uID0gZnVuY3Rpb24gYWRkUG9seWdvbiAocCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBvZmZzZXREaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlO1xuICB2YXIgb2Zmc2V0U2lkZSA9IFBvc2l0aW9uLkxFRlQ7XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8IDAuMCkge1xuICAgIG9mZnNldERpc3RhbmNlID0gLXRoaXMuX2Rpc3RhbmNlO1xuICAgIG9mZnNldFNpZGUgPSBQb3NpdGlvbi5SSUdIVDtcbiAgfVxuICB2YXIgc2hlbGwgPSBwLmdldEV4dGVyaW9yUmluZygpO1xuICB2YXIgc2hlbGxDb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMoc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8IDAuMCAmJiB0aGlzLmlzRXJvZGVkQ29tcGxldGVseShzaGVsbCwgdGhpcy5fZGlzdGFuY2UpKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDw9IDAuMCAmJiBzaGVsbENvb3JkLmxlbmd0aCA8IDMpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLmFkZFBvbHlnb25SaW5nKHNoZWxsQ29vcmQsIG9mZnNldERpc3RhbmNlLCBvZmZzZXRTaWRlLCBMb2NhdGlvbi5FWFRFUklPUiwgTG9jYXRpb24uSU5URVJJT1IpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHAuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkrKykge1xuICAgIHZhciBob2xlID0gcC5nZXRJbnRlcmlvclJpbmdOKGkpO1xuICAgIHZhciBob2xlQ29vcmQgPSBDb29yZGluYXRlQXJyYXlzLnJlbW92ZVJlcGVhdGVkUG9pbnRzKGhvbGUuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgaWYgKHRoaXMkMS5fZGlzdGFuY2UgPiAwLjAgJiYgdGhpcyQxLmlzRXJvZGVkQ29tcGxldGVseShob2xlLCAtdGhpcyQxLl9kaXN0YW5jZSkpIHsgY29udGludWUgfVxuICAgIHRoaXMkMS5hZGRQb2x5Z29uUmluZyhob2xlQ29vcmQsIG9mZnNldERpc3RhbmNlLCBQb3NpdGlvbi5vcHBvc2l0ZShvZmZzZXRTaWRlKSwgTG9jYXRpb24uSU5URVJJT1IsIExvY2F0aW9uLkVYVEVSSU9SKTtcbiAgfVxufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuaXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkgPSBmdW5jdGlvbiBpc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseSAodHJpYW5nbGVDb29yZCwgYnVmZmVyRGlzdGFuY2UpIHtcbiAgdmFyIHRyaSA9IG5ldyBUcmlhbmdsZSh0cmlhbmdsZUNvb3JkWzBdLCB0cmlhbmdsZUNvb3JkWzFdLCB0cmlhbmdsZUNvb3JkWzJdKTtcbiAgdmFyIGluQ2VudHJlID0gdHJpLmluQ2VudHJlKCk7XG4gIHZhciBkaXN0VG9DZW50cmUgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoaW5DZW50cmUsIHRyaS5wMCwgdHJpLnAxKTtcbiAgcmV0dXJuIGRpc3RUb0NlbnRyZSA8IE1hdGguYWJzKGJ1ZmZlckRpc3RhbmNlKVxufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkTGluZVN0cmluZyA9IGZ1bmN0aW9uIGFkZExpbmVTdHJpbmcgKGxpbmUpIHtcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDw9IDAuMCAmJiAhdGhpcy5fY3VydmVCdWlsZGVyLmdldEJ1ZmZlclBhcmFtZXRlcnMoKS5pc1NpbmdsZVNpZGVkKCkpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgY29vcmQgPSBDb29yZGluYXRlQXJyYXlzLnJlbW92ZVJlcGVhdGVkUG9pbnRzKGxpbmUuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gIHZhciBjdXJ2ZSA9IHRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoY29vcmQsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgdGhpcy5hZGRDdXJ2ZShjdXJ2ZSwgTG9jYXRpb24uRVhURVJJT1IsIExvY2F0aW9uLklOVEVSSU9SKTtcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmFkZEN1cnZlID0gZnVuY3Rpb24gYWRkQ3VydmUgKGNvb3JkLCBsZWZ0TG9jLCByaWdodExvYykge1xuICBpZiAoY29vcmQgPT09IG51bGwgfHwgY29vcmQubGVuZ3RoIDwgMikgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBlID0gbmV3IE5vZGVkU2VnbWVudFN0cmluZyhjb29yZCwgbmV3IExhYmVsKDAsIExvY2F0aW9uLkJPVU5EQVJZLCBsZWZ0TG9jLCByaWdodExvYykpO1xuICB0aGlzLl9jdXJ2ZUxpc3QuYWRkKGUpO1xufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuZ2V0Q3VydmVzID0gZnVuY3Rpb24gZ2V0Q3VydmVzICgpIHtcbiAgdGhpcy5hZGQodGhpcy5faW5wdXRHZW9tKTtcbiAgcmV0dXJuIHRoaXMuX2N1cnZlTGlzdFxufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkUG9seWdvblJpbmcgPSBmdW5jdGlvbiBhZGRQb2x5Z29uUmluZyAoY29vcmQsIG9mZnNldERpc3RhbmNlLCBzaWRlLCBjd0xlZnRMb2MsIGN3UmlnaHRMb2MpIHtcbiAgaWYgKG9mZnNldERpc3RhbmNlID09PSAwLjAgJiYgY29vcmQubGVuZ3RoIDwgTGluZWFyUmluZy5NSU5JTVVNX1ZBTElEX1NJWkUpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgbGVmdExvYyA9IGN3TGVmdExvYztcbiAgdmFyIHJpZ2h0TG9jID0gY3dSaWdodExvYztcbiAgaWYgKGNvb3JkLmxlbmd0aCA+PSBMaW5lYXJSaW5nLk1JTklNVU1fVkFMSURfU0laRSAmJiBDR0FsZ29yaXRobXMuaXNDQ1coY29vcmQpKSB7XG4gICAgbGVmdExvYyA9IGN3UmlnaHRMb2M7XG4gICAgcmlnaHRMb2MgPSBjd0xlZnRMb2M7XG4gICAgc2lkZSA9IFBvc2l0aW9uLm9wcG9zaXRlKHNpZGUpO1xuICB9XG4gIHZhciBjdXJ2ZSA9IHRoaXMuX2N1cnZlQnVpbGRlci5nZXRSaW5nQ3VydmUoY29vcmQsIHNpZGUsIG9mZnNldERpc3RhbmNlKTtcbiAgdGhpcy5hZGRDdXJ2ZShjdXJ2ZSwgbGVmdExvYywgcmlnaHRMb2MpO1xufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChnKSB7XG4gIGlmIChnLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChnIGluc3RhbmNlb2YgUG9seWdvbikgeyB0aGlzLmFkZFBvbHlnb24oZyk7IH1cbiAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHsgdGhpcy5hZGRMaW5lU3RyaW5nKGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBQb2ludCkgeyB0aGlzLmFkZFBvaW50KGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aVBvaW50KSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTXVsdGlMaW5lU3RyaW5nKSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICBlbHNlIGlmIChnIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICAvLyBlbHNlIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbihnLmdldENsYXNzKCkuZ2V0TmFtZSgpKVxufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuaXNFcm9kZWRDb21wbGV0ZWx5ID0gZnVuY3Rpb24gaXNFcm9kZWRDb21wbGV0ZWx5IChyaW5nLCBidWZmZXJEaXN0YW5jZSkge1xuICB2YXIgcmluZ0Nvb3JkID0gcmluZy5nZXRDb29yZGluYXRlcygpO1xuICAvLyBjb25zdCBtaW5EaWFtID0gMC4wXG4gIGlmIChyaW5nQ29vcmQubGVuZ3RoIDwgNCkgeyByZXR1cm4gYnVmZmVyRGlzdGFuY2UgPCAwIH1cbiAgaWYgKHJpbmdDb29yZC5sZW5ndGggPT09IDQpIHsgcmV0dXJuIHRoaXMuaXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkocmluZ0Nvb3JkLCBidWZmZXJEaXN0YW5jZSkgfVxuICB2YXIgZW52ID0gcmluZy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIHZhciBlbnZNaW5EaW1lbnNpb24gPSBNYXRoLm1pbihlbnYuZ2V0SGVpZ2h0KCksIGVudi5nZXRXaWR0aCgpKTtcbiAgaWYgKGJ1ZmZlckRpc3RhbmNlIDwgMC4wICYmIDIgKiBNYXRoLmFicyhidWZmZXJEaXN0YW5jZSkgPiBlbnZNaW5EaW1lbnNpb24pIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmFkZENvbGxlY3Rpb24gPSBmdW5jdGlvbiBhZGRDb2xsZWN0aW9uIChnYykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2MuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgZyA9IGdjLmdldEdlb21ldHJ5TihpKTtcbiAgICB0aGlzJDEuYWRkKGcpO1xuICB9XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9mZnNldEN1cnZlU2V0QnVpbGRlclxufTtcblxudmFyIFBvaW50T25HZW9tZXRyeUxvY2F0b3IgPSBmdW5jdGlvbiBQb2ludE9uR2VvbWV0cnlMb2NhdG9yICgpIHt9O1xuXG5Qb2ludE9uR2VvbWV0cnlMb2NhdG9yLnByb3RvdHlwZS5sb2NhdGUgPSBmdW5jdGlvbiBsb2NhdGUgKHApIHt9O1xuUG9pbnRPbkdlb21ldHJ5TG9jYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvaW50T25HZW9tZXRyeUxvY2F0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9pbnRPbkdlb21ldHJ5TG9jYXRvclxufTtcblxudmFyIEdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yID0gZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IgKCkge1xuICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICB0aGlzLl9hdFN0YXJ0ID0gbnVsbDtcbiAgdGhpcy5fbWF4ID0gbnVsbDtcbiAgdGhpcy5faW5kZXggPSBudWxsO1xuICB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IgPSBudWxsO1xuICB2YXIgcGFyZW50ID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX2F0U3RhcnQgPSB0cnVlO1xuICB0aGlzLl9pbmRleCA9IDA7XG4gIHRoaXMuX21heCA9IHBhcmVudC5nZXROdW1HZW9tZXRyaWVzKCk7XG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgaWYgKHRoaXMuX2F0U3RhcnQpIHtcbiAgICB0aGlzLl9hdFN0YXJ0ID0gZmFsc2U7XG4gICAgaWYgKEdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLmlzQXRvbWljKHRoaXMuX3BhcmVudCkpIHsgdGhpcy5faW5kZXgrKzsgfVxuICAgIHJldHVybiB0aGlzLl9wYXJlbnRcbiAgfVxuICBpZiAodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yICE9PSBudWxsKSB7XG4gICAgaWYgKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9tYXgpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbigpXG4gIH1cbiAgdmFyIG9iaiA9IHRoaXMuX3BhcmVudC5nZXRHZW9tZXRyeU4odGhpcy5faW5kZXgrKyk7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IgPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3Iob2JqKTtcbiAgICByZXR1cm4gdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKVxuICB9XG4gIHJldHVybiBvYmpcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiBoYXNOZXh0ICgpIHtcbiAgaWYgKHRoaXMuX2F0U3RhcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmICh0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IgIT09IG51bGwpIHtcbiAgICBpZiAodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbWF4KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbSXRlcmF0b3JdXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3Jcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5pc0F0b21pYyA9IGZ1bmN0aW9uIGlzQXRvbWljIChnZW9tKSB7XG4gIHJldHVybiAhKGdlb20gaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pXG59O1xuXG52YXIgU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yID0gZnVuY3Rpb24gU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yICgpIHtcbiAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9nZW9tID0gZ2VvbTtcbn07XG5TaW1wbGVQb2ludEluQXJlYUxvY2F0b3IucHJvdG90eXBlLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocCkge1xuICByZXR1cm4gU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmxvY2F0ZShwLCB0aGlzLl9nZW9tKVxufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbUG9pbnRPbkdlb21ldHJ5TG9jYXRvcl1cbn07XG5TaW1wbGVQb2ludEluQXJlYUxvY2F0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmlzUG9pbnRJblJpbmcgPSBmdW5jdGlvbiBpc1BvaW50SW5SaW5nIChwLCByaW5nKSB7XG4gIGlmICghcmluZy5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhwKSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gQ0dBbGdvcml0aG1zLmlzUG9pbnRJblJpbmcocCwgcmluZy5nZXRDb29yZGluYXRlcygpKVxufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5jb250YWluc1BvaW50SW5Qb2x5Z29uID0gZnVuY3Rpb24gY29udGFpbnNQb2ludEluUG9seWdvbiAocCwgcG9seSkge1xuICBpZiAocG9seS5pc0VtcHR5KCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIHNoZWxsID0gcG9seS5nZXRFeHRlcmlvclJpbmcoKTtcbiAgaWYgKCFTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuaXNQb2ludEluUmluZyhwLCBzaGVsbCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5LmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICB2YXIgaG9sZSA9IHBvbHkuZ2V0SW50ZXJpb3JSaW5nTihpKTtcbiAgICBpZiAoU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmlzUG9pbnRJblJpbmcocCwgaG9sZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gY29udGFpbnNQb2ludCAocCwgZ2VvbSkge1xuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICByZXR1cm4gU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmNvbnRhaW5zUG9pbnRJblBvbHlnb24ocCwgZ2VvbSlcbiAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgdmFyIGdlb21pID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yKGdlb20pO1xuICAgIHdoaWxlIChnZW9taS5oYXNOZXh0KCkpIHtcbiAgICAgIHZhciBnMiA9IGdlb21pLm5leHQoKTtcbiAgICAgIGlmIChnMiAhPT0gZ2VvbSkgeyBpZiAoU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmNvbnRhaW5zUG9pbnQocCwgZzIpKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5TaW1wbGVQb2ludEluQXJlYUxvY2F0b3IubG9jYXRlID0gZnVuY3Rpb24gbG9jYXRlIChwLCBnZW9tKSB7XG4gIGlmIChnZW9tLmlzRW1wdHkoKSkgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICBpZiAoU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmNvbnRhaW5zUG9pbnQocCwgZ2VvbSkpIHsgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SIH1cbiAgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SXG59O1xuXG52YXIgRWRnZUVuZFN0YXIgPSBmdW5jdGlvbiBFZGdlRW5kU3RhciAoKSB7XG4gIHRoaXMuX2VkZ2VNYXAgPSBuZXcgVHJlZU1hcCgpO1xuICB0aGlzLl9lZGdlTGlzdCA9IG51bGw7XG4gIHRoaXMuX3B0SW5BcmVhTG9jYXRpb24gPSBbTG9jYXRpb24uTk9ORSwgTG9jYXRpb24uTk9ORV07XG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmdldE5leHRDVyA9IGZ1bmN0aW9uIGdldE5leHRDVyAoZWUpIHtcbiAgdGhpcy5nZXRFZGdlcygpO1xuICB2YXIgaSA9IHRoaXMuX2VkZ2VMaXN0LmluZGV4T2YoZWUpO1xuICB2YXIgaU5leHRDVyA9IGkgLSAxO1xuICBpZiAoaSA9PT0gMCkgeyBpTmV4dENXID0gdGhpcy5fZWRnZUxpc3Quc2l6ZSgpIC0gMTsgfVxuICByZXR1cm4gdGhpcy5fZWRnZUxpc3QuZ2V0KGlOZXh0Q1cpXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLnByb3BhZ2F0ZVNpZGVMYWJlbHMgPSBmdW5jdGlvbiBwcm9wYWdhdGVTaWRlTGFiZWxzIChnZW9tSW5kZXgpIHtcbiAgdmFyIHN0YXJ0TG9jID0gTG9jYXRpb24uTk9ORTtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbGFiZWwgPSBlLmdldExhYmVsKCk7XG4gICAgaWYgKGxhYmVsLmlzQXJlYShnZW9tSW5kZXgpICYmIGxhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCkgIT09IExvY2F0aW9uLk5PTkUpIHsgc3RhcnRMb2MgPSBsYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQpOyB9XG4gIH1cbiAgaWYgKHN0YXJ0TG9jID09PSBMb2NhdGlvbi5OT05FKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGN1cnJMb2MgPSBzdGFydExvYztcbiAgZm9yICh2YXIgaXQkMSA9IHRoaXMuaXRlcmF0b3IoKTsgaXQkMS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUkMSA9IGl0JDEubmV4dCgpO1xuICAgIHZhciBsYWJlbCQxID0gZSQxLmdldExhYmVsKCk7XG4gICAgaWYgKGxhYmVsJDEuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5PTikgPT09IExvY2F0aW9uLk5PTkUpIHsgbGFiZWwkMS5zZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLk9OLCBjdXJyTG9jKTsgfVxuICAgIGlmIChsYWJlbCQxLmlzQXJlYShnZW9tSW5kZXgpKSB7XG4gICAgICB2YXIgbGVmdExvYyA9IGxhYmVsJDEuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZUKTtcbiAgICAgIHZhciByaWdodExvYyA9IGxhYmVsJDEuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5SSUdIVCk7XG4gICAgICBpZiAocmlnaHRMb2MgIT09IExvY2F0aW9uLk5PTkUpIHtcbiAgICAgICAgaWYgKHJpZ2h0TG9jICE9PSBjdXJyTG9jKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbignc2lkZSBsb2NhdGlvbiBjb25mbGljdCcsIGUkMS5nZXRDb29yZGluYXRlKCkpIH1cbiAgICAgICAgaWYgKGxlZnRMb2MgPT09IExvY2F0aW9uLk5PTkUpIHtcbiAgICAgICAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoJ2ZvdW5kIHNpbmdsZSBudWxsIHNpZGUgKGF0ICcgKyBlJDEuZ2V0Q29vcmRpbmF0ZSgpICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyTG9jID0gbGVmdExvYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFzc2VydC5pc1RydWUobGFiZWwkMS5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQpID09PSBMb2NhdGlvbi5OT05FLCAnZm91bmQgc2luZ2xlIG51bGwgc2lkZScpO1xuICAgICAgICBsYWJlbCQxLnNldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uUklHSFQsIGN1cnJMb2MpO1xuICAgICAgICBsYWJlbCQxLnNldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCwgY3VyckxvYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpO1xuICBpZiAoIWl0Lmhhc05leHQoKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBlID0gaXQubmV4dCgpO1xuICByZXR1cm4gZS5nZXRDb29yZGluYXRlKClcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gIFN5c3RlbS5vdXQucHJpbnRsbignRWRnZUVuZFN0YXI6ICAgJyArIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICBlLnByaW50KG91dCk7XG4gIH1cbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuaXNBcmVhTGFiZWxzQ29uc2lzdGVudCA9IGZ1bmN0aW9uIGlzQXJlYUxhYmVsc0NvbnNpc3RlbnQgKGdlb21HcmFwaCkge1xuICB0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKGdlb21HcmFwaC5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpO1xuICByZXR1cm4gdGhpcy5jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KDApXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQgPSBmdW5jdGlvbiBjaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50IChnZW9tSW5kZXgpIHtcbiAgdmFyIGVkZ2VzID0gdGhpcy5nZXRFZGdlcygpO1xuICBpZiAoZWRnZXMuc2l6ZSgpIDw9IDApIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgbGFzdEVkZ2VJbmRleCA9IGVkZ2VzLnNpemUoKSAtIDE7XG4gIHZhciBzdGFydExhYmVsID0gZWRnZXMuZ2V0KGxhc3RFZGdlSW5kZXgpLmdldExhYmVsKCk7XG4gIHZhciBzdGFydExvYyA9IHN0YXJ0TGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZUKTtcbiAgQXNzZXJ0LmlzVHJ1ZShzdGFydExvYyAhPT0gTG9jYXRpb24uTk9ORSwgJ0ZvdW5kIHVubGFiZWxsZWQgYXJlYSBlZGdlJyk7XG4gIHZhciBjdXJyTG9jID0gc3RhcnRMb2M7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGxhYmVsID0gZS5nZXRMYWJlbCgpO1xuICAgIEFzc2VydC5pc1RydWUobGFiZWwuaXNBcmVhKGdlb21JbmRleCksICdGb3VuZCBub24tYXJlYSBlZGdlJyk7XG4gICAgdmFyIGxlZnRMb2MgPSBsYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQpO1xuICAgIHZhciByaWdodExvYyA9IGxhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uUklHSFQpO1xuICAgIGlmIChsZWZ0TG9jID09PSByaWdodExvYykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChyaWdodExvYyAhPT0gY3VyckxvYykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGN1cnJMb2MgPSBsZWZ0TG9jO1xuICB9XG4gIHJldHVybiB0cnVlXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmZpbmRJbmRleCA9IGZ1bmN0aW9uIGZpbmRJbmRleCAoZVNlYXJjaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuaXRlcmF0b3IoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lZGdlTGlzdC5zaXplKCk7IGkrKykge1xuICAgIHZhciBlID0gdGhpcyQxLl9lZGdlTGlzdC5nZXQoaSk7XG4gICAgaWYgKGUgPT09IGVTZWFyY2gpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RWRnZXMoKS5pdGVyYXRvcigpXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gZ2V0RWRnZXMgKCkge1xuICBpZiAodGhpcy5fZWRnZUxpc3QgPT09IG51bGwpIHtcbiAgICB0aGlzLl9lZGdlTGlzdCA9IG5ldyBBcnJheUxpc3QodGhpcy5fZWRnZU1hcC52YWx1ZXMoKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2VkZ2VMaXN0XG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGdlb21JbmRleCwgcCwgZ2VvbSkge1xuICBpZiAodGhpcy5fcHRJbkFyZWFMb2NhdGlvbltnZW9tSW5kZXhdID09PSBMb2NhdGlvbi5OT05FKSB7XG4gICAgdGhpcy5fcHRJbkFyZWFMb2NhdGlvbltnZW9tSW5kZXhdID0gU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmxvY2F0ZShwLCBnZW9tW2dlb21JbmRleF0uZ2V0R2VvbWV0cnkoKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bZ2VvbUluZGV4XVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgYnVmLmFwcGVuZCgnRWRnZUVuZFN0YXI6ICAgJyArIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgYnVmLmFwcGVuZCgnXFxuJyk7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgYnVmLmFwcGVuZChlKTtcbiAgICBidWYuYXBwZW5kKCdcXG4nKTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKClcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuY29tcHV0ZUVkZ2VFbmRMYWJlbHMgPSBmdW5jdGlvbiBjb21wdXRlRWRnZUVuZExhYmVscyAoYm91bmRhcnlOb2RlUnVsZSkge1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlZSA9IGl0Lm5leHQoKTtcbiAgICBlZS5jb21wdXRlTGFiZWwoYm91bmRhcnlOb2RlUnVsZSk7XG4gIH1cbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuY29tcHV0ZUxhYmVsbGluZyA9IGZ1bmN0aW9uIGNvbXB1dGVMYWJlbGxpbmcgKGdlb21HcmFwaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHMoZ2VvbUdyYXBoWzBdLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSk7XG4gIHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygwKTtcbiAgdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDEpO1xuICB2YXIgaGFzRGltZW5zaW9uYWxDb2xsYXBzZUVkZ2UgPSBbZmFsc2UsIGZhbHNlXTtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbGFiZWwgPSBlLmdldExhYmVsKCk7XG4gICAgZm9yICh2YXIgZ2VvbWkgPSAwOyBnZW9taSA8IDI7IGdlb21pKyspIHtcbiAgICAgIGlmIChsYWJlbC5pc0xpbmUoZ2VvbWkpICYmIGxhYmVsLmdldExvY2F0aW9uKGdlb21pKSA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgaGFzRGltZW5zaW9uYWxDb2xsYXBzZUVkZ2VbZ2VvbWldID0gdHJ1ZTsgfVxuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpdCQxID0gdGhpcy5pdGVyYXRvcigpOyBpdCQxLmhhc05leHQoKTspIHtcbiAgICB2YXIgZSQxID0gaXQkMS5uZXh0KCk7XG4gICAgdmFyIGxhYmVsJDEgPSBlJDEuZ2V0TGFiZWwoKTtcbiAgICBmb3IgKHZhciBnZW9taSQxID0gMDsgZ2VvbWkkMSA8IDI7IGdlb21pJDErKykge1xuICAgICAgaWYgKGxhYmVsJDEuaXNBbnlOdWxsKGdlb21pJDEpKSB7XG4gICAgICAgIHZhciBsb2MgPSBMb2NhdGlvbi5OT05FO1xuICAgICAgICBpZiAoaGFzRGltZW5zaW9uYWxDb2xsYXBzZUVkZ2VbZ2VvbWkkMV0pIHtcbiAgICAgICAgICBsb2MgPSBMb2NhdGlvbi5FWFRFUklPUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcCA9IGUkMS5nZXRDb29yZGluYXRlKCk7XG4gICAgICAgICAgbG9jID0gdGhpcyQxLmdldExvY2F0aW9uKGdlb21pJDEsIHAsIGdlb21HcmFwaCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFiZWwkMS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoZ2VvbWkkMSwgbG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0RGVncmVlID0gZnVuY3Rpb24gZ2V0RGVncmVlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VNYXAuc2l6ZSgpXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmluc2VydEVkZ2VFbmQgPSBmdW5jdGlvbiBpbnNlcnRFZGdlRW5kIChlLCBvYmopIHtcbiAgdGhpcy5fZWRnZU1hcC5wdXQoZSwgb2JqKTtcbiAgdGhpcy5fZWRnZUxpc3QgPSBudWxsO1xufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZUVuZFN0YXJcbn07XG5cbnZhciBEaXJlY3RlZEVkZ2VTdGFyID0gKGZ1bmN0aW9uIChFZGdlRW5kU3RhciQkMSkge1xuICBmdW5jdGlvbiBEaXJlY3RlZEVkZ2VTdGFyICgpIHtcbiAgICBFZGdlRW5kU3RhciQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdCA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICAgIHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORyA9IDE7XG4gICAgdGhpcy5fTElOS0lOR19UT19PVVRHT0lORyA9IDI7XG4gIH1cblxuICBpZiAoIEVkZ2VFbmRTdGFyJCQxICkgRGlyZWN0ZWRFZGdlU3Rhci5fX3Byb3RvX18gPSBFZGdlRW5kU3RhciQkMTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFZGdlRW5kU3RhciQkMSAmJiBFZGdlRW5kU3RhciQkMS5wcm90b3R5cGUgKTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXJlY3RlZEVkZ2VTdGFyO1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuZ2V0UmVzdWx0QXJlYUVkZ2VzKCk7XG4gICAgdmFyIGZpcnN0T3V0ID0gbnVsbDtcbiAgICB2YXIgaW5jb21pbmcgPSBudWxsO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCk7IGkrKykge1xuICAgICAgdmFyIG5leHRPdXQgPSB0aGlzJDEuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQoaSk7XG4gICAgICB2YXIgbmV4dEluID0gbmV4dE91dC5nZXRTeW0oKTtcbiAgICAgIGlmICghbmV4dE91dC5nZXRMYWJlbCgpLmlzQXJlYSgpKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChmaXJzdE91dCA9PT0gbnVsbCAmJiBuZXh0T3V0LmlzSW5SZXN1bHQoKSkgeyBmaXJzdE91dCA9IG5leHRPdXQ7IH1cbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSB0aGlzJDEuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORzpcbiAgICAgICAgICBpZiAoIW5leHRJbi5pc0luUmVzdWx0KCkpIHsgY29udGludWUgfVxuICAgICAgICAgIGluY29taW5nID0gbmV4dEluO1xuICAgICAgICAgIHN0YXRlID0gdGhpcyQxLl9MSU5LSU5HX1RPX09VVEdPSU5HO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgdGhpcyQxLl9MSU5LSU5HX1RPX09VVEdPSU5HOlxuICAgICAgICAgIGlmICghbmV4dE91dC5pc0luUmVzdWx0KCkpIHsgY29udGludWUgfVxuICAgICAgICAgIGluY29taW5nLnNldE5leHQobmV4dE91dCk7XG4gICAgICAgICAgc3RhdGUgPSB0aGlzJDEuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcpIHtcbiAgICAgIGlmIChmaXJzdE91dCA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ25vIG91dGdvaW5nIGRpckVkZ2UgZm91bmQnLCB0aGlzLmdldENvb3JkaW5hdGUoKSkgfVxuICAgICAgQXNzZXJ0LmlzVHJ1ZShmaXJzdE91dC5pc0luUmVzdWx0KCksICd1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2UnKTtcbiAgICAgIGluY29taW5nLnNldE5leHQoZmlyc3RPdXQpO1xuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0IChlZSkge1xuICAgIHZhciBkZSA9IGVlO1xuICAgIHRoaXMuaW5zZXJ0RWRnZUVuZChkZSwgZGUpO1xuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5nZXRSaWdodG1vc3RFZGdlID0gZnVuY3Rpb24gZ2V0UmlnaHRtb3N0RWRnZSAoKSB7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRFZGdlcygpO1xuICAgIHZhciBzaXplID0gZWRnZXMuc2l6ZSgpO1xuICAgIGlmIChzaXplIDwgMSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGRlMCA9IGVkZ2VzLmdldCgwKTtcbiAgICBpZiAoc2l6ZSA9PT0gMSkgeyByZXR1cm4gZGUwIH1cbiAgICB2YXIgZGVMYXN0ID0gZWRnZXMuZ2V0KHNpemUgLSAxKTtcbiAgICB2YXIgcXVhZDAgPSBkZTAuZ2V0UXVhZHJhbnQoKTtcbiAgICB2YXIgcXVhZDEgPSBkZUxhc3QuZ2V0UXVhZHJhbnQoKTtcbiAgICBpZiAoUXVhZHJhbnQuaXNOb3J0aGVybihxdWFkMCkgJiYgUXVhZHJhbnQuaXNOb3J0aGVybihxdWFkMSkpIHsgcmV0dXJuIGRlMDsgfSBlbHNlIGlmICghUXVhZHJhbnQuaXNOb3J0aGVybihxdWFkMCkgJiYgIVF1YWRyYW50LmlzTm9ydGhlcm4ocXVhZDEpKSB7IHJldHVybiBkZUxhc3Q7IH0gZWxzZSB7XG4gICAgICAvLyBjb25zdCBub25Ib3Jpem9udGFsRWRnZSA9IG51bGxcbiAgICAgIGlmIChkZTAuZ2V0RHkoKSAhPT0gMCkgeyByZXR1cm4gZGUwOyB9IGVsc2UgaWYgKGRlTGFzdC5nZXREeSgpICE9PSAwKSB7IHJldHVybiBkZUxhc3QgfVxuICAgIH1cbiAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoJ2ZvdW5kIHR3byBob3Jpem9udGFsIGVkZ2VzIGluY2lkZW50IG9uIG5vZGUnKTtcbiAgICByZXR1cm4gbnVsbFxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgICBTeXN0ZW0ub3V0LnByaW50bG4oJ0RpcmVjdGVkRWRnZVN0YXI6ICcgKyB0aGlzLmdldENvb3JkaW5hdGUoKSk7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgIG91dC5wcmludCgnb3V0ICcpO1xuICAgICAgZGUucHJpbnQob3V0KTtcbiAgICAgIG91dC5wcmludGxuKCk7XG4gICAgICBvdXQucHJpbnQoJ2luICcpO1xuICAgICAgZGUuZ2V0U3ltKCkucHJpbnQob3V0KTtcbiAgICAgIG91dC5wcmludGxuKCk7XG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5nZXRSZXN1bHRBcmVhRWRnZXMgPSBmdW5jdGlvbiBnZXRSZXN1bHRBcmVhRWRnZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdCAhPT0gbnVsbCkgeyByZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0IH1cbiAgICB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgIGlmIChkZS5pc0luUmVzdWx0KCkgfHwgZGUuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKSB7IHRoaXMkMS5fcmVzdWx0QXJlYUVkZ2VMaXN0LmFkZChkZSk7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdFxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS51cGRhdGVMYWJlbGxpbmcgPSBmdW5jdGlvbiB1cGRhdGVMYWJlbGxpbmcgKG5vZGVMYWJlbCkge1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgbGFiZWwgPSBkZS5nZXRMYWJlbCgpO1xuICAgICAgbGFiZWwuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsIG5vZGVMYWJlbC5nZXRMb2NhdGlvbigwKSk7XG4gICAgICBsYWJlbC5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSwgbm9kZUxhYmVsLmdldExvY2F0aW9uKDEpKTtcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmxpbmtBbGxEaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gbGlua0FsbERpcmVjdGVkRWRnZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5nZXRFZGdlcygpO1xuICAgIHZhciBwcmV2T3V0ID0gbnVsbDtcbiAgICB2YXIgZmlyc3RJbiA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2VkZ2VMaXN0LnNpemUoKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbmV4dE91dCA9IHRoaXMkMS5fZWRnZUxpc3QuZ2V0KGkpO1xuICAgICAgdmFyIG5leHRJbiA9IG5leHRPdXQuZ2V0U3ltKCk7XG4gICAgICBpZiAoZmlyc3RJbiA9PT0gbnVsbCkgeyBmaXJzdEluID0gbmV4dEluOyB9XG4gICAgICBpZiAocHJldk91dCAhPT0gbnVsbCkgeyBuZXh0SW4uc2V0TmV4dChwcmV2T3V0KTsgfVxuICAgICAgcHJldk91dCA9IG5leHRPdXQ7XG4gICAgfVxuICAgIGZpcnN0SW4uc2V0TmV4dChwcmV2T3V0KTtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuY29tcHV0ZURlcHRocyA9IGZ1bmN0aW9uIGNvbXB1dGVEZXB0aHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBkZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBlZGdlSW5kZXggPSB0aGlzLmZpbmRJbmRleChkZSk7XG4gICAgICAvLyBjb25zdCBsYWJlbCA9IGRlLmdldExhYmVsKClcbiAgICAgIHZhciBzdGFydERlcHRoID0gZGUuZ2V0RGVwdGgoUG9zaXRpb24uTEVGVCk7XG4gICAgICB2YXIgdGFyZ2V0TGFzdERlcHRoID0gZGUuZ2V0RGVwdGgoUG9zaXRpb24uUklHSFQpO1xuICAgICAgdmFyIG5leHREZXB0aCA9IHRoaXMuY29tcHV0ZURlcHRocyhlZGdlSW5kZXggKyAxLCB0aGlzLl9lZGdlTGlzdC5zaXplKCksIHN0YXJ0RGVwdGgpO1xuICAgICAgdmFyIGxhc3REZXB0aCA9IHRoaXMuY29tcHV0ZURlcHRocygwLCBlZGdlSW5kZXgsIG5leHREZXB0aCk7XG4gICAgICBpZiAobGFzdERlcHRoICE9PSB0YXJnZXRMYXN0RGVwdGgpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdkZXB0aCBtaXNtYXRjaCBhdCAnICsgZGUuZ2V0Q29vcmRpbmF0ZSgpKSB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB2YXIgc3RhcnRJbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBlbmRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzdGFydERlcHRoJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgY3VyckRlcHRoID0gc3RhcnREZXB0aCQxO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0RGUgPSB0aGlzJDEuX2VkZ2VMaXN0LmdldChpKTtcbiAgICAgICAgLy8gY29uc3QgbGFiZWwgPSBuZXh0RGUuZ2V0TGFiZWwoKVxuICAgICAgICBuZXh0RGUuc2V0RWRnZURlcHRocyhQb3NpdGlvbi5SSUdIVCwgY3VyckRlcHRoKTtcbiAgICAgICAgY3VyckRlcHRoID0gbmV4dERlLmdldERlcHRoKFBvc2l0aW9uLkxFRlQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJEZXB0aFxuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUubWVyZ2VTeW1MYWJlbHMgPSBmdW5jdGlvbiBtZXJnZVN5bUxhYmVscyAoKSB7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBsYWJlbCA9IGRlLmdldExhYmVsKCk7XG4gICAgICBsYWJlbC5tZXJnZShkZS5nZXRTeW0oKS5nZXRMYWJlbCgpKTtcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyAoZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBmaXJzdE91dCA9IG51bGw7XG4gICAgdmFyIGluY29taW5nID0gbnVsbDtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIG5leHRPdXQgPSB0aGlzJDEuX3Jlc3VsdEFyZWFFZGdlTGlzdC5nZXQoaSk7XG4gICAgICB2YXIgbmV4dEluID0gbmV4dE91dC5nZXRTeW0oKTtcbiAgICAgIGlmIChmaXJzdE91dCA9PT0gbnVsbCAmJiBuZXh0T3V0LmdldEVkZ2VSaW5nKCkgPT09IGVyKSB7IGZpcnN0T3V0ID0gbmV4dE91dDsgfVxuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIHRoaXMkMS5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOlxuICAgICAgICAgIGlmIChuZXh0SW4uZ2V0RWRnZVJpbmcoKSAhPT0gZXIpIHsgY29udGludWUgfVxuICAgICAgICAgIGluY29taW5nID0gbmV4dEluO1xuICAgICAgICAgIHN0YXRlID0gdGhpcyQxLl9MSU5LSU5HX1RPX09VVEdPSU5HO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgdGhpcyQxLl9MSU5LSU5HX1RPX09VVEdPSU5HOlxuICAgICAgICAgIGlmIChuZXh0T3V0LmdldEVkZ2VSaW5nKCkgIT09IGVyKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgICBpbmNvbWluZy5zZXROZXh0TWluKG5leHRPdXQpO1xuICAgICAgICAgIHN0YXRlID0gdGhpcyQxLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HKSB7XG4gICAgICBBc3NlcnQuaXNUcnVlKGZpcnN0T3V0ICE9PSBudWxsLCAnZm91bmQgbnVsbCBmb3IgZmlyc3Qgb3V0Z29pbmcgZGlyRWRnZScpO1xuICAgICAgQXNzZXJ0LmlzVHJ1ZShmaXJzdE91dC5nZXRFZGdlUmluZygpID09PSBlciwgJ3VuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZScpO1xuICAgICAgaW5jb21pbmcuc2V0TmV4dE1pbihmaXJzdE91dCk7XG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5nZXRPdXRnb2luZ0RlZ3JlZSA9IGZ1bmN0aW9uIGdldE91dGdvaW5nRGVncmVlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFyIGRlZ3JlZSA9IDA7XG4gICAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICAgIGlmIChkZS5pc0luUmVzdWx0KCkpIHsgZGVncmVlKys7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWdyZWVcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkZWdyZWUkMSA9IDA7XG4gICAgICBmb3IgKHZhciBpdCQxID0gdGhpcy5pdGVyYXRvcigpOyBpdCQxLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGRlJDEgPSBpdCQxLm5leHQoKTtcbiAgICAgICAgaWYgKGRlJDEuZ2V0RWRnZVJpbmcoKSA9PT0gZXIpIHsgZGVncmVlJDErKzsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZ3JlZSQxXG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uIGdldExhYmVsICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFiZWxcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuZmluZENvdmVyZWRMaW5lRWRnZXMgPSBmdW5jdGlvbiBmaW5kQ292ZXJlZExpbmVFZGdlcyAoKSB7XG4gICAgdmFyIHN0YXJ0TG9jID0gTG9jYXRpb24uTk9ORTtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG5leHRPdXQgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgbmV4dEluID0gbmV4dE91dC5nZXRTeW0oKTtcbiAgICAgIGlmICghbmV4dE91dC5pc0xpbmVFZGdlKCkpIHtcbiAgICAgICAgaWYgKG5leHRPdXQuaXNJblJlc3VsdCgpKSB7XG4gICAgICAgICAgc3RhcnRMb2MgPSBMb2NhdGlvbi5JTlRFUklPUjtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0SW4uaXNJblJlc3VsdCgpKSB7XG4gICAgICAgICAgc3RhcnRMb2MgPSBMb2NhdGlvbi5FWFRFUklPUjtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGFydExvYyA9PT0gTG9jYXRpb24uTk9ORSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGN1cnJMb2MgPSBzdGFydExvYztcbiAgICBmb3IgKHZhciBpdCQxID0gdGhpcy5pdGVyYXRvcigpOyBpdCQxLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBuZXh0T3V0JDEgPSBpdCQxLm5leHQoKTtcbiAgICAgIHZhciBuZXh0SW4kMSA9IG5leHRPdXQkMS5nZXRTeW0oKTtcbiAgICAgIGlmIChuZXh0T3V0JDEuaXNMaW5lRWRnZSgpKSB7XG4gICAgICAgIG5leHRPdXQkMS5nZXRFZGdlKCkuc2V0Q292ZXJlZChjdXJyTG9jID09PSBMb2NhdGlvbi5JTlRFUklPUik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobmV4dE91dCQxLmlzSW5SZXN1bHQoKSkgeyBjdXJyTG9jID0gTG9jYXRpb24uRVhURVJJT1I7IH1cbiAgICAgICAgaWYgKG5leHRJbiQxLmlzSW5SZXN1bHQoKSkgeyBjdXJyTG9jID0gTG9jYXRpb24uSU5URVJJT1I7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmNvbXB1dGVMYWJlbGxpbmcgPSBmdW5jdGlvbiBjb21wdXRlTGFiZWxsaW5nIChnZW9tKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBFZGdlRW5kU3RhciQkMS5wcm90b3R5cGUuY29tcHV0ZUxhYmVsbGluZy5jYWxsKHRoaXMsIGdlb20pO1xuICAgIHRoaXMuX2xhYmVsID0gbmV3IExhYmVsKExvY2F0aW9uLk5PTkUpO1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZWUgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgZSA9IGVlLmdldEVkZ2UoKTtcbiAgICAgIHZhciBlTGFiZWwgPSBlLmdldExhYmVsKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICB2YXIgZUxvYyA9IGVMYWJlbC5nZXRMb2NhdGlvbihpKTtcbiAgICAgICAgaWYgKGVMb2MgPT09IExvY2F0aW9uLklOVEVSSU9SIHx8IGVMb2MgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IHRoaXMkMS5fbGFiZWwuc2V0TG9jYXRpb24oaSwgTG9jYXRpb24uSU5URVJJT1IpOyB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIERpcmVjdGVkRWRnZVN0YXJcbiAgfTtcblxuICByZXR1cm4gRGlyZWN0ZWRFZGdlU3Rhcjtcbn0oRWRnZUVuZFN0YXIpKTtcblxudmFyIE92ZXJsYXlOb2RlRmFjdG9yeSA9IChmdW5jdGlvbiAoTm9kZUZhY3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gT3ZlcmxheU5vZGVGYWN0b3J5ICgpIHtcbiAgICBOb2RlRmFjdG9yeSQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBOb2RlRmFjdG9yeSQkMSApIE92ZXJsYXlOb2RlRmFjdG9yeS5fX3Byb3RvX18gPSBOb2RlRmFjdG9yeSQkMTtcbiAgT3ZlcmxheU5vZGVGYWN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE5vZGVGYWN0b3J5JCQxICYmIE5vZGVGYWN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBPdmVybGF5Tm9kZUZhY3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3ZlcmxheU5vZGVGYWN0b3J5O1xuXG4gIE92ZXJsYXlOb2RlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5vZGUgKGNvb3JkKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKGNvb3JkLCBuZXcgRGlyZWN0ZWRFZGdlU3RhcigpKVxuICB9O1xuICBPdmVybGF5Tm9kZUZhY3RvcnkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBPdmVybGF5Tm9kZUZhY3RvcnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBPdmVybGF5Tm9kZUZhY3RvcnlcbiAgfTtcblxuICByZXR1cm4gT3ZlcmxheU5vZGVGYWN0b3J5O1xufShOb2RlRmFjdG9yeSkpO1xuXG52YXIgT3JpZW50ZWRDb29yZGluYXRlQXJyYXkgPSBmdW5jdGlvbiBPcmllbnRlZENvb3JkaW5hdGVBcnJheSAoKSB7XG4gIHRoaXMuX3B0cyA9IG51bGw7XG4gIHRoaXMuX29yaWVudGF0aW9uID0gbnVsbDtcbiAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fcHRzID0gcHRzO1xuICB0aGlzLl9vcmllbnRhdGlvbiA9IE9yaWVudGVkQ29vcmRpbmF0ZUFycmF5Lm9yaWVudGF0aW9uKHB0cyk7XG59O1xuT3JpZW50ZWRDb29yZGluYXRlQXJyYXkucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobzEpIHtcbiAgdmFyIG9jYSA9IG8xO1xuICB2YXIgY29tcCA9IE9yaWVudGVkQ29vcmRpbmF0ZUFycmF5LmNvbXBhcmVPcmllbnRlZCh0aGlzLl9wdHMsIHRoaXMuX29yaWVudGF0aW9uLCBvY2EuX3B0cywgb2NhLl9vcmllbnRhdGlvbik7XG4gIHJldHVybiBjb21wXG59O1xuT3JpZW50ZWRDb29yZGluYXRlQXJyYXkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuT3JpZW50ZWRDb29yZGluYXRlQXJyYXkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT3JpZW50ZWRDb29yZGluYXRlQXJyYXlcbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5vcmllbnRhdGlvbiA9IGZ1bmN0aW9uIG9yaWVudGF0aW9uIChwdHMpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheXMuaW5jcmVhc2luZ0RpcmVjdGlvbihwdHMpID09PSAxXG59O1xuT3JpZW50ZWRDb29yZGluYXRlQXJyYXkuY29tcGFyZU9yaWVudGVkID0gZnVuY3Rpb24gY29tcGFyZU9yaWVudGVkIChwdHMxLCBvcmllbnRhdGlvbjEsIHB0czIsIG9yaWVudGF0aW9uMikge1xuICB2YXIgZGlyMSA9IG9yaWVudGF0aW9uMSA/IDEgOiAtMTtcbiAgdmFyIGRpcjIgPSBvcmllbnRhdGlvbjIgPyAxIDogLTE7XG4gIHZhciBsaW1pdDEgPSBvcmllbnRhdGlvbjEgPyBwdHMxLmxlbmd0aCA6IC0xO1xuICB2YXIgbGltaXQyID0gb3JpZW50YXRpb24yID8gcHRzMi5sZW5ndGggOiAtMTtcbiAgdmFyIGkxID0gb3JpZW50YXRpb24xID8gMCA6IHB0czEubGVuZ3RoIC0gMTtcbiAgdmFyIGkyID0gb3JpZW50YXRpb24yID8gMCA6IHB0czIubGVuZ3RoIC0gMTtcbiAgLy8gY29uc3QgY29tcCA9IDBcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgY29tcFB0ID0gcHRzMVtpMV0uY29tcGFyZVRvKHB0czJbaTJdKTtcbiAgICBpZiAoY29tcFB0ICE9PSAwKSB7IHJldHVybiBjb21wUHQgfVxuICAgIGkxICs9IGRpcjE7XG4gICAgaTIgKz0gZGlyMjtcbiAgICB2YXIgZG9uZTEgPSBpMSA9PT0gbGltaXQxO1xuICAgIHZhciBkb25lMiA9IGkyID09PSBsaW1pdDI7XG4gICAgaWYgKGRvbmUxICYmICFkb25lMikgeyByZXR1cm4gLTEgfVxuICAgIGlmICghZG9uZTEgJiYgZG9uZTIpIHsgcmV0dXJuIDEgfVxuICAgIGlmIChkb25lMSAmJiBkb25lMikgeyByZXR1cm4gMCB9XG4gIH1cbn07XG5cbnZhciBFZGdlTGlzdCA9IGZ1bmN0aW9uIEVkZ2VMaXN0ICgpIHtcbiAgdGhpcy5fZWRnZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX29jYU1hcCA9IG5ldyBUcmVlTWFwKCk7XG59O1xuRWRnZUxpc3QucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIG91dC5wcmludCgnTVVMVElMSU5FU1RSSU5HICggJyk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fZWRnZXMuc2l6ZSgpOyBqKyspIHtcbiAgICB2YXIgZSA9IHRoaXMkMS5fZWRnZXMuZ2V0KGopO1xuICAgIGlmIChqID4gMCkgeyBvdXQucHJpbnQoJywnKTsgfVxuICAgIG91dC5wcmludCgnKCcpO1xuICAgIHZhciBwdHMgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkgeyBvdXQucHJpbnQoJywnKTsgfVxuICAgICAgb3V0LnByaW50KHB0c1tpXS54ICsgJyAnICsgcHRzW2ldLnkpO1xuICAgIH1cbiAgICBvdXQucHJpbnRsbignKScpO1xuICB9XG4gIG91dC5wcmludCgnKSAgJyk7XG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIGFkZEFsbCAoZWRnZUNvbGwpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gZWRnZUNvbGwuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdGhpcyQxLmFkZChpLm5leHQoKSk7XG4gIH1cbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuZmluZEVkZ2VJbmRleCA9IGZ1bmN0aW9uIGZpbmRFZGdlSW5kZXggKGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2VkZ2VzLnNpemUoKTsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5fZWRnZXMuZ2V0KGkpLmVxdWFscyhlKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKVxufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uIGdldEVkZ2VzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VzXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaSkge1xuICByZXR1cm4gdGhpcy5fZWRnZXMuZ2V0KGkpXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmZpbmRFcXVhbEVkZ2UgPSBmdW5jdGlvbiBmaW5kRXF1YWxFZGdlIChlKSB7XG4gIHZhciBvY2EgPSBuZXcgT3JpZW50ZWRDb29yZGluYXRlQXJyYXkoZS5nZXRDb29yZGluYXRlcygpKTtcbiAgdmFyIG1hdGNoRWRnZSA9IHRoaXMuX29jYU1hcC5nZXQob2NhKTtcbiAgcmV0dXJuIG1hdGNoRWRnZVxufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGUpIHtcbiAgdGhpcy5fZWRnZXMuYWRkKGUpO1xuICB2YXIgb2NhID0gbmV3IE9yaWVudGVkQ29vcmRpbmF0ZUFycmF5KGUuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gIHRoaXMuX29jYU1hcC5wdXQob2NhLCBlKTtcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VMaXN0XG59O1xuXG52YXIgU2VnbWVudEludGVyc2VjdG9yID0gZnVuY3Rpb24gU2VnbWVudEludGVyc2VjdG9yICgpIHt9O1xuXG5TZWdtZW50SW50ZXJzZWN0b3IucHJvdG90eXBlLnByb2Nlc3NJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gcHJvY2Vzc0ludGVyc2VjdGlvbnMgKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHt9O1xuU2VnbWVudEludGVyc2VjdG9yLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge307XG5TZWdtZW50SW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TZWdtZW50SW50ZXJzZWN0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudEludGVyc2VjdG9yXG59O1xuXG52YXIgSW50ZXJzZWN0aW9uQWRkZXIgPSBmdW5jdGlvbiBJbnRlcnNlY3Rpb25BZGRlciAoKSB7XG4gIHRoaXMuX2hhc0ludGVyc2VjdGlvbiA9IGZhbHNlO1xuICB0aGlzLl9oYXNQcm9wZXIgPSBmYWxzZTtcbiAgdGhpcy5faGFzUHJvcGVySW50ZXJpb3IgPSBmYWxzZTtcbiAgdGhpcy5faGFzSW50ZXJpb3IgPSBmYWxzZTtcbiAgdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQgPSBudWxsO1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbiA9IG51bGw7XG4gIHRoaXMubnVtSW50ZXJzZWN0aW9ucyA9IDA7XG4gIHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zID0gMDtcbiAgdGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zID0gMDtcbiAgdGhpcy5udW1UZXN0cyA9IDA7XG4gIHZhciBsaSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fbGkgPSBsaTtcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaXNUcml2aWFsSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaXNUcml2aWFsSW50ZXJzZWN0aW9uIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7XG4gIGlmIChlMCA9PT0gZTEpIHtcbiAgICBpZiAodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkgPT09IDEpIHtcbiAgICAgIGlmIChJbnRlcnNlY3Rpb25BZGRlci5pc0FkamFjZW50U2VnbWVudHMoc2VnSW5kZXgwLCBzZWdJbmRleDEpKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChlMC5pc0Nsb3NlZCgpKSB7XG4gICAgICAgIHZhciBtYXhTZWdJbmRleCA9IGUwLnNpemUoKSAtIDE7XG4gICAgICAgIGlmICgoc2VnSW5kZXgwID09PSAwICYmIHNlZ0luZGV4MSA9PT0gbWF4U2VnSW5kZXgpIHx8XG4gICAgICAgICAgICAoc2VnSW5kZXgxID09PSAwICYmIHNlZ0luZGV4MCA9PT0gbWF4U2VnSW5kZXgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCAoKSB7XG4gIHJldHVybiB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludFxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlckludGVyaW9yXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmdldExpbmVJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIGdldExpbmVJbnRlcnNlY3RvciAoKSB7XG4gIHJldHVybiB0aGlzLl9saVxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5oYXNQcm9wZXJJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNQcm9wZXJJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzUHJvcGVyXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLnByb2Nlc3NJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gcHJvY2Vzc0ludGVyc2VjdGlvbnMgKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHtcbiAgaWYgKGUwID09PSBlMSAmJiBzZWdJbmRleDAgPT09IHNlZ0luZGV4MSkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMubnVtVGVzdHMrKztcbiAgdmFyIHAwMCA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwXTtcbiAgdmFyIHAwMSA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwICsgMV07XG4gIHZhciBwMTAgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MV07XG4gIHZhciBwMTEgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MSArIDFdO1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwMCwgcDAxLCBwMTAsIHAxMSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIHRoaXMubnVtSW50ZXJzZWN0aW9ucysrO1xuICAgIGlmICh0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkpIHtcbiAgICAgIHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zKys7XG4gICAgICB0aGlzLl9oYXNJbnRlcmlvciA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24oZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkpIHtcbiAgICAgIHRoaXMuX2hhc0ludGVyc2VjdGlvbiA9IHRydWU7XG4gICAgICBlMC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLCBzZWdJbmRleDAsIDApO1xuICAgICAgZTEuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSwgc2VnSW5kZXgxLCAxKTtcbiAgICAgIGlmICh0aGlzLl9saS5pc1Byb3BlcigpKSB7XG4gICAgICAgIHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucysrO1xuICAgICAgICB0aGlzLl9oYXNQcm9wZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmhhc0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb25cbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzSW50ZXJpb3Jcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VnbWVudEludGVyc2VjdG9yXVxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEludGVyc2VjdGlvbkFkZGVyXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIuaXNBZGphY2VudFNlZ21lbnRzID0gZnVuY3Rpb24gaXNBZGphY2VudFNlZ21lbnRzIChpMSwgaTIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGkxIC0gaTIpID09PSAxXG59O1xuXG52YXIgRWRnZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIEVkZ2VJbnRlcnNlY3Rpb24gKCkge1xuICB0aGlzLmNvb3JkID0gbnVsbDtcbiAgdGhpcy5zZWdtZW50SW5kZXggPSBudWxsO1xuICB0aGlzLmRpc3QgPSBudWxsO1xuICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gIHZhciBzZWdtZW50SW5kZXggPSBhcmd1bWVudHNbMV07XG4gIHZhciBkaXN0ID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLmNvb3JkID0gbmV3IENvb3JkaW5hdGUoY29vcmQpO1xuICB0aGlzLnNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleDtcbiAgdGhpcy5kaXN0ID0gZGlzdDtcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5nZXRTZWdtZW50SW5kZXggPSBmdW5jdGlvbiBnZXRTZWdtZW50SW5kZXggKCkge1xuICByZXR1cm4gdGhpcy5zZWdtZW50SW5kZXhcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLmNvb3JkXG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gIG91dC5wcmludCh0aGlzLmNvb3JkKTtcbiAgb3V0LnByaW50KCcgc2VnICMgPSAnICsgdGhpcy5zZWdtZW50SW5kZXgpO1xuICBvdXQucHJpbnRsbignIGRpc3QgPSAnICsgdGhpcy5kaXN0KTtcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG9iaikge1xuICB2YXIgb3RoZXIgPSBvYmo7XG4gIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIuc2VnbWVudEluZGV4LCBvdGhlci5kaXN0KVxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmlzRW5kUG9pbnQgPSBmdW5jdGlvbiBpc0VuZFBvaW50IChtYXhTZWdtZW50SW5kZXgpIHtcbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4ID09PSAwICYmIHRoaXMuZGlzdCA9PT0gMC4wKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4ID09PSBtYXhTZWdtZW50SW5kZXgpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIHRoaXMuY29vcmQgKyAnIHNlZyAjID0gJyArIHRoaXMuc2VnbWVudEluZGV4ICsgJyBkaXN0ID0gJyArIHRoaXMuZGlzdFxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5kaXN0XG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHNlZ21lbnRJbmRleCwgZGlzdCkge1xuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPCBzZWdtZW50SW5kZXgpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4ID4gc2VnbWVudEluZGV4KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuZGlzdCA8IGRpc3QpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuZGlzdCA+IGRpc3QpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlSW50ZXJzZWN0aW9uXG59O1xuXG52YXIgRWRnZUludGVyc2VjdGlvbkxpc3QgPSBmdW5jdGlvbiBFZGdlSW50ZXJzZWN0aW9uTGlzdCAoKSB7XG4gIHRoaXMuX25vZGVNYXAgPSBuZXcgVHJlZU1hcCgpO1xuICB0aGlzLmVkZ2UgPSBudWxsO1xuICB2YXIgZWRnZSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5lZGdlID0gZWRnZTtcbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gIG91dC5wcmludGxuKCdJbnRlcnNlY3Rpb25zOicpO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlaSA9IGl0Lm5leHQoKTtcbiAgICBlaS5wcmludChvdXQpO1xuICB9XG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpXG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmFkZFNwbGl0RWRnZXMgPSBmdW5jdGlvbiBhZGRTcGxpdEVkZ2VzIChlZGdlTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuYWRkRW5kcG9pbnRzKCk7XG4gIHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgdmFyIGVpUHJldiA9IGl0Lm5leHQoKTtcbiAgd2hpbGUgKGl0Lmhhc05leHQoKSkge1xuICAgIHZhciBlaSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbmV3RWRnZSA9IHRoaXMkMS5jcmVhdGVTcGxpdEVkZ2UoZWlQcmV2LCBlaSk7XG4gICAgZWRnZUxpc3QuYWRkKG5ld0VkZ2UpO1xuICAgIGVpUHJldiA9IGVpO1xuICB9XG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmFkZEVuZHBvaW50cyA9IGZ1bmN0aW9uIGFkZEVuZHBvaW50cyAoKSB7XG4gIHZhciBtYXhTZWdJbmRleCA9IHRoaXMuZWRnZS5wdHMubGVuZ3RoIC0gMTtcbiAgdGhpcy5hZGQodGhpcy5lZGdlLnB0c1swXSwgMCwgMC4wKTtcbiAgdGhpcy5hZGQodGhpcy5lZGdlLnB0c1ttYXhTZWdJbmRleF0sIG1heFNlZ0luZGV4LCAwLjApO1xufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5jcmVhdGVTcGxpdEVkZ2UgPSBmdW5jdGlvbiBjcmVhdGVTcGxpdEVkZ2UgKGVpMCwgZWkxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5wdHMgPSBlaTEuc2VnbWVudEluZGV4IC0gZWkwLnNlZ21lbnRJbmRleCArIDI7XG4gIHZhciBsYXN0U2VnU3RhcnRQdCA9IHRoaXMuZWRnZS5wdHNbZWkxLnNlZ21lbnRJbmRleF07XG4gIHZhciB1c2VJbnRQdDEgPSBlaTEuZGlzdCA+IDAuMCB8fCAhZWkxLmNvb3JkLmVxdWFsczJEKGxhc3RTZWdTdGFydFB0KTtcbiAgaWYgKCF1c2VJbnRQdDEpIHtcbiAgICBucHRzLS07XG4gIH1cbiAgdmFyIHB0cyA9IG5ldyBBcnJheShucHRzKS5maWxsKG51bGwpO1xuICB2YXIgaXB0ID0gMDtcbiAgcHRzW2lwdCsrXSA9IG5ldyBDb29yZGluYXRlKGVpMC5jb29yZCk7XG4gIGZvciAodmFyIGkgPSBlaTAuc2VnbWVudEluZGV4ICsgMTsgaSA8PSBlaTEuc2VnbWVudEluZGV4OyBpKyspIHtcbiAgICBwdHNbaXB0KytdID0gdGhpcyQxLmVkZ2UucHRzW2ldO1xuICB9XG4gIGlmICh1c2VJbnRQdDEpIHsgcHRzW2lwdF0gPSBlaTEuY29vcmQ7IH1cbiAgcmV0dXJuIG5ldyBFZGdlKHB0cywgbmV3IExhYmVsKHRoaXMuZWRnZS5fbGFiZWwpKVxufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGludFB0LCBzZWdtZW50SW5kZXgsIGRpc3QpIHtcbiAgdmFyIGVpTmV3ID0gbmV3IEVkZ2VJbnRlcnNlY3Rpb24oaW50UHQsIHNlZ21lbnRJbmRleCwgZGlzdCk7XG4gIHZhciBlaSA9IHRoaXMuX25vZGVNYXAuZ2V0KGVpTmV3KTtcbiAgaWYgKGVpICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVpXG4gIH1cbiAgdGhpcy5fbm9kZU1hcC5wdXQoZWlOZXcsIGVpTmV3KTtcbiAgcmV0dXJuIGVpTmV3XG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaXNJbnRlcnNlY3Rpb24gKHB0KSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIGlmIChlaS5jb29yZC5lcXVhbHMocHQpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VJbnRlcnNlY3Rpb25MaXN0XG59O1xuXG52YXIgTW9ub3RvbmVDaGFpbkluZGV4ZXIgPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluSW5kZXhlciAoKSB7fTtcblxuTW9ub3RvbmVDaGFpbkluZGV4ZXIucHJvdG90eXBlLmdldENoYWluU3RhcnRJbmRpY2VzID0gZnVuY3Rpb24gZ2V0Q2hhaW5TdGFydEluZGljZXMgKHB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBzdGFydEluZGV4TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgc3RhcnRJbmRleExpc3QuYWRkKG5ldyBJbnRlZ2VyKHN0YXJ0KSk7XG4gIGRvIHtcbiAgICB2YXIgbGFzdCA9IHRoaXMkMS5maW5kQ2hhaW5FbmQocHRzLCBzdGFydCk7XG4gICAgc3RhcnRJbmRleExpc3QuYWRkKG5ldyBJbnRlZ2VyKGxhc3QpKTtcbiAgICBzdGFydCA9IGxhc3Q7XG4gIH0gd2hpbGUgKHN0YXJ0IDwgcHRzLmxlbmd0aCAtIDEpXG4gIHZhciBzdGFydEluZGV4ID0gTW9ub3RvbmVDaGFpbkluZGV4ZXIudG9JbnRBcnJheShzdGFydEluZGV4TGlzdCk7XG4gIHJldHVybiBzdGFydEluZGV4XG59O1xuTW9ub3RvbmVDaGFpbkluZGV4ZXIucHJvdG90eXBlLmZpbmRDaGFpbkVuZCA9IGZ1bmN0aW9uIGZpbmRDaGFpbkVuZCAocHRzLCBzdGFydCkge1xuICB2YXIgY2hhaW5RdWFkID0gUXVhZHJhbnQucXVhZHJhbnQocHRzW3N0YXJ0XSwgcHRzW3N0YXJ0ICsgMV0pO1xuICB2YXIgbGFzdCA9IHN0YXJ0ICsgMTtcbiAgd2hpbGUgKGxhc3QgPCBwdHMubGVuZ3RoKSB7XG4gICAgdmFyIHF1YWQgPSBRdWFkcmFudC5xdWFkcmFudChwdHNbbGFzdCAtIDFdLCBwdHNbbGFzdF0pO1xuICAgIGlmIChxdWFkICE9PSBjaGFpblF1YWQpIHsgYnJlYWsgfVxuICAgIGxhc3QrKztcbiAgfVxuICByZXR1cm4gbGFzdCAtIDFcbn07XG5Nb25vdG9uZUNoYWluSW5kZXhlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW5JbmRleGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm90b25lQ2hhaW5JbmRleGVyXG59O1xuTW9ub3RvbmVDaGFpbkluZGV4ZXIudG9JbnRBcnJheSA9IGZ1bmN0aW9uIHRvSW50QXJyYXkgKGxpc3QpIHtcbiAgdmFyIGFycmF5ID0gbmV3IEFycmF5KGxpc3Quc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBsaXN0LmdldChpKS5pbnRWYWx1ZSgpO1xuICB9XG4gIHJldHVybiBhcnJheVxufTtcblxudmFyIE1vbm90b25lQ2hhaW5FZGdlID0gZnVuY3Rpb24gTW9ub3RvbmVDaGFpbkVkZ2UgKCkge1xuICB0aGlzLmUgPSBudWxsO1xuICB0aGlzLnB0cyA9IG51bGw7XG4gIHRoaXMuc3RhcnRJbmRleCA9IG51bGw7XG4gIHRoaXMuZW52MSA9IG5ldyBFbnZlbG9wZSgpO1xuICB0aGlzLmVudjIgPSBuZXcgRW52ZWxvcGUoKTtcbiAgdmFyIGUgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuZSA9IGU7XG4gIHRoaXMucHRzID0gZS5nZXRDb29yZGluYXRlcygpO1xuICB2YXIgbWNiID0gbmV3IE1vbm90b25lQ2hhaW5JbmRleGVyKCk7XG4gIHRoaXMuc3RhcnRJbmRleCA9IG1jYi5nZXRDaGFpblN0YXJ0SW5kaWNlcyh0aGlzLnB0cyk7XG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5wdHNcbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuZ2V0TWF4WCA9IGZ1bmN0aW9uIGdldE1heFggKGNoYWluSW5kZXgpIHtcbiAgdmFyIHgxID0gdGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W2NoYWluSW5kZXhdXS54O1xuICB2YXIgeDIgPSB0aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbY2hhaW5JbmRleCArIDFdXS54O1xuICByZXR1cm4geDEgPiB4MiA/IHgxIDogeDJcbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuZ2V0TWluWCA9IGZ1bmN0aW9uIGdldE1pblggKGNoYWluSW5kZXgpIHtcbiAgdmFyIHgxID0gdGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W2NoYWluSW5kZXhdXS54O1xuICB2YXIgeDIgPSB0aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbY2hhaW5JbmRleCArIDFdXS54O1xuICByZXR1cm4geDEgPCB4MiA/IHgxIDogeDJcbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbiA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBjaGFpbkluZGV4MCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbWNlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBjaGFpbkluZGV4MSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgc2kgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuc3RhcnRJbmRleFtjaGFpbkluZGV4MF0sIHRoaXMuc3RhcnRJbmRleFtjaGFpbkluZGV4MCArIDFdLCBtY2UsIG1jZS5zdGFydEluZGV4W2NoYWluSW5kZXgxXSwgbWNlLnN0YXJ0SW5kZXhbY2hhaW5JbmRleDEgKyAxXSwgc2kpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDYpIHtcbiAgICB2YXIgc3RhcnQwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBlbmQwID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtY2UkMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgc3RhcnQxID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBlbmQxID0gYXJndW1lbnRzWzRdO1xuICAgIHZhciBlaSA9IGFyZ3VtZW50c1s1XTtcbiAgICB2YXIgcDAwID0gdGhpcy5wdHNbc3RhcnQwXTtcbiAgICB2YXIgcDAxID0gdGhpcy5wdHNbZW5kMF07XG4gICAgdmFyIHAxMCA9IG1jZSQxLnB0c1tzdGFydDFdO1xuICAgIHZhciBwMTEgPSBtY2UkMS5wdHNbZW5kMV07XG4gICAgaWYgKGVuZDAgLSBzdGFydDAgPT09IDEgJiYgZW5kMSAtIHN0YXJ0MSA9PT0gMSkge1xuICAgICAgZWkuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmUsIHN0YXJ0MCwgbWNlJDEuZSwgc3RhcnQxKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHRoaXMuZW52MS5pbml0KHAwMCwgcDAxKTtcbiAgICB0aGlzLmVudjIuaW5pdChwMTAsIHAxMSk7XG4gICAgaWYgKCF0aGlzLmVudjEuaW50ZXJzZWN0cyh0aGlzLmVudjIpKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgbWlkMCA9IE1hdGgudHJ1bmMoKHN0YXJ0MCArIGVuZDApIC8gMik7XG4gICAgdmFyIG1pZDEgPSBNYXRoLnRydW5jKChzdGFydDEgKyBlbmQxKSAvIDIpO1xuICAgIGlmIChzdGFydDAgPCBtaWQwKSB7XG4gICAgICBpZiAoc3RhcnQxIDwgbWlkMSkgeyB0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oc3RhcnQwLCBtaWQwLCBtY2UkMSwgc3RhcnQxLCBtaWQxLCBlaSk7IH1cbiAgICAgIGlmIChtaWQxIDwgZW5kMSkgeyB0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oc3RhcnQwLCBtaWQwLCBtY2UkMSwgbWlkMSwgZW5kMSwgZWkpOyB9XG4gICAgfVxuICAgIGlmIChtaWQwIDwgZW5kMCkge1xuICAgICAgaWYgKHN0YXJ0MSA8IG1pZDEpIHsgdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG1pZDAsIGVuZDAsIG1jZSQxLCBzdGFydDEsIG1pZDEsIGVpKTsgfVxuICAgICAgaWYgKG1pZDEgPCBlbmQxKSB7IHRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihtaWQwLCBlbmQwLCBtY2UkMSwgbWlkMSwgZW5kMSwgZWkpOyB9XG4gICAgfVxuICB9XG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmdldFN0YXJ0SW5kZXhlcyA9IGZ1bmN0aW9uIGdldFN0YXJ0SW5kZXhlcyAoKSB7XG4gIHJldHVybiB0aGlzLnN0YXJ0SW5kZXhcbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdHMgPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0cyAobWNlLCBzaSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdGFydEluZGV4Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWNlLnN0YXJ0SW5kZXgubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICB0aGlzJDEuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihpLCBtY2UsIGosIHNpKTtcbiAgICB9XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm90b25lQ2hhaW5FZGdlXG59O1xuXG52YXIgRGVwdGggPSBmdW5jdGlvbiBEZXB0aCAoKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX2RlcHRoID0gQXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJheSgzKTsgfSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgIHRoaXMkMS5fZGVwdGhbaV1bal0gPSBEZXB0aC5OVUxMX1ZBTFVFO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzMSA9IHsgTlVMTF9WQUxVRTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuRGVwdGgucHJvdG90eXBlLmdldERlcHRoID0gZnVuY3Rpb24gZ2V0RGVwdGggKGdlb21JbmRleCwgcG9zSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2RlcHRoW2dlb21JbmRleF1bcG9zSW5kZXhdXG59O1xuRGVwdGgucHJvdG90eXBlLnNldERlcHRoID0gZnVuY3Rpb24gc2V0RGVwdGggKGdlb21JbmRleCwgcG9zSW5kZXgsIGRlcHRoVmFsdWUpIHtcbiAgdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtwb3NJbmRleF0gPSBkZXB0aFZhbHVlO1xufTtcbkRlcHRoLnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbiBpc051bGwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIGlmICh0aGlzJDEuX2RlcHRoW2ldW2pdICE9PSBEZXB0aC5OVUxMX1ZBTFVFKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoW2dlb21JbmRleF1bMV0gPT09IERlcHRoLk5VTExfVkFMVUVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb21JbmRleCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwb3NJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICByZXR1cm4gdGhpcy5fZGVwdGhbZ2VvbUluZGV4JDFdW3Bvc0luZGV4XSA9PT0gRGVwdGguTlVMTF9WQUxVRVxuICB9XG59O1xuRGVwdGgucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICBpZiAoIXRoaXMkMS5pc051bGwoaSkpIHtcbiAgICAgIHZhciBtaW5EZXB0aCA9IHRoaXMkMS5fZGVwdGhbaV1bMV07XG4gICAgICBpZiAodGhpcyQxLl9kZXB0aFtpXVsyXSA8IG1pbkRlcHRoKSB7IG1pbkRlcHRoID0gdGhpcyQxLl9kZXB0aFtpXVsyXTsgfVxuICAgICAgaWYgKG1pbkRlcHRoIDwgMCkgeyBtaW5EZXB0aCA9IDA7IH1cbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IDA7XG4gICAgICAgIGlmICh0aGlzJDEuX2RlcHRoW2ldW2pdID4gbWluRGVwdGgpIHsgbmV3VmFsdWUgPSAxOyB9XG4gICAgICAgIHRoaXMkMS5fZGVwdGhbaV1bal0gPSBuZXdWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5EZXB0aC5wcm90b3R5cGUuZ2V0RGVsdGEgPSBmdW5jdGlvbiBnZXREZWx0YSAoZ2VvbUluZGV4KSB7XG4gIHJldHVybiB0aGlzLl9kZXB0aFtnZW9tSW5kZXhdW1Bvc2l0aW9uLlJJR0hUXSAtIHRoaXMuX2RlcHRoW2dlb21JbmRleF1bUG9zaXRpb24uTEVGVF1cbn07XG5EZXB0aC5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoZ2VvbUluZGV4LCBwb3NJbmRleCkge1xuICBpZiAodGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtwb3NJbmRleF0gPD0gMCkgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICByZXR1cm4gTG9jYXRpb24uSU5URVJJT1Jcbn07XG5EZXB0aC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiAnQTogJyArIHRoaXMuX2RlcHRoWzBdWzFdICsgJywnICsgdGhpcy5fZGVwdGhbMF1bMl0gKyAnIEI6ICcgKyB0aGlzLl9kZXB0aFsxXVsxXSArICcsJyArIHRoaXMuX2RlcHRoWzFdWzJdXG59O1xuRGVwdGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGJsID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IDM7IGorKykge1xuICAgICAgICB2YXIgbG9jID0gbGJsLmdldExvY2F0aW9uKGksIGopO1xuICAgICAgICBpZiAobG9jID09PSBMb2NhdGlvbi5FWFRFUklPUiB8fCBsb2MgPT09IExvY2F0aW9uLklOVEVSSU9SKSB7XG4gICAgICAgICAgaWYgKHRoaXMkMS5pc051bGwoaSwgaikpIHtcbiAgICAgICAgICAgIHRoaXMkMS5fZGVwdGhbaV1bal0gPSBEZXB0aC5kZXB0aEF0TG9jYXRpb24obG9jKTtcbiAgICAgICAgICB9IGVsc2UgeyB0aGlzJDEuX2RlcHRoW2ldW2pdICs9IERlcHRoLmRlcHRoQXRMb2NhdGlvbihsb2MpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBvc0luZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAobG9jYXRpb24gPT09IExvY2F0aW9uLklOVEVSSU9SKSB7IHRoaXMuX2RlcHRoW2dlb21JbmRleF1bcG9zSW5kZXhdKys7IH1cbiAgfVxufTtcbkRlcHRoLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRGVwdGgucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGVwdGhcbn07XG5EZXB0aC5kZXB0aEF0TG9jYXRpb24gPSBmdW5jdGlvbiBkZXB0aEF0TG9jYXRpb24gKGxvY2F0aW9uKSB7XG4gIGlmIChsb2NhdGlvbiA9PT0gTG9jYXRpb24uRVhURVJJT1IpIHsgcmV0dXJuIDAgfVxuICBpZiAobG9jYXRpb24gPT09IExvY2F0aW9uLklOVEVSSU9SKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIERlcHRoLk5VTExfVkFMVUVcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzEuTlVMTF9WQUxVRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRGVwdGgsIHN0YXRpY0FjY2Vzc29ycyQzMSApO1xuXG52YXIgRWRnZSA9IChmdW5jdGlvbiAoR3JhcGhDb21wb25lbnQkJDEpIHtcbiAgZnVuY3Rpb24gRWRnZSAoKSB7XG4gICAgR3JhcGhDb21wb25lbnQkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnB0cyA9IG51bGw7XG4gICAgdGhpcy5fZW52ID0gbnVsbDtcbiAgICB0aGlzLmVpTGlzdCA9IG5ldyBFZGdlSW50ZXJzZWN0aW9uTGlzdCh0aGlzKTtcbiAgICB0aGlzLl9uYW1lID0gbnVsbDtcbiAgICB0aGlzLl9tY2UgPSBudWxsO1xuICAgIHRoaXMuX2lzSXNvbGF0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2RlcHRoID0gbmV3IERlcHRoKCk7XG4gICAgdGhpcy5fZGVwdGhEZWx0YSA9IDA7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICBFZGdlLmNhbGwodGhpcywgcHRzLCBudWxsKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBwdHMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsYWJlbCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMucHRzID0gcHRzJDE7XG4gICAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICAgIH1cbiAgfVxuXG4gIGlmICggR3JhcGhDb21wb25lbnQkJDEgKSBFZGdlLl9fcHJvdG9fXyA9IEdyYXBoQ29tcG9uZW50JCQxO1xuICBFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdyYXBoQ29tcG9uZW50JCQxICYmIEdyYXBoQ29tcG9uZW50JCQxLnByb3RvdHlwZSApO1xuICBFZGdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVkZ2U7XG4gIEVkZ2UucHJvdG90eXBlLmdldERlcHRoID0gZnVuY3Rpb24gZ2V0RGVwdGggKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXB0aFxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRDb2xsYXBzZWRFZGdlID0gZnVuY3Rpb24gZ2V0Q29sbGFwc2VkRWRnZSAoKSB7XG4gICAgdmFyIG5ld1B0cyA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICAgIG5ld1B0c1swXSA9IHRoaXMucHRzWzBdO1xuICAgIG5ld1B0c1sxXSA9IHRoaXMucHRzWzFdO1xuICAgIHZhciBuZXdlID0gbmV3IEVkZ2UobmV3UHRzLCBMYWJlbC50b0xpbmVMYWJlbCh0aGlzLl9sYWJlbCkpO1xuICAgIHJldHVybiBuZXdlXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmlzSXNvbGF0ZWQgPSBmdW5jdGlvbiBpc0lzb2xhdGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNJc29sYXRlZFxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdHNcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuc2V0SXNvbGF0ZWQgPSBmdW5jdGlvbiBzZXRJc29sYXRlZCAoaXNJc29sYXRlZCkge1xuICAgIHRoaXMuX2lzSXNvbGF0ZWQgPSBpc0lzb2xhdGVkO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24gc2V0TmFtZSAobmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICghKG8gaW5zdGFuY2VvZiBFZGdlKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBlID0gbztcbiAgICBpZiAodGhpcy5wdHMubGVuZ3RoICE9PSBlLnB0cy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgaXNFcXVhbEZvcndhcmQgPSB0cnVlO1xuICAgIHZhciBpc0VxdWFsUmV2ZXJzZSA9IHRydWU7XG4gICAgdmFyIGlSZXYgPSB0aGlzLnB0cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzJDEucHRzW2ldLmVxdWFsczJEKGUucHRzW2ldKSkge1xuICAgICAgICBpc0VxdWFsRm9yd2FyZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzJDEucHRzW2ldLmVxdWFsczJEKGUucHRzWy0taVJldl0pKSB7XG4gICAgICAgIGlzRXF1YWxSZXZlcnNlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRXF1YWxGb3J3YXJkICYmICFpc0VxdWFsUmV2ZXJzZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnB0cy5sZW5ndGggPiAwKSB7IHJldHVybiB0aGlzLnB0c1swXSB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGkgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5wdHNbaV1cbiAgICB9XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgb3V0LnByaW50KCdlZGdlICcgKyB0aGlzLl9uYW1lICsgJzogJyk7XG4gICAgb3V0LnByaW50KCdMSU5FU1RSSU5HICgnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHsgb3V0LnByaW50KCcsJyk7IH1cbiAgICAgIG91dC5wcmludCh0aGlzJDEucHRzW2ldLnggKyAnICcgKyB0aGlzJDEucHRzW2ldLnkpO1xuICAgIH1cbiAgICBvdXQucHJpbnQoJykgICcgKyB0aGlzLl9sYWJlbCArICcgJyArIHRoaXMuX2RlcHRoRGVsdGEpO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5jb21wdXRlSU0gPSBmdW5jdGlvbiBjb21wdXRlSU0gKGltKSB7XG4gICAgRWRnZS51cGRhdGVJTSh0aGlzLl9sYWJlbCwgaW0pO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5pc0NvbGxhcHNlZCA9IGZ1bmN0aW9uIGlzQ29sbGFwc2VkICgpIHtcbiAgICBpZiAoIXRoaXMuX2xhYmVsLmlzQXJlYSgpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRoaXMucHRzLmxlbmd0aCAhPT0gMykgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbMl0pKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGggLSAxXSlcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0TWF4aW11bVNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uIGdldE1heGltdW1TZWdtZW50SW5kZXggKCkge1xuICAgIHJldHVybiB0aGlzLnB0cy5sZW5ndGggLSAxXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldERlcHRoRGVsdGEgPSBmdW5jdGlvbiBnZXREZXB0aERlbHRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVwdGhEZWx0YVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXROdW1Qb2ludHMgPSBmdW5jdGlvbiBnZXROdW1Qb2ludHMgKCkge1xuICAgIHJldHVybiB0aGlzLnB0cy5sZW5ndGhcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUucHJpbnRSZXZlcnNlID0gZnVuY3Rpb24gcHJpbnRSZXZlcnNlIChvdXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIG91dC5wcmludCgnZWRnZSAnICsgdGhpcy5fbmFtZSArICc6ICcpO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnB0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgb3V0LnByaW50KHRoaXMkMS5wdHNbaV0gKyAnICcpO1xuICAgIH1cbiAgICBvdXQucHJpbnRsbignJyk7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldE1vbm90b25lQ2hhaW5FZGdlID0gZnVuY3Rpb24gZ2V0TW9ub3RvbmVDaGFpbkVkZ2UgKCkge1xuICAgIGlmICh0aGlzLl9tY2UgPT09IG51bGwpIHsgdGhpcy5fbWNlID0gbmV3IE1vbm90b25lQ2hhaW5FZGdlKHRoaXMpOyB9XG4gICAgcmV0dXJuIHRoaXMuX21jZVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRFbnZlbG9wZSA9IGZ1bmN0aW9uIGdldEVudmVsb3BlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9lbnYgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2VudiA9IG5ldyBFbnZlbG9wZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzJDEuX2Vudi5leHBhbmRUb0luY2x1ZGUodGhpcyQxLnB0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbnZcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gYWRkSW50ZXJzZWN0aW9uIChsaSwgc2VnbWVudEluZGV4LCBnZW9tSW5kZXgsIGludEluZGV4KSB7XG4gICAgdmFyIGludFB0ID0gbmV3IENvb3JkaW5hdGUobGkuZ2V0SW50ZXJzZWN0aW9uKGludEluZGV4KSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXg7XG4gICAgdmFyIGRpc3QgPSBsaS5nZXRFZGdlRGlzdGFuY2UoZ2VvbUluZGV4LCBpbnRJbmRleCk7XG4gICAgdmFyIG5leHRTZWdJbmRleCA9IG5vcm1hbGl6ZWRTZWdtZW50SW5kZXggKyAxO1xuICAgIGlmIChuZXh0U2VnSW5kZXggPCB0aGlzLnB0cy5sZW5ndGgpIHtcbiAgICAgIHZhciBuZXh0UHQgPSB0aGlzLnB0c1tuZXh0U2VnSW5kZXhdO1xuICAgICAgaWYgKGludFB0LmVxdWFsczJEKG5leHRQdCkpIHtcbiAgICAgICAgbm9ybWFsaXplZFNlZ21lbnRJbmRleCA9IG5leHRTZWdJbmRleDtcbiAgICAgICAgZGlzdCA9IDAuMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5laUxpc3QuYWRkKGludFB0LCBub3JtYWxpemVkU2VnbWVudEluZGV4LCBkaXN0KTtcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICAgIGJ1Zi5hcHBlbmQoJ2VkZ2UgJyArIHRoaXMuX25hbWUgKyAnOiAnKTtcbiAgICBidWYuYXBwZW5kKCdMSU5FU1RSSU5HICgnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHsgYnVmLmFwcGVuZCgnLCcpOyB9XG4gICAgICBidWYuYXBwZW5kKHRoaXMkMS5wdHNbaV0ueCArICcgJyArIHRoaXMkMS5wdHNbaV0ueSk7XG4gICAgfVxuICAgIGJ1Zi5hcHBlbmQoJykgICcgKyB0aGlzLl9sYWJlbCArICcgJyArIHRoaXMuX2RlcHRoRGVsdGEpO1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoKVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5pc1BvaW50d2lzZUVxdWFsID0gZnVuY3Rpb24gaXNQb2ludHdpc2VFcXVhbCAoZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucHRzLmxlbmd0aCAhPT0gZS5wdHMubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzJDEucHRzW2ldLmVxdWFsczJEKGUucHRzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuc2V0RGVwdGhEZWx0YSA9IGZ1bmN0aW9uIHNldERlcHRoRGVsdGEgKGRlcHRoRGVsdGEpIHtcbiAgICB0aGlzLl9kZXB0aERlbHRhID0gZGVwdGhEZWx0YTtcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QgPSBmdW5jdGlvbiBnZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWlMaXN0XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmFkZEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb25zIChsaSwgc2VnbWVudEluZGV4LCBnZW9tSW5kZXgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7IGkrKykge1xuICAgICAgdGhpcyQxLmFkZEludGVyc2VjdGlvbihsaSwgc2VnbWVudEluZGV4LCBnZW9tSW5kZXgsIGkpO1xuICAgIH1cbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBFZGdlXG4gIH07XG4gIEVkZ2UudXBkYXRlSU0gPSBmdW5jdGlvbiB1cGRhdGVJTSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBsYWJlbCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBpbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGltLnNldEF0TGVhc3RJZlZhbGlkKGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLk9OKSwgbGFiZWwuZ2V0TG9jYXRpb24oMSwgUG9zaXRpb24uT04pLCAxKTtcbiAgICAgIGlmIChsYWJlbC5pc0FyZWEoKSkge1xuICAgICAgICBpbS5zZXRBdExlYXN0SWZWYWxpZChsYWJlbC5nZXRMb2NhdGlvbigwLCBQb3NpdGlvbi5MRUZUKSwgbGFiZWwuZ2V0TG9jYXRpb24oMSwgUG9zaXRpb24uTEVGVCksIDIpO1xuICAgICAgICBpbS5zZXRBdExlYXN0SWZWYWxpZChsYWJlbC5nZXRMb2NhdGlvbigwLCBQb3NpdGlvbi5SSUdIVCksIGxhYmVsLmdldExvY2F0aW9uKDEsIFBvc2l0aW9uLlJJR0hUKSwgMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgcmV0dXJuIEdyYXBoQ29tcG9uZW50JCQxLnByb3RvdHlwZS51cGRhdGVJTS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcblxuICByZXR1cm4gRWRnZTtcbn0oR3JhcGhDb21wb25lbnQpKTtcblxudmFyIEJ1ZmZlckJ1aWxkZXIgPSBmdW5jdGlvbiBCdWZmZXJCdWlsZGVyIChidWZQYXJhbXMpIHtcbiAgdGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsID0gbnVsbDtcbiAgdGhpcy5fd29ya2luZ05vZGVyID0gbnVsbDtcbiAgdGhpcy5fZ2VvbUZhY3QgPSBudWxsO1xuICB0aGlzLl9ncmFwaCA9IG51bGw7XG4gIHRoaXMuX2VkZ2VMaXN0ID0gbmV3IEVkZ2VMaXN0KCk7XG4gIHRoaXMuX2J1ZlBhcmFtcyA9IGJ1ZlBhcmFtcyB8fCBudWxsO1xufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLnNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCA9IGZ1bmN0aW9uIHNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCAocG0pIHtcbiAgdGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsID0gcG07XG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuaW5zZXJ0VW5pcXVlRWRnZSA9IGZ1bmN0aW9uIGluc2VydFVuaXF1ZUVkZ2UgKGUpIHtcbiAgdmFyIGV4aXN0aW5nRWRnZSA9IHRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UoZSk7XG4gIGlmIChleGlzdGluZ0VkZ2UgIT09IG51bGwpIHtcbiAgICB2YXIgZXhpc3RpbmdMYWJlbCA9IGV4aXN0aW5nRWRnZS5nZXRMYWJlbCgpO1xuICAgIHZhciBsYWJlbFRvTWVyZ2UgPSBlLmdldExhYmVsKCk7XG4gICAgaWYgKCFleGlzdGluZ0VkZ2UuaXNQb2ludHdpc2VFcXVhbChlKSkge1xuICAgICAgbGFiZWxUb01lcmdlID0gbmV3IExhYmVsKGUuZ2V0TGFiZWwoKSk7XG4gICAgICBsYWJlbFRvTWVyZ2UuZmxpcCgpO1xuICAgIH1cbiAgICBleGlzdGluZ0xhYmVsLm1lcmdlKGxhYmVsVG9NZXJnZSk7XG4gICAgdmFyIG1lcmdlRGVsdGEgPSBCdWZmZXJCdWlsZGVyLmRlcHRoRGVsdGEobGFiZWxUb01lcmdlKTtcbiAgICB2YXIgZXhpc3RpbmdEZWx0YSA9IGV4aXN0aW5nRWRnZS5nZXREZXB0aERlbHRhKCk7XG4gICAgdmFyIG5ld0RlbHRhID0gZXhpc3RpbmdEZWx0YSArIG1lcmdlRGVsdGE7XG4gICAgZXhpc3RpbmdFZGdlLnNldERlcHRoRGVsdGEobmV3RGVsdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2VkZ2VMaXN0LmFkZChlKTtcbiAgICBlLnNldERlcHRoRGVsdGEoQnVmZmVyQnVpbGRlci5kZXB0aERlbHRhKGUuZ2V0TGFiZWwoKSkpO1xuICB9XG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuYnVpbGRTdWJncmFwaHMgPSBmdW5jdGlvbiBidWlsZFN1YmdyYXBocyAoc3ViZ3JhcGhMaXN0LCBwb2x5QnVpbGRlcikge1xuICB2YXIgcHJvY2Vzc2VkR3JhcGhzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gc3ViZ3JhcGhMaXN0Lml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBzdWJncmFwaCA9IGkubmV4dCgpO1xuICAgIHZhciBwID0gc3ViZ3JhcGguZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSgpO1xuICAgIHZhciBsb2NhdGVyID0gbmV3IFN1YmdyYXBoRGVwdGhMb2NhdGVyKHByb2Nlc3NlZEdyYXBocyk7XG4gICAgdmFyIG91dHNpZGVEZXB0aCA9IGxvY2F0ZXIuZ2V0RGVwdGgocCk7XG4gICAgc3ViZ3JhcGguY29tcHV0ZURlcHRoKG91dHNpZGVEZXB0aCk7XG4gICAgc3ViZ3JhcGguZmluZFJlc3VsdEVkZ2VzKCk7XG4gICAgcHJvY2Vzc2VkR3JhcGhzLmFkZChzdWJncmFwaCk7XG4gICAgcG9seUJ1aWxkZXIuYWRkKHN1YmdyYXBoLmdldERpcmVjdGVkRWRnZXMoKSwgc3ViZ3JhcGguZ2V0Tm9kZXMoKSk7XG4gIH1cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVTdWJncmFwaHMgPSBmdW5jdGlvbiBjcmVhdGVTdWJncmFwaHMgKGdyYXBoKSB7XG4gIHZhciBzdWJncmFwaExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSBncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBub2RlID0gaS5uZXh0KCk7XG4gICAgaWYgKCFub2RlLmlzVmlzaXRlZCgpKSB7XG4gICAgICB2YXIgc3ViZ3JhcGggPSBuZXcgQnVmZmVyU3ViZ3JhcGgoKTtcbiAgICAgIHN1YmdyYXBoLmNyZWF0ZShub2RlKTtcbiAgICAgIHN1YmdyYXBoTGlzdC5hZGQoc3ViZ3JhcGgpO1xuICAgIH1cbiAgfVxuICBDb2xsZWN0aW9ucy5zb3J0KHN1YmdyYXBoTGlzdCwgQ29sbGVjdGlvbnMucmV2ZXJzZU9yZGVyKCkpO1xuICByZXR1cm4gc3ViZ3JhcGhMaXN0XG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSA9IGZ1bmN0aW9uIGNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkgKCkge1xuICB2YXIgZW1wdHlHZW9tID0gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9seWdvbigpO1xuICByZXR1cm4gZW1wdHlHZW9tXG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuZ2V0Tm9kZXIgPSBmdW5jdGlvbiBnZXROb2RlciAocHJlY2lzaW9uTW9kZWwpIHtcbiAgaWYgKHRoaXMuX3dvcmtpbmdOb2RlciAhPT0gbnVsbCkgeyByZXR1cm4gdGhpcy5fd29ya2luZ05vZGVyIH1cbiAgdmFyIG5vZGVyID0gbmV3IE1DSW5kZXhOb2RlcigpO1xuICB2YXIgbGkgPSBuZXcgUm9idXN0TGluZUludGVyc2VjdG9yKCk7XG4gIGxpLnNldFByZWNpc2lvbk1vZGVsKHByZWNpc2lvbk1vZGVsKTtcbiAgbm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKG5ldyBJbnRlcnNlY3Rpb25BZGRlcihsaSkpO1xuICByZXR1cm4gbm9kZXJcbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5idWZmZXIgPSBmdW5jdGlvbiBidWZmZXIgKGcsIGRpc3RhbmNlKSB7XG4gIHZhciBwcmVjaXNpb25Nb2RlbCA9IHRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbDtcbiAgaWYgKHByZWNpc2lvbk1vZGVsID09PSBudWxsKSB7IHByZWNpc2lvbk1vZGVsID0gZy5nZXRQcmVjaXNpb25Nb2RlbCgpOyB9XG4gIHRoaXMuX2dlb21GYWN0ID0gZy5nZXRGYWN0b3J5KCk7XG4gIHZhciBjdXJ2ZUJ1aWxkZXIgPSBuZXcgT2Zmc2V0Q3VydmVCdWlsZGVyKHByZWNpc2lvbk1vZGVsLCB0aGlzLl9idWZQYXJhbXMpO1xuICB2YXIgY3VydmVTZXRCdWlsZGVyID0gbmV3IE9mZnNldEN1cnZlU2V0QnVpbGRlcihnLCBkaXN0YW5jZSwgY3VydmVCdWlsZGVyKTtcbiAgdmFyIGJ1ZmZlclNlZ1N0ckxpc3QgPSBjdXJ2ZVNldEJ1aWxkZXIuZ2V0Q3VydmVzKCk7XG4gIGlmIChidWZmZXJTZWdTdHJMaXN0LnNpemUoKSA8PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpXG4gIH1cbiAgdGhpcy5jb21wdXRlTm9kZWRFZGdlcyhidWZmZXJTZWdTdHJMaXN0LCBwcmVjaXNpb25Nb2RlbCk7XG4gIHRoaXMuX2dyYXBoID0gbmV3IFBsYW5hckdyYXBoKG5ldyBPdmVybGF5Tm9kZUZhY3RvcnkoKSk7XG4gIHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpO1xuICB2YXIgc3ViZ3JhcGhMaXN0ID0gdGhpcy5jcmVhdGVTdWJncmFwaHModGhpcy5fZ3JhcGgpO1xuICB2YXIgcG9seUJ1aWxkZXIgPSBuZXcgUG9seWdvbkJ1aWxkZXIodGhpcy5fZ2VvbUZhY3QpO1xuICB0aGlzLmJ1aWxkU3ViZ3JhcGhzKHN1YmdyYXBoTGlzdCwgcG9seUJ1aWxkZXIpO1xuICB2YXIgcmVzdWx0UG9seUxpc3QgPSBwb2x5QnVpbGRlci5nZXRQb2x5Z29ucygpO1xuICBpZiAocmVzdWx0UG9seUxpc3Quc2l6ZSgpIDw9IDApIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KClcbiAgfVxuICB2YXIgcmVzdWx0R2VvbSA9IHRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkocmVzdWx0UG9seUxpc3QpO1xuICByZXR1cm4gcmVzdWx0R2VvbVxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmNvbXB1dGVOb2RlZEVkZ2VzID0gZnVuY3Rpb24gY29tcHV0ZU5vZGVkRWRnZXMgKGJ1ZmZlclNlZ1N0ckxpc3QsIHByZWNpc2lvbk1vZGVsKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGVyID0gdGhpcy5nZXROb2RlcihwcmVjaXNpb25Nb2RlbCk7XG4gIG5vZGVyLmNvbXB1dGVOb2RlcyhidWZmZXJTZWdTdHJMaXN0KTtcbiAgdmFyIG5vZGVkU2VnU3RyaW5ncyA9IG5vZGVyLmdldE5vZGVkU3Vic3RyaW5ncygpO1xuICBmb3IgKHZhciBpID0gbm9kZWRTZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBzZWdTdHIgPSBpLm5leHQoKTtcbiAgICB2YXIgcHRzID0gc2VnU3RyLmdldENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKHB0cy5sZW5ndGggPT09IDIgJiYgcHRzWzBdLmVxdWFsczJEKHB0c1sxXSkpIHsgY29udGludWUgfVxuICAgIHZhciBvbGRMYWJlbCA9IHNlZ1N0ci5nZXREYXRhKCk7XG4gICAgdmFyIGVkZ2UgPSBuZXcgRWRnZShzZWdTdHIuZ2V0Q29vcmRpbmF0ZXMoKSwgbmV3IExhYmVsKG9sZExhYmVsKSk7XG4gICAgdGhpcyQxLmluc2VydFVuaXF1ZUVkZ2UoZWRnZSk7XG4gIH1cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5zZXROb2RlciA9IGZ1bmN0aW9uIHNldE5vZGVyIChub2Rlcikge1xuICB0aGlzLl93b3JraW5nTm9kZXIgPSBub2Rlcjtcbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJCdWlsZGVyXG59O1xuQnVmZmVyQnVpbGRlci5kZXB0aERlbHRhID0gZnVuY3Rpb24gZGVwdGhEZWx0YSAobGFiZWwpIHtcbiAgdmFyIGxMb2MgPSBsYWJlbC5nZXRMb2NhdGlvbigwLCBQb3NpdGlvbi5MRUZUKTtcbiAgdmFyIHJMb2MgPSBsYWJlbC5nZXRMb2NhdGlvbigwLCBQb3NpdGlvbi5SSUdIVCk7XG4gIGlmIChsTG9jID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiByTG9jID09PSBMb2NhdGlvbi5FWFRFUklPUikgeyByZXR1cm4gMTsgfSBlbHNlIGlmIChsTG9jID09PSBMb2NhdGlvbi5FWFRFUklPUiAmJiByTG9jID09PSBMb2NhdGlvbi5JTlRFUklPUikgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gMFxufTtcbkJ1ZmZlckJ1aWxkZXIuY29udmVydFNlZ1N0cmluZ3MgPSBmdW5jdGlvbiBjb252ZXJ0U2VnU3RyaW5ncyAoaXQpIHtcbiAgdmFyIGZhY3QgPSBuZXcgR2VvbWV0cnlGYWN0b3J5KCk7XG4gIHZhciBsaW5lcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgd2hpbGUgKGl0Lmhhc05leHQoKSkge1xuICAgIHZhciBzcyA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbGluZSA9IGZhY3QuY3JlYXRlTGluZVN0cmluZyhzcy5nZXRDb29yZGluYXRlcygpKTtcbiAgICBsaW5lcy5hZGQobGluZSk7XG4gIH1cbiAgcmV0dXJuIGZhY3QuYnVpbGRHZW9tZXRyeShsaW5lcylcbn07XG5cbnZhciBTY2FsZWROb2RlciA9IGZ1bmN0aW9uIFNjYWxlZE5vZGVyICgpIHtcbiAgdGhpcy5fbm9kZXIgPSBudWxsO1xuICB0aGlzLl9zY2FsZUZhY3RvciA9IG51bGw7XG4gIHRoaXMuX29mZnNldFggPSBudWxsO1xuICB0aGlzLl9vZmZzZXRZID0gbnVsbDtcbiAgdGhpcy5faXNTY2FsZWQgPSBmYWxzZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgbm9kZXIgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNjYWxlRmFjdG9yID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX25vZGVyID0gbm9kZXI7XG4gICAgdGhpcy5fc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLl9vZmZzZXRYID0gMC4wO1xuICAgIHRoaXMuX29mZnNldFkgPSAwLjA7XG4gICAgdGhpcy5faXNTY2FsZWQgPSAhdGhpcy5pc0ludGVnZXJQcmVjaXNpb24oKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIG5vZGVyJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNjYWxlRmFjdG9yJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG9mZnNldFggPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIG9mZnNldFkgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5fbm9kZXIgPSBub2RlciQxO1xuICAgIHRoaXMuX3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3IkMTtcbiAgICB0aGlzLl9vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLl9vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICB0aGlzLl9pc1NjYWxlZCA9ICF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpO1xuICB9XG59O1xuU2NhbGVkTm9kZXIucHJvdG90eXBlLnJlc2NhbGUgPSBmdW5jdGlvbiByZXNjYWxlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikpIHtcbiAgICB2YXIgc2VnU3RyaW5ncyA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBzcyA9IGkubmV4dCgpO1xuICAgICAgdGhpcyQxLnJlc2NhbGUoc3MuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgICAvLyBsZXQgcDAgPSBudWxsXG4gICAgLy8gbGV0IHAxID0gbnVsbFxuICAgIC8vIGlmIChwdHMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gcDAgPSBuZXcgQ29vcmRpbmF0ZShwdHNbMF0pXG4gICAgLy8gcDEgPSBuZXcgQ29vcmRpbmF0ZShwdHNbMV0pXG4gICAgLy8gfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHB0cy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICBwdHNbaSQxXS54ID0gcHRzW2kkMV0ueCAvIHRoaXMkMS5fc2NhbGVGYWN0b3IgKyB0aGlzJDEuX29mZnNldFg7XG4gICAgICBwdHNbaSQxXS55ID0gcHRzW2kkMV0ueSAvIHRoaXMkMS5fc2NhbGVGYWN0b3IgKyB0aGlzJDEuX29mZnNldFk7XG4gICAgfVxuICAgIGlmIChwdHMubGVuZ3RoID09PSAyICYmIHB0c1swXS5lcXVhbHMyRChwdHNbMV0pKSB7XG4gICAgICBTeXN0ZW0ub3V0LnByaW50bG4ocHRzKTtcbiAgICB9XG4gIH1cbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvbGxlY3Rpb24pKSB7XG4gICAgdmFyIHNlZ1N0cmluZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGVkU2VnbWVudFN0cmluZ3MgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaSA9IHNlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgc3MgPSBpLm5leHQoKTtcbiAgICAgIG5vZGVkU2VnbWVudFN0cmluZ3MuYWRkKG5ldyBOb2RlZFNlZ21lbnRTdHJpbmcodGhpcyQxLnNjYWxlKHNzLmdldENvb3JkaW5hdGVzKCkpLCBzcy5nZXREYXRhKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVkU2VnbWVudFN0cmluZ3NcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHJvdW5kUHRzID0gbmV3IEFycmF5KHB0cy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHRzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIHJvdW5kUHRzW2kkMV0gPSBuZXcgQ29vcmRpbmF0ZShNYXRoLnJvdW5kKChwdHNbaSQxXS54IC0gdGhpcyQxLl9vZmZzZXRYKSAqIHRoaXMkMS5fc2NhbGVGYWN0b3IpLCBNYXRoLnJvdW5kKChwdHNbaSQxXS55IC0gdGhpcyQxLl9vZmZzZXRZKSAqIHRoaXMkMS5fc2NhbGVGYWN0b3IpLCBwdHNbaSQxXS56KTtcbiAgICB9XG4gICAgdmFyIHJvdW5kUHRzTm9EdXAgPSBDb29yZGluYXRlQXJyYXlzLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHJvdW5kUHRzKTtcbiAgICByZXR1cm4gcm91bmRQdHNOb0R1cFxuICB9XG59O1xuU2NhbGVkTm9kZXIucHJvdG90eXBlLmlzSW50ZWdlclByZWNpc2lvbiA9IGZ1bmN0aW9uIGlzSW50ZWdlclByZWNpc2lvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9zY2FsZUZhY3RvciA9PT0gMS4wXG59O1xuU2NhbGVkTm9kZXIucHJvdG90eXBlLmdldE5vZGVkU3Vic3RyaW5ncyA9IGZ1bmN0aW9uIGdldE5vZGVkU3Vic3RyaW5ncyAoKSB7XG4gIHZhciBzcGxpdFNTID0gdGhpcy5fbm9kZXIuZ2V0Tm9kZWRTdWJzdHJpbmdzKCk7XG4gIGlmICh0aGlzLl9pc1NjYWxlZCkgeyB0aGlzLnJlc2NhbGUoc3BsaXRTUyk7IH1cbiAgcmV0dXJuIHNwbGl0U1Ncbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuY29tcHV0ZU5vZGVzID0gZnVuY3Rpb24gY29tcHV0ZU5vZGVzIChpbnB1dFNlZ1N0cmluZ3MpIHtcbiAgdmFyIGludFNlZ1N0cmluZ3MgPSBpbnB1dFNlZ1N0cmluZ3M7XG4gIGlmICh0aGlzLl9pc1NjYWxlZCkgeyBpbnRTZWdTdHJpbmdzID0gdGhpcy5zY2FsZShpbnB1dFNlZ1N0cmluZ3MpOyB9XG4gIHRoaXMuX25vZGVyLmNvbXB1dGVOb2RlcyhpbnRTZWdTdHJpbmdzKTtcbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbTm9kZXJdXG59O1xuU2NhbGVkTm9kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2NhbGVkTm9kZXJcbn07XG5cbnZhciBOb2RpbmdWYWxpZGF0b3IgPSBmdW5jdGlvbiBOb2RpbmdWYWxpZGF0b3IgKCkge1xuICB0aGlzLl9saSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgdGhpcy5fc2VnU3RyaW5ncyA9IG51bGw7XG4gIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9zZWdTdHJpbmdzID0gc2VnU3RyaW5ncztcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzMgPSB7IGZhY3Q6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBjaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBzcyA9IGkubmV4dCgpO1xuICAgICAgdmFyIHB0cyA9IHNzLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICB0aGlzJDEuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMocHRzWzBdLCB0aGlzJDEuX3NlZ1N0cmluZ3MpO1xuICAgICAgdGhpcyQxLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKHB0c1twdHMubGVuZ3RoIC0gMV0sIHRoaXMkMS5fc2VnU3RyaW5ncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgdGVzdFB0ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzFdO1xuICAgIGZvciAodmFyIGkkMSA9IHNlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaSQxLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBzcyQxID0gaSQxLm5leHQoKTtcbiAgICAgIHZhciBwdHMkMSA9IHNzJDEuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcHRzJDEubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgIGlmIChwdHMkMVtqXS5lcXVhbHModGVzdFB0KSkgeyB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignZm91bmQgZW5kcHQvaW50ZXJpb3IgcHQgaW50ZXJzZWN0aW9uIGF0IGluZGV4ICcgKyBqICsgJyA6cHQgJyArIHRlc3RQdCkgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBjaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBzczAgPSBpLm5leHQoKTtcbiAgICAgIGZvciAodmFyIGogPSB0aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGouaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgc3MxID0gai5uZXh0KCk7XG4gICAgICAgIHRoaXMkMS5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhzczAsIHNzMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc3MwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNzMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdHMwID0gc3MwJDEuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgcHRzMSA9IHNzMSQxLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaTAgPSAwOyBpMCA8IHB0czAubGVuZ3RoIC0gMTsgaTArKykge1xuICAgICAgZm9yICh2YXIgaTEgPSAwOyBpMSA8IHB0czEubGVuZ3RoIC0gMTsgaTErKykge1xuICAgICAgICB0aGlzJDEuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoc3MwJDEsIGkwLCBzczEkMSwgaTEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIGUwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzZWdJbmRleDAgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGUxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBzZWdJbmRleDEgPSBhcmd1bWVudHNbM107XG4gICAgaWYgKGUwID09PSBlMSAmJiBzZWdJbmRleDAgPT09IHNlZ0luZGV4MSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIHAwMCA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwXTtcbiAgICB2YXIgcDAxID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDAgKyAxXTtcbiAgICB2YXIgcDEwID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDFdO1xuICAgIHZhciBwMTEgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MSArIDFdO1xuICAgIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAwLCBwMDEsIHAxMCwgcDExKTtcbiAgICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICAgIGlmICh0aGlzLl9saS5pc1Byb3BlcigpIHx8IHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksIHAwMCwgcDAxKSB8fCB0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMuX2xpLCBwMTAsIHAxMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ2ZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYXQgJyArIHAwMCArICctJyArIHAwMSArICcgYW5kICcgKyBwMTAgKyAnLScgKyBwMTEpXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja1ZhbGlkID0gZnVuY3Rpb24gY2hlY2tWYWxpZCAoKSB7XG4gIHRoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoKTtcbiAgdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpO1xuICB0aGlzLmNoZWNrQ29sbGFwc2VzKCk7XG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0NvbGxhcHNlcyA9IGZ1bmN0aW9uIGNoZWNrQ29sbGFwc2VzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzID0gaS5uZXh0KCk7XG4gICAgICB0aGlzJDEuY2hlY2tDb2xsYXBzZXMoc3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHNzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0cyA9IHNzJDEuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwdHMubGVuZ3RoIC0gMjsgaSQxKyspIHtcbiAgICAgIHRoaXMkMS5jaGVja0NvbGxhcHNlKHB0c1tpJDFdLCBwdHNbaSQxICsgMV0sIHB0c1tpJDEgKyAyXSk7XG4gICAgfVxuICB9XG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5oYXNJbnRlcmlvckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc0ludGVyaW9ySW50ZXJzZWN0aW9uIChsaSwgcDAsIHAxKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7IGkrKykge1xuICAgIHZhciBpbnRQdCA9IGxpLmdldEludGVyc2VjdGlvbihpKTtcbiAgICBpZiAoIShpbnRQdC5lcXVhbHMocDApIHx8IGludFB0LmVxdWFscyhwMSkpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrQ29sbGFwc2UgPSBmdW5jdGlvbiBjaGVja0NvbGxhcHNlIChwMCwgcDEsIHAyKSB7XG4gIGlmIChwMC5lcXVhbHMocDIpKSB7IHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKCdmb3VuZCBub24tbm9kZWQgY29sbGFwc2UgYXQgJyArIE5vZGluZ1ZhbGlkYXRvci5mYWN0LmNyZWF0ZUxpbmVTdHJpbmcoW3AwLCBwMSwgcDJdKSkgfVxufTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOb2RpbmdWYWxpZGF0b3Jcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzMuZmFjdC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgR2VvbWV0cnlGYWN0b3J5KCkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE5vZGluZ1ZhbGlkYXRvciwgc3RhdGljQWNjZXNzb3JzJDMzICk7XG5cbnZhciBIb3RQaXhlbCA9IGZ1bmN0aW9uIEhvdFBpeGVsICgpIHtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9wdCA9IG51bGw7XG4gIHRoaXMuX29yaWdpbmFsUHQgPSBudWxsO1xuICB0aGlzLl9wdFNjYWxlZCA9IG51bGw7XG4gIHRoaXMuX3AwU2NhbGVkID0gbnVsbDtcbiAgdGhpcy5fcDFTY2FsZWQgPSBudWxsO1xuICB0aGlzLl9zY2FsZUZhY3RvciA9IG51bGw7XG4gIHRoaXMuX21pbnggPSBudWxsO1xuICB0aGlzLl9tYXh4ID0gbnVsbDtcbiAgdGhpcy5fbWlueSA9IG51bGw7XG4gIHRoaXMuX21heHkgPSBudWxsO1xuICB0aGlzLl9jb3JuZXIgPSBuZXcgQXJyYXkoNCkuZmlsbChudWxsKTtcbiAgdGhpcy5fc2FmZUVudiA9IG51bGw7XG4gIHZhciBwdCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIHNjYWxlRmFjdG9yID0gYXJndW1lbnRzWzFdO1xuICB2YXIgbGkgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuX29yaWdpbmFsUHQgPSBwdDtcbiAgdGhpcy5fcHQgPSBwdDtcbiAgdGhpcy5fc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgdGhpcy5fbGkgPSBsaTtcbiAgaWYgKHNjYWxlRmFjdG9yIDw9IDApIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignU2NhbGUgZmFjdG9yIG11c3QgYmUgbm9uLXplcm8nKSB9XG4gIGlmIChzY2FsZUZhY3RvciAhPT0gMS4wKSB7XG4gICAgdGhpcy5fcHQgPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLnNjYWxlKHB0LngpLCB0aGlzLnNjYWxlKHB0LnkpKTtcbiAgICB0aGlzLl9wMFNjYWxlZCA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgdGhpcy5fcDFTY2FsZWQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICB9XG4gIHRoaXMuaW5pdENvcm5lcnModGhpcy5fcHQpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzNCA9IHsgU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuSG90UGl4ZWwucHJvdG90eXBlLmludGVyc2VjdHNTY2FsZWQgPSBmdW5jdGlvbiBpbnRlcnNlY3RzU2NhbGVkIChwMCwgcDEpIHtcbiAgdmFyIHNlZ01pbnggPSBNYXRoLm1pbihwMC54LCBwMS54KTtcbiAgdmFyIHNlZ01heHggPSBNYXRoLm1heChwMC54LCBwMS54KTtcbiAgdmFyIHNlZ01pbnkgPSBNYXRoLm1pbihwMC55LCBwMS55KTtcbiAgdmFyIHNlZ01heHkgPSBNYXRoLm1heChwMC55LCBwMS55KTtcbiAgdmFyIGlzT3V0c2lkZVBpeGVsRW52ID0gdGhpcy5fbWF4eCA8IHNlZ01pbnggfHwgdGhpcy5fbWlueCA+IHNlZ01heHggfHwgdGhpcy5fbWF4eSA8IHNlZ01pbnkgfHwgdGhpcy5fbWlueSA+IHNlZ01heHk7XG4gIGlmIChpc091dHNpZGVQaXhlbEVudikgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgaW50ZXJzZWN0cyA9IHRoaXMuaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZShwMCwgcDEpO1xuICBBc3NlcnQuaXNUcnVlKCEoaXNPdXRzaWRlUGl4ZWxFbnYgJiYgaW50ZXJzZWN0cyksICdGb3VuZCBiYWQgZW52ZWxvcGUgdGVzdCcpO1xuICByZXR1cm4gaW50ZXJzZWN0c1xufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5pbml0Q29ybmVycyA9IGZ1bmN0aW9uIGluaXRDb3JuZXJzIChwdCkge1xuICB2YXIgdG9sZXJhbmNlID0gMC41O1xuICB0aGlzLl9taW54ID0gcHQueCAtIHRvbGVyYW5jZTtcbiAgdGhpcy5fbWF4eCA9IHB0LnggKyB0b2xlcmFuY2U7XG4gIHRoaXMuX21pbnkgPSBwdC55IC0gdG9sZXJhbmNlO1xuICB0aGlzLl9tYXh5ID0gcHQueSArIHRvbGVyYW5jZTtcbiAgdGhpcy5fY29ybmVyWzBdID0gbmV3IENvb3JkaW5hdGUodGhpcy5fbWF4eCwgdGhpcy5fbWF4eSk7XG4gIHRoaXMuX2Nvcm5lclsxXSA9IG5ldyBDb29yZGluYXRlKHRoaXMuX21pbngsIHRoaXMuX21heHkpO1xuICB0aGlzLl9jb3JuZXJbMl0gPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9taW54LCB0aGlzLl9taW55KTtcbiAgdGhpcy5fY29ybmVyWzNdID0gbmV3IENvb3JkaW5hdGUodGhpcy5fbWF4eCwgdGhpcy5fbWlueSk7XG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiBpbnRlcnNlY3RzIChwMCwgcDEpIHtcbiAgaWYgKHRoaXMuX3NjYWxlRmFjdG9yID09PSAxLjApIHsgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NjYWxlZChwMCwgcDEpIH1cbiAgdGhpcy5jb3B5U2NhbGVkKHAwLCB0aGlzLl9wMFNjYWxlZCk7XG4gIHRoaXMuY29weVNjYWxlZChwMSwgdGhpcy5fcDFTY2FsZWQpO1xuICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzU2NhbGVkKHRoaXMuX3AwU2NhbGVkLCB0aGlzLl9wMVNjYWxlZClcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSAodmFsKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIHRoaXMuX3NjYWxlRmFjdG9yKVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9vcmlnaW5hbFB0XG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmNvcHlTY2FsZWQgPSBmdW5jdGlvbiBjb3B5U2NhbGVkIChwLCBwU2NhbGVkKSB7XG4gIHBTY2FsZWQueCA9IHRoaXMuc2NhbGUocC54KTtcbiAgcFNjYWxlZC55ID0gdGhpcy5zY2FsZShwLnkpO1xufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5nZXRTYWZlRW52ZWxvcGUgPSBmdW5jdGlvbiBnZXRTYWZlRW52ZWxvcGUgKCkge1xuICBpZiAodGhpcy5fc2FmZUVudiA9PT0gbnVsbCkge1xuICAgIHZhciBzYWZlVG9sZXJhbmNlID0gSG90UGl4ZWwuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUiAvIHRoaXMuX3NjYWxlRmFjdG9yO1xuICAgIHRoaXMuX3NhZmVFbnYgPSBuZXcgRW52ZWxvcGUodGhpcy5fb3JpZ2luYWxQdC54IC0gc2FmZVRvbGVyYW5jZSwgdGhpcy5fb3JpZ2luYWxQdC54ICsgc2FmZVRvbGVyYW5jZSwgdGhpcy5fb3JpZ2luYWxQdC55IC0gc2FmZVRvbGVyYW5jZSwgdGhpcy5fb3JpZ2luYWxQdC55ICsgc2FmZVRvbGVyYW5jZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3NhZmVFbnZcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuaW50ZXJzZWN0c1BpeGVsQ2xvc3VyZSA9IGZ1bmN0aW9uIGludGVyc2VjdHNQaXhlbENsb3N1cmUgKHAwLCBwMSkge1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzBdLCB0aGlzLl9jb3JuZXJbMV0pO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHsgcmV0dXJuIHRydWUgfVxuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzFdLCB0aGlzLl9jb3JuZXJbMl0pO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHsgcmV0dXJuIHRydWUgfVxuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzJdLCB0aGlzLl9jb3JuZXJbM10pO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHsgcmV0dXJuIHRydWUgfVxuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzNdLCB0aGlzLl9jb3JuZXJbMF0pO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSA9IGZ1bmN0aW9uIGludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUgKHAwLCBwMSkge1xuICB2YXIgaW50ZXJzZWN0c0xlZnQgPSBmYWxzZTtcbiAgdmFyIGludGVyc2VjdHNCb3R0b20gPSBmYWxzZTtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMCwgcDEsIHRoaXMuX2Nvcm5lclswXSwgdGhpcy5fY29ybmVyWzFdKTtcbiAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkpIHsgcmV0dXJuIHRydWUgfVxuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzFdLCB0aGlzLl9jb3JuZXJbMl0pO1xuICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyBpbnRlcnNlY3RzTGVmdCA9IHRydWU7IH1cbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMCwgcDEsIHRoaXMuX2Nvcm5lclsyXSwgdGhpcy5fY29ybmVyWzNdKTtcbiAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHsgaW50ZXJzZWN0c0JvdHRvbSA9IHRydWU7IH1cbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMCwgcDEsIHRoaXMuX2Nvcm5lclszXSwgdGhpcy5fY29ybmVyWzBdKTtcbiAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoaW50ZXJzZWN0c0xlZnQgJiYgaW50ZXJzZWN0c0JvdHRvbSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwMC5lcXVhbHModGhpcy5fcHQpKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHAxLmVxdWFscyh0aGlzLl9wdCkpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuYWRkU25hcHBlZE5vZGUgPSBmdW5jdGlvbiBhZGRTbmFwcGVkTm9kZSAoc2VnU3RyLCBzZWdJbmRleCkge1xuICB2YXIgcDAgPSBzZWdTdHIuZ2V0Q29vcmRpbmF0ZShzZWdJbmRleCk7XG4gIHZhciBwMSA9IHNlZ1N0ci5nZXRDb29yZGluYXRlKHNlZ0luZGV4ICsgMSk7XG4gIGlmICh0aGlzLmludGVyc2VjdHMocDAsIHAxKSkge1xuICAgIHNlZ1N0ci5hZGRJbnRlcnNlY3Rpb24odGhpcy5nZXRDb29yZGluYXRlKCksIHNlZ0luZGV4KTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSG90UGl4ZWxcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzQuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwLjc1IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBIb3RQaXhlbCwgc3RhdGljQWNjZXNzb3JzJDM0ICk7XG5cbnZhciBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uID0gZnVuY3Rpb24gTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiAoKSB7XG4gIHRoaXMudGVtcEVudjEgPSBuZXcgRW52ZWxvcGUoKTtcbiAgdGhpcy5zZWxlY3RlZFNlZ21lbnQgPSBuZXcgTGluZVNlZ21lbnQoKTtcbn07XG5Nb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIGNvbnN0IHNlZyA9IGFyZ3VtZW50c1swXVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgbWMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgbWMuZ2V0TGluZVNlZ21lbnQoc3RhcnRJbmRleCwgdGhpcy5zZWxlY3RlZFNlZ21lbnQpO1xuICAgIHRoaXMuc2VsZWN0KHRoaXMuc2VsZWN0ZWRTZWdtZW50KTtcbiAgfVxufTtcbk1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Nb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb25cbn07XG5cbnZhciBNQ0luZGV4UG9pbnRTbmFwcGVyID0gZnVuY3Rpb24gTUNJbmRleFBvaW50U25hcHBlciAoKSB7XG4gIHRoaXMuX2luZGV4ID0gbnVsbDtcbiAgdmFyIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9pbmRleCA9IGluZGV4O1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzNSA9IHsgSG90UGl4ZWxTbmFwQWN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5NQ0luZGV4UG9pbnRTbmFwcGVyLnByb3RvdHlwZS5zbmFwID0gZnVuY3Rpb24gc25hcCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGhvdFBpeGVsID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLnNuYXAoaG90UGl4ZWwsIG51bGwsIC0xKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgaG90UGl4ZWwkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcGFyZW50RWRnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaG90UGl4ZWxWZXJ0ZXhJbmRleCA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgcGl4ZWxFbnYgPSBob3RQaXhlbCQxLmdldFNhZmVFbnZlbG9wZSgpO1xuICAgIHZhciBob3RQaXhlbFNuYXBBY3Rpb24gPSBuZXcgSG90UGl4ZWxTbmFwQWN0aW9uKGhvdFBpeGVsJDEsIHBhcmVudEVkZ2UsIGhvdFBpeGVsVmVydGV4SW5kZXgpO1xuICAgIHRoaXMuX2luZGV4LnF1ZXJ5KHBpeGVsRW52LCB7XG4gICAgICBpbnRlcmZhY2VzXzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW0l0ZW1WaXNpdG9yXVxuICAgICAgfSxcbiAgICAgIHZpc2l0SXRlbTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIHRlc3RDaGFpbiA9IGl0ZW07XG4gICAgICAgIHRlc3RDaGFpbi5zZWxlY3QocGl4ZWxFbnYsIGhvdFBpeGVsU25hcEFjdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhvdFBpeGVsU25hcEFjdGlvbi5pc05vZGVBZGRlZCgpXG4gIH1cbn07XG5NQ0luZGV4UG9pbnRTbmFwcGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTUNJbmRleFBvaW50U25hcHBlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNQ0luZGV4UG9pbnRTbmFwcGVyXG59O1xuc3RhdGljQWNjZXNzb3JzJDM1LkhvdFBpeGVsU25hcEFjdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBIb3RQaXhlbFNuYXBBY3Rpb24gfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1DSW5kZXhQb2ludFNuYXBwZXIsIHN0YXRpY0FjY2Vzc29ycyQzNSApO1xuXG52YXIgSG90UGl4ZWxTbmFwQWN0aW9uID0gKGZ1bmN0aW9uIChNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIEhvdFBpeGVsU25hcEFjdGlvbiAoKSB7XG4gICAgTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX2hvdFBpeGVsID0gbnVsbDtcbiAgICB0aGlzLl9wYXJlbnRFZGdlID0gbnVsbDtcbiAgICB0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4ID0gbnVsbDtcbiAgICB0aGlzLl9pc05vZGVBZGRlZCA9IGZhbHNlO1xuICAgIHZhciBob3RQaXhlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcGFyZW50RWRnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaG90UGl4ZWxWZXJ0ZXhJbmRleCA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9ob3RQaXhlbCA9IGhvdFBpeGVsO1xuICAgIHRoaXMuX3BhcmVudEVkZ2UgPSBwYXJlbnRFZGdlO1xuICAgIHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXggPSBob3RQaXhlbFZlcnRleEluZGV4O1xuICB9XG5cbiAgaWYgKCBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxICkgSG90UGl4ZWxTbmFwQWN0aW9uLl9fcHJvdG9fXyA9IE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDE7XG4gIEhvdFBpeGVsU25hcEFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxICYmIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIEhvdFBpeGVsU25hcEFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIb3RQaXhlbFNuYXBBY3Rpb247XG4gIEhvdFBpeGVsU25hcEFjdGlvbi5wcm90b3R5cGUuaXNOb2RlQWRkZWQgPSBmdW5jdGlvbiBpc05vZGVBZGRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzTm9kZUFkZGVkXG4gIH07XG4gIEhvdFBpeGVsU25hcEFjdGlvbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG1jID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgc3MgPSBtYy5nZXRDb250ZXh0KCk7XG4gICAgICBpZiAodGhpcy5fcGFyZW50RWRnZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc3MgPT09IHRoaXMuX3BhcmVudEVkZ2UgJiYgc3RhcnRJbmRleCA9PT0gdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pc05vZGVBZGRlZCA9IHRoaXMuX2hvdFBpeGVsLmFkZFNuYXBwZWROb2RlKHNzLCBzdGFydEluZGV4KTtcbiAgICB9IGVsc2UgeyByZXR1cm4gTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMS5wcm90b3R5cGUuc2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBIb3RQaXhlbFNuYXBBY3Rpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBIb3RQaXhlbFNuYXBBY3Rpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBIb3RQaXhlbFNuYXBBY3Rpb25cbiAgfTtcblxuICByZXR1cm4gSG90UGl4ZWxTbmFwQWN0aW9uO1xufShNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uKSk7XG5cbnZhciBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyID0gZnVuY3Rpb24gSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlciAoKSB7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zID0gbnVsbDtcbiAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9saSA9IGxpO1xuICB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnMgPSBuZXcgQXJyYXlMaXN0KCk7XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlci5wcm90b3R5cGUucHJvY2Vzc0ludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzSW50ZXJzZWN0aW9ucyAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChlMCA9PT0gZTEgJiYgc2VnSW5kZXgwID09PSBzZWdJbmRleDEpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcDAwID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDBdO1xuICB2YXIgcDAxID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDAgKyAxXTtcbiAgdmFyIHAxMCA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxXTtcbiAgdmFyIHAxMSA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxICsgMV07XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAwLCBwMDEsIHAxMCwgcDExKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgaWYgKHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSkge1xuICAgICAgZm9yICh2YXIgaW50SW5kZXggPSAwOyBpbnRJbmRleCA8IHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpOyBpbnRJbmRleCsrKSB7XG4gICAgICAgIHRoaXMkMS5faW50ZXJpb3JJbnRlcnNlY3Rpb25zLmFkZCh0aGlzJDEuX2xpLmdldEludGVyc2VjdGlvbihpbnRJbmRleCkpO1xuICAgICAgfVxuICAgICAgZTAuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSwgc2VnSW5kZXgwLCAwKTtcbiAgICAgIGUxLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MSwgMSk7XG4gICAgfVxuICB9XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlci5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlci5wcm90b3R5cGUuZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uc1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlZ21lbnRJbnRlcnNlY3Rvcl1cbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXJcbn07XG5cbnZhciBNQ0luZGV4U25hcFJvdW5kZXIgPSBmdW5jdGlvbiBNQ0luZGV4U25hcFJvdW5kZXIgKCkge1xuICB0aGlzLl9wbSA9IG51bGw7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5fc2NhbGVGYWN0b3IgPSBudWxsO1xuICB0aGlzLl9ub2RlciA9IG51bGw7XG4gIHRoaXMuX3BvaW50U25hcHBlciA9IG51bGw7XG4gIHRoaXMuX25vZGVkU2VnU3RyaW5ncyA9IG51bGw7XG4gIHZhciBwbSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fcG0gPSBwbTtcbiAgdGhpcy5fbGkgPSBuZXcgUm9idXN0TGluZUludGVyc2VjdG9yKCk7XG4gIHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHBtKTtcbiAgdGhpcy5fc2NhbGVGYWN0b3IgPSBwbS5nZXRTY2FsZSgpO1xufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuY2hlY2tDb3JyZWN0bmVzcyA9IGZ1bmN0aW9uIGNoZWNrQ29ycmVjdG5lc3MgKGlucHV0U2VnbWVudFN0cmluZ3MpIHtcbiAgdmFyIHJlc3VsdFNlZ1N0cmluZ3MgPSBOb2RlZFNlZ21lbnRTdHJpbmcuZ2V0Tm9kZWRTdWJzdHJpbmdzKGlucHV0U2VnbWVudFN0cmluZ3MpO1xuICB2YXIgbnYgPSBuZXcgTm9kaW5nVmFsaWRhdG9yKHJlc3VsdFNlZ1N0cmluZ3MpO1xuICB0cnkge1xuICAgIG52LmNoZWNrVmFsaWQoKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZXggaW5zdGFuY2VvZiBFeGNlcHRpb24pIHtcbiAgICAgIGV4LnByaW50U3RhY2tUcmFjZSgpO1xuICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgfSBmaW5hbGx5IHt9XG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5nZXROb2RlZFN1YnN0cmluZ3MgPSBmdW5jdGlvbiBnZXROb2RlZFN1YnN0cmluZ3MgKCkge1xuICByZXR1cm4gTm9kZWRTZWdtZW50U3RyaW5nLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpXG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5zbmFwUm91bmQgPSBmdW5jdGlvbiBzbmFwUm91bmQgKHNlZ1N0cmluZ3MsIGxpKSB7XG4gIHZhciBpbnRlcnNlY3Rpb25zID0gdGhpcy5maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHNlZ1N0cmluZ3MsIGxpKTtcbiAgdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uU25hcHMoaW50ZXJzZWN0aW9ucyk7XG4gIHRoaXMuY29tcHV0ZVZlcnRleFNuYXBzKHNlZ1N0cmluZ3MpO1xufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGZpbmRJbnRlcmlvckludGVyc2VjdGlvbnMgKHNlZ1N0cmluZ3MsIGxpKSB7XG4gIHZhciBpbnRGaW5kZXJBZGRlciA9IG5ldyBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyKGxpKTtcbiAgdGhpcy5fbm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKGludEZpbmRlckFkZGVyKTtcbiAgdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKHNlZ1N0cmluZ3MpO1xuICByZXR1cm4gaW50RmluZGVyQWRkZXIuZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zKClcbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmNvbXB1dGVWZXJ0ZXhTbmFwcyA9IGZ1bmN0aW9uIGNvbXB1dGVWZXJ0ZXhTbmFwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvbGxlY3Rpb24pKSB7XG4gICAgdmFyIGVkZ2VzID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkwID0gZWRnZXMuaXRlcmF0b3IoKTsgaTAuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGVkZ2UwID0gaTAubmV4dCgpO1xuICAgICAgdGhpcyQxLmNvbXB1dGVWZXJ0ZXhTbmFwcyhlZGdlMCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE5vZGVkU2VnbWVudFN0cmluZykge1xuICAgIHZhciBlID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdHMwID0gZS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzMC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhvdFBpeGVsID0gbmV3IEhvdFBpeGVsKHB0czBbaV0sIHRoaXMkMS5fc2NhbGVGYWN0b3IsIHRoaXMkMS5fbGkpO1xuICAgICAgdmFyIGlzTm9kZUFkZGVkID0gdGhpcyQxLl9wb2ludFNuYXBwZXIuc25hcChob3RQaXhlbCwgZSwgaSk7XG4gICAgICBpZiAoaXNOb2RlQWRkZWQpIHtcbiAgICAgICAgZS5hZGRJbnRlcnNlY3Rpb24ocHRzMFtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5jb21wdXRlTm9kZXMgPSBmdW5jdGlvbiBjb21wdXRlTm9kZXMgKGlucHV0U2VnbWVudFN0cmluZ3MpIHtcbiAgdGhpcy5fbm9kZWRTZWdTdHJpbmdzID0gaW5wdXRTZWdtZW50U3RyaW5ncztcbiAgdGhpcy5fbm9kZXIgPSBuZXcgTUNJbmRleE5vZGVyKCk7XG4gIHRoaXMuX3BvaW50U25hcHBlciA9IG5ldyBNQ0luZGV4UG9pbnRTbmFwcGVyKHRoaXMuX25vZGVyLmdldEluZGV4KCkpO1xuICB0aGlzLnNuYXBSb3VuZChpbnB1dFNlZ21lbnRTdHJpbmdzLCB0aGlzLl9saSk7XG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9uU25hcHMgPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0aW9uU25hcHMgKHNuYXBQdHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpdCA9IHNuYXBQdHMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBzbmFwUHQgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGhvdFBpeGVsID0gbmV3IEhvdFBpeGVsKHNuYXBQdCwgdGhpcyQxLl9zY2FsZUZhY3RvciwgdGhpcyQxLl9saSk7XG4gICAgdGhpcyQxLl9wb2ludFNuYXBwZXIuc25hcChob3RQaXhlbCk7XG4gIH1cbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW05vZGVyXVxufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNQ0luZGV4U25hcFJvdW5kZXJcbn07XG5cbnZhciBCdWZmZXJPcCA9IGZ1bmN0aW9uIEJ1ZmZlck9wICgpIHtcbiAgdGhpcy5fYXJnR2VvbSA9IG51bGw7XG4gIHRoaXMuX2Rpc3RhbmNlID0gbnVsbDtcbiAgdGhpcy5fYnVmUGFyYW1zID0gbmV3IEJ1ZmZlclBhcmFtZXRlcnMoKTtcbiAgdGhpcy5fcmVzdWx0R2VvbWV0cnkgPSBudWxsO1xuICB0aGlzLl9zYXZlRXhjZXB0aW9uID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9hcmdHZW9tID0gZztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGckMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYnVmUGFyYW1zID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2FyZ0dlb20gPSBnJDE7XG4gICAgdGhpcy5fYnVmUGFyYW1zID0gYnVmUGFyYW1zO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDMyID0geyBDQVBfUk9VTkQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ0FQX0JVVFQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ0FQX0ZMQVQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ0FQX1NRVUFSRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNQVhfUFJFQ0lTSU9OX0RJR0lUUzogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVyT3AucHJvdG90eXBlLmJ1ZmZlckZpeGVkUHJlY2lzaW9uID0gZnVuY3Rpb24gYnVmZmVyRml4ZWRQcmVjaXNpb24gKGZpeGVkUE0pIHtcbiAgdmFyIG5vZGVyID0gbmV3IFNjYWxlZE5vZGVyKG5ldyBNQ0luZGV4U25hcFJvdW5kZXIobmV3IFByZWNpc2lvbk1vZGVsKDEuMCkpLCBmaXhlZFBNLmdldFNjYWxlKCkpO1xuICB2YXIgYnVmQnVpbGRlciA9IG5ldyBCdWZmZXJCdWlsZGVyKHRoaXMuX2J1ZlBhcmFtcyk7XG4gIGJ1ZkJ1aWxkZXIuc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsKGZpeGVkUE0pO1xuICBidWZCdWlsZGVyLnNldE5vZGVyKG5vZGVyKTtcbiAgdGhpcy5fcmVzdWx0R2VvbWV0cnkgPSBidWZCdWlsZGVyLmJ1ZmZlcih0aGlzLl9hcmdHZW9tLCB0aGlzLl9kaXN0YW5jZSk7XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24gPSBmdW5jdGlvbiBidWZmZXJSZWR1Y2VkUHJlY2lzaW9uICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAodmFyIHByZWNEaWdpdHMgPSBCdWZmZXJPcC5NQVhfUFJFQ0lTSU9OX0RJR0lUUzsgcHJlY0RpZ2l0cyA+PSAwOyBwcmVjRGlnaXRzLS0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMkMS5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKHByZWNEaWdpdHMpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgVG9wb2xvZ3lFeGNlcHRpb24pIHtcbiAgICAgICAgICB0aGlzJDEuX3NhdmVFeGNlcHRpb24gPSBleDtcbiAgICAgICAgfSBlbHNlIHsgdGhyb3cgZXggfVxuICAgICAgfSBmaW5hbGx5IHt9XG4gICAgICBpZiAodGhpcyQxLl9yZXN1bHRHZW9tZXRyeSAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgfVxuICAgIHRocm93IHRoaXMuX3NhdmVFeGNlcHRpb25cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHByZWNpc2lvbkRpZ2l0cyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2l6ZUJhc2VkU2NhbGVGYWN0b3IgPSBCdWZmZXJPcC5wcmVjaXNpb25TY2FsZUZhY3Rvcih0aGlzLl9hcmdHZW9tLCB0aGlzLl9kaXN0YW5jZSwgcHJlY2lzaW9uRGlnaXRzKTtcbiAgICB2YXIgZml4ZWRQTSA9IG5ldyBQcmVjaXNpb25Nb2RlbChzaXplQmFzZWRTY2FsZUZhY3Rvcik7XG4gICAgdGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbihmaXhlZFBNKTtcbiAgfVxufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5jb21wdXRlR2VvbWV0cnkgPSBmdW5jdGlvbiBjb21wdXRlR2VvbWV0cnkgKCkge1xuICB0aGlzLmJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCk7XG4gIGlmICh0aGlzLl9yZXN1bHRHZW9tZXRyeSAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBhcmdQTSA9IHRoaXMuX2FyZ0dlb20uZ2V0RmFjdG9yeSgpLmdldFByZWNpc2lvbk1vZGVsKCk7XG4gIGlmIChhcmdQTS5nZXRUeXBlKCkgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7IHRoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24oYXJnUE0pOyB9IGVsc2UgeyB0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKTsgfVxufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5zZXRRdWFkcmFudFNlZ21lbnRzID0gZnVuY3Rpb24gc2V0UXVhZHJhbnRTZWdtZW50cyAocXVhZHJhbnRTZWdtZW50cykge1xuICB0aGlzLl9idWZQYXJhbXMuc2V0UXVhZHJhbnRTZWdtZW50cyhxdWFkcmFudFNlZ21lbnRzKTtcbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24gPSBmdW5jdGlvbiBidWZmZXJPcmlnaW5hbFByZWNpc2lvbiAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZkJ1aWxkZXIgPSBuZXcgQnVmZmVyQnVpbGRlcih0aGlzLl9idWZQYXJhbXMpO1xuICAgIHRoaXMuX3Jlc3VsdEdlb21ldHJ5ID0gYnVmQnVpbGRlci5idWZmZXIodGhpcy5fYXJnR2VvbSwgdGhpcy5fZGlzdGFuY2UpO1xuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChleCBpbnN0YW5jZW9mIFJ1bnRpbWVFeGNlcHRpb24pIHtcbiAgICAgIHRoaXMuX3NhdmVFeGNlcHRpb24gPSBleDtcbiAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gIH0gZmluYWxseSB7fVxufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5nZXRSZXN1bHRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFJlc3VsdEdlb21ldHJ5IChkaXN0YW5jZSkge1xuICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICB0aGlzLmNvbXB1dGVHZW9tZXRyeSgpO1xuICByZXR1cm4gdGhpcy5fcmVzdWx0R2VvbWV0cnlcbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuc2V0RW5kQ2FwU3R5bGUgPSBmdW5jdGlvbiBzZXRFbmRDYXBTdHlsZSAoZW5kQ2FwU3R5bGUpIHtcbiAgdGhpcy5fYnVmUGFyYW1zLnNldEVuZENhcFN0eWxlKGVuZENhcFN0eWxlKTtcbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlck9wXG59O1xuQnVmZmVyT3AuYnVmZmVyT3AgPSBmdW5jdGlvbiBidWZmZXJPcCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBnQnVmID0gbmV3IEJ1ZmZlck9wKGcpO1xuICAgIHZhciBnZW9tQnVmID0gZ0J1Zi5nZXRSZXN1bHRHZW9tZXRyeShkaXN0YW5jZSk7XG4gICAgcmV0dXJuIGdlb21CdWZcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgZyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRpc3RhbmNlJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgcXVhZHJhbnRTZWdtZW50cyA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBidWZPcCA9IG5ldyBCdWZmZXJPcChnJDEpO1xuICAgICAgYnVmT3Auc2V0UXVhZHJhbnRTZWdtZW50cyhxdWFkcmFudFNlZ21lbnRzKTtcbiAgICAgIHZhciBnZW9tQnVmJDEgPSBidWZPcC5nZXRSZXN1bHRHZW9tZXRyeShkaXN0YW5jZSQxKTtcbiAgICAgIHJldHVybiBnZW9tQnVmJDFcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIEJ1ZmZlclBhcmFtZXRlcnMgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIGckMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaXN0YW5jZSQyID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBidWZPcCQxID0gbmV3IEJ1ZmZlck9wKGckMiwgcGFyYW1zKTtcbiAgICAgIHZhciBnZW9tQnVmJDIgPSBidWZPcCQxLmdldFJlc3VsdEdlb21ldHJ5KGRpc3RhbmNlJDIpO1xuICAgICAgcmV0dXJuIGdlb21CdWYkMlxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIGckMyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGlzdGFuY2UkMyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcXVhZHJhbnRTZWdtZW50cyQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBlbmRDYXBTdHlsZSA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgYnVmT3AkMiA9IG5ldyBCdWZmZXJPcChnJDMpO1xuICAgIGJ1Zk9wJDIuc2V0UXVhZHJhbnRTZWdtZW50cyhxdWFkcmFudFNlZ21lbnRzJDEpO1xuICAgIGJ1Zk9wJDIuc2V0RW5kQ2FwU3R5bGUoZW5kQ2FwU3R5bGUpO1xuICAgIHZhciBnZW9tQnVmJDMgPSBidWZPcCQyLmdldFJlc3VsdEdlb21ldHJ5KGRpc3RhbmNlJDMpO1xuICAgIHJldHVybiBnZW9tQnVmJDNcbiAgfVxufTtcbkJ1ZmZlck9wLnByZWNpc2lvblNjYWxlRmFjdG9yID0gZnVuY3Rpb24gcHJlY2lzaW9uU2NhbGVGYWN0b3IgKGcsIGRpc3RhbmNlLCBtYXhQcmVjaXNpb25EaWdpdHMpIHtcbiAgdmFyIGVudiA9IGcuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICB2YXIgZW52TWF4ID0gTWF0aFV0aWwubWF4KE1hdGguYWJzKGVudi5nZXRNYXhYKCkpLCBNYXRoLmFicyhlbnYuZ2V0TWF4WSgpKSwgTWF0aC5hYnMoZW52LmdldE1pblgoKSksIE1hdGguYWJzKGVudi5nZXRNaW5ZKCkpKTtcbiAgdmFyIGV4cGFuZEJ5RGlzdGFuY2UgPSBkaXN0YW5jZSA+IDAuMCA/IGRpc3RhbmNlIDogMC4wO1xuICB2YXIgYnVmRW52TWF4ID0gZW52TWF4ICsgMiAqIGV4cGFuZEJ5RGlzdGFuY2U7XG4gIHZhciBidWZFbnZQcmVjaXNpb25EaWdpdHMgPSBNYXRoLnRydW5jKE1hdGgubG9nKGJ1ZkVudk1heCkgLyBNYXRoLmxvZygxMCkgKyAxLjApO1xuICB2YXIgbWluVW5pdExvZzEwID0gbWF4UHJlY2lzaW9uRGlnaXRzIC0gYnVmRW52UHJlY2lzaW9uRGlnaXRzO1xuICB2YXIgc2NhbGVGYWN0b3IgPSBNYXRoLnBvdygxMC4wLCBtaW5Vbml0TG9nMTApO1xuICByZXR1cm4gc2NhbGVGYWN0b3Jcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzIuQ0FQX1JPVU5ELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1JPVU5EIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzIuQ0FQX0JVVFQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQnVmZmVyUGFyYW1ldGVycy5DQVBfRkxBVCB9O1xuc3RhdGljQWNjZXNzb3JzJDMyLkNBUF9GTEFULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX0ZMQVQgfTtcbnN0YXRpY0FjY2Vzc29ycyQzMi5DQVBfU1FVQVJFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1NRVUFSRSB9O1xuc3RhdGljQWNjZXNzb3JzJDMyLk1BWF9QUkVDSVNJT05fRElHSVRTLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJPcCwgc3RhdGljQWNjZXNzb3JzJDMyICk7XG5cbnZhciBQb2ludFBhaXJEaXN0YW5jZSA9IGZ1bmN0aW9uIFBvaW50UGFpckRpc3RhbmNlICgpIHtcbiAgdGhpcy5fcHQgPSBbbmV3IENvb3JkaW5hdGUoKSwgbmV3IENvb3JkaW5hdGUoKV07XG4gIHRoaXMuX2Rpc3RhbmNlID0gRG91YmxlLk5hTjtcbiAgdGhpcy5faXNOdWxsID0gdHJ1ZTtcbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9wdFxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICByZXR1cm4gdGhpcy5fcHRbaV1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuc2V0TWluaW11bSA9IGZ1bmN0aW9uIHNldE1pbmltdW0gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwdERpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRNaW5pbXVtKHB0RGlzdC5fcHRbMF0sIHB0RGlzdC5fcHRbMV0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLl9pc051bGwpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdmFyIGRpc3QgPSBwMC5kaXN0YW5jZShwMSk7XG4gICAgaWYgKGRpc3QgPCB0aGlzLl9kaXN0YW5jZSkgeyB0aGlzLmluaXRpYWxpemUocDAsIHAxLCBkaXN0KTsgfVxuICB9XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9pc051bGwgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUocDApO1xuICAgIHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUocDEpO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gcDAuZGlzdGFuY2UocDEpO1xuICAgIHRoaXMuX2lzTnVsbCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgcDAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZGlzdGFuY2UgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZShwMCQxKTtcbiAgICB0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKHAxJDEpO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgdGhpcy5faXNOdWxsID0gZmFsc2U7XG4gIH1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLl9kaXN0YW5jZVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5zZXRNYXhpbXVtID0gZnVuY3Rpb24gc2V0TWF4aW11bSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHB0RGlzdCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldE1heGltdW0ocHREaXN0Ll9wdFswXSwgcHREaXN0Ll9wdFsxXSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuX2lzTnVsbCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKHAwLCBwMSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YXIgZGlzdCA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICBpZiAoZGlzdCA+IHRoaXMuX2Rpc3RhbmNlKSB7IHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEsIGRpc3QpOyB9XG4gIH1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvaW50UGFpckRpc3RhbmNlXG59O1xuXG52YXIgRGlzdGFuY2VUb1BvaW50RmluZGVyID0gZnVuY3Rpb24gRGlzdGFuY2VUb1BvaW50RmluZGVyICgpIHt9O1xuXG5EaXN0YW5jZVRvUG9pbnRGaW5kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EaXN0YW5jZVRvUG9pbnRGaW5kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGlzdGFuY2VUb1BvaW50RmluZGVyXG59O1xuRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVEaXN0YW5jZSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVN0cmluZyAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBsaW5lID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0ID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBjb29yZHMgPSBsaW5lLmdldENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHRlbXBTZWdtZW50ID0gbmV3IExpbmVTZWdtZW50KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB0ZW1wU2VnbWVudC5zZXRDb29yZGluYXRlcyhjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0pO1xuICAgICAgdmFyIGNsb3Nlc3RQdCA9IHRlbXBTZWdtZW50LmNsb3Nlc3RQb2ludChwdCk7XG4gICAgICBwdERpc3Quc2V0TWluaW11bShjbG9zZXN0UHQsIHB0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFBvbHlnb24gJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgcG9seSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0JDEgPSBhcmd1bWVudHNbMl07XG4gICAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZShwb2x5LmdldEV4dGVyaW9yUmluZygpLCBwdCQxLCBwdERpc3QkMSk7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSQxKyspIHtcbiAgICAgIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UocG9seS5nZXRJbnRlcmlvclJpbmdOKGkkMSksIHB0JDEsIHB0RGlzdCQxKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCQyID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChnZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgICAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZShnZW9tLCBwdCQyLCBwdERpc3QkMik7XG4gICAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgICAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZShnZW9tLCBwdCQyLCBwdERpc3QkMik7XG4gICAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZ2MgPSBnZW9tO1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgZ2MuZ2V0TnVtR2VvbWV0cmllcygpOyBpJDIrKykge1xuICAgICAgICB2YXIgZyA9IGdjLmdldEdlb21ldHJ5TihpJDIpO1xuICAgICAgICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKGcsIHB0JDIsIHB0RGlzdCQyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHREaXN0JDIuc2V0TWluaW11bShnZW9tLmdldENvb3JkaW5hdGUoKSwgcHQkMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU2VnbWVudCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBzZWdtZW50ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY2xvc2VzdFB0JDEgPSBzZWdtZW50LmNsb3Nlc3RQb2ludChwdCQzKTtcbiAgICBwdERpc3QkMy5zZXRNaW5pbXVtKGNsb3Nlc3RQdCQxLCBwdCQzKTtcbiAgfVxufTtcblxudmFyIEJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyID0gZnVuY3Rpb24gQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIgKGlucHV0R2VvbSkge1xuICB0aGlzLl9tYXhQdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UoKTtcbiAgdGhpcy5faW5wdXRHZW9tID0gaW5wdXRHZW9tIHx8IG51bGw7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDM2ID0geyBNYXhQb2ludERpc3RhbmNlRmlsdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyLnByb3RvdHlwZS5jb21wdXRlTWF4TWlkcG9pbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVNYXhNaWRwb2ludERpc3RhbmNlIChjdXJ2ZSkge1xuICB2YXIgZGlzdEZpbHRlciA9IG5ldyBNYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyKHRoaXMuX2lucHV0R2VvbSk7XG4gIGN1cnZlLmFwcGx5KGRpc3RGaWx0ZXIpO1xuICB0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bShkaXN0RmlsdGVyLmdldE1heFBvaW50RGlzdGFuY2UoKSk7XG59O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmNvbXB1dGVNYXhWZXJ0ZXhEaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVNYXhWZXJ0ZXhEaXN0YW5jZSAoY3VydmUpIHtcbiAgdmFyIGRpc3RGaWx0ZXIgPSBuZXcgTWF4UG9pbnREaXN0YW5jZUZpbHRlcih0aGlzLl9pbnB1dEdlb20pO1xuICBjdXJ2ZS5hcHBseShkaXN0RmlsdGVyKTtcbiAgdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0oZGlzdEZpbHRlci5nZXRNYXhQb2ludERpc3RhbmNlKCkpO1xufTtcbkJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyLnByb3RvdHlwZS5maW5kRGlzdGFuY2UgPSBmdW5jdGlvbiBmaW5kRGlzdGFuY2UgKGJ1ZmZlckN1cnZlKSB7XG4gIHRoaXMuY29tcHV0ZU1heFZlcnRleERpc3RhbmNlKGJ1ZmZlckN1cnZlKTtcbiAgdGhpcy5jb21wdXRlTWF4TWlkcG9pbnREaXN0YW5jZShidWZmZXJDdXJ2ZSk7XG4gIHJldHVybiB0aGlzLl9tYXhQdERpc3QuZ2V0RGlzdGFuY2UoKVxufTtcbkJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyLnByb3RvdHlwZS5nZXREaXN0YW5jZVBvaW50cyA9IGZ1bmN0aW9uIGdldERpc3RhbmNlUG9pbnRzICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heFB0RGlzdFxufTtcbkJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXJcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzYuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXhQb2ludERpc3RhbmNlRmlsdGVyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzYuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlciwgc3RhdGljQWNjZXNzb3JzJDM2ICk7XG5cbnZhciBNYXhQb2ludERpc3RhbmNlRmlsdGVyID0gZnVuY3Rpb24gTWF4UG9pbnREaXN0YW5jZUZpbHRlciAoZ2VvbSkge1xuICB0aGlzLl9tYXhQdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UoKTtcbiAgdGhpcy5fbWluUHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlKCk7XG4gIHRoaXMuX2dlb20gPSBnZW9tIHx8IG51bGw7XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChwdCkge1xuICB0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpO1xuICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sIHB0LCB0aGlzLl9taW5QdERpc3QpO1xuICB0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpO1xufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmdldE1heFBvaW50RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRNYXhQb2ludERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heFB0RGlzdFxufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nvb3JkaW5hdGVGaWx0ZXJdXG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNYXhQb2ludERpc3RhbmNlRmlsdGVyXG59O1xuXG52YXIgTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlciA9IGZ1bmN0aW9uIE1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIgKGdlb20pIHtcbiAgdGhpcy5fbWF4UHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlKCk7XG4gIHRoaXMuX21pblB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSgpO1xuICB0aGlzLl9nZW9tID0gZ2VvbSB8fCBudWxsO1xufTtcbk1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoc2VxLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IDApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcDAgPSBzZXEuZ2V0Q29vcmRpbmF0ZShpbmRleCAtIDEpO1xuICB2YXIgcDEgPSBzZXEuZ2V0Q29vcmRpbmF0ZShpbmRleCk7XG4gIHZhciBtaWRQdCA9IG5ldyBDb29yZGluYXRlKChwMC54ICsgcDEueCkgLyAyLCAocDAueSArIHAxLnkpIC8gMik7XG4gIHRoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCk7XG4gIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSwgbWlkUHQsIHRoaXMuX21pblB0RGlzdCk7XG4gIHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCk7XG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaXNHZW9tZXRyeUNoYW5nZWQgPSBmdW5jdGlvbiBpc0dlb21ldHJ5Q2hhbmdlZCAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcbk1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmdldE1heFBvaW50RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRNYXhQb2ludERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heFB0RGlzdFxufTtcbk1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcl1cbn07XG5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXJcbn07XG5cbnZhciBQb2x5Z29uRXh0cmFjdGVyID0gZnVuY3Rpb24gUG9seWdvbkV4dHJhY3RlciAoY29tcHMpIHtcbiAgdGhpcy5fY29tcHMgPSBjb21wcyB8fCBudWxsO1xufTtcblBvbHlnb25FeHRyYWN0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZ2VvbSkge1xuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHsgdGhpcy5fY29tcHMuYWRkKGdlb20pOyB9XG59O1xuUG9seWdvbkV4dHJhY3Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlGaWx0ZXJdXG59O1xuUG9seWdvbkV4dHJhY3Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2x5Z29uRXh0cmFjdGVyXG59O1xuUG9seWdvbkV4dHJhY3Rlci5nZXRQb2x5Z29ucyA9IGZ1bmN0aW9uIGdldFBvbHlnb25zICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gUG9seWdvbkV4dHJhY3Rlci5nZXRQb2x5Z29ucyhnZW9tLCBuZXcgQXJyYXlMaXN0KCkpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxpc3QgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGdlb20kMSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICAgIGxpc3QuYWRkKGdlb20kMSk7XG4gICAgfSBlbHNlIGlmIChnZW9tJDEgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICAgIGdlb20kMS5hcHBseShuZXcgUG9seWdvbkV4dHJhY3RlcihsaXN0KSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0XG4gIH1cbn07XG5cbnZhciBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIgPSBmdW5jdGlvbiBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIgKCkge1xuICB0aGlzLl9saW5lcyA9IG51bGw7XG4gIHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nID0gZmFsc2U7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxpbmVzID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX2xpbmVzID0gbGluZXM7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBsaW5lcyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBpc0ZvcmNlZFRvTGluZVN0cmluZyA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9saW5lcyA9IGxpbmVzJDE7XG4gICAgdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcgPSBpc0ZvcmNlZFRvTGluZVN0cmluZztcbiAgfVxufTtcbkxpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7XG4gIGlmICh0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZyAmJiBnZW9tIGluc3RhbmNlb2YgTGluZWFyUmluZykge1xuICAgIHZhciBsaW5lID0gZ2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhnZW9tLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTtcbiAgICB0aGlzLl9saW5lcy5hZGQobGluZSk7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHsgdGhpcy5fbGluZXMuYWRkKGdlb20pOyB9XG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLnByb3RvdHlwZS5zZXRGb3JjZVRvTGluZVN0cmluZyA9IGZ1bmN0aW9uIHNldEZvcmNlVG9MaW5lU3RyaW5nIChpc0ZvcmNlZFRvTGluZVN0cmluZykge1xuICB0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZyA9IGlzRm9yY2VkVG9MaW5lU3RyaW5nO1xufTtcbkxpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlDb21wb25lbnRGaWx0ZXJdXG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExpbmVhckNvbXBvbmVudEV4dHJhY3RlclxufTtcbkxpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gZ2VvbS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMoZ2VvbSkpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGZvcmNlVG9MaW5lU3RyaW5nID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiBnZW9tJDEuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKGdlb20kMSwgZm9yY2VUb0xpbmVTdHJpbmcpKVxuICB9XG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzID0gZnVuY3Rpb24gZ2V0TGluZXMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMoZ2VvbSwgZmFsc2UpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb2xsZWN0aW9uKSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBDb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGdlb21zID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxpbmVzJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICBmb3IgKHZhciBpID0gZ2VvbXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBnID0gaS5uZXh0KCk7XG4gICAgICAgIExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnLCBsaW5lcyQxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcyQxXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnYm9vbGVhbicpIHtcbiAgICAgIHZhciBnZW9tJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZm9yY2VUb0xpbmVTdHJpbmcgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbGluZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgICBnZW9tJDEuYXBwbHkobmV3IExpbmVhckNvbXBvbmVudEV4dHJhY3RlcihsaW5lcywgZm9yY2VUb0xpbmVTdHJpbmcpKTtcbiAgICAgIHJldHVybiBsaW5lc1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgQ29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBnZW9tJDIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGluZXMkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChnZW9tJDIgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgICAgIGxpbmVzJDIuYWRkKGdlb20kMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW9tJDIuYXBwbHkobmV3IExpbmVhckNvbXBvbmVudEV4dHJhY3RlcihsaW5lcyQyKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXMkMlxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdib29sZWFuJyAmJiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgQ29sbGVjdGlvbikpKSB7XG4gICAgICB2YXIgZ2VvbXMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lcyQzID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGZvcmNlVG9MaW5lU3RyaW5nJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICBmb3IgKHZhciBpJDEgPSBnZW9tcyQxLml0ZXJhdG9yKCk7IGkkMS5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBnJDEgPSBpJDEubmV4dCgpO1xuICAgICAgICBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMoZyQxLCBsaW5lcyQzLCBmb3JjZVRvTGluZVN0cmluZyQxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcyQzXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnYm9vbGVhbicgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIENvbGxlY3Rpb24pKSkge1xuICAgICAgdmFyIGdlb20kMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lcyQ0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGZvcmNlVG9MaW5lU3RyaW5nJDIgPSBhcmd1bWVudHNbMl07XG4gICAgICBnZW9tJDMuYXBwbHkobmV3IExpbmVhckNvbXBvbmVudEV4dHJhY3RlcihsaW5lcyQ0LCBmb3JjZVRvTGluZVN0cmluZyQyKSk7XG4gICAgICByZXR1cm4gbGluZXMkNFxuICAgIH1cbiAgfVxufTtcblxudmFyIFBvaW50TG9jYXRvciA9IGZ1bmN0aW9uIFBvaW50TG9jYXRvciAoKSB7XG4gIHRoaXMuX2JvdW5kYXJ5UnVsZSA9IEJvdW5kYXJ5Tm9kZVJ1bGUuT0dDX1NGU19CT1VOREFSWV9SVUxFO1xuICB0aGlzLl9pc0luID0gbnVsbDtcbiAgdGhpcy5fbnVtQm91bmRhcmllcyA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGJvdW5kYXJ5UnVsZSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoYm91bmRhcnlSdWxlID09PSBudWxsKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1J1bGUgbXVzdCBiZSBub24tbnVsbCcpIH1cbiAgICB0aGlzLl9ib3VuZGFyeVJ1bGUgPSBib3VuZGFyeVJ1bGU7XG4gIH1cbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLmxvY2F0ZUludGVybmFsID0gZnVuY3Rpb24gbG9jYXRlSW50ZXJuYWwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcG9seSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAocG9seS5pc0VtcHR5KCkpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgICB2YXIgc2hlbGwgPSBwb2x5LmdldEV4dGVyaW9yUmluZygpO1xuICAgIHZhciBzaGVsbExvYyA9IHRoaXMubG9jYXRlSW5Qb2x5Z29uUmluZyhwLCBzaGVsbCk7XG4gICAgaWYgKHNoZWxsTG9jID09PSBMb2NhdGlvbi5FWFRFUklPUikgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICAgIGlmIChzaGVsbExvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgcmV0dXJuIExvY2F0aW9uLkJPVU5EQVJZIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkrKykge1xuICAgICAgdmFyIGhvbGUgPSBwb2x5LmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgICB2YXIgaG9sZUxvYyA9IHRoaXMkMS5sb2NhdGVJblBvbHlnb25SaW5nKHAsIGhvbGUpO1xuICAgICAgaWYgKGhvbGVMb2MgPT09IExvY2F0aW9uLklOVEVSSU9SKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gICAgICBpZiAoaG9sZUxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgcmV0dXJuIExvY2F0aW9uLkJPVU5EQVJZIH1cbiAgICB9XG4gICAgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgdmFyIHAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbCA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoIWwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMocCQxKSkgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICAgIHZhciBwdCA9IGwuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAoIWwuaXNDbG9zZWQoKSkge1xuICAgICAgaWYgKHAkMS5lcXVhbHMocHRbMF0pIHx8IHAkMS5lcXVhbHMocHRbcHQubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHJldHVybiBMb2NhdGlvbi5CT1VOREFSWVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQ0dBbGdvcml0aG1zLmlzT25MaW5lKHAkMSwgcHQpKSB7IHJldHVybiBMb2NhdGlvbi5JTlRFUklPUiB9XG4gICAgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBQb2ludCkge1xuICAgIHZhciBwJDIgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0Q29vcmQgPSBwdCQxLmdldENvb3JkaW5hdGUoKTtcbiAgICBpZiAocHRDb29yZC5lcXVhbHMyRChwJDIpKSB7IHJldHVybiBMb2NhdGlvbi5JTlRFUklPUiB9XG4gICAgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SXG4gIH1cbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLmxvY2F0ZUluUG9seWdvblJpbmcgPSBmdW5jdGlvbiBsb2NhdGVJblBvbHlnb25SaW5nIChwLCByaW5nKSB7XG4gIGlmICghcmluZy5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhwKSkgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICByZXR1cm4gQ0dBbGdvcml0aG1zLmxvY2F0ZVBvaW50SW5SaW5nKHAsIHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSlcbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiBpbnRlcnNlY3RzIChwLCBnZW9tKSB7XG4gIHJldHVybiB0aGlzLmxvY2F0ZShwLCBnZW9tKSAhPT0gTG9jYXRpb24uRVhURVJJT1Jcbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLnVwZGF0ZUxvY2F0aW9uSW5mbyA9IGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uSW5mbyAobG9jKSB7XG4gIGlmIChsb2MgPT09IExvY2F0aW9uLklOVEVSSU9SKSB7IHRoaXMuX2lzSW4gPSB0cnVlOyB9XG4gIGlmIChsb2MgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IHRoaXMuX251bUJvdW5kYXJpZXMrKzsgfVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUuY29tcHV0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY29tcHV0ZUxvY2F0aW9uIChwLCBnZW9tKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2ludCkge1xuICAgIHRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwocCwgZ2VvbSkpO1xuICB9XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgIHRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwocCwgZ2VvbSkpO1xuICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbChwLCBnZW9tKSk7XG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIE11bHRpTGluZVN0cmluZykge1xuICAgIHZhciBtbCA9IGdlb207XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtbC5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgICAgdmFyIGwgPSBtbC5nZXRHZW9tZXRyeU4oaSk7XG4gICAgICB0aGlzJDEudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMkMS5sb2NhdGVJbnRlcm5hbChwLCBsKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pIHtcbiAgICB2YXIgbXBvbHkgPSBnZW9tO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG1wb2x5LmdldE51bUdlb21ldHJpZXMoKTsgaSQxKyspIHtcbiAgICAgIHZhciBwb2x5ID0gbXBvbHkuZ2V0R2VvbWV0cnlOKGkkMSk7XG4gICAgICB0aGlzJDEudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMkMS5sb2NhdGVJbnRlcm5hbChwLCBwb2x5KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICB2YXIgZ2VvbWkgPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IoZ2VvbSk7XG4gICAgd2hpbGUgKGdlb21pLmhhc05leHQoKSkge1xuICAgICAgdmFyIGcyID0gZ2VvbWkubmV4dCgpO1xuICAgICAgaWYgKGcyICE9PSBnZW9tKSB7IHRoaXMkMS5jb21wdXRlTG9jYXRpb24ocCwgZzIpOyB9XG4gICAgfVxuICB9XG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS5sb2NhdGUgPSBmdW5jdGlvbiBsb2NhdGUgKHAsIGdlb20pIHtcbiAgaWYgKGdlb20uaXNFbXB0eSgpKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmxvY2F0ZUludGVybmFsKHAsIGdlb20pXG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhdGVJbnRlcm5hbChwLCBnZW9tKVxuICB9XG4gIHRoaXMuX2lzSW4gPSBmYWxzZTtcbiAgdGhpcy5fbnVtQm91bmRhcmllcyA9IDA7XG4gIHRoaXMuY29tcHV0ZUxvY2F0aW9uKHAsIGdlb20pO1xuICBpZiAodGhpcy5fYm91bmRhcnlSdWxlLmlzSW5Cb3VuZGFyeSh0aGlzLl9udW1Cb3VuZGFyaWVzKSkgeyByZXR1cm4gTG9jYXRpb24uQk9VTkRBUlkgfVxuICBpZiAodGhpcy5fbnVtQm91bmRhcmllcyA+IDAgfHwgdGhpcy5faXNJbikgeyByZXR1cm4gTG9jYXRpb24uSU5URVJJT1IgfVxuICByZXR1cm4gTG9jYXRpb24uRVhURVJJT1Jcbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9pbnRMb2NhdG9yXG59O1xuXG52YXIgR2VvbWV0cnlMb2NhdGlvbiA9IGZ1bmN0aW9uIEdlb21ldHJ5TG9jYXRpb24gKCkge1xuICB0aGlzLl9jb21wb25lbnQgPSBudWxsO1xuICB0aGlzLl9zZWdJbmRleCA9IG51bGw7XG4gIHRoaXMuX3B0ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCA9IGFyZ3VtZW50c1sxXTtcbiAgICBHZW9tZXRyeUxvY2F0aW9uLmNhbGwodGhpcywgY29tcG9uZW50LCBHZW9tZXRyeUxvY2F0aW9uLklOU0lERV9BUkVBLCBwdCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBjb21wb25lbnQkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2VnSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0JDEgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5fY29tcG9uZW50ID0gY29tcG9uZW50JDE7XG4gICAgdGhpcy5fc2VnSW5kZXggPSBzZWdJbmRleDtcbiAgICB0aGlzLl9wdCA9IHB0JDE7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzggPSB7IElOU0lERV9BUkVBOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5HZW9tZXRyeUxvY2F0aW9uLnByb3RvdHlwZS5pc0luc2lkZUFyZWEgPSBmdW5jdGlvbiBpc0luc2lkZUFyZWEgKCkge1xuICByZXR1cm4gdGhpcy5fc2VnSW5kZXggPT09IEdlb21ldHJ5TG9jYXRpb24uSU5TSURFX0FSRUFcbn07XG5HZW9tZXRyeUxvY2F0aW9uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9wdFxufTtcbkdlb21ldHJ5TG9jYXRpb24ucHJvdG90eXBlLmdldEdlb21ldHJ5Q29tcG9uZW50ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlDb21wb25lbnQgKCkge1xuICByZXR1cm4gdGhpcy5fY29tcG9uZW50XG59O1xuR2VvbWV0cnlMb2NhdGlvbi5wcm90b3R5cGUuZ2V0U2VnbWVudEluZGV4ID0gZnVuY3Rpb24gZ2V0U2VnbWVudEluZGV4ICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NlZ0luZGV4XG59O1xuR2VvbWV0cnlMb2NhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5TG9jYXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlMb2NhdGlvblxufTtcbnN0YXRpY0FjY2Vzc29ycyQzOC5JTlNJREVfQVJFQS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggR2VvbWV0cnlMb2NhdGlvbiwgc3RhdGljQWNjZXNzb3JzJDM4ICk7XG5cbnZhciBQb2ludEV4dHJhY3RlciA9IGZ1bmN0aW9uIFBvaW50RXh0cmFjdGVyIChwdHMpIHtcbiAgdGhpcy5fcHRzID0gcHRzIHx8IG51bGw7XG59O1xuUG9pbnRFeHRyYWN0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZ2VvbSkge1xuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvaW50KSB7IHRoaXMuX3B0cy5hZGQoZ2VvbSk7IH1cbn07XG5Qb2ludEV4dHJhY3Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlGaWx0ZXJdXG59O1xuUG9pbnRFeHRyYWN0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9pbnRFeHRyYWN0ZXJcbn07XG5Qb2ludEV4dHJhY3Rlci5nZXRQb2ludHMgPSBmdW5jdGlvbiBnZXRQb2ludHMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChnZW9tIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgIHJldHVybiBDb2xsZWN0aW9ucy5zaW5nbGV0b25MaXN0KGdlb20pXG4gICAgfVxuICAgIHJldHVybiBQb2ludEV4dHJhY3Rlci5nZXRQb2ludHMoZ2VvbSwgbmV3IEFycmF5TGlzdCgpKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsaXN0ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChnZW9tJDEgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgbGlzdC5hZGQoZ2VvbSQxKTtcbiAgICB9IGVsc2UgaWYgKGdlb20kMSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgICAgZ2VvbSQxLmFwcGx5KG5ldyBQb2ludEV4dHJhY3RlcihsaXN0KSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0XG4gIH1cbn07XG5cbnZhciBDb25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIgPSBmdW5jdGlvbiBDb25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIgKCkge1xuICB0aGlzLl9sb2NhdGlvbnMgPSBudWxsO1xuICB2YXIgbG9jYXRpb25zID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9sb2NhdGlvbnMgPSBsb2NhdGlvbnM7XG59O1xuQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHtcbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2ludCB8fCBnZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZyB8fCBnZW9tIGluc3RhbmNlb2YgUG9seWdvbikgeyB0aGlzLl9sb2NhdGlvbnMuYWRkKG5ldyBHZW9tZXRyeUxvY2F0aW9uKGdlb20sIDAsIGdlb20uZ2V0Q29vcmRpbmF0ZSgpKSk7IH1cbn07XG5Db25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5RmlsdGVyXVxufTtcbkNvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXJcbn07XG5Db25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIuZ2V0TG9jYXRpb25zID0gZnVuY3Rpb24gZ2V0TG9jYXRpb25zIChnZW9tKSB7XG4gIHZhciBsb2NhdGlvbnMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGdlb20uYXBwbHkobmV3IENvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlcihsb2NhdGlvbnMpKTtcbiAgcmV0dXJuIGxvY2F0aW9uc1xufTtcblxudmFyIERpc3RhbmNlT3AgPSBmdW5jdGlvbiBEaXN0YW5jZU9wICgpIHtcbiAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gIHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlID0gMC4wO1xuICB0aGlzLl9wdExvY2F0b3IgPSBuZXcgUG9pbnRMb2NhdG9yKCk7XG4gIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb24gPSBudWxsO1xuICB0aGlzLl9taW5EaXN0YW5jZSA9IERvdWJsZS5NQVhfVkFMVUU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGcwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9nZW9tID0gW2cwLCBnMV07XG4gICAgdGhpcy5fdGVybWluYXRlRGlzdGFuY2UgPSAwLjA7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB0ZXJtaW5hdGVEaXN0YW5jZSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9nZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5fZ2VvbVswXSA9IGcwJDE7XG4gICAgdGhpcy5fZ2VvbVsxXSA9IGcxJDE7XG4gICAgdGhpcy5fdGVybWluYXRlRGlzdGFuY2UgPSB0ZXJtaW5hdGVEaXN0YW5jZTtcbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIGxvY1B0UG9seSA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICAgIHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMCwgbG9jUHRQb2x5KTtcbiAgICBpZiAodGhpcy5fbWluRGlzdGFuY2UgPD0gdGhpcy5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgIHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMSwgbG9jUHRQb2x5KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHBvbHlHZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvY1B0UG9seSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsb2NhdGlvbnNJbmRleCA9IDEgLSBwb2x5R2VvbUluZGV4O1xuICAgIHZhciBwb2x5cyA9IFBvbHlnb25FeHRyYWN0ZXIuZ2V0UG9seWdvbnModGhpcy5fZ2VvbVtwb2x5R2VvbUluZGV4XSk7XG4gICAgaWYgKHBvbHlzLnNpemUoKSA+IDApIHtcbiAgICAgIHZhciBpbnNpZGVMb2NzID0gQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyLmdldExvY2F0aW9ucyh0aGlzLl9nZW9tW2xvY2F0aW9uc0luZGV4XSk7XG4gICAgICB0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKGluc2lkZUxvY3MsIHBvbHlzLCBsb2NQdFBvbHkkMSk7XG4gICAgICBpZiAodGhpcy5fbWluRGlzdGFuY2UgPD0gdGhpcy5fdGVybWluYXRlRGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbltsb2NhdGlvbnNJbmRleF0gPSBsb2NQdFBvbHkkMVswXTtcbiAgICAgICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbltwb2x5R2VvbUluZGV4XSA9IGxvY1B0UG9seSQxWzFdO1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIEFycmF5ICYmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBMaXN0KSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBMaXN0KSkpIHtcbiAgICAgIHZhciBsb2NzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHBvbHlzJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbG9jUHRQb2x5JDIgPSBhcmd1bWVudHNbMl07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3Muc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgdmFyIGxvYyA9IGxvY3MuZ2V0KGkpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvbHlzJDEuc2l6ZSgpOyBqKyspIHtcbiAgICAgICAgICB0aGlzJDEuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UobG9jLCBwb2x5cyQxLmdldChqKSwgbG9jUHRQb2x5JDIpO1xuICAgICAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBBcnJheSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnlMb2NhdGlvbiAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBQb2x5Z29uKSkge1xuICAgICAgdmFyIHB0TG9jID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHBvbHkgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbG9jUHRQb2x5JDMgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgcHQgPSBwdExvYy5nZXRDb29yZGluYXRlKCk7XG4gICAgICBpZiAoTG9jYXRpb24uRVhURVJJT1IgIT09IHRoaXMuX3B0TG9jYXRvci5sb2NhdGUocHQsIHBvbHkpKSB7XG4gICAgICAgIHRoaXMuX21pbkRpc3RhbmNlID0gMC4wO1xuICAgICAgICBsb2NQdFBvbHkkM1swXSA9IHB0TG9jO1xuICAgICAgICBsb2NQdFBvbHkkM1sxXSA9IG5ldyBHZW9tZXRyeUxvY2F0aW9uKHBvbHksIHB0KTtcblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzID0gZnVuY3Rpb24gY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMgKGxpbmVzLCBwb2ludHMsIGxvY0dlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lcy5nZXQoaSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludHMuc2l6ZSgpOyBqKyspIHtcbiAgICAgIHZhciBwdCA9IHBvaW50cy5nZXQoaik7XG4gICAgICB0aGlzJDEuY29tcHV0ZU1pbkRpc3RhbmNlKGxpbmUsIHB0LCBsb2NHZW9tKTtcbiAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgIH1cbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmNvbXB1dGVGYWNldERpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZUZhY2V0RGlzdGFuY2UgKCkge1xuICB2YXIgbG9jR2VvbSA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICB2YXIgbGluZXMwID0gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKHRoaXMuX2dlb21bMF0pO1xuICB2YXIgbGluZXMxID0gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKHRoaXMuX2dlb21bMV0pO1xuICB2YXIgcHRzMCA9IFBvaW50RXh0cmFjdGVyLmdldFBvaW50cyh0aGlzLl9nZW9tWzBdKTtcbiAgdmFyIHB0czEgPSBQb2ludEV4dHJhY3Rlci5nZXRQb2ludHModGhpcy5fZ2VvbVsxXSk7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXMobGluZXMwLCBsaW5lczEsIGxvY0dlb20pO1xuICB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKGxvY0dlb20sIGZhbHNlKTtcbiAgaWYgKHRoaXMuX21pbkRpc3RhbmNlIDw9IHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgbG9jR2VvbVswXSA9IG51bGw7XG4gIGxvY0dlb21bMV0gPSBudWxsO1xuICB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKGxpbmVzMCwgcHRzMSwgbG9jR2VvbSk7XG4gIHRoaXMudXBkYXRlTWluRGlzdGFuY2UobG9jR2VvbSwgZmFsc2UpO1xuICBpZiAodGhpcy5fbWluRGlzdGFuY2UgPD0gdGhpcy5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICBsb2NHZW9tWzBdID0gbnVsbDtcbiAgbG9jR2VvbVsxXSA9IG51bGw7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMobGluZXMxLCBwdHMwLCBsb2NHZW9tKTtcbiAgdGhpcy51cGRhdGVNaW5EaXN0YW5jZShsb2NHZW9tLCB0cnVlKTtcbiAgaWYgKHRoaXMuX21pbkRpc3RhbmNlIDw9IHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgbG9jR2VvbVswXSA9IG51bGw7XG4gIGxvY0dlb21bMV0gPSBudWxsO1xuICB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyhwdHMwLCBwdHMxLCBsb2NHZW9tKTtcbiAgdGhpcy51cGRhdGVNaW5EaXN0YW5jZShsb2NHZW9tLCBmYWxzZSk7XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUubmVhcmVzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIG5lYXJlc3RMb2NhdGlvbnMgKCkge1xuICB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpO1xuICByZXR1cm4gdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLnVwZGF0ZU1pbkRpc3RhbmNlID0gZnVuY3Rpb24gdXBkYXRlTWluRGlzdGFuY2UgKGxvY0dlb20sIGZsaXApIHtcbiAgaWYgKGxvY0dlb21bMF0gPT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZmxpcCkge1xuICAgIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF0gPSBsb2NHZW9tWzFdO1xuICAgIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV0gPSBsb2NHZW9tWzBdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF0gPSBsb2NHZW9tWzBdO1xuICAgIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV0gPSBsb2NHZW9tWzFdO1xuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUubmVhcmVzdFBvaW50cyA9IGZ1bmN0aW9uIG5lYXJlc3RQb2ludHMgKCkge1xuICB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpO1xuICB2YXIgbmVhcmVzdFB0cyA9IFt0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdLmdldENvb3JkaW5hdGUoKSwgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXS5nZXRDb29yZGluYXRlKCldO1xuICByZXR1cm4gbmVhcmVzdFB0c1xufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmNvbXB1dGVNaW5EaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVNaW5EaXN0YW5jZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbiAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbiA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICAgIHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoKTtcbiAgICBpZiAodGhpcy5fbWluRGlzdGFuY2UgPD0gdGhpcy5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgIHRoaXMuY29tcHV0ZUZhY2V0RGlzdGFuY2UoKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIEFycmF5ICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFBvaW50KSkge1xuICAgICAgdmFyIGxpbmUgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcHQgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbG9jR2VvbSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGlmIChsaW5lLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShwdC5nZXRFbnZlbG9wZUludGVybmFsKCkpID4gdGhpcy5fbWluRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgdmFyIGNvb3JkMCA9IGxpbmUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHZhciBjb29yZCA9IHB0LmdldENvb3JkaW5hdGUoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmQwLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShjb29yZCwgY29vcmQwW2ldLCBjb29yZDBbaSArIDFdKTtcbiAgICAgICAgaWYgKGRpc3QgPCB0aGlzJDEuX21pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgdGhpcyQxLl9taW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgdmFyIHNlZyA9IG5ldyBMaW5lU2VnbWVudChjb29yZDBbaV0sIGNvb3JkMFtpICsgMV0pO1xuICAgICAgICAgIHZhciBzZWdDbG9zZXN0UG9pbnQgPSBzZWcuY2xvc2VzdFBvaW50KGNvb3JkKTtcbiAgICAgICAgICBsb2NHZW9tWzBdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24obGluZSwgaSwgc2VnQ2xvc2VzdFBvaW50KTtcbiAgICAgICAgICBsb2NHZW9tWzFdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24ocHQsIDAsIGNvb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyQxLl9taW5EaXN0YW5jZSA8PSB0aGlzJDEuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIEFycmF5ICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpKSB7XG4gICAgICB2YXIgbGluZTAgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGluZTEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbG9jR2VvbSQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgaWYgKGxpbmUwLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShsaW5lMS5nZXRFbnZlbG9wZUludGVybmFsKCkpID4gdGhpcy5fbWluRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgdmFyIGNvb3JkMCQxID0gbGluZTAuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHZhciBjb29yZDEgPSBsaW5lMS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY29vcmQwJDEubGVuZ3RoIC0gMTsgaSQxKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb29yZDEubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgdmFyIGRpc3QkMSA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZUxpbmVMaW5lKGNvb3JkMCQxW2kkMV0sIGNvb3JkMCQxW2kkMSArIDFdLCBjb29yZDFbal0sIGNvb3JkMVtqICsgMV0pO1xuICAgICAgICAgIGlmIChkaXN0JDEgPCB0aGlzJDEuX21pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzJDEuX21pbkRpc3RhbmNlID0gZGlzdCQxO1xuICAgICAgICAgICAgdmFyIHNlZzAgPSBuZXcgTGluZVNlZ21lbnQoY29vcmQwJDFbaSQxXSwgY29vcmQwJDFbaSQxICsgMV0pO1xuICAgICAgICAgICAgdmFyIHNlZzEgPSBuZXcgTGluZVNlZ21lbnQoY29vcmQxW2pdLCBjb29yZDFbaiArIDFdKTtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0UHQgPSBzZWcwLmNsb3Nlc3RQb2ludHMoc2VnMSk7XG4gICAgICAgICAgICBsb2NHZW9tJDFbMF0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihsaW5lMCwgaSQxLCBjbG9zZXN0UHRbMF0pO1xuICAgICAgICAgICAgbG9jR2VvbSQxWzFdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24obGluZTEsIGosIGNsb3Nlc3RQdFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzID0gZnVuY3Rpb24gY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzIChwb2ludHMwLCBwb2ludHMxLCBsb2NHZW9tKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMwLnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIHB0MCA9IHBvaW50czAuZ2V0KGkpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzMS5zaXplKCk7IGorKykge1xuICAgICAgdmFyIHB0MSA9IHBvaW50czEuZ2V0KGopO1xuICAgICAgdmFyIGRpc3QgPSBwdDAuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKHB0MS5nZXRDb29yZGluYXRlKCkpO1xuICAgICAgaWYgKGRpc3QgPCB0aGlzJDEuX21pbkRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMkMS5fbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICBsb2NHZW9tWzBdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24ocHQwLCAwLCBwdDAuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICAgICAgbG9jR2VvbVsxXSA9IG5ldyBHZW9tZXRyeUxvY2F0aW9uKHB0MSwgMCwgcHQxLmdldENvb3JkaW5hdGUoKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcyQxLl9taW5EaXN0YW5jZSA8PSB0aGlzJDEuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICB9XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlICgpIHtcbiAgaWYgKHRoaXMuX2dlb21bMF0gPT09IG51bGwgfHwgdGhpcy5fZ2VvbVsxXSA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdudWxsIGdlb21ldHJpZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKSB9XG4gIGlmICh0aGlzLl9nZW9tWzBdLmlzRW1wdHkoKSB8fCB0aGlzLl9nZW9tWzFdLmlzRW1wdHkoKSkgeyByZXR1cm4gMC4wIH1cbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKTtcbiAgcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlXG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXMgPSBmdW5jdGlvbiBjb21wdXRlTWluRGlzdGFuY2VMaW5lcyAobGluZXMwLCBsaW5lczEsIGxvY0dlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzMC5zaXplKCk7IGkrKykge1xuICAgIHZhciBsaW5lMCA9IGxpbmVzMC5nZXQoaSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lczEuc2l6ZSgpOyBqKyspIHtcbiAgICAgIHZhciBsaW5lMSA9IGxpbmVzMS5nZXQoaik7XG4gICAgICB0aGlzJDEuY29tcHV0ZU1pbkRpc3RhbmNlKGxpbmUwLCBsaW5lMSwgbG9jR2VvbSk7XG4gICAgICBpZiAodGhpcyQxLl9taW5EaXN0YW5jZSA8PSB0aGlzJDEuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICB9XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEaXN0YW5jZU9wXG59O1xuRGlzdGFuY2VPcC5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlIChnMCwgZzEpIHtcbiAgdmFyIGRpc3RPcCA9IG5ldyBEaXN0YW5jZU9wKGcwLCBnMSk7XG4gIHJldHVybiBkaXN0T3AuZGlzdGFuY2UoKVxufTtcbkRpc3RhbmNlT3AuaXNXaXRoaW5EaXN0YW5jZSA9IGZ1bmN0aW9uIGlzV2l0aGluRGlzdGFuY2UgKGcwLCBnMSwgZGlzdGFuY2UpIHtcbiAgdmFyIGRpc3RPcCA9IG5ldyBEaXN0YW5jZU9wKGcwLCBnMSwgZGlzdGFuY2UpO1xuICByZXR1cm4gZGlzdE9wLmRpc3RhbmNlKCkgPD0gZGlzdGFuY2Vcbn07XG5EaXN0YW5jZU9wLm5lYXJlc3RQb2ludHMgPSBmdW5jdGlvbiBuZWFyZXN0UG9pbnRzIChnMCwgZzEpIHtcbiAgdmFyIGRpc3RPcCA9IG5ldyBEaXN0YW5jZU9wKGcwLCBnMSk7XG4gIHJldHVybiBkaXN0T3AubmVhcmVzdFBvaW50cygpXG59O1xuXG52YXIgUG9pbnRQYWlyRGlzdGFuY2UkMiA9IGZ1bmN0aW9uIFBvaW50UGFpckRpc3RhbmNlICgpIHtcbiAgdGhpcy5fcHQgPSBbbmV3IENvb3JkaW5hdGUoKSwgbmV3IENvb3JkaW5hdGUoKV07XG4gIHRoaXMuX2Rpc3RhbmNlID0gRG91YmxlLk5hTjtcbiAgdGhpcy5faXNOdWxsID0gdHJ1ZTtcbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgcmV0dXJuIHRoaXMuX3B0W2ldXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuc2V0TWluaW11bSA9IGZ1bmN0aW9uIHNldE1pbmltdW0gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwdERpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRNaW5pbXVtKHB0RGlzdC5fcHRbMF0sIHB0RGlzdC5fcHRbMV0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLl9pc051bGwpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdmFyIGRpc3QgPSBwMC5kaXN0YW5jZShwMSk7XG4gICAgaWYgKGRpc3QgPCB0aGlzLl9kaXN0YW5jZSkgeyB0aGlzLmluaXRpYWxpemUocDAsIHAxLCBkaXN0KTsgfVxuICB9XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIGluaXRpYWxpemUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2lzTnVsbCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZShwMCk7XG4gICAgdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShwMSk7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBwMC5kaXN0YW5jZShwMSk7XG4gICAgdGhpcy5faXNOdWxsID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBwMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkaXN0YW5jZSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHAwJDEpO1xuICAgIHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUocDEkMSk7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB0aGlzLl9pc051bGwgPSBmYWxzZTtcbiAgfVxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gV0tUV3JpdGVyLnRvTGluZVN0cmluZyh0aGlzLl9wdFswXSwgdGhpcy5fcHRbMV0pXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLl9kaXN0YW5jZVxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLnNldE1heGltdW0gPSBmdW5jdGlvbiBzZXRNYXhpbXVtICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHREaXN0ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0TWF4aW11bShwdERpc3QuX3B0WzBdLCBwdERpc3QuX3B0WzFdKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5faXNOdWxsKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUocDAsIHAxKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHZhciBkaXN0ID0gcDAuZGlzdGFuY2UocDEpO1xuICAgIGlmIChkaXN0ID4gdGhpcy5fZGlzdGFuY2UpIHsgdGhpcy5pbml0aWFsaXplKHAwLCBwMSwgZGlzdCk7IH1cbiAgfVxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvaW50UGFpckRpc3RhbmNlJDJcbn07XG5cbnZhciBEaXN0YW5jZVRvUG9pbnQgPSBmdW5jdGlvbiBEaXN0YW5jZVRvUG9pbnQgKCkge307XG5cbkRpc3RhbmNlVG9Qb2ludC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkRpc3RhbmNlVG9Qb2ludC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEaXN0YW5jZVRvUG9pbnRcbn07XG5EaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZURpc3RhbmNlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlJDIgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgbGluZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgdGVtcFNlZ21lbnQgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgICB2YXIgY29vcmRzID0gbGluZS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdGVtcFNlZ21lbnQuc2V0Q29vcmRpbmF0ZXMoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKTtcbiAgICAgIHZhciBjbG9zZXN0UHQgPSB0ZW1wU2VnbWVudC5jbG9zZXN0UG9pbnQocHQpO1xuICAgICAgcHREaXN0LnNldE1pbmltdW0oY2xvc2VzdFB0LCBwdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlJDIgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFBvbHlnb24gJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgcG9seSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0JDEgPSBhcmd1bWVudHNbMl07XG4gICAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZShwb2x5LmdldEV4dGVyaW9yUmluZygpLCBwdCQxLCBwdERpc3QkMSk7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSQxKyspIHtcbiAgICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UocG9seS5nZXRJbnRlcmlvclJpbmdOKGkkMSksIHB0JDEsIHB0RGlzdCQxKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UkMiAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0JDIgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKGdlb20sIHB0JDIsIHB0RGlzdCQyKTtcbiAgICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKGdlb20sIHB0JDIsIHB0RGlzdCQyKTtcbiAgICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBnYyA9IGdlb207XG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBnYy5nZXROdW1HZW9tZXRyaWVzKCk7IGkkMisrKSB7XG4gICAgICAgIHZhciBnID0gZ2MuZ2V0R2VvbWV0cnlOKGkkMik7XG4gICAgICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UoZywgcHQkMiwgcHREaXN0JDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdERpc3QkMi5zZXRNaW5pbXVtKGdlb20uZ2V0Q29vcmRpbmF0ZSgpLCBwdCQyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UkMiAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVNlZ21lbnQgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgc2VnbWVudCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0JDMgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGNsb3Nlc3RQdCQxID0gc2VnbWVudC5jbG9zZXN0UG9pbnQocHQkMyk7XG4gICAgcHREaXN0JDMuc2V0TWluaW11bShjbG9zZXN0UHQkMSwgcHQkMyk7XG4gIH1cbn07XG5cbnZhciBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlID0gZnVuY3Rpb24gRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZSAoKSB7XG4gIHRoaXMuX2cwID0gbnVsbDtcbiAgdGhpcy5fZzEgPSBudWxsO1xuICB0aGlzLl9wdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9kZW5zaWZ5RnJhYyA9IDAuMDtcbiAgdmFyIGcwID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2cwID0gZzA7XG4gIHRoaXMuX2cxID0gZzE7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDM5ID0geyBNYXhQb2ludERpc3RhbmNlRmlsdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9wdERpc3QuZ2V0Q29vcmRpbmF0ZXMoKVxufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLnNldERlbnNpZnlGcmFjdGlvbiA9IGZ1bmN0aW9uIHNldERlbnNpZnlGcmFjdGlvbiAoZGVuc2lmeUZyYWMpIHtcbiAgaWYgKGRlbnNpZnlGcmFjID4gMS4wIHx8IGRlbnNpZnlGcmFjIDw9IDAuMCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdGcmFjdGlvbiBpcyBub3QgaW4gcmFuZ2UgKDAuMCAtIDEuMF0nKSB9XG4gIHRoaXMuX2RlbnNpZnlGcmFjID0gZGVuc2lmeUZyYWM7XG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuY29tcHV0ZSA9IGZ1bmN0aW9uIGNvbXB1dGUgKGcwLCBnMSkge1xuICB0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKGcwLCBnMSwgdGhpcy5fcHREaXN0KTtcbiAgdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZShnMSwgZzAsIHRoaXMuX3B0RGlzdCk7XG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoKSB7XG4gIHRoaXMuY29tcHV0ZSh0aGlzLl9nMCwgdGhpcy5fZzEpO1xuICByZXR1cm4gdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKClcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVPcmllbnRlZERpc3RhbmNlIChkaXNjcmV0ZUdlb20sIGdlb20sIHB0RGlzdCkge1xuICB2YXIgZGlzdEZpbHRlciA9IG5ldyBNYXhQb2ludERpc3RhbmNlRmlsdGVyJDEoZ2VvbSk7XG4gIGRpc2NyZXRlR2VvbS5hcHBseShkaXN0RmlsdGVyKTtcbiAgcHREaXN0LnNldE1heGltdW0oZGlzdEZpbHRlci5nZXRNYXhQb2ludERpc3RhbmNlKCkpO1xuICBpZiAodGhpcy5fZGVuc2lmeUZyYWMgPiAwKSB7XG4gICAgdmFyIGZyYWNGaWx0ZXIgPSBuZXcgTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyKGdlb20sIHRoaXMuX2RlbnNpZnlGcmFjKTtcbiAgICBkaXNjcmV0ZUdlb20uYXBwbHkoZnJhY0ZpbHRlcik7XG4gICAgcHREaXN0LnNldE1heGltdW0oZnJhY0ZpbHRlci5nZXRNYXhQb2ludERpc3RhbmNlKCkpO1xuICB9XG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUub3JpZW50ZWREaXN0YW5jZSA9IGZ1bmN0aW9uIG9yaWVudGVkRGlzdGFuY2UgKCkge1xuICB0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKHRoaXMuX2cwLCB0aGlzLl9nMSwgdGhpcy5fcHREaXN0KTtcbiAgcmV0dXJuIHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpXG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZVxufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGcwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZGlzdCA9IG5ldyBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlKGcwLCBnMSk7XG4gICAgcmV0dXJuIGRpc3QuZGlzdGFuY2UoKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgZzAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZGVuc2lmeUZyYWMgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGRpc3QkMSA9IG5ldyBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlKGcwJDEsIGcxJDEpO1xuICAgIGRpc3QkMS5zZXREZW5zaWZ5RnJhY3Rpb24oZGVuc2lmeUZyYWMpO1xuICAgIHJldHVybiBkaXN0JDEuZGlzdGFuY2UoKVxuICB9XG59O1xuc3RhdGljQWNjZXNzb3JzJDM5Lk1heFBvaW50RGlzdGFuY2VGaWx0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzkuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlciB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZSwgc3RhdGljQWNjZXNzb3JzJDM5ICk7XG5cbnZhciBNYXhQb2ludERpc3RhbmNlRmlsdGVyJDEgPSBmdW5jdGlvbiBNYXhQb2ludERpc3RhbmNlRmlsdGVyICgpIHtcbiAgdGhpcy5fbWF4UHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlJDIoKTtcbiAgdGhpcy5fbWluUHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlJDIoKTtcbiAgdGhpcy5fZXVjbGlkZWFuRGlzdCA9IG5ldyBEaXN0YW5jZVRvUG9pbnQoKTtcbiAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9nZW9tID0gZ2VvbTtcbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyJDEucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAocHQpIHtcbiAgdGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKTtcbiAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLCBwdCwgdGhpcy5fbWluUHREaXN0KTtcbiAgdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KTtcbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyJDEucHJvdG90eXBlLmdldE1heFBvaW50RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRNYXhQb2ludERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heFB0RGlzdFxufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZUZpbHRlcl1cbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyJDEucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxXG59O1xuXG52YXIgTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyID0gZnVuY3Rpb24gTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyICgpIHtcbiAgdGhpcy5fbWF4UHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlJDIoKTtcbiAgdGhpcy5fbWluUHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlJDIoKTtcbiAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gIHRoaXMuX251bVN1YlNlZ3MgPSAwO1xuICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGZyYWN0aW9uID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl9nZW9tID0gZ2VvbTtcbiAgdGhpcy5fbnVtU3ViU2VncyA9IE1hdGgudHJ1bmMoTWF0aC5yb3VuZCgxLjAgLyBmcmFjdGlvbikpO1xufTtcbk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChzZXEsIGluZGV4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGluZGV4ID09PSAwKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHAwID0gc2VxLmdldENvb3JkaW5hdGUoaW5kZXggLSAxKTtcbiAgdmFyIHAxID0gc2VxLmdldENvb3JkaW5hdGUoaW5kZXgpO1xuICB2YXIgZGVseCA9IChwMS54IC0gcDAueCkgLyB0aGlzLl9udW1TdWJTZWdzO1xuICB2YXIgZGVseSA9IChwMS55IC0gcDAueSkgLyB0aGlzLl9udW1TdWJTZWdzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX251bVN1YlNlZ3M7IGkrKykge1xuICAgIHZhciB4ID0gcDAueCArIGkgKiBkZWx4O1xuICAgIHZhciB5ID0gcDAueSArIGkgKiBkZWx5O1xuICAgIHZhciBwdCA9IG5ldyBDb29yZGluYXRlKHgsIHkpO1xuICAgIHRoaXMkMS5fbWluUHREaXN0LmluaXRpYWxpemUoKTtcbiAgICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKHRoaXMkMS5fZ2VvbSwgcHQsIHRoaXMkMS5fbWluUHREaXN0KTtcbiAgICB0aGlzJDEuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMkMS5fbWluUHREaXN0KTtcbiAgfVxufTtcbk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pc0dlb21ldHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDaGFuZ2VkICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5nZXRNYXhQb2ludERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0TWF4UG9pbnREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXhQdERpc3Rcbn07XG5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcl1cbn07XG5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyXG59O1xuXG52YXIgQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IgPSBmdW5jdGlvbiBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvciAoaW5wdXQsIGJ1ZkRpc3RhbmNlLCByZXN1bHQpIHtcbiAgdGhpcy5fbWluVmFsaWREaXN0YW5jZSA9IG51bGw7XG4gIHRoaXMuX21heFZhbGlkRGlzdGFuY2UgPSBudWxsO1xuICB0aGlzLl9taW5EaXN0YW5jZUZvdW5kID0gbnVsbDtcbiAgdGhpcy5fbWF4RGlzdGFuY2VGb3VuZCA9IG51bGw7XG4gIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICB0aGlzLl9lcnJNc2cgPSBudWxsO1xuICB0aGlzLl9lcnJvckxvY2F0aW9uID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSBudWxsO1xuICB0aGlzLl9pbnB1dCA9IGlucHV0IHx8IG51bGw7XG4gIHRoaXMuX2J1ZkRpc3RhbmNlID0gYnVmRGlzdGFuY2UgfHwgbnVsbDtcbiAgdGhpcy5fcmVzdWx0ID0gcmVzdWx0IHx8IG51bGw7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDM3ID0geyBWRVJCT1NFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1BWF9ESVNUQU5DRV9ESUZGX0ZSQUM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja01heGltdW1EaXN0YW5jZSA9IGZ1bmN0aW9uIGNoZWNrTWF4aW11bURpc3RhbmNlIChpbnB1dCwgYnVmQ3VydmUsIG1heERpc3QpIHtcbiAgdmFyIGhhdXMgPSBuZXcgRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZShidWZDdXJ2ZSwgaW5wdXQpO1xuICBoYXVzLnNldERlbnNpZnlGcmFjdGlvbigwLjI1KTtcbiAgdGhpcy5fbWF4RGlzdGFuY2VGb3VuZCA9IGhhdXMub3JpZW50ZWREaXN0YW5jZSgpO1xuICBpZiAodGhpcy5fbWF4RGlzdGFuY2VGb3VuZCA+IG1heERpc3QpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIHB0cyA9IGhhdXMuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB0aGlzLl9lcnJvckxvY2F0aW9uID0gcHRzWzFdO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcocHRzKTtcbiAgICB0aGlzLl9lcnJNc2cgPSAnRGlzdGFuY2UgYmV0d2VlbiBidWZmZXIgY3VydmUgYW5kIGlucHV0IGlzIHRvbyBsYXJnZSAoJyArIHRoaXMuX21heERpc3RhbmNlRm91bmQgKyAnIGF0ICcgKyBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKHB0c1swXSwgcHRzWzFdKSArICcpJztcbiAgfVxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAoKSB7XG4gIHZhciBwb3NEaXN0YW5jZSA9IE1hdGguYWJzKHRoaXMuX2J1ZkRpc3RhbmNlKTtcbiAgdmFyIGRpc3REZWx0YSA9IEJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLk1BWF9ESVNUQU5DRV9ESUZGX0ZSQUMgKiBwb3NEaXN0YW5jZTtcbiAgdGhpcy5fbWluVmFsaWREaXN0YW5jZSA9IHBvc0Rpc3RhbmNlIC0gZGlzdERlbHRhO1xuICB0aGlzLl9tYXhWYWxpZERpc3RhbmNlID0gcG9zRGlzdGFuY2UgKyBkaXN0RGVsdGE7XG4gIGlmICh0aGlzLl9pbnB1dC5pc0VtcHR5KCkgfHwgdGhpcy5fcmVzdWx0LmlzRW1wdHkoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICh0aGlzLl9idWZEaXN0YW5jZSA+IDAuMCkge1xuICAgIHRoaXMuY2hlY2tQb3NpdGl2ZVZhbGlkKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5jaGVja05lZ2F0aXZlVmFsaWQoKTtcbiAgfVxuICBpZiAoQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IuVkVSQk9TRSkge1xuICAgIFN5c3RlbS5vdXQucHJpbnRsbignTWluIERpc3Q9ICcgKyB0aGlzLl9taW5EaXN0YW5jZUZvdW5kICsgJyAgZXJyPSAnICsgKDEuMCAtIHRoaXMuX21pbkRpc3RhbmNlRm91bmQgLyB0aGlzLl9idWZEaXN0YW5jZSkgKyAnICBNYXggRGlzdD0gJyArIHRoaXMuX21heERpc3RhbmNlRm91bmQgKyAnICBlcnI9ICcgKyAodGhpcy5fbWF4RGlzdGFuY2VGb3VuZCAvIHRoaXMuX2J1ZkRpc3RhbmNlIC0gMS4wKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2lzVmFsaWRcbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tOZWdhdGl2ZVZhbGlkID0gZnVuY3Rpb24gY2hlY2tOZWdhdGl2ZVZhbGlkICgpIHtcbiAgaWYgKCEodGhpcy5faW5wdXQgaW5zdGFuY2VvZiBQb2x5Z29uIHx8IHRoaXMuX2lucHV0IGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uIHx8IHRoaXMuX2lucHV0IGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIGlucHV0Q3VydmUgPSB0aGlzLmdldFBvbHlnb25MaW5lcyh0aGlzLl9pbnB1dCk7XG4gIHRoaXMuY2hlY2tNaW5pbXVtRGlzdGFuY2UoaW5wdXRDdXJ2ZSwgdGhpcy5fcmVzdWx0LCB0aGlzLl9taW5WYWxpZERpc3RhbmNlKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5jaGVja01heGltdW1EaXN0YW5jZShpbnB1dEN1cnZlLCB0aGlzLl9yZXN1bHQsIHRoaXMuX21heFZhbGlkRGlzdGFuY2UpO1xufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvckluZGljYXRvciA9IGZ1bmN0aW9uIGdldEVycm9ySW5kaWNhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9ySW5kaWNhdG9yXG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrTWluaW11bURpc3RhbmNlID0gZnVuY3Rpb24gY2hlY2tNaW5pbXVtRGlzdGFuY2UgKGcxLCBnMiwgbWluRGlzdCkge1xuICB2YXIgZGlzdE9wID0gbmV3IERpc3RhbmNlT3AoZzEsIGcyLCBtaW5EaXN0KTtcbiAgdGhpcy5fbWluRGlzdGFuY2VGb3VuZCA9IGRpc3RPcC5kaXN0YW5jZSgpO1xuICBpZiAodGhpcy5fbWluRGlzdGFuY2VGb3VuZCA8IG1pbkRpc3QpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIHB0cyA9IGRpc3RPcC5uZWFyZXN0UG9pbnRzKCk7XG4gICAgdGhpcy5fZXJyb3JMb2NhdGlvbiA9IGRpc3RPcC5uZWFyZXN0UG9pbnRzKClbMV07XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSBnMS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhwdHMpO1xuICAgIHRoaXMuX2Vyck1zZyA9ICdEaXN0YW5jZSBiZXR3ZWVuIGJ1ZmZlciBjdXJ2ZSBhbmQgaW5wdXQgaXMgdG9vIHNtYWxsICgnICsgdGhpcy5fbWluRGlzdGFuY2VGb3VuZCArICcgYXQgJyArIFdLVFdyaXRlci50b0xpbmVTdHJpbmcocHRzWzBdLCBwdHNbMV0pICsgJyApJztcbiAgfVxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja1Bvc2l0aXZlVmFsaWQgPSBmdW5jdGlvbiBjaGVja1Bvc2l0aXZlVmFsaWQgKCkge1xuICB2YXIgYnVmQ3VydmUgPSB0aGlzLl9yZXN1bHQuZ2V0Qm91bmRhcnkoKTtcbiAgdGhpcy5jaGVja01pbmltdW1EaXN0YW5jZSh0aGlzLl9pbnB1dCwgYnVmQ3VydmUsIHRoaXMuX21pblZhbGlkRGlzdGFuY2UpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLmNoZWNrTWF4aW11bURpc3RhbmNlKHRoaXMuX2lucHV0LCBidWZDdXJ2ZSwgdGhpcy5fbWF4VmFsaWREaXN0YW5jZSk7XG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9yTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRFcnJvckxvY2F0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9yTG9jYXRpb25cbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuZ2V0UG9seWdvbkxpbmVzID0gZnVuY3Rpb24gZ2V0UG9seWdvbkxpbmVzIChnKSB7XG4gIHZhciBsaW5lcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIGxpbmVFeHRyYWN0ZXIgPSBuZXcgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyKGxpbmVzKTtcbiAgdmFyIHBvbHlzID0gUG9seWdvbkV4dHJhY3Rlci5nZXRQb2x5Z29ucyhnKTtcbiAgZm9yICh2YXIgaSA9IHBvbHlzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBwb2x5ID0gaS5uZXh0KCk7XG4gICAgcG9seS5hcHBseShsaW5lRXh0cmFjdGVyKTtcbiAgfVxuICByZXR1cm4gZy5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShsaW5lcylcbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Vyck1zZ1xufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3Jcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzcuVkVSQk9TRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZSB9O1xuc3RhdGljQWNjZXNzb3JzJDM3Lk1BWF9ESVNUQU5DRV9ESUZGX0ZSQUMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMC4wMTIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkMzcgKTtcblxudmFyIEJ1ZmZlclJlc3VsdFZhbGlkYXRvciA9IGZ1bmN0aW9uIEJ1ZmZlclJlc3VsdFZhbGlkYXRvciAoaW5wdXQsIGRpc3RhbmNlLCByZXN1bHQpIHtcbiAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gIHRoaXMuX2Vycm9yTXNnID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JMb2NhdGlvbiA9IG51bGw7XG4gIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gbnVsbDtcbiAgdGhpcy5faW5wdXQgPSBpbnB1dCB8fCBudWxsO1xuICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlIHx8IG51bGw7XG4gIHRoaXMuX3Jlc3VsdCA9IHJlc3VsdCB8fCBudWxsO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0MCA9IHsgVkVSQk9TRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNQVhfRU5WX0RJRkZfRlJBQzogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAoKSB7XG4gIHRoaXMuY2hlY2tQb2x5Z29uYWwoKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiB0aGlzLl9pc1ZhbGlkIH1cbiAgdGhpcy5jaGVja0V4cGVjdGVkRW1wdHkoKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiB0aGlzLl9pc1ZhbGlkIH1cbiAgdGhpcy5jaGVja0VudmVsb3BlKCk7XG4gIGlmICghdGhpcy5faXNWYWxpZCkgeyByZXR1cm4gdGhpcy5faXNWYWxpZCB9XG4gIHRoaXMuY2hlY2tBcmVhKCk7XG4gIGlmICghdGhpcy5faXNWYWxpZCkgeyByZXR1cm4gdGhpcy5faXNWYWxpZCB9XG4gIHRoaXMuY2hlY2tEaXN0YW5jZSgpO1xuICByZXR1cm4gdGhpcy5faXNWYWxpZFxufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tFbnZlbG9wZSA9IGZ1bmN0aW9uIGNoZWNrRW52ZWxvcGUgKCkge1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPCAwLjApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcGFkZGluZyA9IHRoaXMuX2Rpc3RhbmNlICogQnVmZmVyUmVzdWx0VmFsaWRhdG9yLk1BWF9FTlZfRElGRl9GUkFDO1xuICBpZiAocGFkZGluZyA9PT0gMC4wKSB7IHBhZGRpbmcgPSAwLjAwMTsgfVxuICB2YXIgZXhwZWN0ZWRFbnYgPSBuZXcgRW52ZWxvcGUodGhpcy5faW5wdXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtcbiAgZXhwZWN0ZWRFbnYuZXhwYW5kQnkodGhpcy5fZGlzdGFuY2UpO1xuICB2YXIgYnVmRW52ID0gbmV3IEVudmVsb3BlKHRoaXMuX3Jlc3VsdC5nZXRFbnZlbG9wZUludGVybmFsKCkpO1xuICBidWZFbnYuZXhwYW5kQnkocGFkZGluZyk7XG4gIGlmICghYnVmRW52LmNvbnRhaW5zKGV4cGVjdGVkRW52KSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvck1zZyA9ICdCdWZmZXIgZW52ZWxvcGUgaXMgaW5jb3JyZWN0JztcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IHRoaXMuX2lucHV0LmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KGJ1ZkVudik7XG4gIH1cbiAgdGhpcy5yZXBvcnQoJ0VudmVsb3BlJyk7XG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0Rpc3RhbmNlID0gZnVuY3Rpb24gY2hlY2tEaXN0YW5jZSAoKSB7XG4gIHZhciBkaXN0VmFsaWQgPSBuZXcgQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IodGhpcy5faW5wdXQsIHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl9yZXN1bHQpO1xuICBpZiAoIWRpc3RWYWxpZC5pc1ZhbGlkKCkpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5fZXJyb3JNc2cgPSBkaXN0VmFsaWQuZ2V0RXJyb3JNZXNzYWdlKCk7XG4gICAgdGhpcy5fZXJyb3JMb2NhdGlvbiA9IGRpc3RWYWxpZC5nZXRFcnJvckxvY2F0aW9uKCk7XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSBkaXN0VmFsaWQuZ2V0RXJyb3JJbmRpY2F0b3IoKTtcbiAgfVxuICB0aGlzLnJlcG9ydCgnRGlzdGFuY2UnKTtcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrQXJlYSA9IGZ1bmN0aW9uIGNoZWNrQXJlYSAoKSB7XG4gIHZhciBpbnB1dEFyZWEgPSB0aGlzLl9pbnB1dC5nZXRBcmVhKCk7XG4gIHZhciByZXN1bHRBcmVhID0gdGhpcy5fcmVzdWx0LmdldEFyZWEoKTtcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlID4gMC4wICYmIGlucHV0QXJlYSA+IHJlc3VsdEFyZWEpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5fZXJyb3JNc2cgPSAnQXJlYSBvZiBwb3NpdGl2ZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIGlucHV0JztcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IHRoaXMuX3Jlc3VsdDtcbiAgfVxuICBpZiAodGhpcy5fZGlzdGFuY2UgPCAwLjAgJiYgaW5wdXRBcmVhIDwgcmVzdWx0QXJlYSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvck1zZyA9ICdBcmVhIG9mIG5lZ2F0aXZlIGJ1ZmZlciBpcyBsYXJnZXIgdGhhbiBpbnB1dCc7XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSB0aGlzLl9yZXN1bHQ7XG4gIH1cbiAgdGhpcy5yZXBvcnQoJ0FyZWEnKTtcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrUG9seWdvbmFsID0gZnVuY3Rpb24gY2hlY2tQb2x5Z29uYWwgKCkge1xuICBpZiAoISh0aGlzLl9yZXN1bHQgaW5zdGFuY2VvZiBQb2x5Z29uIHx8IHRoaXMuX3Jlc3VsdCBpbnN0YW5jZW9mIE11bHRpUG9seWdvbikpIHsgdGhpcy5faXNWYWxpZCA9IGZhbHNlOyB9XG4gIHRoaXMuX2Vycm9yTXNnID0gJ1Jlc3VsdCBpcyBub3QgcG9seWdvbmFsJztcbiAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSB0aGlzLl9yZXN1bHQ7XG4gIHRoaXMucmVwb3J0KCdQb2x5Z29uYWwnKTtcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9ySW5kaWNhdG9yID0gZnVuY3Rpb24gZ2V0RXJyb3JJbmRpY2F0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JJbmRpY2F0b3Jcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9yTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRFcnJvckxvY2F0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9yTG9jYXRpb25cbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrRXhwZWN0ZWRFbXB0eSA9IGZ1bmN0aW9uIGNoZWNrRXhwZWN0ZWRFbXB0eSAoKSB7XG4gIGlmICh0aGlzLl9pbnB1dC5nZXREaW1lbnNpb24oKSA+PSAyKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKHRoaXMuX2Rpc3RhbmNlID4gMC4wKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKCF0aGlzLl9yZXN1bHQuaXNFbXB0eSgpKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yTXNnID0gJ1Jlc3VsdCBpcyBub24tZW1wdHknO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gdGhpcy5fcmVzdWx0O1xuICB9XG4gIHRoaXMucmVwb3J0KCdFeHBlY3RlZEVtcHR5Jyk7XG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5yZXBvcnQgPSBmdW5jdGlvbiByZXBvcnQgKGNoZWNrTmFtZSkge1xuICBpZiAoIUJ1ZmZlclJlc3VsdFZhbGlkYXRvci5WRVJCT1NFKSB7IHJldHVybiBudWxsIH1cbiAgU3lzdGVtLm91dC5wcmludGxuKCdDaGVjayAnICsgY2hlY2tOYW1lICsgJzogJyArICh0aGlzLl9pc1ZhbGlkID8gJ3Bhc3NlZCcgOiAnRkFJTEVEJykpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9yTXNnXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlclJlc3VsdFZhbGlkYXRvclxufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5pc1ZhbGlkTXNnID0gZnVuY3Rpb24gaXNWYWxpZE1zZyAoZywgZGlzdGFuY2UsIHJlc3VsdCkge1xuICB2YXIgdmFsaWRhdG9yID0gbmV3IEJ1ZmZlclJlc3VsdFZhbGlkYXRvcihnLCBkaXN0YW5jZSwgcmVzdWx0KTtcbiAgaWYgKCF2YWxpZGF0b3IuaXNWYWxpZCgpKSB7IHJldHVybiB2YWxpZGF0b3IuZ2V0RXJyb3JNZXNzYWdlKCkgfVxuICByZXR1cm4gbnVsbFxufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAoZywgZGlzdGFuY2UsIHJlc3VsdCkge1xuICB2YXIgdmFsaWRhdG9yID0gbmV3IEJ1ZmZlclJlc3VsdFZhbGlkYXRvcihnLCBkaXN0YW5jZSwgcmVzdWx0KTtcbiAgaWYgKHZhbGlkYXRvci5pc1ZhbGlkKCkpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDAuVkVSQk9TRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZSB9O1xuc3RhdGljQWNjZXNzb3JzJDQwLk1BWF9FTlZfRElGRl9GUkFDLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDEyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJSZXN1bHRWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyQ0MCApO1xuXG4vLyBvcGVyYXRpb24uYnVmZmVyXG5cbnZhciBCYXNpY1NlZ21lbnRTdHJpbmcgPSBmdW5jdGlvbiBCYXNpY1NlZ21lbnRTdHJpbmcgKCkge1xuICB0aGlzLl9wdHMgPSBudWxsO1xuICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGRhdGEgPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX3B0cyA9IHB0cztcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0c1xufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICByZXR1cm4gdGhpcy5fcHRzLmxlbmd0aFxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgcmV0dXJuIHRoaXMuX3B0c1tpXVxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7XG4gIHJldHVybiB0aGlzLl9wdHNbMF0uZXF1YWxzKHRoaXMuX3B0c1t0aGlzLl9wdHMubGVuZ3RoIC0gMV0pXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRTZWdtZW50T2N0YW50ID0gZnVuY3Rpb24gZ2V0U2VnbWVudE9jdGFudCAoaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSB0aGlzLl9wdHMubGVuZ3RoIC0gMSkgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gT2N0YW50Lm9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUoaW5kZXgpLCB0aGlzLmdldENvb3JkaW5hdGUoaW5kZXggKyAxKSlcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiBzZXREYXRhIChkYXRhKSB7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIGdldERhdGEgKCkge1xuICByZXR1cm4gdGhpcy5fZGF0YVxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZSh0aGlzLl9wdHMpKVxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VnbWVudFN0cmluZ11cbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQmFzaWNTZWdtZW50U3RyaW5nXG59O1xuXG52YXIgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIgPSBmdW5jdGlvbiBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlciAoKSB7XG4gIHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zID0gZmFsc2U7XG4gIHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHkgPSBmYWxzZTtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiA9IG51bGw7XG4gIHRoaXMuX2ludFNlZ21lbnRzID0gbnVsbDtcbiAgdGhpcy5faW50ZXJzZWN0aW9ucyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5faW50ZXJzZWN0aW9uQ291bnQgPSAwO1xuICB0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucyA9IHRydWU7XG4gIHZhciBsaSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fbGkgPSBsaTtcbiAgdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBudWxsO1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5nZXRJbnRlcmlvckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGdldEludGVyaW9ySW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLnNldENoZWNrRW5kU2VnbWVudHNPbmx5ID0gZnVuY3Rpb24gc2V0Q2hlY2tFbmRTZWdtZW50c09ubHkgKGlzQ2hlY2tFbmRTZWdtZW50c09ubHkpIHtcbiAgdGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seSA9IGlzQ2hlY2tFbmRTZWdtZW50c09ubHk7XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmdldEludGVyc2VjdGlvblNlZ21lbnRzID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uU2VnbWVudHMgKCkge1xuICByZXR1cm4gdGhpcy5faW50U2VnbWVudHNcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiBjb3VudCAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnRlcnNlY3Rpb25Db3VudFxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5nZXRJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9ucyAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnRlcnNlY3Rpb25zXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gc2V0RmluZEFsbEludGVyc2VjdGlvbnMgKGZpbmRBbGxJbnRlcnNlY3Rpb25zKSB7XG4gIHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zID0gZmluZEFsbEludGVyc2VjdGlvbnM7XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLnNldEtlZXBJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gc2V0S2VlcEludGVyc2VjdGlvbnMgKGtlZXBJbnRlcnNlY3Rpb25zKSB7XG4gIHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zID0ga2VlcEludGVyc2VjdGlvbnM7XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLnByb2Nlc3NJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gcHJvY2Vzc0ludGVyc2VjdGlvbnMgKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHtcbiAgaWYgKCF0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyAmJiB0aGlzLmhhc0ludGVyc2VjdGlvbigpKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGUwID09PSBlMSAmJiBzZWdJbmRleDAgPT09IHNlZ0luZGV4MSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmICh0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5KSB7XG4gICAgdmFyIGlzRW5kU2VnUHJlc2VudCA9IHRoaXMuaXNFbmRTZWdtZW50KGUwLCBzZWdJbmRleDApIHx8IHRoaXMuaXNFbmRTZWdtZW50KGUxLCBzZWdJbmRleDEpO1xuICAgIGlmICghaXNFbmRTZWdQcmVzZW50KSB7IHJldHVybiBudWxsIH1cbiAgfVxuICB2YXIgcDAwID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDBdO1xuICB2YXIgcDAxID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDAgKyAxXTtcbiAgdmFyIHAxMCA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxXTtcbiAgdmFyIHAxMSA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxICsgMV07XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAwLCBwMDEsIHAxMCwgcDExKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgaWYgKHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSkge1xuICAgICAgdGhpcy5faW50U2VnbWVudHMgPSBuZXcgQXJyYXkoNCkuZmlsbChudWxsKTtcbiAgICAgIHRoaXMuX2ludFNlZ21lbnRzWzBdID0gcDAwO1xuICAgICAgdGhpcy5faW50U2VnbWVudHNbMV0gPSBwMDE7XG4gICAgICB0aGlzLl9pbnRTZWdtZW50c1syXSA9IHAxMDtcbiAgICAgIHRoaXMuX2ludFNlZ21lbnRzWzNdID0gcDExO1xuICAgICAgdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24gPSB0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCk7XG4gICAgICBpZiAodGhpcy5fa2VlcEludGVyc2VjdGlvbnMpIHsgdGhpcy5faW50ZXJzZWN0aW9ucy5hZGQodGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24pOyB9XG4gICAgICB0aGlzLl9pbnRlcnNlY3Rpb25Db3VudCsrO1xuICAgIH1cbiAgfVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5pc0VuZFNlZ21lbnQgPSBmdW5jdGlvbiBpc0VuZFNlZ21lbnQgKHNlZ1N0ciwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSAwKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGluZGV4ID49IHNlZ1N0ci5zaXplKCkgLSAyKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmhhc0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiAhPT0gbnVsbFxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICBpZiAodGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uICE9PSBudWxsXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlZ21lbnRJbnRlcnNlY3Rvcl1cbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlclxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLmNyZWF0ZUFsbEludGVyc2VjdGlvbnNGaW5kZXIgPSBmdW5jdGlvbiBjcmVhdGVBbGxJbnRlcnNlY3Rpb25zRmluZGVyIChsaSkge1xuICB2YXIgZmluZGVyID0gbmV3IEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyKGxpKTtcbiAgZmluZGVyLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHRydWUpO1xuICByZXR1cm4gZmluZGVyXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIuY3JlYXRlQW55SW50ZXJzZWN0aW9uRmluZGVyID0gZnVuY3Rpb24gY3JlYXRlQW55SW50ZXJzZWN0aW9uRmluZGVyIChsaSkge1xuICByZXR1cm4gbmV3IEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyKGxpKVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLmNyZWF0ZUludGVyc2VjdGlvbkNvdW50ZXIgPSBmdW5jdGlvbiBjcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyIChsaSkge1xuICB2YXIgZmluZGVyID0gbmV3IEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyKGxpKTtcbiAgZmluZGVyLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHRydWUpO1xuICBmaW5kZXIuc2V0S2VlcEludGVyc2VjdGlvbnMoZmFsc2UpO1xuICByZXR1cm4gZmluZGVyXG59O1xuXG52YXIgRmFzdE5vZGluZ1ZhbGlkYXRvciA9IGZ1bmN0aW9uIEZhc3ROb2RpbmdWYWxpZGF0b3IgKCkge1xuICB0aGlzLl9saSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgdGhpcy5fc2VnU3RyaW5ncyA9IG51bGw7XG4gIHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zID0gZmFsc2U7XG4gIHRoaXMuX3NlZ0ludCA9IG51bGw7XG4gIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICB2YXIgc2VnU3RyaW5ncyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fc2VnU3RyaW5ncyA9IHNlZ1N0cmluZ3M7XG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIGV4ZWN1dGUgKCkge1xuICBpZiAodGhpcy5fc2VnSW50ICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpO1xufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmdldEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25zKClcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAoKSB7XG4gIHRoaXMuZXhlY3V0ZSgpO1xuICByZXR1cm4gdGhpcy5faXNWYWxpZFxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gc2V0RmluZEFsbEludGVyc2VjdGlvbnMgKGZpbmRBbGxJbnRlcnNlY3Rpb25zKSB7XG4gIHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zID0gZmluZEFsbEludGVyc2VjdGlvbnM7XG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBjaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyAoKSB7XG4gIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICB0aGlzLl9zZWdJbnQgPSBuZXcgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIodGhpcy5fbGkpO1xuICB0aGlzLl9zZWdJbnQuc2V0RmluZEFsbEludGVyc2VjdGlvbnModGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMpO1xuICB2YXIgbm9kZXIgPSBuZXcgTUNJbmRleE5vZGVyKCk7XG4gIG5vZGVyLnNldFNlZ21lbnRJbnRlcnNlY3Rvcih0aGlzLl9zZWdJbnQpO1xuICBub2Rlci5jb21wdXRlTm9kZXModGhpcy5fc2VnU3RyaW5ncyk7XG4gIGlmICh0aGlzLl9zZWdJbnQuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrVmFsaWQgPSBmdW5jdGlvbiBjaGVja1ZhbGlkICgpIHtcbiAgdGhpcy5leGVjdXRlKCk7XG4gIGlmICghdGhpcy5faXNWYWxpZCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24odGhpcy5nZXRFcnJvck1lc3NhZ2UoKSwgdGhpcy5fc2VnSW50LmdldEludGVyaW9ySW50ZXJzZWN0aW9uKCkpIH1cbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UgKCkge1xuICBpZiAodGhpcy5faXNWYWxpZCkgeyByZXR1cm4gJ25vIGludGVyc2VjdGlvbnMgZm91bmQnIH1cbiAgdmFyIGludFNlZ3MgPSB0aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9uU2VnbWVudHMoKTtcbiAgcmV0dXJuICdmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGJldHdlZW4gJyArIFdLVFdyaXRlci50b0xpbmVTdHJpbmcoaW50U2Vnc1swXSwgaW50U2Vnc1sxXSkgKyAnIGFuZCAnICsgV0tUV3JpdGVyLnRvTGluZVN0cmluZyhpbnRTZWdzWzJdLCBpbnRTZWdzWzNdKVxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEZhc3ROb2RpbmdWYWxpZGF0b3Jcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLmNvbXB1dGVJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdGlvbnMgKHNlZ1N0cmluZ3MpIHtcbiAgdmFyIG52ID0gbmV3IEZhc3ROb2RpbmdWYWxpZGF0b3Ioc2VnU3RyaW5ncyk7XG4gIG52LnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHRydWUpO1xuICBudi5pc1ZhbGlkKCk7XG4gIHJldHVybiBudi5nZXRJbnRlcnNlY3Rpb25zKClcbn07XG5cbnZhciBFZGdlTm9kaW5nVmFsaWRhdG9yID0gZnVuY3Rpb24gRWRnZU5vZGluZ1ZhbGlkYXRvciAoKSB7XG4gIHRoaXMuX252ID0gbnVsbDtcbiAgdmFyIGVkZ2VzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9udiA9IG5ldyBGYXN0Tm9kaW5nVmFsaWRhdG9yKEVkZ2VOb2RpbmdWYWxpZGF0b3IudG9TZWdtZW50U3RyaW5ncyhlZGdlcykpO1xufTtcbkVkZ2VOb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrVmFsaWQgPSBmdW5jdGlvbiBjaGVja1ZhbGlkICgpIHtcbiAgdGhpcy5fbnYuY2hlY2tWYWxpZCgpO1xufTtcbkVkZ2VOb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5FZGdlTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VOb2RpbmdWYWxpZGF0b3Jcbn07XG5FZGdlTm9kaW5nVmFsaWRhdG9yLnRvU2VnbWVudFN0cmluZ3MgPSBmdW5jdGlvbiB0b1NlZ21lbnRTdHJpbmdzIChlZGdlcykge1xuICB2YXIgc2VnU3RyaW5ncyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IGVkZ2VzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaS5uZXh0KCk7XG4gICAgc2VnU3RyaW5ncy5hZGQobmV3IEJhc2ljU2VnbWVudFN0cmluZyhlLmdldENvb3JkaW5hdGVzKCksIGUpKTtcbiAgfVxuICByZXR1cm4gc2VnU3RyaW5nc1xufTtcbkVkZ2VOb2RpbmdWYWxpZGF0b3IuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKGVkZ2VzKSB7XG4gIHZhciB2YWxpZGF0b3IgPSBuZXcgRWRnZU5vZGluZ1ZhbGlkYXRvcihlZGdlcyk7XG4gIHZhbGlkYXRvci5jaGVja1ZhbGlkKCk7XG59O1xuXG52YXIgR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyID0gZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyIChtYXBPcCkge1xuICB0aGlzLl9tYXBPcCA9IG1hcE9wO1xufTtcbkdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlci5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gbWFwIChnYykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBtYXBwZWQgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2MuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgZyA9IHRoaXMkMS5fbWFwT3AubWFwKGdjLmdldEdlb21ldHJ5TihpKSk7XG4gICAgaWYgKCFnLmlzRW1wdHkoKSkgeyBtYXBwZWQuYWRkKGcpOyB9XG4gIH1cbiAgcmV0dXJuIGdjLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oR2VvbWV0cnlGYWN0b3J5LnRvR2VvbWV0cnlBcnJheShtYXBwZWQpKVxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXJcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIubWFwID0gZnVuY3Rpb24gbWFwIChnYywgb3ApIHtcbiAgdmFyIG1hcHBlciA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIob3ApO1xuICByZXR1cm4gbWFwcGVyLm1hcChnYylcbn07XG5cbnZhciBMaW5lQnVpbGRlciA9IGZ1bmN0aW9uIExpbmVCdWlsZGVyICgpIHtcbiAgdGhpcy5fb3AgPSBudWxsO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBudWxsO1xuICB0aGlzLl9wdExvY2F0b3IgPSBudWxsO1xuICB0aGlzLl9saW5lRWRnZXNMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9yZXN1bHRMaW5lTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIG9wID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZ2VvbWV0cnlGYWN0b3J5ID0gYXJndW1lbnRzWzFdO1xuICB2YXIgcHRMb2NhdG9yID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9vcCA9IG9wO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3Rvcnk7XG4gIHRoaXMuX3B0TG9jYXRvciA9IHB0TG9jYXRvcjtcbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuY29sbGVjdExpbmVzID0gZnVuY3Rpb24gY29sbGVjdExpbmVzIChvcENvZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpdCA9IHRoaXMuX29wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgIHRoaXMkMS5jb2xsZWN0TGluZUVkZ2UoZGUsIG9wQ29kZSwgdGhpcyQxLl9saW5lRWRnZXNMaXN0KTtcbiAgICB0aGlzJDEuY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlKGRlLCBvcENvZGUsIHRoaXMkMS5fbGluZUVkZ2VzTGlzdCk7XG4gIH1cbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUubGFiZWxJc29sYXRlZExpbmUgPSBmdW5jdGlvbiBsYWJlbElzb2xhdGVkTGluZSAoZSwgdGFyZ2V0SW5kZXgpIHtcbiAgdmFyIGxvYyA9IHRoaXMuX3B0TG9jYXRvci5sb2NhdGUoZS5nZXRDb29yZGluYXRlKCksIHRoaXMuX29wLmdldEFyZ0dlb21ldHJ5KHRhcmdldEluZGV4KSk7XG4gIGUuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbih0YXJnZXRJbmRleCwgbG9jKTtcbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiBidWlsZCAob3BDb2RlKSB7XG4gIHRoaXMuZmluZENvdmVyZWRMaW5lRWRnZXMoKTtcbiAgdGhpcy5jb2xsZWN0TGluZXMob3BDb2RlKTtcbiAgdGhpcy5idWlsZExpbmVzKG9wQ29kZSk7XG4gIHJldHVybiB0aGlzLl9yZXN1bHRMaW5lTGlzdFxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb2xsZWN0TGluZUVkZ2UgPSBmdW5jdGlvbiBjb2xsZWN0TGluZUVkZ2UgKGRlLCBvcENvZGUsIGVkZ2VzKSB7XG4gIHZhciBsYWJlbCA9IGRlLmdldExhYmVsKCk7XG4gIHZhciBlID0gZGUuZ2V0RWRnZSgpO1xuICBpZiAoZGUuaXNMaW5lRWRnZSgpKSB7XG4gICAgaWYgKCFkZS5pc1Zpc2l0ZWQoKSAmJiBPdmVybGF5T3AuaXNSZXN1bHRPZk9wKGxhYmVsLCBvcENvZGUpICYmICFlLmlzQ292ZXJlZCgpKSB7XG4gICAgICBlZGdlcy5hZGQoZSk7XG4gICAgICBkZS5zZXRWaXNpdGVkRWRnZSh0cnVlKTtcbiAgICB9XG4gIH1cbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuZmluZENvdmVyZWRMaW5lRWRnZXMgPSBmdW5jdGlvbiBmaW5kQ292ZXJlZExpbmVFZGdlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBub2RlaXQubmV4dCgpO1xuICAgIG5vZGUuZ2V0RWRnZXMoKS5maW5kQ292ZXJlZExpbmVFZGdlcygpO1xuICB9XG4gIGZvciAodmFyIGl0ID0gdGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGUgPSBkZS5nZXRFZGdlKCk7XG4gICAgaWYgKGRlLmlzTGluZUVkZ2UoKSAmJiAhZS5pc0NvdmVyZWRTZXQoKSkge1xuICAgICAgdmFyIGlzQ292ZXJlZCA9IHRoaXMkMS5fb3AuaXNDb3ZlcmVkQnlBKGRlLmdldENvb3JkaW5hdGUoKSk7XG4gICAgICBlLnNldENvdmVyZWQoaXNDb3ZlcmVkKTtcbiAgICB9XG4gIH1cbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUubGFiZWxJc29sYXRlZExpbmVzID0gZnVuY3Rpb24gbGFiZWxJc29sYXRlZExpbmVzIChlZGdlc0xpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpdCA9IGVkZ2VzTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGxhYmVsID0gZS5nZXRMYWJlbCgpO1xuICAgIGlmIChlLmlzSXNvbGF0ZWQoKSkge1xuICAgICAgaWYgKGxhYmVsLmlzTnVsbCgwKSkgeyB0aGlzJDEubGFiZWxJc29sYXRlZExpbmUoZSwgMCk7IH0gZWxzZSB7IHRoaXMkMS5sYWJlbElzb2xhdGVkTGluZShlLCAxKTsgfVxuICAgIH1cbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5idWlsZExpbmVzID0gZnVuY3Rpb24gYnVpbGRMaW5lcyAob3BDb2RlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9saW5lRWRnZXNMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICAvLyBjb25zdCBsYWJlbCA9IGUuZ2V0TGFiZWwoKVxuICAgIHZhciBsaW5lID0gdGhpcyQxLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlLmdldENvb3JkaW5hdGVzKCkpO1xuICAgIHRoaXMkMS5fcmVzdWx0TGluZUxpc3QuYWRkKGxpbmUpO1xuICAgIGUuc2V0SW5SZXN1bHQodHJ1ZSk7XG4gIH1cbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlID0gZnVuY3Rpb24gY29sbGVjdEJvdW5kYXJ5VG91Y2hFZGdlIChkZSwgb3BDb2RlLCBlZGdlcykge1xuICB2YXIgbGFiZWwgPSBkZS5nZXRMYWJlbCgpO1xuICBpZiAoZGUuaXNMaW5lRWRnZSgpKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGRlLmlzVmlzaXRlZCgpKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGRlLmlzSW50ZXJpb3JBcmVhRWRnZSgpKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGRlLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpIHsgcmV0dXJuIG51bGwgfVxuICBBc3NlcnQuaXNUcnVlKCEoZGUuaXNJblJlc3VsdCgpIHx8IGRlLmdldFN5bSgpLmlzSW5SZXN1bHQoKSkgfHwgIWRlLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpO1xuICBpZiAoT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcChsYWJlbCwgb3BDb2RlKSAmJiBvcENvZGUgPT09IE92ZXJsYXlPcC5JTlRFUlNFQ1RJT04pIHtcbiAgICBlZGdlcy5hZGQoZGUuZ2V0RWRnZSgpKTtcbiAgICBkZS5zZXRWaXNpdGVkRWRnZSh0cnVlKTtcbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGluZUJ1aWxkZXJcbn07XG5cbnZhciBQb2ludEJ1aWxkZXIgPSBmdW5jdGlvbiBQb2ludEJ1aWxkZXIgKCkge1xuICB0aGlzLl9vcCA9IG51bGw7XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IG51bGw7XG4gIHRoaXMuX3Jlc3VsdFBvaW50TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIG9wID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZ2VvbWV0cnlGYWN0b3J5ID0gYXJndW1lbnRzWzFdO1xuICAvLyBjb25zdCBwdExvY2F0b3IgPSBhcmd1bWVudHNbMl1cbiAgdGhpcy5fb3AgPSBvcDtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gZ2VvbWV0cnlGYWN0b3J5O1xufTtcblBvaW50QnVpbGRlci5wcm90b3R5cGUuZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50ID0gZnVuY3Rpb24gZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50IChuKSB7XG4gIHZhciBjb29yZCA9IG4uZ2V0Q29vcmRpbmF0ZSgpO1xuICBpZiAoIXRoaXMuX29wLmlzQ292ZXJlZEJ5TEEoY29vcmQpKSB7XG4gICAgdmFyIHB0ID0gdGhpcy5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGNvb3JkKTtcbiAgICB0aGlzLl9yZXN1bHRQb2ludExpc3QuYWRkKHB0KTtcbiAgfVxufTtcblBvaW50QnVpbGRlci5wcm90b3R5cGUuZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2RlcyA9IGZ1bmN0aW9uIGV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXMgKG9wQ29kZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIG5vZGVpdCA9IHRoaXMuX29wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBuID0gbm9kZWl0Lm5leHQoKTtcbiAgICBpZiAobi5pc0luUmVzdWx0KCkpIHsgY29udGludWUgfVxuICAgIGlmIChuLmlzSW5jaWRlbnRFZGdlSW5SZXN1bHQoKSkgeyBjb250aW51ZSB9XG4gICAgaWYgKG4uZ2V0RWRnZXMoKS5nZXREZWdyZWUoKSA9PT0gMCB8fCBvcENvZGUgPT09IE92ZXJsYXlPcC5JTlRFUlNFQ1RJT04pIHtcbiAgICAgIHZhciBsYWJlbCA9IG4uZ2V0TGFiZWwoKTtcbiAgICAgIGlmIChPdmVybGF5T3AuaXNSZXN1bHRPZk9wKGxhYmVsLCBvcENvZGUpKSB7XG4gICAgICAgIHRoaXMkMS5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQobik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuUG9pbnRCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIGJ1aWxkIChvcENvZGUpIHtcbiAgdGhpcy5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKG9wQ29kZSk7XG4gIHJldHVybiB0aGlzLl9yZXN1bHRQb2ludExpc3Rcbn07XG5Qb2ludEJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb2ludEJ1aWxkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9pbnRCdWlsZGVyXG59O1xuXG52YXIgR2VvbWV0cnlUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIEdlb21ldHJ5VHJhbnNmb3JtZXIgKCkge1xuICB0aGlzLl9pbnB1dEdlb20gPSBudWxsO1xuICB0aGlzLl9mYWN0b3J5ID0gbnVsbDtcbiAgdGhpcy5fcHJ1bmVFbXB0eUdlb21ldHJ5ID0gdHJ1ZTtcbiAgdGhpcy5fcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlID0gdHJ1ZTtcbiAgdGhpcy5fcHJlc2VydmVDb2xsZWN0aW9ucyA9IGZhbHNlO1xuICB0aGlzLl9wcmVzZXJ2ZVR5cGUgPSBmYWxzZTtcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50IChnZW9tLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyhnZW9tLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLCBnZW9tKSlcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2x5Z29uID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9seWdvbiAoZ2VvbSwgcGFyZW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGlzQWxsVmFsaWRMaW5lYXJSaW5ncyA9IHRydWU7XG4gIHZhciBzaGVsbCA9IHRoaXMudHJhbnNmb3JtTGluZWFyUmluZyhnZW9tLmdldEV4dGVyaW9yUmluZygpLCBnZW9tKTtcbiAgaWYgKHNoZWxsID09PSBudWxsIHx8ICEoc2hlbGwgaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB8fCBzaGVsbC5pc0VtcHR5KCkpIHsgaXNBbGxWYWxpZExpbmVhclJpbmdzID0gZmFsc2U7IH1cbiAgdmFyIGhvbGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkrKykge1xuICAgIHZhciBob2xlID0gdGhpcyQxLnRyYW5zZm9ybUxpbmVhclJpbmcoZ2VvbS5nZXRJbnRlcmlvclJpbmdOKGkpLCBnZW9tKTtcbiAgICBpZiAoaG9sZSA9PT0gbnVsbCB8fCBob2xlLmlzRW1wdHkoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCEoaG9sZSBpbnN0YW5jZW9mIExpbmVhclJpbmcpKSB7IGlzQWxsVmFsaWRMaW5lYXJSaW5ncyA9IGZhbHNlOyB9XG4gICAgaG9sZXMuYWRkKGhvbGUpO1xuICB9XG4gIGlmIChpc0FsbFZhbGlkTGluZWFyUmluZ3MpIHsgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihzaGVsbCwgaG9sZXMudG9BcnJheShbXSkpOyB9IGVsc2Uge1xuICAgIHZhciBjb21wb25lbnRzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGlmIChzaGVsbCAhPT0gbnVsbCkgeyBjb21wb25lbnRzLmFkZChzaGVsbCk7IH1cbiAgICBjb21wb25lbnRzLmFkZEFsbChob2xlcyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeShjb21wb25lbnRzKVxuICB9XG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUuY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlID0gZnVuY3Rpb24gY3JlYXRlQ29vcmRpbmF0ZVNlcXVlbmNlIChjb29yZHMpIHtcbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShjb29yZHMpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUuZ2V0SW5wdXRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldElucHV0R2VvbWV0cnkgKCkge1xuICByZXR1cm4gdGhpcy5faW5wdXRHZW9tXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gdHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nIChnZW9tLCBwYXJlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdHJhbnNHZW9tTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIHRyYW5zZm9ybUdlb20gPSB0aGlzJDEudHJhbnNmb3JtTGluZVN0cmluZyhnZW9tLmdldEdlb21ldHJ5TihpKSwgZ2VvbSk7XG4gICAgaWYgKHRyYW5zZm9ybUdlb20gPT09IG51bGwpIHsgY29udGludWUgfVxuICAgIGlmICh0cmFuc2Zvcm1HZW9tLmlzRW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgdHJhbnNHZW9tTGlzdC5hZGQodHJhbnNmb3JtR2VvbSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0cmFuc0dlb21MaXN0KVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gdHJhbnNmb3JtQ29vcmRpbmF0ZXMgKGNvb3JkcywgcGFyZW50KSB7XG4gIHJldHVybiB0aGlzLmNvcHkoY29vcmRzKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUxpbmVTdHJpbmcgPSBmdW5jdGlvbiB0cmFuc2Zvcm1MaW5lU3RyaW5nIChnZW9tLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGdlb20uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb20pKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybU11bHRpUG9pbnQgPSBmdW5jdGlvbiB0cmFuc2Zvcm1NdWx0aVBvaW50IChnZW9tLCBwYXJlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdHJhbnNHZW9tTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIHRyYW5zZm9ybUdlb20gPSB0aGlzJDEudHJhbnNmb3JtUG9pbnQoZ2VvbS5nZXRHZW9tZXRyeU4oaSksIGdlb20pO1xuICAgIGlmICh0cmFuc2Zvcm1HZW9tID09PSBudWxsKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAodHJhbnNmb3JtR2VvbS5pc0VtcHR5KCkpIHsgY29udGludWUgfVxuICAgIHRyYW5zR2VvbUxpc3QuYWRkKHRyYW5zZm9ybUdlb20pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodHJhbnNHZW9tTGlzdClcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1NdWx0aVBvbHlnb24gPSBmdW5jdGlvbiB0cmFuc2Zvcm1NdWx0aVBvbHlnb24gKGdlb20sIHBhcmVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0cmFuc0dlb21MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgdHJhbnNmb3JtR2VvbSA9IHRoaXMkMS50cmFuc2Zvcm1Qb2x5Z29uKGdlb20uZ2V0R2VvbWV0cnlOKGkpLCBnZW9tKTtcbiAgICBpZiAodHJhbnNmb3JtR2VvbSA9PT0gbnVsbCkgeyBjb250aW51ZSB9XG4gICAgaWYgKHRyYW5zZm9ybUdlb20uaXNFbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICB0cmFuc0dlb21MaXN0LmFkZCh0cmFuc2Zvcm1HZW9tKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRyYW5zR2VvbUxpc3QpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHNlcSkge1xuICByZXR1cm4gc2VxLmNvcHkoKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIHRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbiAoZ2VvbSwgcGFyZW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHRyYW5zR2VvbUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciB0cmFuc2Zvcm1HZW9tID0gdGhpcyQxLnRyYW5zZm9ybShnZW9tLmdldEdlb21ldHJ5TihpKSk7XG4gICAgaWYgKHRyYW5zZm9ybUdlb20gPT09IG51bGwpIHsgY29udGludWUgfVxuICAgIGlmICh0aGlzJDEuX3BydW5lRW1wdHlHZW9tZXRyeSAmJiB0cmFuc2Zvcm1HZW9tLmlzRW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgdHJhbnNHZW9tTGlzdC5hZGQodHJhbnNmb3JtR2VvbSk7XG4gIH1cbiAgaWYgKHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZSkgeyByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oR2VvbWV0cnlGYWN0b3J5LnRvR2VvbWV0cnlBcnJheSh0cmFuc0dlb21MaXN0KSkgfVxuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRyYW5zR2VvbUxpc3QpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChpbnB1dEdlb20pIHtcbiAgdGhpcy5faW5wdXRHZW9tID0gaW5wdXRHZW9tO1xuICB0aGlzLl9mYWN0b3J5ID0gaW5wdXRHZW9tLmdldEZhY3RvcnkoKTtcbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIFBvaW50KSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybVBvaW50KGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgTXVsdGlQb2ludCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvaW50KGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgTGluZWFyUmluZykgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZykgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgTXVsdGlMaW5lU3RyaW5nKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpTGluZVN0cmluZyhpbnB1dEdlb20sIG51bGwpIH1cbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9seWdvbihpbnB1dEdlb20sIG51bGwpIH1cbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIE11bHRpUG9seWdvbikgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvbHlnb24oaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uKGlucHV0R2VvbSwgbnVsbCkgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdVbmtub3duIEdlb21ldHJ5IHN1YnR5cGU6ICcgKyBpbnB1dEdlb20uZ2V0Q2xhc3MoKS5nZXROYW1lKCkpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtTGluZWFyUmluZyA9IGZ1bmN0aW9uIHRyYW5zZm9ybUxpbmVhclJpbmcgKGdlb20sIHBhcmVudCkge1xuICB2YXIgc2VxID0gdGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyhnZW9tLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLCBnZW9tKTtcbiAgaWYgKHNlcSA9PT0gbnVsbCkgeyByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG51bGwpIH1cbiAgdmFyIHNlcVNpemUgPSBzZXEuc2l6ZSgpO1xuICBpZiAoc2VxU2l6ZSA+IDAgJiYgc2VxU2l6ZSA8IDQgJiYgIXRoaXMuX3ByZXNlcnZlVHlwZSkgeyByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHNlcSkgfVxuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHNlcSlcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeVRyYW5zZm9ybWVyXG59O1xuXG52YXIgTGluZVN0cmluZ1NuYXBwZXIgPSBmdW5jdGlvbiBMaW5lU3RyaW5nU25hcHBlciAoKSB7XG4gIHRoaXMuX3NuYXBUb2xlcmFuY2UgPSAwLjA7XG4gIHRoaXMuX3NyY1B0cyA9IG51bGw7XG4gIHRoaXMuX3NlZyA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyA9IGZhbHNlO1xuICB0aGlzLl9pc0Nsb3NlZCA9IGZhbHNlO1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVN0cmluZyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgIHZhciBzcmNMaW5lID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzbmFwVG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgIExpbmVTdHJpbmdTbmFwcGVyLmNhbGwodGhpcywgc3JjTGluZS5nZXRDb29yZGluYXRlcygpLCBzbmFwVG9sZXJhbmNlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgIHZhciBzcmNQdHMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNuYXBUb2xlcmFuY2UkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9zcmNQdHMgPSBzcmNQdHM7XG4gICAgdGhpcy5faXNDbG9zZWQgPSBMaW5lU3RyaW5nU25hcHBlci5pc0Nsb3NlZChzcmNQdHMpO1xuICAgIHRoaXMuX3NuYXBUb2xlcmFuY2UgPSBzbmFwVG9sZXJhbmNlJDE7XG4gIH1cbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuc25hcFZlcnRpY2VzID0gZnVuY3Rpb24gc25hcFZlcnRpY2VzIChzcmNDb29yZHMsIHNuYXBQdHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZW5kID0gdGhpcy5faXNDbG9zZWQgPyBzcmNDb29yZHMuc2l6ZSgpIC0gMSA6IHNyY0Nvb3Jkcy5zaXplKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgc3JjUHQgPSBzcmNDb29yZHMuZ2V0KGkpO1xuICAgIHZhciBzbmFwVmVydCA9IHRoaXMkMS5maW5kU25hcEZvclZlcnRleChzcmNQdCwgc25hcFB0cyk7XG4gICAgaWYgKHNuYXBWZXJ0ICE9PSBudWxsKSB7XG4gICAgICBzcmNDb29yZHMuc2V0KGksIG5ldyBDb29yZGluYXRlKHNuYXBWZXJ0KSk7XG4gICAgICBpZiAoaSA9PT0gMCAmJiB0aGlzJDEuX2lzQ2xvc2VkKSB7IHNyY0Nvb3Jkcy5zZXQoc3JjQ29vcmRzLnNpemUoKSAtIDEsIG5ldyBDb29yZGluYXRlKHNuYXBWZXJ0KSk7IH1cbiAgICB9XG4gIH1cbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuZmluZFNuYXBGb3JWZXJ0ZXggPSBmdW5jdGlvbiBmaW5kU25hcEZvclZlcnRleCAocHQsIHNuYXBQdHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNuYXBQdHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocHQuZXF1YWxzMkQoc25hcFB0c1tpXSkpIHsgcmV0dXJuIG51bGwgfVxuICAgIGlmIChwdC5kaXN0YW5jZShzbmFwUHRzW2ldKSA8IHRoaXMkMS5fc25hcFRvbGVyYW5jZSkgeyByZXR1cm4gc25hcFB0c1tpXSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuc25hcFRvID0gZnVuY3Rpb24gc25hcFRvIChzbmFwUHRzKSB7XG4gIHZhciBjb29yZExpc3QgPSBuZXcgQ29vcmRpbmF0ZUxpc3QodGhpcy5fc3JjUHRzKTtcbiAgdGhpcy5zbmFwVmVydGljZXMoY29vcmRMaXN0LCBzbmFwUHRzKTtcbiAgdGhpcy5zbmFwU2VnbWVudHMoY29vcmRMaXN0LCBzbmFwUHRzKTtcbiAgdmFyIG5ld1B0cyA9IGNvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpO1xuICByZXR1cm4gbmV3UHRzXG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLnNuYXBTZWdtZW50cyA9IGZ1bmN0aW9uIHNuYXBTZWdtZW50cyAoc3JjQ29vcmRzLCBzbmFwUHRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHNuYXBQdHMubGVuZ3RoID09PSAwKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGRpc3RpbmN0UHRDb3VudCA9IHNuYXBQdHMubGVuZ3RoO1xuICBpZiAoc25hcFB0c1swXS5lcXVhbHMyRChzbmFwUHRzW3NuYXBQdHMubGVuZ3RoIC0gMV0pKSB7IGRpc3RpbmN0UHRDb3VudCA9IHNuYXBQdHMubGVuZ3RoIC0gMTsgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3RpbmN0UHRDb3VudDsgaSsrKSB7XG4gICAgdmFyIHNuYXBQdCA9IHNuYXBQdHNbaV07XG4gICAgdmFyIGluZGV4ID0gdGhpcyQxLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAoc25hcFB0LCBzcmNDb29yZHMpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBzcmNDb29yZHMuYWRkKGluZGV4ICsgMSwgbmV3IENvb3JkaW5hdGUoc25hcFB0KSwgZmFsc2UpO1xuICAgIH1cbiAgfVxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5maW5kU2VnbWVudEluZGV4VG9TbmFwID0gZnVuY3Rpb24gZmluZFNlZ21lbnRJbmRleFRvU25hcCAoc25hcFB0LCBzcmNDb29yZHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbWluRGlzdCA9IERvdWJsZS5NQVhfVkFMVUU7XG4gIHZhciBzbmFwSW5kZXggPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmNDb29yZHMuc2l6ZSgpIC0gMTsgaSsrKSB7XG4gICAgdGhpcyQxLl9zZWcucDAgPSBzcmNDb29yZHMuZ2V0KGkpO1xuICAgIHRoaXMkMS5fc2VnLnAxID0gc3JjQ29vcmRzLmdldChpICsgMSk7XG4gICAgaWYgKHRoaXMkMS5fc2VnLnAwLmVxdWFsczJEKHNuYXBQdCkgfHwgdGhpcyQxLl9zZWcucDEuZXF1YWxzMkQoc25hcFB0KSkge1xuICAgICAgaWYgKHRoaXMkMS5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMpIHsgY29udGludWU7IH0gZWxzZSB7IHJldHVybiAtMSB9XG4gICAgfVxuICAgIHZhciBkaXN0ID0gdGhpcyQxLl9zZWcuZGlzdGFuY2Uoc25hcFB0KTtcbiAgICBpZiAoZGlzdCA8IHRoaXMkMS5fc25hcFRvbGVyYW5jZSAmJiBkaXN0IDwgbWluRGlzdCkge1xuICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICBzbmFwSW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc25hcEluZGV4XG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLnNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzID0gZnVuY3Rpb24gc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMgKGFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKSB7XG4gIHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzID0gYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM7XG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMaW5lU3RyaW5nU25hcHBlclxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKHB0cykge1xuICBpZiAocHRzLmxlbmd0aCA8PSAxKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBwdHNbMF0uZXF1YWxzMkQocHRzW3B0cy5sZW5ndGggLSAxXSlcbn07XG5cbnZhciBHZW9tZXRyeVNuYXBwZXIgPSBmdW5jdGlvbiBHZW9tZXRyeVNuYXBwZXIgKHNyY0dlb20pIHtcbiAgdGhpcy5fc3JjR2VvbSA9IHNyY0dlb20gfHwgbnVsbDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDEgPSB7IFNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuR2VvbWV0cnlTbmFwcGVyLnByb3RvdHlwZS5zbmFwVG8gPSBmdW5jdGlvbiBzbmFwVG8gKHNuYXBHZW9tLCBzbmFwVG9sZXJhbmNlKSB7XG4gIHZhciBzbmFwUHRzID0gdGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXMoc25hcEdlb20pO1xuICB2YXIgc25hcFRyYW5zID0gbmV3IFNuYXBUcmFuc2Zvcm1lcihzbmFwVG9sZXJhbmNlLCBzbmFwUHRzKTtcbiAgcmV0dXJuIHNuYXBUcmFucy50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSlcbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLnNuYXBUb1NlbGYgPSBmdW5jdGlvbiBzbmFwVG9TZWxmIChzbmFwVG9sZXJhbmNlLCBjbGVhblJlc3VsdCkge1xuICB2YXIgc25hcFB0cyA9IHRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHRoaXMuX3NyY0dlb20pO1xuICB2YXIgc25hcFRyYW5zID0gbmV3IFNuYXBUcmFuc2Zvcm1lcihzbmFwVG9sZXJhbmNlLCBzbmFwUHRzLCB0cnVlKTtcbiAgdmFyIHNuYXBwZWRHZW9tID0gc25hcFRyYW5zLnRyYW5zZm9ybSh0aGlzLl9zcmNHZW9tKTtcbiAgdmFyIHJlc3VsdCA9IHNuYXBwZWRHZW9tO1xuICBpZiAoY2xlYW5SZXN1bHQgJiYgaGFzSW50ZXJmYWNlKHJlc3VsdCwgUG9seWdvbmFsKSkge1xuICAgIHJlc3VsdCA9IHNuYXBwZWRHZW9tLmJ1ZmZlcigwKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuR2VvbWV0cnlTbmFwcGVyLnByb3RvdHlwZS5jb21wdXRlU25hcFRvbGVyYW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVTbmFwVG9sZXJhbmNlIChyaW5nUHRzKSB7XG4gIHZhciBtaW5TZWdMZW4gPSB0aGlzLmNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aChyaW5nUHRzKTtcbiAgdmFyIHNuYXBUb2wgPSBtaW5TZWdMZW4gLyAxMDtcbiAgcmV0dXJuIHNuYXBUb2xcbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyAoZykge1xuICB2YXIgcHRTZXQgPSBuZXcgVHJlZVNldCgpO1xuICB2YXIgcHRzID0gZy5nZXRDb29yZGluYXRlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgIHB0U2V0LmFkZChwdHNbaV0pO1xuICB9XG4gIHJldHVybiBwdFNldC50b0FycmF5KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKVxufTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoID0gZnVuY3Rpb24gY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoIChwdHMpIHtcbiAgdmFyIG1pblNlZ0xlbiA9IERvdWJsZS5NQVhfVkFMVUU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHZhciBzZWdMZW4gPSBwdHNbaV0uZGlzdGFuY2UocHRzW2kgKyAxXSk7XG4gICAgaWYgKHNlZ0xlbiA8IG1pblNlZ0xlbikgeyBtaW5TZWdMZW4gPSBzZWdMZW47IH1cbiAgfVxuICByZXR1cm4gbWluU2VnTGVuXG59O1xuR2VvbWV0cnlTbmFwcGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlTbmFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5U25hcHBlclxufTtcbkdlb21ldHJ5U25hcHBlci5zbmFwID0gZnVuY3Rpb24gc25hcCAoZzAsIGcxLCBzbmFwVG9sZXJhbmNlKSB7XG4gIHZhciBzbmFwR2VvbSA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICB2YXIgc25hcHBlcjAgPSBuZXcgR2VvbWV0cnlTbmFwcGVyKGcwKTtcbiAgc25hcEdlb21bMF0gPSBzbmFwcGVyMC5zbmFwVG8oZzEsIHNuYXBUb2xlcmFuY2UpO1xuICB2YXIgc25hcHBlcjEgPSBuZXcgR2VvbWV0cnlTbmFwcGVyKGcxKTtcbiAgc25hcEdlb21bMV0gPSBzbmFwcGVyMS5zbmFwVG8oc25hcEdlb21bMF0sIHNuYXBUb2xlcmFuY2UpO1xuICByZXR1cm4gc25hcEdlb21cbn07XG5HZW9tZXRyeVNuYXBwZXIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc25hcFRvbGVyYW5jZSA9IEdlb21ldHJ5U25hcHBlci5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZShnKTtcbiAgICB2YXIgcG0gPSBnLmdldFByZWNpc2lvbk1vZGVsKCk7XG4gICAgaWYgKHBtLmdldFR5cGUoKSA9PT0gUHJlY2lzaW9uTW9kZWwuRklYRUQpIHtcbiAgICAgIHZhciBmaXhlZFNuYXBUb2wgPSAxIC8gcG0uZ2V0U2NhbGUoKSAqIDIgLyAxLjQxNTtcbiAgICAgIGlmIChmaXhlZFNuYXBUb2wgPiBzbmFwVG9sZXJhbmNlKSB7IHNuYXBUb2xlcmFuY2UgPSBmaXhlZFNuYXBUb2w7IH1cbiAgICB9XG4gICAgcmV0dXJuIHNuYXBUb2xlcmFuY2VcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGcwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgICByZXR1cm4gTWF0aC5taW4oR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShnMCksIEdlb21ldHJ5U25hcHBlci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UoZzEpKVxuICB9XG59O1xuR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlID0gZnVuY3Rpb24gY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UgKGcpIHtcbiAgdmFyIGVudiA9IGcuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICB2YXIgbWluRGltZW5zaW9uID0gTWF0aC5taW4oZW52LmdldEhlaWdodCgpLCBlbnYuZ2V0V2lkdGgoKSk7XG4gIHZhciBzbmFwVG9sID0gbWluRGltZW5zaW9uICogR2VvbWV0cnlTbmFwcGVyLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUjtcbiAgcmV0dXJuIHNuYXBUb2xcbn07XG5HZW9tZXRyeVNuYXBwZXIuc25hcFRvU2VsZiA9IGZ1bmN0aW9uIHNuYXBUb1NlbGYgKGdlb20sIHNuYXBUb2xlcmFuY2UsIGNsZWFuUmVzdWx0KSB7XG4gIHZhciBzbmFwcGVyMCA9IG5ldyBHZW9tZXRyeVNuYXBwZXIoZ2VvbSk7XG4gIHJldHVybiBzbmFwcGVyMC5zbmFwVG9TZWxmKHNuYXBUb2xlcmFuY2UsIGNsZWFuUmVzdWx0KVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0MS5TTkFQX1BSRUNJU0lPTl9GQUNUT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMWUtOSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggR2VvbWV0cnlTbmFwcGVyLCBzdGF0aWNBY2Nlc3NvcnMkNDEgKTtcblxudmFyIFNuYXBUcmFuc2Zvcm1lciA9IChmdW5jdGlvbiAoR2VvbWV0cnlUcmFuc2Zvcm1lciQkMSkge1xuICBmdW5jdGlvbiBTbmFwVHJhbnNmb3JtZXIgKHNuYXBUb2xlcmFuY2UsIHNuYXBQdHMsIGlzU2VsZlNuYXApIHtcbiAgICBHZW9tZXRyeVRyYW5zZm9ybWVyJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fc25hcFRvbGVyYW5jZSA9IHNuYXBUb2xlcmFuY2UgfHwgbnVsbDtcbiAgICB0aGlzLl9zbmFwUHRzID0gc25hcFB0cyB8fCBudWxsO1xuICAgIHRoaXMuX2lzU2VsZlNuYXAgPSAoaXNTZWxmU25hcCAhPT0gdW5kZWZpbmVkKSA/IGlzU2VsZlNuYXAgOiBmYWxzZTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnlUcmFuc2Zvcm1lciQkMSApIFNuYXBUcmFuc2Zvcm1lci5fX3Byb3RvX18gPSBHZW9tZXRyeVRyYW5zZm9ybWVyJCQxO1xuICBTbmFwVHJhbnNmb3JtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnlUcmFuc2Zvcm1lciQkMSAmJiBHZW9tZXRyeVRyYW5zZm9ybWVyJCQxLnByb3RvdHlwZSApO1xuICBTbmFwVHJhbnNmb3JtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU25hcFRyYW5zZm9ybWVyO1xuICBTbmFwVHJhbnNmb3JtZXIucHJvdG90eXBlLnNuYXBMaW5lID0gZnVuY3Rpb24gc25hcExpbmUgKHNyY1B0cywgc25hcFB0cykge1xuICAgIHZhciBzbmFwcGVyID0gbmV3IExpbmVTdHJpbmdTbmFwcGVyKHNyY1B0cywgdGhpcy5fc25hcFRvbGVyYW5jZSk7XG4gICAgc25hcHBlci5zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyh0aGlzLl9pc1NlbGZTbmFwKTtcbiAgICByZXR1cm4gc25hcHBlci5zbmFwVG8oc25hcFB0cylcbiAgfTtcbiAgU25hcFRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1Db29yZGluYXRlcyA9IGZ1bmN0aW9uIHRyYW5zZm9ybUNvb3JkaW5hdGVzIChjb29yZHMsIHBhcmVudCkge1xuICAgIHZhciBzcmNQdHMgPSBjb29yZHMudG9Db29yZGluYXRlQXJyYXkoKTtcbiAgICB2YXIgbmV3UHRzID0gdGhpcy5zbmFwTGluZShzcmNQdHMsIHRoaXMuX3NuYXBQdHMpO1xuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUobmV3UHRzKVxuICB9O1xuICBTbmFwVHJhbnNmb3JtZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBTbmFwVHJhbnNmb3JtZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBTbmFwVHJhbnNmb3JtZXJcbiAgfTtcblxuICByZXR1cm4gU25hcFRyYW5zZm9ybWVyO1xufShHZW9tZXRyeVRyYW5zZm9ybWVyKSk7XG5cbnZhciBDb21tb25CaXRzID0gZnVuY3Rpb24gQ29tbW9uQml0cyAoKSB7XG4gIHRoaXMuX2lzRmlyc3QgPSB0cnVlO1xuICB0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudCA9IDUzO1xuICB0aGlzLl9jb21tb25CaXRzID0gMDtcbiAgdGhpcy5fY29tbW9uU2lnbkV4cCA9IG51bGw7XG59O1xuQ29tbW9uQml0cy5wcm90b3R5cGUuZ2V0Q29tbW9uID0gZnVuY3Rpb24gZ2V0Q29tbW9uICgpIHtcbiAgcmV0dXJuIERvdWJsZS5sb25nQml0c1RvRG91YmxlKHRoaXMuX2NvbW1vbkJpdHMpXG59O1xuQ29tbW9uQml0cy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgdmFyIG51bUJpdHMgPSBEb3VibGUuZG91YmxlVG9Mb25nQml0cyhudW0pO1xuICBpZiAodGhpcy5faXNGaXJzdCkge1xuICAgIHRoaXMuX2NvbW1vbkJpdHMgPSBudW1CaXRzO1xuICAgIHRoaXMuX2NvbW1vblNpZ25FeHAgPSBDb21tb25CaXRzLnNpZ25FeHBCaXRzKHRoaXMuX2NvbW1vbkJpdHMpO1xuICAgIHRoaXMuX2lzRmlyc3QgPSBmYWxzZTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciBudW1TaWduRXhwID0gQ29tbW9uQml0cy5zaWduRXhwQml0cyhudW1CaXRzKTtcbiAgaWYgKG51bVNpZ25FeHAgIT09IHRoaXMuX2NvbW1vblNpZ25FeHApIHtcbiAgICB0aGlzLl9jb21tb25CaXRzID0gMDtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50ID0gQ29tbW9uQml0cy5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzKHRoaXMuX2NvbW1vbkJpdHMsIG51bUJpdHMpO1xuICB0aGlzLl9jb21tb25CaXRzID0gQ29tbW9uQml0cy56ZXJvTG93ZXJCaXRzKHRoaXMuX2NvbW1vbkJpdHMsIDY0IC0gKDEyICsgdGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQpKTtcbn07XG5Db21tb25CaXRzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgYml0cyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeCA9IERvdWJsZS5sb25nQml0c1RvRG91YmxlKGJpdHMpO1xuICAgIHZhciBudW1TdHIgPSBEb3VibGUudG9CaW5hcnlTdHJpbmcoYml0cyk7XG4gICAgdmFyIHBhZFN0ciA9ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyArIG51bVN0cjtcbiAgICB2YXIgYml0U3RyID0gcGFkU3RyLnN1YnN0cmluZyhwYWRTdHIubGVuZ3RoIC0gNjQpO1xuICAgIHZhciBzdHIgPSBiaXRTdHIuc3Vic3RyaW5nKDAsIDEpICsgJyAgJyArIGJpdFN0ci5zdWJzdHJpbmcoMSwgMTIpICsgJyhleHApICcgKyBiaXRTdHIuc3Vic3RyaW5nKDEyKSArICcgWyAnICsgeCArICcgXSc7XG4gICAgcmV0dXJuIHN0clxuICB9XG59O1xuQ29tbW9uQml0cy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvbW1vbkJpdHMucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29tbW9uQml0c1xufTtcbkNvbW1vbkJpdHMuZ2V0Qml0ID0gZnVuY3Rpb24gZ2V0Qml0IChiaXRzLCBpKSB7XG4gIHZhciBtYXNrID0gMSA8PCBpO1xuICByZXR1cm4gKGJpdHMgJiBtYXNrKSAhPT0gMCA/IDEgOiAwXG59O1xuQ29tbW9uQml0cy5zaWduRXhwQml0cyA9IGZ1bmN0aW9uIHNpZ25FeHBCaXRzIChudW0pIHtcbiAgcmV0dXJuIG51bSA+PiA1MlxufTtcbkNvbW1vbkJpdHMuemVyb0xvd2VyQml0cyA9IGZ1bmN0aW9uIHplcm9Mb3dlckJpdHMgKGJpdHMsIG5CaXRzKSB7XG4gIHZhciBpbnZNYXNrID0gKDEgPDwgbkJpdHMpIC0gMTtcbiAgdmFyIG1hc2sgPSB+aW52TWFzaztcbiAgdmFyIHplcm9lZCA9IGJpdHMgJiBtYXNrO1xuICByZXR1cm4gemVyb2VkXG59O1xuQ29tbW9uQml0cy5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzID0gZnVuY3Rpb24gbnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyAobnVtMSwgbnVtMikge1xuICB2YXIgY291bnQgPSAwO1xuICBmb3IgKHZhciBpID0gNTI7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKENvbW1vbkJpdHMuZ2V0Qml0KG51bTEsIGkpICE9PSBDb21tb25CaXRzLmdldEJpdChudW0yLCBpKSkgeyByZXR1cm4gY291bnQgfVxuICAgIGNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIDUyXG59O1xuXG52YXIgQ29tbW9uQml0c1JlbW92ZXIgPSBmdW5jdGlvbiBDb21tb25CaXRzUmVtb3ZlciAoKSB7XG4gIHRoaXMuX2NvbW1vbkNvb3JkID0gbnVsbDtcbiAgdGhpcy5fY2NGaWx0ZXIgPSBuZXcgQ29tbW9uQ29vcmRpbmF0ZUZpbHRlcigpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0MiA9IHsgQ29tbW9uQ29vcmRpbmF0ZUZpbHRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxUcmFuc2xhdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5Db21tb25CaXRzUmVtb3Zlci5wcm90b3R5cGUuYWRkQ29tbW9uQml0cyA9IGZ1bmN0aW9uIGFkZENvbW1vbkJpdHMgKGdlb20pIHtcbiAgdmFyIHRyYW5zID0gbmV3IFRyYW5zbGF0ZXIodGhpcy5fY29tbW9uQ29vcmQpO1xuICBnZW9tLmFwcGx5KHRyYW5zKTtcbiAgZ2VvbS5nZW9tZXRyeUNoYW5nZWQoKTtcbn07XG5Db21tb25CaXRzUmVtb3Zlci5wcm90b3R5cGUucmVtb3ZlQ29tbW9uQml0cyA9IGZ1bmN0aW9uIHJlbW92ZUNvbW1vbkJpdHMgKGdlb20pIHtcbiAgaWYgKHRoaXMuX2NvbW1vbkNvb3JkLnggPT09IDAuMCAmJiB0aGlzLl9jb21tb25Db29yZC55ID09PSAwLjApIHsgcmV0dXJuIGdlb20gfVxuICB2YXIgaW52Q29vcmQgPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9jb21tb25Db29yZCk7XG4gIGludkNvb3JkLnggPSAtaW52Q29vcmQueDtcbiAgaW52Q29vcmQueSA9IC1pbnZDb29yZC55O1xuICB2YXIgdHJhbnMgPSBuZXcgVHJhbnNsYXRlcihpbnZDb29yZCk7XG4gIGdlb20uYXBwbHkodHJhbnMpO1xuICBnZW9tLmdlb21ldHJ5Q2hhbmdlZCgpO1xuICByZXR1cm4gZ2VvbVxufTtcbkNvbW1vbkJpdHNSZW1vdmVyLnByb3RvdHlwZS5nZXRDb21tb25Db29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29tbW9uQ29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9jb21tb25Db29yZFxufTtcbkNvbW1vbkJpdHNSZW1vdmVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGdlb20pIHtcbiAgZ2VvbS5hcHBseSh0aGlzLl9jY0ZpbHRlcik7XG4gIHRoaXMuX2NvbW1vbkNvb3JkID0gdGhpcy5fY2NGaWx0ZXIuZ2V0Q29tbW9uQ29vcmRpbmF0ZSgpO1xufTtcbkNvbW1vbkJpdHNSZW1vdmVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29tbW9uQml0c1JlbW92ZXJcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDIuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDb21tb25Db29yZGluYXRlRmlsdGVyIH07XG5zdGF0aWNBY2Nlc3NvcnMkNDIuVHJhbnNsYXRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBUcmFuc2xhdGVyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb21tb25CaXRzUmVtb3Zlciwgc3RhdGljQWNjZXNzb3JzJDQyICk7XG5cbnZhciBDb21tb25Db29yZGluYXRlRmlsdGVyID0gZnVuY3Rpb24gQ29tbW9uQ29vcmRpbmF0ZUZpbHRlciAoKSB7XG4gIHRoaXMuX2NvbW1vbkJpdHNYID0gbmV3IENvbW1vbkJpdHMoKTtcbiAgdGhpcy5fY29tbW9uQml0c1kgPSBuZXcgQ29tbW9uQml0cygpO1xufTtcbkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoY29vcmQpIHtcbiAgdGhpcy5fY29tbW9uQml0c1guYWRkKGNvb3JkLngpO1xuICB0aGlzLl9jb21tb25CaXRzWS5hZGQoY29vcmQueSk7XG59O1xuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuZ2V0Q29tbW9uQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvbW1vbkNvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUodGhpcy5fY29tbW9uQml0c1guZ2V0Q29tbW9uKCksIHRoaXMuX2NvbW1vbkJpdHNZLmdldENvbW1vbigpKVxufTtcbkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nvb3JkaW5hdGVGaWx0ZXJdXG59O1xuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb21tb25Db29yZGluYXRlRmlsdGVyXG59O1xuXG52YXIgVHJhbnNsYXRlciA9IGZ1bmN0aW9uIFRyYW5zbGF0ZXIgKCkge1xuICB0aGlzLnRyYW5zID0gbnVsbDtcbiAgdmFyIHRyYW5zID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLnRyYW5zID0gdHJhbnM7XG59O1xuVHJhbnNsYXRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChzZXEsIGkpIHtcbiAgdmFyIHhwID0gc2VxLmdldE9yZGluYXRlKGksIDApICsgdGhpcy50cmFucy54O1xuICB2YXIgeXAgPSBzZXEuZ2V0T3JkaW5hdGUoaSwgMSkgKyB0aGlzLnRyYW5zLnk7XG4gIHNlcS5zZXRPcmRpbmF0ZShpLCAwLCB4cCk7XG4gIHNlcS5zZXRPcmRpbmF0ZShpLCAxLCB5cCk7XG59O1xuVHJhbnNsYXRlci5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuVHJhbnNsYXRlci5wcm90b3R5cGUuaXNHZW9tZXRyeUNoYW5nZWQgPSBmdW5jdGlvbiBpc0dlb21ldHJ5Q2hhbmdlZCAoKSB7XG4gIHJldHVybiB0cnVlXG59O1xuVHJhbnNsYXRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyXVxufTtcblRyYW5zbGF0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gVHJhbnNsYXRlclxufTtcblxudmFyIFNuYXBPdmVybGF5T3AgPSBmdW5jdGlvbiBTbmFwT3ZlcmxheU9wIChnMSwgZzIpIHtcbiAgdGhpcy5fZ2VvbSA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICB0aGlzLl9zbmFwVG9sZXJhbmNlID0gbnVsbDtcbiAgdGhpcy5fY2JyID0gbnVsbDtcbiAgdGhpcy5fZ2VvbVswXSA9IGcxO1xuICB0aGlzLl9nZW9tWzFdID0gZzI7XG4gIHRoaXMuY29tcHV0ZVNuYXBUb2xlcmFuY2UoKTtcbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5zZWxmU25hcCA9IGZ1bmN0aW9uIHNlbGZTbmFwIChnZW9tKSB7XG4gIHZhciBzbmFwcGVyMCA9IG5ldyBHZW9tZXRyeVNuYXBwZXIoZ2VvbSk7XG4gIHZhciBzbmFwR2VvbSA9IHNuYXBwZXIwLnNuYXBUbyhnZW9tLCB0aGlzLl9zbmFwVG9sZXJhbmNlKTtcbiAgcmV0dXJuIHNuYXBHZW9tXG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUucmVtb3ZlQ29tbW9uQml0cyA9IGZ1bmN0aW9uIHJlbW92ZUNvbW1vbkJpdHMgKGdlb20pIHtcbiAgdGhpcy5fY2JyID0gbmV3IENvbW1vbkJpdHNSZW1vdmVyKCk7XG4gIHRoaXMuX2Nici5hZGQoZ2VvbVswXSk7XG4gIHRoaXMuX2Nici5hZGQoZ2VvbVsxXSk7XG4gIHZhciByZW1HZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHJlbUdlb21bMF0gPSB0aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyhnZW9tWzBdLmNvcHkoKSk7XG4gIHJlbUdlb21bMV0gPSB0aGlzLl9jYnIucmVtb3ZlQ29tbW9uQml0cyhnZW9tWzFdLmNvcHkoKSk7XG4gIHJldHVybiByZW1HZW9tXG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUucHJlcGFyZVJlc3VsdCA9IGZ1bmN0aW9uIHByZXBhcmVSZXN1bHQgKGdlb20pIHtcbiAgdGhpcy5fY2JyLmFkZENvbW1vbkJpdHMoZ2VvbSk7XG4gIHJldHVybiBnZW9tXG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0UmVzdWx0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRSZXN1bHRHZW9tZXRyeSAob3BDb2RlKSB7XG4gIHZhciBwcmVwR2VvbSA9IHRoaXMuc25hcCh0aGlzLl9nZW9tKTtcbiAgdmFyIHJlc3VsdCA9IE92ZXJsYXlPcC5vdmVybGF5T3AocHJlcEdlb21bMF0sIHByZXBHZW9tWzFdLCBvcENvZGUpO1xuICByZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KHJlc3VsdClcbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5jaGVja1ZhbGlkID0gZnVuY3Rpb24gY2hlY2tWYWxpZCAoZykge1xuICBpZiAoIWcuaXNWYWxpZCgpKSB7XG4gICAgU3lzdGVtLm91dC5wcmludGxuKCdTbmFwcGVkIGdlb21ldHJ5IGlzIGludmFsaWQnKTtcbiAgfVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLmNvbXB1dGVTbmFwVG9sZXJhbmNlID0gZnVuY3Rpb24gY29tcHV0ZVNuYXBUb2xlcmFuY2UgKCkge1xuICB0aGlzLl9zbmFwVG9sZXJhbmNlID0gR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSh0aGlzLl9nZW9tWzBdLCB0aGlzLl9nZW9tWzFdKTtcbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5zbmFwID0gZnVuY3Rpb24gc25hcCAoZ2VvbSkge1xuICB2YXIgcmVtR2VvbSA9IHRoaXMucmVtb3ZlQ29tbW9uQml0cyhnZW9tKTtcbiAgdmFyIHNuYXBHZW9tID0gR2VvbWV0cnlTbmFwcGVyLnNuYXAocmVtR2VvbVswXSwgcmVtR2VvbVsxXSwgdGhpcy5fc25hcFRvbGVyYW5jZSk7XG4gIHJldHVybiBzbmFwR2VvbVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNuYXBPdmVybGF5T3Bcbn07XG5TbmFwT3ZlcmxheU9wLm92ZXJsYXlPcCA9IGZ1bmN0aW9uIG92ZXJsYXlPcCAoZzAsIGcxLCBvcENvZGUpIHtcbiAgdmFyIG9wID0gbmV3IFNuYXBPdmVybGF5T3AoZzAsIGcxKTtcbiAgcmV0dXJuIG9wLmdldFJlc3VsdEdlb21ldHJ5KG9wQ29kZSlcbn07XG5TbmFwT3ZlcmxheU9wLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKGcwLCBnMSkge1xuICByZXR1cm4gU25hcE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuVU5JT04pXG59O1xuU25hcE92ZXJsYXlPcC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKGcwLCBnMSkge1xuICByZXR1cm4gU25hcE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuSU5URVJTRUNUSU9OKVxufTtcblNuYXBPdmVybGF5T3Auc3ltRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIHN5bURpZmZlcmVuY2UgKGcwLCBnMSkge1xuICByZXR1cm4gU25hcE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuU1lNRElGRkVSRU5DRSlcbn07XG5TbmFwT3ZlcmxheU9wLmRpZmZlcmVuY2UgPSBmdW5jdGlvbiBkaWZmZXJlbmNlIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLkRJRkZFUkVOQ0UpXG59O1xuXG52YXIgU25hcElmTmVlZGVkT3ZlcmxheU9wID0gZnVuY3Rpb24gU25hcElmTmVlZGVkT3ZlcmxheU9wIChnMSwgZzIpIHtcbiAgdGhpcy5fZ2VvbSA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICB0aGlzLl9nZW9tWzBdID0gZzE7XG4gIHRoaXMuX2dlb21bMV0gPSBnMjtcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3AucHJvdG90eXBlLmdldFJlc3VsdEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0UmVzdWx0R2VvbWV0cnkgKG9wQ29kZSkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgdmFyIGlzU3VjY2VzcyA9IGZhbHNlO1xuICB2YXIgc2F2ZWRFeGNlcHRpb24gPSBudWxsO1xuICB0cnkge1xuICAgIHJlc3VsdCA9IE92ZXJsYXlPcC5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSwgdGhpcy5fZ2VvbVsxXSwgb3BDb2RlKTtcbiAgICB2YXIgaXNWYWxpZCA9IHRydWU7XG4gICAgaWYgKGlzVmFsaWQpIHsgaXNTdWNjZXNzID0gdHJ1ZTsgfVxuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChleCBpbnN0YW5jZW9mIFJ1bnRpbWVFeGNlcHRpb24pIHtcbiAgICAgIHNhdmVkRXhjZXB0aW9uID0gZXg7XG4gICAgfSBlbHNlIHsgdGhyb3cgZXggfVxuICB9IGZpbmFsbHkge31cbiAgaWYgKCFpc1N1Y2Nlc3MpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gU25hcE92ZXJsYXlPcC5vdmVybGF5T3AodGhpcy5fZ2VvbVswXSwgdGhpcy5fZ2VvbVsxXSwgb3BDb2RlKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGV4IGluc3RhbmNlb2YgUnVudGltZUV4Y2VwdGlvbikge1xuICAgICAgICB0aHJvdyBzYXZlZEV4Y2VwdGlvblxuICAgICAgfSBlbHNlIHsgdGhyb3cgZXggfVxuICAgIH0gZmluYWxseSB7fVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wXG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcCA9IGZ1bmN0aW9uIG92ZXJsYXlPcCAoZzAsIGcxLCBvcENvZGUpIHtcbiAgdmFyIG9wID0gbmV3IFNuYXBJZk5lZWRlZE92ZXJsYXlPcChnMCwgZzEpO1xuICByZXR1cm4gb3AuZ2V0UmVzdWx0R2VvbWV0cnkob3BDb2RlKVxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuVU5JT04pXG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLklOVEVSU0VDVElPTilcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3Auc3ltRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIHN5bURpZmZlcmVuY2UgKGcwLCBnMSkge1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFKVxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5kaWZmZXJlbmNlID0gZnVuY3Rpb24gZGlmZmVyZW5jZSAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLkRJRkZFUkVOQ0UpXG59O1xuXG52YXIgTW9ub3RvbmVDaGFpbiQyID0gZnVuY3Rpb24gTW9ub3RvbmVDaGFpbiAoKSB7XG4gIHRoaXMubWNlID0gbnVsbDtcbiAgdGhpcy5jaGFpbkluZGV4ID0gbnVsbDtcbiAgdmFyIG1jZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGNoYWluSW5kZXggPSBhcmd1bWVudHNbMV07XG4gIHRoaXMubWNlID0gbWNlO1xuICB0aGlzLmNoYWluSW5kZXggPSBjaGFpbkluZGV4O1xufTtcbk1vbm90b25lQ2hhaW4kMi5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0aW9ucyAobWMsIHNpKSB7XG4gIHRoaXMubWNlLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5jaGFpbkluZGV4LCBtYy5tY2UsIG1jLmNoYWluSW5kZXgsIHNpKTtcbn07XG5Nb25vdG9uZUNoYWluJDIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Nb25vdG9uZUNoYWluJDIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpbiQyXG59O1xuXG52YXIgU3dlZXBMaW5lRXZlbnQgPSBmdW5jdGlvbiBTd2VlcExpbmVFdmVudCAoKSB7XG4gIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgdGhpcy5feFZhbHVlID0gbnVsbDtcbiAgdGhpcy5fZXZlbnRUeXBlID0gbnVsbDtcbiAgdGhpcy5faW5zZXJ0RXZlbnQgPSBudWxsO1xuICB0aGlzLl9kZWxldGVFdmVudEluZGV4ID0gbnVsbDtcbiAgdGhpcy5fb2JqID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgaW5zZXJ0RXZlbnQgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fZXZlbnRUeXBlID0gU3dlZXBMaW5lRXZlbnQuREVMRVRFO1xuICAgIHRoaXMuX3hWYWx1ZSA9IHg7XG4gICAgdGhpcy5faW5zZXJ0RXZlbnQgPSBpbnNlcnRFdmVudDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGxhYmVsID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB4JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG9iaiA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9ldmVudFR5cGUgPSBTd2VlcExpbmVFdmVudC5JTlNFUlQ7XG4gICAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLl94VmFsdWUgPSB4JDE7XG4gICAgdGhpcy5fb2JqID0gb2JqO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQzID0geyBJTlNFUlQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sREVMRVRFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuaXNEZWxldGUgPSBmdW5jdGlvbiBpc0RlbGV0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudFR5cGUgPT09IFN3ZWVwTGluZUV2ZW50LkRFTEVURVxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5zZXREZWxldGVFdmVudEluZGV4ID0gZnVuY3Rpb24gc2V0RGVsZXRlRXZlbnRJbmRleCAoZGVsZXRlRXZlbnRJbmRleCkge1xuICB0aGlzLl9kZWxldGVFdmVudEluZGV4ID0gZGVsZXRlRXZlbnRJbmRleDtcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuZ2V0T2JqZWN0ID0gZnVuY3Rpb24gZ2V0T2JqZWN0ICgpIHtcbiAgcmV0dXJuIHRoaXMuX29ialxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIHBlID0gbztcbiAgaWYgKHRoaXMuX3hWYWx1ZSA8IHBlLl94VmFsdWUpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX3hWYWx1ZSA+IHBlLl94VmFsdWUpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fZXZlbnRUeXBlIDwgcGUuX2V2ZW50VHlwZSkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fZXZlbnRUeXBlID4gcGUuX2V2ZW50VHlwZSkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmdldEluc2VydEV2ZW50ID0gZnVuY3Rpb24gZ2V0SW5zZXJ0RXZlbnQgKCkge1xuICByZXR1cm4gdGhpcy5faW5zZXJ0RXZlbnRcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuaXNJbnNlcnQgPSBmdW5jdGlvbiBpc0luc2VydCAoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudFR5cGUgPT09IFN3ZWVwTGluZUV2ZW50LklOU0VSVFxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5pc1NhbWVMYWJlbCA9IGZ1bmN0aW9uIGlzU2FtZUxhYmVsIChldikge1xuICBpZiAodGhpcy5fbGFiZWwgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRoaXMuX2xhYmVsID09PSBldi5fbGFiZWxcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuZ2V0RGVsZXRlRXZlbnRJbmRleCA9IGZ1bmN0aW9uIGdldERlbGV0ZUV2ZW50SW5kZXggKCkge1xuICByZXR1cm4gdGhpcy5fZGVsZXRlRXZlbnRJbmRleFxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFN3ZWVwTGluZUV2ZW50XG59O1xuc3RhdGljQWNjZXNzb3JzJDQzLklOU0VSVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkNDMuREVMRVRFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFN3ZWVwTGluZUV2ZW50LCBzdGF0aWNBY2Nlc3NvcnMkNDMgKTtcblxudmFyIEVkZ2VTZXRJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIEVkZ2VTZXRJbnRlcnNlY3RvciAoKSB7fTtcblxuRWRnZVNldEludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRWRnZVNldEludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VTZXRJbnRlcnNlY3RvclxufTtcblxudmFyIFNlZ21lbnRJbnRlcnNlY3RvciQyID0gZnVuY3Rpb24gU2VnbWVudEludGVyc2VjdG9yICgpIHtcbiAgdGhpcy5faGFzSW50ZXJzZWN0aW9uID0gZmFsc2U7XG4gIHRoaXMuX2hhc1Byb3BlciA9IGZhbHNlO1xuICB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvciA9IGZhbHNlO1xuICB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IG51bGw7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5faW5jbHVkZVByb3BlciA9IG51bGw7XG4gIHRoaXMuX3JlY29yZElzb2xhdGVkID0gbnVsbDtcbiAgdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgdGhpcy5fbnVtSW50ZXJzZWN0aW9ucyA9IDA7XG4gIHRoaXMubnVtVGVzdHMgPSAwO1xuICB0aGlzLl9iZHlOb2RlcyA9IG51bGw7XG4gIHRoaXMuX2lzRG9uZSA9IGZhbHNlO1xuICB0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50ID0gZmFsc2U7XG4gIHZhciBsaSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGluY2x1ZGVQcm9wZXIgPSBhcmd1bWVudHNbMV07XG4gIHZhciByZWNvcmRJc29sYXRlZCA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5fbGkgPSBsaTtcbiAgdGhpcy5faW5jbHVkZVByb3BlciA9IGluY2x1ZGVQcm9wZXI7XG4gIHRoaXMuX3JlY29yZElzb2xhdGVkID0gcmVjb3JkSXNvbGF0ZWQ7XG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmlzVHJpdmlhbEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGlzVHJpdmlhbEludGVyc2VjdGlvbiAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge1xuICBpZiAoZTAgPT09IGUxKSB7XG4gICAgaWYgKHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpID09PSAxKSB7XG4gICAgICBpZiAoU2VnbWVudEludGVyc2VjdG9yJDIuaXNBZGphY2VudFNlZ21lbnRzKHNlZ0luZGV4MCwgc2VnSW5kZXgxKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAoZTAuaXNDbG9zZWQoKSkge1xuICAgICAgICB2YXIgbWF4U2VnSW5kZXggPSBlMC5nZXROdW1Qb2ludHMoKSAtIDE7XG4gICAgICAgIGlmICgoc2VnSW5kZXgwID09PSAwICYmIHNlZ0luZGV4MSA9PT0gbWF4U2VnSW5kZXgpIHx8XG4gICAgICAgICAgICAoc2VnSW5kZXgxID09PSAwICYmIHNlZ0luZGV4MCA9PT0gbWF4U2VnSW5kZXgpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCAoKSB7XG4gIHJldHVybiB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludFxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5zZXRJc0RvbmVJZlByb3BlckludCA9IGZ1bmN0aW9uIHNldElzRG9uZUlmUHJvcGVySW50IChpc0RvbmVXaGVuUHJvcGVySW50KSB7XG4gIHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQgPSBpc0RvbmVXaGVuUHJvcGVySW50O1xufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlckludGVyaW9yXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmlzQm91bmRhcnlQb2ludEludGVybmFsID0gZnVuY3Rpb24gaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwgKGxpLCBiZHlOb2Rlcykge1xuICBmb3IgKHZhciBpID0gYmR5Tm9kZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBpLm5leHQoKTtcbiAgICB2YXIgcHQgPSBub2RlLmdldENvb3JkaW5hdGUoKTtcbiAgICBpZiAobGkuaXNJbnRlcnNlY3Rpb24ocHQpKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaGFzUHJvcGVySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzUHJvcGVySW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlclxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5oYXNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9uXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0RvbmVcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaXNCb3VuZGFyeVBvaW50ID0gZnVuY3Rpb24gaXNCb3VuZGFyeVBvaW50IChsaSwgYmR5Tm9kZXMpIHtcbiAgaWYgKGJkeU5vZGVzID09PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICh0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKGxpLCBiZHlOb2Rlc1swXSkpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAodGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbChsaSwgYmR5Tm9kZXNbMV0pKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLnNldEJvdW5kYXJ5Tm9kZXMgPSBmdW5jdGlvbiBzZXRCb3VuZGFyeU5vZGVzIChiZHlOb2RlczAsIGJkeU5vZGVzMSkge1xuICB0aGlzLl9iZHlOb2RlcyA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICB0aGlzLl9iZHlOb2Rlc1swXSA9IGJkeU5vZGVzMDtcbiAgdGhpcy5fYmR5Tm9kZXNbMV0gPSBiZHlOb2RlczE7XG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmFkZEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb25zIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7XG4gIGlmIChlMCA9PT0gZTEgJiYgc2VnSW5kZXgwID09PSBzZWdJbmRleDEpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLm51bVRlc3RzKys7XG4gIHZhciBwMDAgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MF07XG4gIHZhciBwMDEgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MCArIDFdO1xuICB2YXIgcDEwID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDFdO1xuICB2YXIgcDExID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDEgKyAxXTtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMDAsIHAwMSwgcDEwLCBwMTEpO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkSXNvbGF0ZWQpIHtcbiAgICAgIGUwLnNldElzb2xhdGVkKGZhbHNlKTtcbiAgICAgIGUxLnNldElzb2xhdGVkKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5fbnVtSW50ZXJzZWN0aW9ucysrO1xuICAgIGlmICghdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24oZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkpIHtcbiAgICAgIHRoaXMuX2hhc0ludGVyc2VjdGlvbiA9IHRydWU7XG4gICAgICBpZiAodGhpcy5faW5jbHVkZVByb3BlciB8fCAhdGhpcy5fbGkuaXNQcm9wZXIoKSkge1xuICAgICAgICBlMC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLCBzZWdJbmRleDAsIDApO1xuICAgICAgICBlMS5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLCBzZWdJbmRleDEsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkpIHtcbiAgICAgICAgdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQgPSB0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkuY29weSgpO1xuICAgICAgICB0aGlzLl9oYXNQcm9wZXIgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5faXNEb25lV2hlblByb3BlckludCkge1xuICAgICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQm91bmRhcnlQb2ludCh0aGlzLl9saSwgdGhpcy5fYmR5Tm9kZXMpKSB7IHRoaXMuX2hhc1Byb3BlckludGVyaW9yID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudEludGVyc2VjdG9yJDJcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5pc0FkamFjZW50U2VnbWVudHMgPSBmdW5jdGlvbiBpc0FkamFjZW50U2VnbWVudHMgKGkxLCBpMikge1xuICByZXR1cm4gTWF0aC5hYnMoaTEgLSBpMikgPT09IDFcbn07XG5cbnZhciBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yID0gKGZ1bmN0aW9uIChFZGdlU2V0SW50ZXJzZWN0b3IkJDEpIHtcbiAgZnVuY3Rpb24gU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3RvciAoKSB7XG4gICAgRWRnZVNldEludGVyc2VjdG9yJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5uT3ZlcmxhcHMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCBFZGdlU2V0SW50ZXJzZWN0b3IkJDEgKSBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLl9fcHJvdG9fXyA9IEVkZ2VTZXRJbnRlcnNlY3RvciQkMTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFZGdlU2V0SW50ZXJzZWN0b3IkJDEgJiYgRWRnZVNldEludGVyc2VjdG9yJCQxLnByb3RvdHlwZSApO1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3I7XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLnByZXBhcmVFdmVudHMgPSBmdW5jdGlvbiBwcmVwYXJlRXZlbnRzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIENvbGxlY3Rpb25zLnNvcnQodGhpcy5ldmVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIHZhciBldiA9IHRoaXMkMS5ldmVudHMuZ2V0KGkpO1xuICAgICAgaWYgKGV2LmlzRGVsZXRlKCkpIHtcbiAgICAgICAgZXYuZ2V0SW5zZXJ0RXZlbnQoKS5zZXREZWxldGVFdmVudEluZGV4KGkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0aW9ucyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHNpID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5uT3ZlcmxhcHMgPSAwO1xuICAgICAgdGhpcy5wcmVwYXJlRXZlbnRzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgIHZhciBldiA9IHRoaXMkMS5ldmVudHMuZ2V0KGkpO1xuICAgICAgICBpZiAoZXYuaXNJbnNlcnQoKSkge1xuICAgICAgICAgIHRoaXMkMS5wcm9jZXNzT3ZlcmxhcHMoaSwgZXYuZ2V0RGVsZXRlRXZlbnRJbmRleCgpLCBldiwgc2kpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaS5pc0RvbmUoKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBTZWdtZW50SW50ZXJzZWN0b3IkMiAmJiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgTGlzdCkgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgTGlzdCkpKSB7XG4gICAgICAgIHZhciBlZGdlczAgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBlZGdlczEgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBzaSQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB0aGlzLmFkZEVkZ2VzKGVkZ2VzMCwgZWRnZXMwKTtcbiAgICAgICAgdGhpcy5hZGRFZGdlcyhlZGdlczEsIGVkZ2VzMSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMoc2kkMSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdib29sZWFuJyAmJiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgTGlzdCkgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgU2VnbWVudEludGVyc2VjdG9yJDIpKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIHNpJDIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciB0ZXN0QWxsU2VnbWVudHMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICh0ZXN0QWxsU2VnbWVudHMpIHsgdGhpcy5hZGRFZGdlcyhlZGdlcywgbnVsbCk7IH0gZWxzZSB7IHRoaXMuYWRkRWRnZXMoZWRnZXMpOyB9XG4gICAgICAgIHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMoc2kkMik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5hZGRFZGdlID0gZnVuY3Rpb24gYWRkRWRnZSAoZWRnZSwgZWRnZVNldCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG1jZSA9IGVkZ2UuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UoKTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IG1jZS5nZXRTdGFydEluZGV4ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0SW5kZXgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgbWMgPSBuZXcgTW9ub3RvbmVDaGFpbiQyKG1jZSwgaSk7XG4gICAgICB2YXIgaW5zZXJ0RXZlbnQgPSBuZXcgU3dlZXBMaW5lRXZlbnQoZWRnZVNldCwgbWNlLmdldE1pblgoaSksIG1jKTtcbiAgICAgIHRoaXMkMS5ldmVudHMuYWRkKGluc2VydEV2ZW50KTtcbiAgICAgIHRoaXMkMS5ldmVudHMuYWRkKG5ldyBTd2VlcExpbmVFdmVudChtY2UuZ2V0TWF4WChpKSwgaW5zZXJ0RXZlbnQpKTtcbiAgICB9XG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLnByb2Nlc3NPdmVybGFwcyA9IGZ1bmN0aW9uIHByb2Nlc3NPdmVybGFwcyAoc3RhcnQsIGVuZCwgZXYwLCBzaSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG1jMCA9IGV2MC5nZXRPYmplY3QoKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGV2MSA9IHRoaXMkMS5ldmVudHMuZ2V0KGkpO1xuICAgICAgaWYgKGV2MS5pc0luc2VydCgpKSB7XG4gICAgICAgIHZhciBtYzEgPSBldjEuZ2V0T2JqZWN0KCk7XG4gICAgICAgIGlmICghZXYwLmlzU2FtZUxhYmVsKGV2MSkpIHtcbiAgICAgICAgICBtYzAuY29tcHV0ZUludGVyc2VjdGlvbnMobWMxLCBzaSk7XG4gICAgICAgICAgdGhpcyQxLm5PdmVybGFwcysrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5hZGRFZGdlcyA9IGZ1bmN0aW9uIGFkZEVkZ2VzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgZWRnZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKHZhciBpID0gZWRnZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBlZGdlID0gaS5uZXh0KCk7XG4gICAgICAgIHRoaXMkMS5hZGRFZGdlKGVkZ2UsIGVkZ2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGVkZ2VzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZWRnZVNldCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IGVkZ2VzJDEuaXRlcmF0b3IoKTsgaSQxLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGVkZ2UkMSA9IGkkMS5uZXh0KCk7XG4gICAgICAgIHRoaXMkMS5hZGRFZGdlKGVkZ2UkMSwgZWRnZVNldCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3JcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvcjtcbn0oRWRnZVNldEludGVyc2VjdG9yKSk7XG5cbnZhciBJbnRlcnZhbFJUcmVlTm9kZSA9IGZ1bmN0aW9uIEludGVydmFsUlRyZWVOb2RlICgpIHtcbiAgdGhpcy5fbWluID0gRG91YmxlLlBPU0lUSVZFX0lORklOSVRZO1xuICB0aGlzLl9tYXggPSBEb3VibGUuTkVHQVRJVkVfSU5GSU5JVFk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQ1ID0geyBOb2RlQ29tcGFyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuSW50ZXJ2YWxSVHJlZU5vZGUucHJvdG90eXBlLmdldE1pbiA9IGZ1bmN0aW9uIGdldE1pbiAoKSB7XG4gIHJldHVybiB0aGlzLl9taW5cbn07XG5JbnRlcnZhbFJUcmVlTm9kZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKHF1ZXJ5TWluLCBxdWVyeU1heCkge1xuICBpZiAodGhpcy5fbWluID4gcXVlcnlNYXggfHwgdGhpcy5fbWF4IDwgcXVlcnlNaW4pIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRydWVcbn07XG5JbnRlcnZhbFJUcmVlTm9kZS5wcm90b3R5cGUuZ2V0TWF4ID0gZnVuY3Rpb24gZ2V0TWF4ICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heFxufTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIFdLVFdyaXRlci50b0xpbmVTdHJpbmcobmV3IENvb3JkaW5hdGUodGhpcy5fbWluLCAwKSwgbmV3IENvb3JkaW5hdGUodGhpcy5fbWF4LCAwKSlcbn07XG5JbnRlcnZhbFJUcmVlTm9kZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEludGVydmFsUlRyZWVOb2RlXG59O1xuc3RhdGljQWNjZXNzb3JzJDQ1Lk5vZGVDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5vZGVDb21wYXJhdG9yIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBJbnRlcnZhbFJUcmVlTm9kZSwgc3RhdGljQWNjZXNzb3JzJDQ1ICk7XG5cbnZhciBOb2RlQ29tcGFyYXRvciA9IGZ1bmN0aW9uIE5vZGVDb21wYXJhdG9yICgpIHt9O1xuXG5Ob2RlQ29tcGFyYXRvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKG8xLCBvMikge1xuICB2YXIgbjEgPSBvMTtcbiAgdmFyIG4yID0gbzI7XG4gIHZhciBtaWQxID0gKG4xLl9taW4gKyBuMS5fbWF4KSAvIDI7XG4gIHZhciBtaWQyID0gKG4yLl9taW4gKyBuMi5fbWF4KSAvIDI7XG4gIGlmIChtaWQxIDwgbWlkMikgeyByZXR1cm4gLTEgfVxuICBpZiAobWlkMSA+IG1pZDIpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbk5vZGVDb21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhdG9yXVxufTtcbk5vZGVDb21wYXJhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGVDb21wYXJhdG9yXG59O1xuXG52YXIgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlID0gKGZ1bmN0aW9uIChJbnRlcnZhbFJUcmVlTm9kZSQkMSkge1xuICBmdW5jdGlvbiBJbnRlcnZhbFJUcmVlTGVhZk5vZGUgKCkge1xuICAgIEludGVydmFsUlRyZWVOb2RlJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgdmFyIG1pbiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbWF4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBpdGVtID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gIH1cblxuICBpZiAoIEludGVydmFsUlRyZWVOb2RlJCQxICkgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLl9fcHJvdG9fXyA9IEludGVydmFsUlRyZWVOb2RlJCQxO1xuICBJbnRlcnZhbFJUcmVlTGVhZk5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJ2YWxSVHJlZU5vZGUkJDEgJiYgSW50ZXJ2YWxSVHJlZU5vZGUkJDEucHJvdG90eXBlICk7XG4gIEludGVydmFsUlRyZWVMZWFmTm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcnZhbFJUcmVlTGVhZk5vZGU7XG4gIEludGVydmFsUlRyZWVMZWFmTm9kZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiBxdWVyeSAocXVlcnlNaW4sIHF1ZXJ5TWF4LCB2aXNpdG9yKSB7XG4gICAgaWYgKCF0aGlzLmludGVyc2VjdHMocXVlcnlNaW4sIHF1ZXJ5TWF4KSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmlzaXRvci52aXNpdEl0ZW0odGhpcy5faXRlbSk7XG4gIH07XG4gIEludGVydmFsUlRyZWVMZWFmTm9kZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIEludGVydmFsUlRyZWVMZWFmTm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEludGVydmFsUlRyZWVMZWFmTm9kZVxuICB9O1xuXG4gIHJldHVybiBJbnRlcnZhbFJUcmVlTGVhZk5vZGU7XG59KEludGVydmFsUlRyZWVOb2RlKSk7XG5cbnZhciBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZSA9IChmdW5jdGlvbiAoSW50ZXJ2YWxSVHJlZU5vZGUkJDEpIHtcbiAgZnVuY3Rpb24gSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUgKCkge1xuICAgIEludGVydmFsUlRyZWVOb2RlJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fbm9kZTEgPSBudWxsO1xuICAgIHRoaXMuX25vZGUyID0gbnVsbDtcbiAgICB2YXIgbjEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG4yID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX25vZGUxID0gbjE7XG4gICAgdGhpcy5fbm9kZTIgPSBuMjtcbiAgICB0aGlzLmJ1aWxkRXh0ZW50KHRoaXMuX25vZGUxLCB0aGlzLl9ub2RlMik7XG4gIH1cblxuICBpZiAoIEludGVydmFsUlRyZWVOb2RlJCQxICkgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUuX19wcm90b19fID0gSW50ZXJ2YWxSVHJlZU5vZGUkJDE7XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVydmFsUlRyZWVOb2RlJCQxICYmIEludGVydmFsUlRyZWVOb2RlJCQxLnByb3RvdHlwZSApO1xuICBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZTtcbiAgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUucHJvdG90eXBlLmJ1aWxkRXh0ZW50ID0gZnVuY3Rpb24gYnVpbGRFeHRlbnQgKG4xLCBuMikge1xuICAgIHRoaXMuX21pbiA9IE1hdGgubWluKG4xLl9taW4sIG4yLl9taW4pO1xuICAgIHRoaXMuX21heCA9IE1hdGgubWF4KG4xLl9tYXgsIG4yLl9tYXgpO1xuICB9O1xuICBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiBxdWVyeSAocXVlcnlNaW4sIHF1ZXJ5TWF4LCB2aXNpdG9yKSB7XG4gICAgaWYgKCF0aGlzLmludGVyc2VjdHMocXVlcnlNaW4sIHF1ZXJ5TWF4KSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMuX25vZGUxICE9PSBudWxsKSB7IHRoaXMuX25vZGUxLnF1ZXJ5KHF1ZXJ5TWluLCBxdWVyeU1heCwgdmlzaXRvcik7IH1cbiAgICBpZiAodGhpcy5fbm9kZTIgIT09IG51bGwpIHsgdGhpcy5fbm9kZTIucXVlcnkocXVlcnlNaW4sIHF1ZXJ5TWF4LCB2aXNpdG9yKTsgfVxuICB9O1xuICBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGVcbiAgfTtcblxuICByZXR1cm4gSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGU7XG59KEludGVydmFsUlRyZWVOb2RlKSk7XG5cbnZhciBTb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlID0gZnVuY3Rpb24gU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZSAoKSB7XG4gIHRoaXMuX2xlYXZlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fcm9vdCA9IG51bGw7XG4gIHRoaXMuX2xldmVsID0gMDtcbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5idWlsZFRyZWUgPSBmdW5jdGlvbiBidWlsZFRyZWUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIENvbGxlY3Rpb25zLnNvcnQodGhpcy5fbGVhdmVzLCBuZXcgSW50ZXJ2YWxSVHJlZU5vZGUuTm9kZUNvbXBhcmF0b3IoKSk7XG4gIHZhciBzcmMgPSB0aGlzLl9sZWF2ZXM7XG4gIHZhciB0ZW1wID0gbnVsbDtcbiAgdmFyIGRlc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdGhpcyQxLmJ1aWxkTGV2ZWwoc3JjLCBkZXN0KTtcbiAgICBpZiAoZGVzdC5zaXplKCkgPT09IDEpIHsgcmV0dXJuIGRlc3QuZ2V0KDApIH1cbiAgICB0ZW1wID0gc3JjO1xuICAgIHNyYyA9IGRlc3Q7XG4gICAgZGVzdCA9IHRlbXA7XG4gIH1cbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKG1pbiwgbWF4LCBpdGVtKSB7XG4gIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7IHRocm93IG5ldyBFcnJvcignSW5kZXggY2Fubm90IGJlIGFkZGVkIHRvIG9uY2UgaXQgaGFzIGJlZW4gcXVlcmllZCcpIH1cbiAgdGhpcy5fbGVhdmVzLmFkZChuZXcgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlKG1pbiwgbWF4LCBpdGVtKSk7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiBxdWVyeSAobWluLCBtYXgsIHZpc2l0b3IpIHtcbiAgdGhpcy5pbml0KCk7XG4gIHRoaXMuX3Jvb3QucXVlcnkobWluLCBtYXgsIHZpc2l0b3IpO1xufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmJ1aWxkUm9vdCA9IGZ1bmN0aW9uIGJ1aWxkUm9vdCAoKSB7XG4gIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5fcm9vdCA9IHRoaXMuYnVpbGRUcmVlKCk7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUucHJpbnROb2RlID0gZnVuY3Rpb24gcHJpbnROb2RlIChub2RlKSB7XG4gIFN5c3RlbS5vdXQucHJpbnRsbihXS1RXcml0ZXIudG9MaW5lU3RyaW5nKG5ldyBDb29yZGluYXRlKG5vZGUuX21pbiwgdGhpcy5fbGV2ZWwpLCBuZXcgQ29vcmRpbmF0ZShub2RlLl9tYXgsIHRoaXMuX2xldmVsKSkpO1xufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0ICgpIHtcbiAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLmJ1aWxkUm9vdCgpO1xufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmJ1aWxkTGV2ZWwgPSBmdW5jdGlvbiBidWlsZExldmVsIChzcmMsIGRlc3QpIHtcbiAgdGhpcy5fbGV2ZWwrKztcbiAgZGVzdC5jbGVhcigpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNyYy5zaXplKCk7IGkgKz0gMikge1xuICAgIHZhciBuMSA9IHNyYy5nZXQoaSk7XG4gICAgdmFyIG4yID0gaSArIDEgPCBzcmMuc2l6ZSgpID8gc3JjLmdldChpKSA6IG51bGw7XG4gICAgaWYgKG4yID09PSBudWxsKSB7XG4gICAgICBkZXN0LmFkZChuMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub2RlID0gbmV3IEludGVydmFsUlRyZWVCcmFuY2hOb2RlKHNyYy5nZXQoaSksIHNyYy5nZXQoaSArIDEpKTtcbiAgICAgIGRlc3QuYWRkKG5vZGUpO1xuICAgIH1cbiAgfVxufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNvcnRlZFBhY2tlZEludGVydmFsUlRyZWVcbn07XG5cbnZhciBBcnJheUxpc3RWaXNpdG9yID0gZnVuY3Rpb24gQXJyYXlMaXN0VmlzaXRvciAoKSB7XG4gIHRoaXMuX2l0ZW1zID0gbmV3IEFycmF5TGlzdCgpO1xufTtcbkFycmF5TGlzdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SXRlbSA9IGZ1bmN0aW9uIHZpc2l0SXRlbSAoaXRlbSkge1xuICB0aGlzLl9pdGVtcy5hZGQoaXRlbSk7XG59O1xuQXJyYXlMaXN0VmlzaXRvci5wcm90b3R5cGUuZ2V0SXRlbXMgPSBmdW5jdGlvbiBnZXRJdGVtcyAoKSB7XG4gIHJldHVybiB0aGlzLl9pdGVtc1xufTtcbkFycmF5TGlzdFZpc2l0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0l0ZW1WaXNpdG9yXVxufTtcbkFycmF5TGlzdFZpc2l0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQXJyYXlMaXN0VmlzaXRvclxufTtcblxudmFyIEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3IgPSBmdW5jdGlvbiBJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yICgpIHtcbiAgdGhpcy5faW5kZXggPSBudWxsO1xuICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgaWYgKCFoYXNJbnRlcmZhY2UoZywgUG9seWdvbmFsKSkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdBcmd1bWVudCBtdXN0IGJlIFBvbHlnb25hbCcpIH1cbiAgdGhpcy5faW5kZXggPSBuZXcgSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkoZyk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQ0ID0geyBTZWdtZW50VmlzaXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxJbnRlcnZhbEluZGV4ZWRHZW9tZXRyeTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUubG9jYXRlID0gZnVuY3Rpb24gbG9jYXRlIChwKSB7XG4gIHZhciByY2MgPSBuZXcgUmF5Q3Jvc3NpbmdDb3VudGVyKHApO1xuICB2YXIgdmlzaXRvciA9IG5ldyBTZWdtZW50VmlzaXRvcihyY2MpO1xuICB0aGlzLl9pbmRleC5xdWVyeShwLnksIHAueSwgdmlzaXRvcik7XG4gIHJldHVybiByY2MuZ2V0TG9jYXRpb24oKVxufTtcbkluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1BvaW50T25HZW9tZXRyeUxvY2F0b3JdXG59O1xuSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yXG59O1xuc3RhdGljQWNjZXNzb3JzJDQ0LlNlZ21lbnRWaXNpdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNlZ21lbnRWaXNpdG9yIH07XG5zdGF0aWNBY2Nlc3NvcnMkNDQuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3IsIHN0YXRpY0FjY2Vzc29ycyQ0NCApO1xuXG52YXIgU2VnbWVudFZpc2l0b3IgPSBmdW5jdGlvbiBTZWdtZW50VmlzaXRvciAoKSB7XG4gIHRoaXMuX2NvdW50ZXIgPSBudWxsO1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fY291bnRlciA9IGNvdW50ZXI7XG59O1xuU2VnbWVudFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SXRlbSA9IGZ1bmN0aW9uIHZpc2l0SXRlbSAoaXRlbSkge1xuICB2YXIgc2VnID0gaXRlbTtcbiAgdGhpcy5fY291bnRlci5jb3VudFNlZ21lbnQoc2VnLmdldENvb3JkaW5hdGUoMCksIHNlZy5nZXRDb29yZGluYXRlKDEpKTtcbn07XG5TZWdtZW50VmlzaXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbSXRlbVZpc2l0b3JdXG59O1xuU2VnbWVudFZpc2l0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudFZpc2l0b3Jcbn07XG5cbnZhciBJbnRlcnZhbEluZGV4ZWRHZW9tZXRyeSA9IGZ1bmN0aW9uIEludGVydmFsSW5kZXhlZEdlb21ldHJ5ICgpIHtcbiAgdGhpcy5faW5kZXggPSBuZXcgU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZSgpO1xuICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5pbml0KGdlb20pO1xufTtcbkludGVydmFsSW5kZXhlZEdlb21ldHJ5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoZ2VvbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBsaW5lcyA9IExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnZW9tKTtcbiAgZm9yICh2YXIgaSA9IGxpbmVzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBsaW5lID0gaS5uZXh0KCk7XG4gICAgdmFyIHB0cyA9IGxpbmUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB0aGlzJDEuYWRkTGluZShwdHMpO1xuICB9XG59O1xuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbiBhZGRMaW5lIChwdHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWcgPSBuZXcgTGluZVNlZ21lbnQocHRzW2kgLSAxXSwgcHRzW2ldKTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4oc2VnLnAwLnksIHNlZy5wMS55KTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgoc2VnLnAwLnksIHNlZy5wMS55KTtcbiAgICB0aGlzJDEuX2luZGV4Lmluc2VydChtaW4sIG1heCwgc2VnKTtcbiAgfVxufTtcbkludGVydmFsSW5kZXhlZEdlb21ldHJ5LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgbWluID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtYXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgQXJyYXlMaXN0VmlzaXRvcigpO1xuICAgIHRoaXMuX2luZGV4LnF1ZXJ5KG1pbiwgbWF4LCB2aXNpdG9yKTtcbiAgICByZXR1cm4gdmlzaXRvci5nZXRJdGVtcygpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBtaW4kMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbWF4JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHZpc2l0b3IkMSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9pbmRleC5xdWVyeShtaW4kMSwgbWF4JDEsIHZpc2l0b3IkMSk7XG4gIH1cbn07XG5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkludGVydmFsSW5kZXhlZEdlb21ldHJ5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEludGVydmFsSW5kZXhlZEdlb21ldHJ5XG59O1xuXG52YXIgR2VvbWV0cnlHcmFwaCA9IChmdW5jdGlvbiAoUGxhbmFyR3JhcGgkJDEpIHtcbiAgZnVuY3Rpb24gR2VvbWV0cnlHcmFwaCAoKSB7XG4gICAgUGxhbmFyR3JhcGgkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wYXJlbnRHZW9tID0gbnVsbDtcbiAgICB0aGlzLl9saW5lRWRnZU1hcCA9IG5ldyBIYXNoTWFwKCk7XG4gICAgdGhpcy5fYm91bmRhcnlOb2RlUnVsZSA9IG51bGw7XG4gICAgdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZSA9IHRydWU7XG4gICAgdGhpcy5fYXJnSW5kZXggPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kYXJ5Tm9kZXMgPSBudWxsO1xuICAgIHRoaXMuX2hhc1Rvb0Zld1BvaW50cyA9IGZhbHNlO1xuICAgIHRoaXMuX2ludmFsaWRQb2ludCA9IG51bGw7XG4gICAgdGhpcy5fYXJlYVB0TG9jYXRvciA9IG51bGw7XG4gICAgdGhpcy5fcHRMb2NhdG9yID0gbmV3IFBvaW50TG9jYXRvcigpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcGFyZW50R2VvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBib3VuZGFyeU5vZGVSdWxlID0gQm91bmRhcnlOb2RlUnVsZS5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU7XG4gICAgICB0aGlzLl9hcmdJbmRleCA9IGFyZ0luZGV4O1xuICAgICAgdGhpcy5fcGFyZW50R2VvbSA9IHBhcmVudEdlb207XG4gICAgICB0aGlzLl9ib3VuZGFyeU5vZGVSdWxlID0gYm91bmRhcnlOb2RlUnVsZTtcbiAgICAgIGlmIChwYXJlbnRHZW9tICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYWRkKHBhcmVudEdlb20pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgdmFyIGFyZ0luZGV4JDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcGFyZW50R2VvbSQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGJvdW5kYXJ5Tm9kZVJ1bGUkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHRoaXMuX2FyZ0luZGV4ID0gYXJnSW5kZXgkMTtcbiAgICAgIHRoaXMuX3BhcmVudEdlb20gPSBwYXJlbnRHZW9tJDE7XG4gICAgICB0aGlzLl9ib3VuZGFyeU5vZGVSdWxlID0gYm91bmRhcnlOb2RlUnVsZSQxO1xuICAgICAgaWYgKHBhcmVudEdlb20kMSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFkZChwYXJlbnRHZW9tJDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICggUGxhbmFyR3JhcGgkJDEgKSBHZW9tZXRyeUdyYXBoLl9fcHJvdG9fXyA9IFBsYW5hckdyYXBoJCQxO1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBsYW5hckdyYXBoJCQxICYmIFBsYW5hckdyYXBoJCQxLnByb3RvdHlwZSApO1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlb21ldHJ5R3JhcGg7XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmluc2VydEJvdW5kYXJ5UG9pbnQgPSBmdW5jdGlvbiBpbnNlcnRCb3VuZGFyeVBvaW50IChhcmdJbmRleCwgY29vcmQpIHtcbiAgICB2YXIgbiA9IHRoaXMuX25vZGVzLmFkZE5vZGUoY29vcmQpO1xuICAgIHZhciBsYmwgPSBuLmdldExhYmVsKCk7XG4gICAgdmFyIGJvdW5kYXJ5Q291bnQgPSAxO1xuICAgIHZhciBsb2MgPSBMb2NhdGlvbi5OT05FO1xuICAgIGxvYyA9IGxibC5nZXRMb2NhdGlvbihhcmdJbmRleCwgUG9zaXRpb24uT04pO1xuICAgIGlmIChsb2MgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IGJvdW5kYXJ5Q291bnQrKzsgfVxuICAgIHZhciBuZXdMb2MgPSBHZW9tZXRyeUdyYXBoLmRldGVybWluZUJvdW5kYXJ5KHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUsIGJvdW5kYXJ5Q291bnQpO1xuICAgIGxibC5zZXRMb2NhdGlvbihhcmdJbmRleCwgbmV3TG9jKTtcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuY29tcHV0ZVNlbGZOb2RlcyA9IGZ1bmN0aW9uIGNvbXB1dGVTZWxmTm9kZXMgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbGkgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY29tcHV0ZVJpbmdTZWxmTm9kZXMgPSBhcmd1bWVudHNbMV07XG4gICAgICByZXR1cm4gdGhpcy5jb21wdXRlU2VsZk5vZGVzKGxpLCBjb21wdXRlUmluZ1NlbGZOb2RlcywgZmFsc2UpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB2YXIgbGkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wdXRlUmluZ1NlbGZOb2RlcyQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGlzRG9uZUlmUHJvcGVySW50ID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIHNpID0gbmV3IFNlZ21lbnRJbnRlcnNlY3RvciQyKGxpJDEsIHRydWUsIGZhbHNlKTtcbiAgICAgIHNpLnNldElzRG9uZUlmUHJvcGVySW50KGlzRG9uZUlmUHJvcGVySW50KTtcbiAgICAgIHZhciBlc2kgPSB0aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpO1xuICAgICAgdmFyIGlzUmluZ3MgPSB0aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgTGluZWFyUmluZyB8fCB0aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgUG9seWdvbiB8fCB0aGlzLl9wYXJlbnRHZW9tIGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uO1xuICAgICAgdmFyIGNvbXB1dGVBbGxTZWdtZW50cyA9IGNvbXB1dGVSaW5nU2VsZk5vZGVzJDEgfHwgIWlzUmluZ3M7XG4gICAgICBlc2kuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMsIHNpLCBjb21wdXRlQWxsU2VnbWVudHMpO1xuICAgICAgdGhpcy5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXModGhpcy5fYXJnSW5kZXgpO1xuICAgICAgcmV0dXJuIHNpXG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5jb21wdXRlU3BsaXRFZGdlcyA9IGZ1bmN0aW9uIGNvbXB1dGVTcGxpdEVkZ2VzIChlZGdlbGlzdCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9lZGdlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlID0gaS5uZXh0KCk7XG4gICAgICBlLmVpTGlzdC5hZGRTcGxpdEVkZ2VzKGVkZ2VsaXN0KTtcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyAoZywgbGksIGluY2x1ZGVQcm9wZXIpIHtcbiAgICB2YXIgc2kgPSBuZXcgU2VnbWVudEludGVyc2VjdG9yJDIobGksIGluY2x1ZGVQcm9wZXIsIHRydWUpO1xuICAgIHNpLnNldEJvdW5kYXJ5Tm9kZXModGhpcy5nZXRCb3VuZGFyeU5vZGVzKCksIGcuZ2V0Qm91bmRhcnlOb2RlcygpKTtcbiAgICB2YXIgZXNpID0gdGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKTtcbiAgICBlc2kuY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5fZWRnZXMsIGcuX2VkZ2VzLCBzaSk7XG4gICAgcmV0dXJuIHNpXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRHZW9tXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmdldEJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeU5vZGVSdWxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYm91bmRhcnlOb2RlUnVsZVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5oYXNUb29GZXdQb2ludHMgPSBmdW5jdGlvbiBoYXNUb29GZXdQb2ludHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHNcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkUG9pbnQgPSBmdW5jdGlvbiBhZGRQb2ludCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb29yZCA9IHAuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgICAgdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCwgY29vcmQsIExvY2F0aW9uLklOVEVSSU9SKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwdCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsIHB0LCBMb2NhdGlvbi5JTlRFUklPUik7XG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRQb2x5Z29uID0gZnVuY3Rpb24gYWRkUG9seWdvbiAocCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5hZGRQb2x5Z29uUmluZyhwLmdldEV4dGVyaW9yUmluZygpLCBMb2NhdGlvbi5FWFRFUklPUiwgTG9jYXRpb24uSU5URVJJT1IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgICB2YXIgaG9sZSA9IHAuZ2V0SW50ZXJpb3JSaW5nTihpKTtcbiAgICAgIHRoaXMkMS5hZGRQb2x5Z29uUmluZyhob2xlLCBMb2NhdGlvbi5JTlRFUklPUiwgTG9jYXRpb24uRVhURVJJT1IpO1xuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkRWRnZSA9IGZ1bmN0aW9uIGFkZEVkZ2UgKGUpIHtcbiAgICB0aGlzLmluc2VydEVkZ2UoZSk7XG4gICAgdmFyIGNvb3JkID0gZS5nZXRDb29yZGluYXRlcygpO1xuICAgIHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsIGNvb3JkWzBdLCBMb2NhdGlvbi5CT1VOREFSWSk7XG4gICAgdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCwgY29vcmRbY29vcmQubGVuZ3RoIC0gMV0sIExvY2F0aW9uLkJPVU5EQVJZKTtcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkTGluZVN0cmluZyA9IGZ1bmN0aW9uIGFkZExpbmVTdHJpbmcgKGxpbmUpIHtcbiAgICB2YXIgY29vcmQgPSBDb29yZGluYXRlQXJyYXlzLnJlbW92ZVJlcGVhdGVkUG9pbnRzKGxpbmUuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgaWYgKGNvb3JkLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRoaXMuX2hhc1Rvb0Zld1BvaW50cyA9IHRydWU7XG4gICAgICB0aGlzLl9pbnZhbGlkUG9pbnQgPSBjb29yZFswXTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHZhciBlID0gbmV3IEVkZ2UoY29vcmQsIG5ldyBMYWJlbCh0aGlzLl9hcmdJbmRleCwgTG9jYXRpb24uSU5URVJJT1IpKTtcbiAgICB0aGlzLl9saW5lRWRnZU1hcC5wdXQobGluZSwgZSk7XG4gICAgdGhpcy5pbnNlcnRFZGdlKGUpO1xuICAgIEFzc2VydC5pc1RydWUoY29vcmQubGVuZ3RoID49IDIsICdmb3VuZCBMaW5lU3RyaW5nIHdpdGggc2luZ2xlIHBvaW50Jyk7XG4gICAgdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuX2FyZ0luZGV4LCBjb29yZFswXSk7XG4gICAgdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHRoaXMuX2FyZ0luZGV4LCBjb29yZFtjb29yZC5sZW5ndGggLSAxXSk7XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmdldEludmFsaWRQb2ludCA9IGZ1bmN0aW9uIGdldEludmFsaWRQb2ludCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludmFsaWRQb2ludFxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5nZXRCb3VuZGFyeVBvaW50cyA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5UG9pbnRzICgpIHtcbiAgICB2YXIgY29sbCA9IHRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpO1xuICAgIHZhciBwdHMgPSBuZXcgQXJyYXkoY29sbC5zaXplKCkpLmZpbGwobnVsbCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAodmFyIGl0ID0gY29sbC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbm9kZSA9IGl0Lm5leHQoKTtcbiAgICAgIHB0c1tpKytdID0gbm9kZS5nZXRDb29yZGluYXRlKCkuY29weSgpO1xuICAgIH1cbiAgICByZXR1cm4gcHRzXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmdldEJvdW5kYXJ5Tm9kZXMgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeU5vZGVzICgpIHtcbiAgICBpZiAodGhpcy5fYm91bmRhcnlOb2RlcyA9PT0gbnVsbCkgeyB0aGlzLl9ib3VuZGFyeU5vZGVzID0gdGhpcy5fbm9kZXMuZ2V0Qm91bmRhcnlOb2Rlcyh0aGlzLl9hcmdJbmRleCk7IH1cbiAgICByZXR1cm4gdGhpcy5fYm91bmRhcnlOb2Rlc1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSA9IGZ1bmN0aW9uIGFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlIChhcmdJbmRleCwgY29vcmQsIGxvYykge1xuICAgIGlmICh0aGlzLmlzQm91bmRhcnlOb2RlKGFyZ0luZGV4LCBjb29yZCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIGlmIChsb2MgPT09IExvY2F0aW9uLkJPVU5EQVJZICYmIHRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGUpIHsgdGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KGFyZ0luZGV4LCBjb29yZCk7IH0gZWxzZSB7IHRoaXMuaW5zZXJ0UG9pbnQoYXJnSW5kZXgsIGNvb3JkLCBsb2MpOyB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZFBvbHlnb25SaW5nID0gZnVuY3Rpb24gYWRkUG9seWdvblJpbmcgKGxyLCBjd0xlZnQsIGN3UmlnaHQpIHtcbiAgICBpZiAobHIuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgY29vcmQgPSBDb29yZGluYXRlQXJyYXlzLnJlbW92ZVJlcGVhdGVkUG9pbnRzKGxyLmdldENvb3JkaW5hdGVzKCkpO1xuICAgIGlmIChjb29yZC5sZW5ndGggPCA0KSB7XG4gICAgICB0aGlzLl9oYXNUb29GZXdQb2ludHMgPSB0cnVlO1xuICAgICAgdGhpcy5faW52YWxpZFBvaW50ID0gY29vcmRbMF07XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YXIgbGVmdCA9IGN3TGVmdDtcbiAgICB2YXIgcmlnaHQgPSBjd1JpZ2h0O1xuICAgIGlmIChDR0FsZ29yaXRobXMuaXNDQ1coY29vcmQpKSB7XG4gICAgICBsZWZ0ID0gY3dSaWdodDtcbiAgICAgIHJpZ2h0ID0gY3dMZWZ0O1xuICAgIH1cbiAgICB2YXIgZSA9IG5ldyBFZGdlKGNvb3JkLCBuZXcgTGFiZWwodGhpcy5fYXJnSW5kZXgsIExvY2F0aW9uLkJPVU5EQVJZLCBsZWZ0LCByaWdodCkpO1xuICAgIHRoaXMuX2xpbmVFZGdlTWFwLnB1dChsciwgZSk7XG4gICAgdGhpcy5pbnNlcnRFZGdlKGUpO1xuICAgIHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsIGNvb3JkWzBdLCBMb2NhdGlvbi5CT1VOREFSWSk7XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmluc2VydFBvaW50ID0gZnVuY3Rpb24gaW5zZXJ0UG9pbnQgKGFyZ0luZGV4LCBjb29yZCwgb25Mb2NhdGlvbikge1xuICAgIHZhciBuID0gdGhpcy5fbm9kZXMuYWRkTm9kZShjb29yZCk7XG4gICAgdmFyIGxibCA9IG4uZ2V0TGFiZWwoKTtcbiAgICBpZiAobGJsID09PSBudWxsKSB7XG4gICAgICBuLl9sYWJlbCA9IG5ldyBMYWJlbChhcmdJbmRleCwgb25Mb2NhdGlvbik7XG4gICAgfSBlbHNlIHsgbGJsLnNldExvY2F0aW9uKGFyZ0luZGV4LCBvbkxvY2F0aW9uKTsgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IgPSBmdW5jdGlvbiBjcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IgKCkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3RvcigpXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlcyA9IGZ1bmN0aW9uIGFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlcyAoYXJnSW5kZXgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSB0aGlzLl9lZGdlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlID0gaS5uZXh0KCk7XG4gICAgICB2YXIgZUxvYyA9IGUuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihhcmdJbmRleCk7XG4gICAgICBmb3IgKHZhciBlaUl0ID0gZS5laUxpc3QuaXRlcmF0b3IoKTsgZWlJdC5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBlaSA9IGVpSXQubmV4dCgpO1xuICAgICAgICB0aGlzJDEuYWRkU2VsZkludGVyc2VjdGlvbk5vZGUoYXJnSW5kZXgsIGVpLmNvb3JkLCBlTG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKGcuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIGlmIChnIGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSB7IHRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGUgPSBmYWxzZTsgfVxuICAgICAgaWYgKGcgaW5zdGFuY2VvZiBQb2x5Z29uKSB7IHRoaXMuYWRkUG9seWdvbihnKTsgfVxuICAgICAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHsgdGhpcy5hZGRMaW5lU3RyaW5nKGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgUG9pbnQpIHsgdGhpcy5hZGRQb2ludChnKTsgfVxuICAgICAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIE11bHRpUG9pbnQpIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTXVsdGlMaW5lU3RyaW5nKSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICAgICAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIE11bHRpUG9seWdvbikgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgICAgIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gICAgICBlbHNlIHsgdGhyb3cgbmV3IEVycm9yKGcuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpIH1cbiAgICB9IGVsc2UgeyByZXR1cm4gUGxhbmFyR3JhcGgkJDEucHJvdG90eXBlLmFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGFkZENvbGxlY3Rpb24gKGdjKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdjLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgICB2YXIgZyA9IGdjLmdldEdlb21ldHJ5TihpKTtcbiAgICAgIHRoaXMkMS5hZGQoZyk7XG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5sb2NhdGUgPSBmdW5jdGlvbiBsb2NhdGUgKHB0KSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZSh0aGlzLl9wYXJlbnRHZW9tLCBQb2x5Z29uYWwpICYmIHRoaXMuX3BhcmVudEdlb20uZ2V0TnVtR2VvbWV0cmllcygpID4gNTApIHtcbiAgICAgIGlmICh0aGlzLl9hcmVhUHRMb2NhdG9yID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2FyZWFQdExvY2F0b3IgPSBuZXcgSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvcih0aGlzLl9wYXJlbnRHZW9tKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9hcmVhUHRMb2NhdG9yLmxvY2F0ZShwdClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B0TG9jYXRvci5sb2NhdGUocHQsIHRoaXMuX3BhcmVudEdlb20pXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmZpbmRFZGdlID0gZnVuY3Rpb24gZmluZEVkZ2UgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbGluZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLl9saW5lRWRnZU1hcC5nZXQobGluZSlcbiAgICB9IGVsc2UgeyByZXR1cm4gUGxhbmFyR3JhcGgkJDEucHJvdG90eXBlLmZpbmRFZGdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5R3JhcGhcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5kZXRlcm1pbmVCb3VuZGFyeSA9IGZ1bmN0aW9uIGRldGVybWluZUJvdW5kYXJ5IChib3VuZGFyeU5vZGVSdWxlLCBib3VuZGFyeUNvdW50KSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5Tm9kZVJ1bGUuaXNJbkJvdW5kYXJ5KGJvdW5kYXJ5Q291bnQpID8gTG9jYXRpb24uQk9VTkRBUlkgOiBMb2NhdGlvbi5JTlRFUklPUlxuICB9O1xuXG4gIHJldHVybiBHZW9tZXRyeUdyYXBoO1xufShQbGFuYXJHcmFwaCkpO1xuXG52YXIgR2VvbWV0cnlHcmFwaE9wID0gZnVuY3Rpb24gR2VvbWV0cnlHcmFwaE9wICgpIHtcbiAgdGhpcy5fbGkgPSBuZXcgUm9idXN0TGluZUludGVyc2VjdG9yKCk7XG4gIHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsID0gbnVsbDtcbiAgdGhpcy5fYXJnID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihnMC5nZXRQcmVjaXNpb25Nb2RlbCgpKTtcbiAgICB0aGlzLl9hcmcgPSBuZXcgQXJyYXkoMSkuZmlsbChudWxsKTtcbiAgICB0aGlzLl9hcmdbMF0gPSBuZXcgR2VvbWV0cnlHcmFwaCgwLCBnMCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYm91bmRhcnlOb2RlUnVsZSA9IEJvdW5kYXJ5Tm9kZVJ1bGUuT0dDX1NGU19CT1VOREFSWV9SVUxFO1xuICAgIGlmIChnMCQxLmdldFByZWNpc2lvbk1vZGVsKCkuY29tcGFyZVRvKGcxLmdldFByZWNpc2lvbk1vZGVsKCkpID49IDApIHsgdGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihnMCQxLmdldFByZWNpc2lvbk1vZGVsKCkpOyB9IGVsc2UgeyB0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGcxLmdldFByZWNpc2lvbk1vZGVsKCkpOyB9XG4gICAgdGhpcy5fYXJnID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5fYXJnWzBdID0gbmV3IEdlb21ldHJ5R3JhcGgoMCwgZzAkMSwgYm91bmRhcnlOb2RlUnVsZSk7XG4gICAgdGhpcy5fYXJnWzFdID0gbmV3IEdlb21ldHJ5R3JhcGgoMSwgZzEsIGJvdW5kYXJ5Tm9kZVJ1bGUpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgZzAkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYm91bmRhcnlOb2RlUnVsZSQxID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChnMCQyLmdldFByZWNpc2lvbk1vZGVsKCkuY29tcGFyZVRvKGcxJDEuZ2V0UHJlY2lzaW9uTW9kZWwoKSkgPj0gMCkgeyB0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGcwJDIuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7IH0gZWxzZSB7IHRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZzEkMS5nZXRQcmVjaXNpb25Nb2RlbCgpKTsgfVxuICAgIHRoaXMuX2FyZyA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICAgIHRoaXMuX2FyZ1swXSA9IG5ldyBHZW9tZXRyeUdyYXBoKDAsIGcwJDIsIGJvdW5kYXJ5Tm9kZVJ1bGUkMSk7XG4gICAgdGhpcy5fYXJnWzFdID0gbmV3IEdlb21ldHJ5R3JhcGgoMSwgZzEkMSwgYm91bmRhcnlOb2RlUnVsZSQxKTtcbiAgfVxufTtcbkdlb21ldHJ5R3JhcGhPcC5wcm90b3R5cGUuZ2V0QXJnR2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRBcmdHZW9tZXRyeSAoaSkge1xuICByZXR1cm4gdGhpcy5fYXJnW2ldLmdldEdlb21ldHJ5KClcbn07XG5HZW9tZXRyeUdyYXBoT3AucHJvdG90eXBlLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uID0gZnVuY3Rpb24gc2V0Q29tcHV0YXRpb25QcmVjaXNpb24gKHBtKSB7XG4gIHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsID0gcG07XG4gIHRoaXMuX2xpLnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3Jlc3VsdFByZWNpc2lvbk1vZGVsKTtcbn07XG5HZW9tZXRyeUdyYXBoT3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeUdyYXBoT3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlHcmFwaE9wXG59O1xuXG4vLyBvcGVyYXRpb24uZ2VvbWV0cnlncmFwaFxuXG52YXIgR2VvbWV0cnlNYXBwZXIgPSBmdW5jdGlvbiBHZW9tZXRyeU1hcHBlciAoKSB7fTtcblxuR2VvbWV0cnlNYXBwZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeU1hcHBlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeU1hcHBlclxufTtcbkdlb21ldHJ5TWFwcGVyLm1hcCA9IGZ1bmN0aW9uIG1hcCAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBHZW9tZXRyeU1hcHBlci5NYXBPcCkpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb3AgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBlZCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICAgIHZhciBnID0gb3AubWFwKGdlb20uZ2V0R2VvbWV0cnlOKGkpKTtcbiAgICAgIGlmIChnICE9PSBudWxsKSB7IG1hcHBlZC5hZGQoZyk7IH1cbiAgICB9XG4gICAgcmV0dXJuIGdlb20uZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkobWFwcGVkKVxuICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvbGxlY3Rpb24pICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIEdlb21ldHJ5TWFwcGVyLk1hcE9wKSkge1xuICAgIHZhciBnZW9tcyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb3AkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGVkJDEgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaSQxID0gZ2VvbXMuaXRlcmF0b3IoKTsgaSQxLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBnJDEgPSBpJDEubmV4dCgpO1xuICAgICAgdmFyIGdyID0gb3AkMS5tYXAoZyQxKTtcbiAgICAgIGlmIChnciAhPT0gbnVsbCkgeyBtYXBwZWQkMS5hZGQoZ3IpOyB9XG4gICAgfVxuICAgIHJldHVybiBtYXBwZWQkMVxuICB9XG59O1xuR2VvbWV0cnlNYXBwZXIuTWFwT3AgPSBmdW5jdGlvbiBNYXBPcCAoKSB7fTtcblxudmFyIE92ZXJsYXlPcCA9IChmdW5jdGlvbiAoR2VvbWV0cnlHcmFwaE9wKSB7XG4gIGZ1bmN0aW9uIE92ZXJsYXlPcCAoKSB7XG4gICAgdmFyIGcwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBHZW9tZXRyeUdyYXBoT3AuY2FsbCh0aGlzLCBnMCwgZzEpO1xuICAgIHRoaXMuX3B0TG9jYXRvciA9IG5ldyBQb2ludExvY2F0b3IoKTtcbiAgICB0aGlzLl9nZW9tRmFjdCA9IG51bGw7XG4gICAgdGhpcy5fcmVzdWx0R2VvbSA9IG51bGw7XG4gICAgdGhpcy5fZ3JhcGggPSBudWxsO1xuICAgIHRoaXMuX2VkZ2VMaXN0ID0gbmV3IEVkZ2VMaXN0KCk7XG4gICAgdGhpcy5fcmVzdWx0UG9seUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5fcmVzdWx0TGluZUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5fcmVzdWx0UG9pbnRMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHRoaXMuX2dyYXBoID0gbmV3IFBsYW5hckdyYXBoKG5ldyBPdmVybGF5Tm9kZUZhY3RvcnkoKSk7XG4gICAgdGhpcy5fZ2VvbUZhY3QgPSBnMC5nZXRGYWN0b3J5KCk7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5R3JhcGhPcCApIE92ZXJsYXlPcC5fX3Byb3RvX18gPSBHZW9tZXRyeUdyYXBoT3A7XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeUdyYXBoT3AgJiYgR2VvbWV0cnlHcmFwaE9wLnByb3RvdHlwZSApO1xuICBPdmVybGF5T3AucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT3ZlcmxheU9wO1xuICBPdmVybGF5T3AucHJvdG90eXBlLmluc2VydFVuaXF1ZUVkZ2UgPSBmdW5jdGlvbiBpbnNlcnRVbmlxdWVFZGdlIChlKSB7XG4gICAgdmFyIGV4aXN0aW5nRWRnZSA9IHRoaXMuX2VkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UoZSk7XG4gICAgaWYgKGV4aXN0aW5nRWRnZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGV4aXN0aW5nTGFiZWwgPSBleGlzdGluZ0VkZ2UuZ2V0TGFiZWwoKTtcbiAgICAgIHZhciBsYWJlbFRvTWVyZ2UgPSBlLmdldExhYmVsKCk7XG4gICAgICBpZiAoIWV4aXN0aW5nRWRnZS5pc1BvaW50d2lzZUVxdWFsKGUpKSB7XG4gICAgICAgIGxhYmVsVG9NZXJnZSA9IG5ldyBMYWJlbChlLmdldExhYmVsKCkpO1xuICAgICAgICBsYWJlbFRvTWVyZ2UuZmxpcCgpO1xuICAgICAgfVxuICAgICAgdmFyIGRlcHRoID0gZXhpc3RpbmdFZGdlLmdldERlcHRoKCk7XG4gICAgICBpZiAoZGVwdGguaXNOdWxsKCkpIHtcbiAgICAgICAgZGVwdGguYWRkKGV4aXN0aW5nTGFiZWwpO1xuICAgICAgfVxuICAgICAgZGVwdGguYWRkKGxhYmVsVG9NZXJnZSk7XG4gICAgICBleGlzdGluZ0xhYmVsLm1lcmdlKGxhYmVsVG9NZXJnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VkZ2VMaXN0LmFkZChlKTtcbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0R3JhcGggPSBmdW5jdGlvbiBnZXRHcmFwaCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMgPSBmdW5jdGlvbiBjYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcyAoKSB7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLl9ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBzeW0gPSBkZS5nZXRTeW0oKTtcbiAgICAgIGlmIChkZS5pc0luUmVzdWx0KCkgJiYgc3ltLmlzSW5SZXN1bHQoKSkge1xuICAgICAgICBkZS5zZXRJblJlc3VsdChmYWxzZSk7XG4gICAgICAgIHN5bS5zZXRJblJlc3VsdChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmlzQ292ZXJlZEJ5TEEgPSBmdW5jdGlvbiBpc0NvdmVyZWRCeUxBIChjb29yZCkge1xuICAgIGlmICh0aGlzLmlzQ292ZXJlZChjb29yZCwgdGhpcy5fcmVzdWx0TGluZUxpc3QpKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAodGhpcy5pc0NvdmVyZWQoY29vcmQsIHRoaXMuX3Jlc3VsdFBvbHlMaXN0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY29tcHV0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gY29tcHV0ZUdlb21ldHJ5IChyZXN1bHRQb2ludExpc3QsIHJlc3VsdExpbmVMaXN0LCByZXN1bHRQb2x5TGlzdCwgb3Bjb2RlKSB7XG4gICAgdmFyIGdlb21MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGdlb21MaXN0LmFkZEFsbChyZXN1bHRQb2ludExpc3QpO1xuICAgIGdlb21MaXN0LmFkZEFsbChyZXN1bHRMaW5lTGlzdCk7XG4gICAgZ2VvbUxpc3QuYWRkQWxsKHJlc3VsdFBvbHlMaXN0KTtcbiAgICBpZiAoZ2VvbUxpc3QuaXNFbXB0eSgpKSB7IHJldHVybiBPdmVybGF5T3AuY3JlYXRlRW1wdHlSZXN1bHQob3Bjb2RlLCB0aGlzLl9hcmdbMF0uZ2V0R2VvbWV0cnkoKSwgdGhpcy5fYXJnWzFdLmdldEdlb21ldHJ5KCksIHRoaXMuX2dlb21GYWN0KSB9XG4gICAgcmV0dXJuIHRoaXMuX2dlb21GYWN0LmJ1aWxkR2VvbWV0cnkoZ2VvbUxpc3QpXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUubWVyZ2VTeW1MYWJlbHMgPSBmdW5jdGlvbiBtZXJnZVN5bUxhYmVscyAoKSB7XG4gICAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG5vZGUgPSBub2RlaXQubmV4dCgpO1xuICAgICAgbm9kZS5nZXRFZGdlcygpLm1lcmdlU3ltTGFiZWxzKCk7XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmlzQ292ZXJlZCA9IGZ1bmN0aW9uIGlzQ292ZXJlZCAoY29vcmQsIGdlb21MaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpdCA9IGdlb21MaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBnZW9tID0gaXQubmV4dCgpO1xuICAgICAgdmFyIGxvYyA9IHRoaXMkMS5fcHRMb2NhdG9yLmxvY2F0ZShjb29yZCwgZ2VvbSk7XG4gICAgICBpZiAobG9jICE9PSBMb2NhdGlvbi5FWFRFUklPUikgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLnJlcGxhY2VDb2xsYXBzZWRFZGdlcyA9IGZ1bmN0aW9uIHJlcGxhY2VDb2xsYXBzZWRFZGdlcyAoKSB7XG4gICAgdmFyIG5ld0VkZ2VzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5fZWRnZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgICBpZiAoZS5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGl0LnJlbW92ZSgpO1xuICAgICAgICBuZXdFZGdlcy5hZGQoZS5nZXRDb2xsYXBzZWRFZGdlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9lZGdlTGlzdC5hZGRBbGwobmV3RWRnZXMpO1xuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLnVwZGF0ZU5vZGVMYWJlbGxpbmcgPSBmdW5jdGlvbiB1cGRhdGVOb2RlTGFiZWxsaW5nICgpIHtcbiAgICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgICB2YXIgbGJsID0gbm9kZS5nZXRFZGdlcygpLmdldExhYmVsKCk7XG4gICAgICBub2RlLmdldExhYmVsKCkubWVyZ2UobGJsKTtcbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0UmVzdWx0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRSZXN1bHRHZW9tZXRyeSAob3ZlcmxheU9wQ29kZSkge1xuICAgIHRoaXMuY29tcHV0ZU92ZXJsYXkob3ZlcmxheU9wQ29kZSk7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3VsdEdlb21cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5pbnNlcnRVbmlxdWVFZGdlcyA9IGZ1bmN0aW9uIGluc2VydFVuaXF1ZUVkZ2VzIChlZGdlcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IGVkZ2VzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGUgPSBpLm5leHQoKTtcbiAgICAgIHRoaXMkMS5pbnNlcnRVbmlxdWVFZGdlKGUpO1xuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb21wdXRlT3ZlcmxheSA9IGZ1bmN0aW9uIGNvbXB1dGVPdmVybGF5IChvcENvZGUpIHtcbiAgICB0aGlzLmNvcHlQb2ludHMoMCk7XG4gICAgdGhpcy5jb3B5UG9pbnRzKDEpO1xuICAgIHRoaXMuX2FyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCBmYWxzZSk7XG4gICAgdGhpcy5fYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksIGZhbHNlKTtcbiAgICB0aGlzLl9hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuX2FyZ1sxXSwgdGhpcy5fbGksIHRydWUpO1xuICAgIHZhciBiYXNlU3BsaXRFZGdlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLl9hcmdbMF0uY29tcHV0ZVNwbGl0RWRnZXMoYmFzZVNwbGl0RWRnZXMpO1xuICAgIHRoaXMuX2FyZ1sxXS5jb21wdXRlU3BsaXRFZGdlcyhiYXNlU3BsaXRFZGdlcyk7XG4gICAgLy8gY29uc3Qgc3BsaXRFZGdlcyA9IGJhc2VTcGxpdEVkZ2VzXG4gICAgdGhpcy5pbnNlcnRVbmlxdWVFZGdlcyhiYXNlU3BsaXRFZGdlcyk7XG4gICAgdGhpcy5jb21wdXRlTGFiZWxzRnJvbURlcHRocygpO1xuICAgIHRoaXMucmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCk7XG4gICAgRWRnZU5vZGluZ1ZhbGlkYXRvci5jaGVja1ZhbGlkKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpO1xuICAgIHRoaXMuX2dyYXBoLmFkZEVkZ2VzKHRoaXMuX2VkZ2VMaXN0LmdldEVkZ2VzKCkpO1xuICAgIHRoaXMuY29tcHV0ZUxhYmVsbGluZygpO1xuICAgIHRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZXMoKTtcbiAgICB0aGlzLmZpbmRSZXN1bHRBcmVhRWRnZXMob3BDb2RlKTtcbiAgICB0aGlzLmNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzKCk7XG4gICAgdmFyIHBvbHlCdWlsZGVyID0gbmV3IFBvbHlnb25CdWlsZGVyKHRoaXMuX2dlb21GYWN0KTtcbiAgICBwb2x5QnVpbGRlci5hZGQodGhpcy5fZ3JhcGgpO1xuICAgIHRoaXMuX3Jlc3VsdFBvbHlMaXN0ID0gcG9seUJ1aWxkZXIuZ2V0UG9seWdvbnMoKTtcbiAgICB2YXIgbGluZUJ1aWxkZXIgPSBuZXcgTGluZUJ1aWxkZXIodGhpcywgdGhpcy5fZ2VvbUZhY3QsIHRoaXMuX3B0TG9jYXRvcik7XG4gICAgdGhpcy5fcmVzdWx0TGluZUxpc3QgPSBsaW5lQnVpbGRlci5idWlsZChvcENvZGUpO1xuICAgIHZhciBwb2ludEJ1aWxkZXIgPSBuZXcgUG9pbnRCdWlsZGVyKHRoaXMsIHRoaXMuX2dlb21GYWN0LCB0aGlzLl9wdExvY2F0b3IpO1xuICAgIHRoaXMuX3Jlc3VsdFBvaW50TGlzdCA9IHBvaW50QnVpbGRlci5idWlsZChvcENvZGUpO1xuICAgIHRoaXMuX3Jlc3VsdEdlb20gPSB0aGlzLmNvbXB1dGVHZW9tZXRyeSh0aGlzLl9yZXN1bHRQb2ludExpc3QsIHRoaXMuX3Jlc3VsdExpbmVMaXN0LCB0aGlzLl9yZXN1bHRQb2x5TGlzdCwgb3BDb2RlKTtcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5sYWJlbEluY29tcGxldGVOb2RlID0gZnVuY3Rpb24gbGFiZWxJbmNvbXBsZXRlTm9kZSAobiwgdGFyZ2V0SW5kZXgpIHtcbiAgICB2YXIgbG9jID0gdGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShuLmdldENvb3JkaW5hdGUoKSwgdGhpcy5fYXJnW3RhcmdldEluZGV4XS5nZXRHZW9tZXRyeSgpKTtcbiAgICBuLmdldExhYmVsKCkuc2V0TG9jYXRpb24odGFyZ2V0SW5kZXgsIGxvYyk7XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY29weVBvaW50cyA9IGZ1bmN0aW9uIGNvcHlQb2ludHMgKGFyZ0luZGV4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy5fYXJnW2FyZ0luZGV4XS5nZXROb2RlSXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZ3JhcGhOb2RlID0gaS5uZXh0KCk7XG4gICAgICB2YXIgbmV3Tm9kZSA9IHRoaXMkMS5fZ3JhcGguYWRkTm9kZShncmFwaE5vZGUuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICAgIG5ld05vZGUuc2V0TGFiZWwoYXJnSW5kZXgsIGdyYXBoTm9kZS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGFyZ0luZGV4KSk7XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmZpbmRSZXN1bHRBcmVhRWRnZXMgPSBmdW5jdGlvbiBmaW5kUmVzdWx0QXJlYUVkZ2VzIChvcENvZGUpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIGxhYmVsID0gZGUuZ2V0TGFiZWwoKTtcbiAgICAgIGlmIChsYWJlbC5pc0FyZWEoKSAmJiAhZGUuaXNJbnRlcmlvckFyZWFFZGdlKCkgJiYgT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcChsYWJlbC5nZXRMb2NhdGlvbigwLCBQb3NpdGlvbi5SSUdIVCksIGxhYmVsLmdldExvY2F0aW9uKDEsIFBvc2l0aW9uLlJJR0hUKSwgb3BDb2RlKSkge1xuICAgICAgICBkZS5zZXRJblJlc3VsdCh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMgPSBmdW5jdGlvbiBjb21wdXRlTGFiZWxzRnJvbURlcHRocyAoKSB7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBsYmwgPSBlLmdldExhYmVsKCk7XG4gICAgICB2YXIgZGVwdGggPSBlLmdldERlcHRoKCk7XG4gICAgICBpZiAoIWRlcHRoLmlzTnVsbCgpKSB7XG4gICAgICAgIGRlcHRoLm5vcm1hbGl6ZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgIGlmICghbGJsLmlzTnVsbChpKSAmJiBsYmwuaXNBcmVhKCkgJiYgIWRlcHRoLmlzTnVsbChpKSkge1xuICAgICAgICAgICAgaWYgKGRlcHRoLmdldERlbHRhKGkpID09PSAwKSB7XG4gICAgICAgICAgICAgIGxibC50b0xpbmUoaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBBc3NlcnQuaXNUcnVlKCFkZXB0aC5pc051bGwoaSwgUG9zaXRpb24uTEVGVCksICdkZXB0aCBvZiBMRUZUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICAgIGxibC5zZXRMb2NhdGlvbihpLCBQb3NpdGlvbi5MRUZULCBkZXB0aC5nZXRMb2NhdGlvbihpLCBQb3NpdGlvbi5MRUZUKSk7XG4gICAgICAgICAgICAgIEFzc2VydC5pc1RydWUoIWRlcHRoLmlzTnVsbChpLCBQb3NpdGlvbi5SSUdIVCksICdkZXB0aCBvZiBSSUdIVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgICBsYmwuc2V0TG9jYXRpb24oaSwgUG9zaXRpb24uUklHSFQsIGRlcHRoLmdldExvY2F0aW9uKGksIFBvc2l0aW9uLlJJR0hUKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmNvbXB1dGVMYWJlbGxpbmcgPSBmdW5jdGlvbiBjb21wdXRlTGFiZWxsaW5nICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIG5vZGVpdCA9IHRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICAgIG5vZGUuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMkMS5fYXJnKTtcbiAgICB9XG4gICAgdGhpcy5tZXJnZVN5bUxhYmVscygpO1xuICAgIHRoaXMudXBkYXRlTm9kZUxhYmVsbGluZygpO1xuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmxhYmVsSW5jb21wbGV0ZU5vZGVzID0gZnVuY3Rpb24gbGFiZWxJbmNvbXBsZXRlTm9kZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgLy8gbGV0IG5vZGVDb3VudCA9IDBcbiAgICBmb3IgKHZhciBuaSA9IHRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgbmkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG4gPSBuaS5uZXh0KCk7XG4gICAgICB2YXIgbGFiZWwgPSBuLmdldExhYmVsKCk7XG4gICAgICBpZiAobi5pc0lzb2xhdGVkKCkpIHtcbiAgICAgICAgLy8gbm9kZUNvdW50KytcbiAgICAgICAgaWYgKGxhYmVsLmlzTnVsbCgwKSkgeyB0aGlzJDEubGFiZWxJbmNvbXBsZXRlTm9kZShuLCAwKTsgfSBlbHNlIHsgdGhpcyQxLmxhYmVsSW5jb21wbGV0ZU5vZGUobiwgMSk7IH1cbiAgICAgIH1cbiAgICAgIG4uZ2V0RWRnZXMoKS51cGRhdGVMYWJlbGxpbmcobGFiZWwpO1xuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5pc0NvdmVyZWRCeUEgPSBmdW5jdGlvbiBpc0NvdmVyZWRCeUEgKGNvb3JkKSB7XG4gICAgaWYgKHRoaXMuaXNDb3ZlcmVkKGNvb3JkLCB0aGlzLl9yZXN1bHRQb2x5TGlzdCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBPdmVybGF5T3BcbiAgfTtcblxuICByZXR1cm4gT3ZlcmxheU9wO1xufShHZW9tZXRyeUdyYXBoT3ApKTtcblxuT3ZlcmxheU9wLm92ZXJsYXlPcCA9IGZ1bmN0aW9uIChnZW9tMCwgZ2VvbTEsIG9wQ29kZSkge1xuICB2YXIgZ292ID0gbmV3IE92ZXJsYXlPcChnZW9tMCwgZ2VvbTEpO1xuICB2YXIgZ2VvbU92ID0gZ292LmdldFJlc3VsdEdlb21ldHJ5KG9wQ29kZSk7XG4gIHJldHVybiBnZW9tT3Zcbn07XG5PdmVybGF5T3AuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKGcsIG90aGVyKSB7XG4gIGlmIChnLmlzRW1wdHkoKSB8fCBvdGhlci5pc0VtcHR5KCkpIHsgcmV0dXJuIE92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdChPdmVybGF5T3AuSU5URVJTRUNUSU9OLCBnLCBvdGhlciwgZy5nZXRGYWN0b3J5KCkpIH1cbiAgaWYgKGcuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSkge1xuICAgIHZhciBnMiA9IG90aGVyO1xuICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIubWFwKGcsIHtcbiAgICAgIGludGVyZmFjZXNfOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbR2VvbWV0cnlNYXBwZXIuTWFwT3BdXG4gICAgICB9LFxuICAgICAgbWFwOiBmdW5jdGlvbiAoZykge1xuICAgICAgICByZXR1cm4gZy5pbnRlcnNlY3Rpb24oZzIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBnLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGcpO1xuICBnLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKG90aGVyKTtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZywgb3RoZXIsIE92ZXJsYXlPcC5JTlRFUlNFQ1RJT04pXG59O1xuT3ZlcmxheU9wLnN5bURpZmZlcmVuY2UgPSBmdW5jdGlvbiAoZywgb3RoZXIpIHtcbiAgaWYgKGcuaXNFbXB0eSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xuICAgIGlmIChnLmlzRW1wdHkoKSAmJiBvdGhlci5pc0VtcHR5KCkpIHsgcmV0dXJuIE92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdChPdmVybGF5T3AuU1lNRElGRkVSRU5DRSwgZywgb3RoZXIsIGcuZ2V0RmFjdG9yeSgpKSB9XG4gICAgaWYgKGcuaXNFbXB0eSgpKSB7IHJldHVybiBvdGhlci5jb3B5KCkgfVxuICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHsgcmV0dXJuIGcuY29weSgpIH1cbiAgfVxuICBnLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGcpO1xuICBnLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKG90aGVyKTtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZywgb3RoZXIsIE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFKVxufTtcbk92ZXJsYXlPcC5yZXN1bHREaW1lbnNpb24gPSBmdW5jdGlvbiAob3BDb2RlLCBnMCwgZzEpIHtcbiAgdmFyIGRpbTAgPSBnMC5nZXREaW1lbnNpb24oKTtcbiAgdmFyIGRpbTEgPSBnMS5nZXREaW1lbnNpb24oKTtcbiAgdmFyIHJlc3VsdERpbWVuc2lvbiA9IC0xO1xuICBzd2l0Y2ggKG9wQ29kZSkge1xuICAgIGNhc2UgT3ZlcmxheU9wLklOVEVSU0VDVElPTjpcbiAgICAgIHJlc3VsdERpbWVuc2lvbiA9IE1hdGgubWluKGRpbTAsIGRpbTEpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIE92ZXJsYXlPcC5VTklPTjpcbiAgICAgIHJlc3VsdERpbWVuc2lvbiA9IE1hdGgubWF4KGRpbTAsIGRpbTEpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIE92ZXJsYXlPcC5ESUZGRVJFTkNFOlxuICAgICAgcmVzdWx0RGltZW5zaW9uID0gZGltMDtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBPdmVybGF5T3AuU1lNRElGRkVSRU5DRTpcbiAgICAgIHJlc3VsdERpbWVuc2lvbiA9IE1hdGgubWF4KGRpbTAsIGRpbTEpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiByZXN1bHREaW1lbnNpb25cbn07XG5PdmVybGF5T3AuY3JlYXRlRW1wdHlSZXN1bHQgPSBmdW5jdGlvbiAob3ZlcmxheU9wQ29kZSwgYSwgYiwgZ2VvbUZhY3QpIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHN3aXRjaCAoT3ZlcmxheU9wLnJlc3VsdERpbWVuc2lvbihvdmVybGF5T3BDb2RlLCBhLCBiKSkge1xuICAgIGNhc2UgLTE6XG4gICAgICByZXN1bHQgPSBnZW9tRmFjdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obmV3IEFycmF5KDApLmZpbGwobnVsbCkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDA6XG4gICAgICByZXN1bHQgPSBnZW9tRmFjdC5jcmVhdGVQb2ludCgpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDE6XG4gICAgICByZXN1bHQgPSBnZW9tRmFjdC5jcmVhdGVMaW5lU3RyaW5nKCk7XG4gICAgICBicmVha1xuICAgIGNhc2UgMjpcbiAgICAgIHJlc3VsdCA9IGdlb21GYWN0LmNyZWF0ZVBvbHlnb24oKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuT3ZlcmxheU9wLmRpZmZlcmVuY2UgPSBmdW5jdGlvbiAoZywgb3RoZXIpIHtcbiAgaWYgKGcuaXNFbXB0eSgpKSB7IHJldHVybiBPdmVybGF5T3AuY3JlYXRlRW1wdHlSZXN1bHQoT3ZlcmxheU9wLkRJRkZFUkVOQ0UsIGcsIG90aGVyLCBnLmdldEZhY3RvcnkoKSkgfVxuICBpZiAob3RoZXIuaXNFbXB0eSgpKSB7IHJldHVybiBnLmNvcHkoKSB9XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZyk7XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24ob3RoZXIpO1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnLCBvdGhlciwgT3ZlcmxheU9wLkRJRkZFUkVOQ0UpXG59O1xuT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgbGFiZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9wQ29kZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbG9jMCA9IGxhYmVsLmdldExvY2F0aW9uKDApO1xuICAgIHZhciBsb2MxID0gbGFiZWwuZ2V0TG9jYXRpb24oMSk7XG4gICAgcmV0dXJuIE92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AobG9jMCwgbG9jMSwgb3BDb2RlKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgbG9jMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsb2MxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG92ZXJsYXlPcENvZGUgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGxvYzAkMSA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgbG9jMCQxID0gTG9jYXRpb24uSU5URVJJT1I7IH1cbiAgICBpZiAobG9jMSQxID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBsb2MxJDEgPSBMb2NhdGlvbi5JTlRFUklPUjsgfVxuICAgIHN3aXRjaCAob3ZlcmxheU9wQ29kZSkge1xuICAgICAgY2FzZSBPdmVybGF5T3AuSU5URVJTRUNUSU9OOlxuICAgICAgICByZXR1cm4gbG9jMCQxID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiBsb2MxJDEgPT09IExvY2F0aW9uLklOVEVSSU9SXG4gICAgICBjYXNlIE92ZXJsYXlPcC5VTklPTjpcbiAgICAgICAgcmV0dXJuIGxvYzAkMSA9PT0gTG9jYXRpb24uSU5URVJJT1IgfHwgbG9jMSQxID09PSBMb2NhdGlvbi5JTlRFUklPUlxuICAgICAgY2FzZSBPdmVybGF5T3AuRElGRkVSRU5DRTpcbiAgICAgICAgcmV0dXJuIGxvYzAkMSA9PT0gTG9jYXRpb24uSU5URVJJT1IgJiYgbG9jMSQxICE9PSBMb2NhdGlvbi5JTlRFUklPUlxuICAgICAgY2FzZSBPdmVybGF5T3AuU1lNRElGRkVSRU5DRTpcbiAgICAgICAgcmV0dXJuIChsb2MwJDEgPT09IExvY2F0aW9uLklOVEVSSU9SICYmIGxvYzEkMSAhPT0gTG9jYXRpb24uSU5URVJJT1IpIHx8IChsb2MwJDEgIT09IExvY2F0aW9uLklOVEVSSU9SICYmIGxvYzEkMSA9PT0gTG9jYXRpb24uSU5URVJJT1IpXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcbk92ZXJsYXlPcC5JTlRFUlNFQ1RJT04gPSAxO1xuT3ZlcmxheU9wLlVOSU9OID0gMjtcbk92ZXJsYXlPcC5ESUZGRVJFTkNFID0gMztcbk92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFID0gNDtcblxudmFyIEZ1enp5UG9pbnRMb2NhdG9yID0gZnVuY3Rpb24gRnV6enlQb2ludExvY2F0b3IgKCkge1xuICB0aGlzLl9nID0gbnVsbDtcbiAgdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSA9IG51bGw7XG4gIHRoaXMuX2xpbmV3b3JrID0gbnVsbDtcbiAgdGhpcy5fcHRMb2NhdG9yID0gbmV3IFBvaW50TG9jYXRvcigpO1xuICB0aGlzLl9zZWcgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gIHZhciBib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl9nID0gZztcbiAgdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSA9IGJvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2U7XG4gIHRoaXMuX2xpbmV3b3JrID0gdGhpcy5leHRyYWN0TGluZXdvcmsoZyk7XG59O1xuRnV6enlQb2ludExvY2F0b3IucHJvdG90eXBlLmlzV2l0aGluVG9sZXJhbmNlT2ZCb3VuZGFyeSA9IGZ1bmN0aW9uIGlzV2l0aGluVG9sZXJhbmNlT2ZCb3VuZGFyeSAocHQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpbmV3b3JrLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzJDEuX2xpbmV3b3JrLmdldEdlb21ldHJ5TihpKTtcbiAgICB2YXIgc2VxID0gbGluZS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcS5zaXplKCkgLSAxOyBqKyspIHtcbiAgICAgIHNlcS5nZXRDb29yZGluYXRlKGosIHRoaXMkMS5fc2VnLnAwKTtcbiAgICAgIHNlcS5nZXRDb29yZGluYXRlKGogKyAxLCB0aGlzJDEuX3NlZy5wMSk7XG4gICAgICB2YXIgZGlzdCA9IHRoaXMkMS5fc2VnLmRpc3RhbmNlKHB0KTtcbiAgICAgIGlmIChkaXN0IDw9IHRoaXMkMS5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkZ1enp5UG9pbnRMb2NhdG9yLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uIChwdCkge1xuICBpZiAodGhpcy5pc1dpdGhpblRvbGVyYW5jZU9mQm91bmRhcnkocHQpKSB7IHJldHVybiBMb2NhdGlvbi5CT1VOREFSWSB9XG4gIHJldHVybiB0aGlzLl9wdExvY2F0b3IubG9jYXRlKHB0LCB0aGlzLl9nKVxufTtcbkZ1enp5UG9pbnRMb2NhdG9yLnByb3RvdHlwZS5leHRyYWN0TGluZXdvcmsgPSBmdW5jdGlvbiBleHRyYWN0TGluZXdvcmsgKGcpIHtcbiAgdmFyIGV4dHJhY3RlciA9IG5ldyBQb2x5Z29uYWxMaW5ld29ya0V4dHJhY3RlcigpO1xuICBnLmFwcGx5KGV4dHJhY3Rlcik7XG4gIHZhciBsaW5ld29yayA9IGV4dHJhY3Rlci5nZXRMaW5ld29yaygpO1xuICB2YXIgbGluZXMgPSBHZW9tZXRyeUZhY3RvcnkudG9MaW5lU3RyaW5nQXJyYXkobGluZXdvcmspO1xuICByZXR1cm4gZy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGxpbmVzKVxufTtcbkZ1enp5UG9pbnRMb2NhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRnV6enlQb2ludExvY2F0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRnV6enlQb2ludExvY2F0b3Jcbn07XG5cbnZhciBQb2x5Z29uYWxMaW5ld29ya0V4dHJhY3RlciA9IGZ1bmN0aW9uIFBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyICgpIHtcbiAgdGhpcy5fbGluZXdvcmsgPSBudWxsO1xuICB0aGlzLl9saW5ld29yayA9IG5ldyBBcnJheUxpc3QoKTtcbn07XG5Qb2x5Z29uYWxMaW5ld29ya0V4dHJhY3Rlci5wcm90b3R5cGUuZ2V0TGluZXdvcmsgPSBmdW5jdGlvbiBnZXRMaW5ld29yayAoKSB7XG4gIHJldHVybiB0aGlzLl9saW5ld29ya1xufTtcblBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGcpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoZyBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICB2YXIgcG9seSA9IGc7XG4gICAgdGhpcy5fbGluZXdvcmsuYWRkKHBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgICB0aGlzJDEuX2xpbmV3b3JrLmFkZChwb2x5LmdldEludGVyaW9yUmluZ04oaSkpO1xuICAgIH1cbiAgfVxufTtcblBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUZpbHRlcl1cbn07XG5Qb2x5Z29uYWxMaW5ld29ya0V4dHJhY3Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2x5Z29uYWxMaW5ld29ya0V4dHJhY3RlclxufTtcblxudmFyIE9mZnNldFBvaW50R2VuZXJhdG9yID0gZnVuY3Rpb24gT2Zmc2V0UG9pbnRHZW5lcmF0b3IgKCkge1xuICB0aGlzLl9nID0gbnVsbDtcbiAgdGhpcy5fZG9MZWZ0ID0gdHJ1ZTtcbiAgdGhpcy5fZG9SaWdodCA9IHRydWU7XG4gIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9nID0gZztcbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuZXh0cmFjdFBvaW50cyA9IGZ1bmN0aW9uIGV4dHJhY3RQb2ludHMgKGxpbmUsIG9mZnNldERpc3RhbmNlLCBvZmZzZXRQdHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcHRzID0gbGluZS5nZXRDb29yZGluYXRlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB0aGlzJDEuY29tcHV0ZU9mZnNldFBvaW50cyhwdHNbaV0sIHB0c1tpICsgMV0sIG9mZnNldERpc3RhbmNlLCBvZmZzZXRQdHMpO1xuICB9XG59O1xuT2Zmc2V0UG9pbnRHZW5lcmF0b3IucHJvdG90eXBlLnNldFNpZGVzVG9HZW5lcmF0ZSA9IGZ1bmN0aW9uIHNldFNpZGVzVG9HZW5lcmF0ZSAoZG9MZWZ0LCBkb1JpZ2h0KSB7XG4gIHRoaXMuX2RvTGVmdCA9IGRvTGVmdDtcbiAgdGhpcy5fZG9SaWdodCA9IGRvUmlnaHQ7XG59O1xuT2Zmc2V0UG9pbnRHZW5lcmF0b3IucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uIGdldFBvaW50cyAob2Zmc2V0RGlzdGFuY2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb2Zmc2V0UHRzID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgbGluZXMgPSBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXModGhpcy5fZyk7XG4gIGZvciAodmFyIGkgPSBsaW5lcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgbGluZSA9IGkubmV4dCgpO1xuICAgIHRoaXMkMS5leHRyYWN0UG9pbnRzKGxpbmUsIG9mZnNldERpc3RhbmNlLCBvZmZzZXRQdHMpO1xuICB9XG4gIHJldHVybiBvZmZzZXRQdHNcbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuY29tcHV0ZU9mZnNldFBvaW50cyA9IGZ1bmN0aW9uIGNvbXB1dGVPZmZzZXRQb2ludHMgKHAwLCBwMSwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFB0cykge1xuICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB2YXIgdXggPSBvZmZzZXREaXN0YW5jZSAqIGR4IC8gbGVuO1xuICB2YXIgdXkgPSBvZmZzZXREaXN0YW5jZSAqIGR5IC8gbGVuO1xuICB2YXIgbWlkWCA9IChwMS54ICsgcDAueCkgLyAyO1xuICB2YXIgbWlkWSA9IChwMS55ICsgcDAueSkgLyAyO1xuICBpZiAodGhpcy5fZG9MZWZ0KSB7XG4gICAgdmFyIG9mZnNldExlZnQgPSBuZXcgQ29vcmRpbmF0ZShtaWRYIC0gdXksIG1pZFkgKyB1eCk7XG4gICAgb2Zmc2V0UHRzLmFkZChvZmZzZXRMZWZ0KTtcbiAgfVxuICBpZiAodGhpcy5fZG9SaWdodCkge1xuICAgIHZhciBvZmZzZXRSaWdodCA9IG5ldyBDb29yZGluYXRlKG1pZFggKyB1eSwgbWlkWSAtIHV4KTtcbiAgICBvZmZzZXRQdHMuYWRkKG9mZnNldFJpZ2h0KTtcbiAgfVxufTtcbk9mZnNldFBvaW50R2VuZXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT2Zmc2V0UG9pbnRHZW5lcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT2Zmc2V0UG9pbnRHZW5lcmF0b3Jcbn07XG5cbnZhciBPdmVybGF5UmVzdWx0VmFsaWRhdG9yID0gZnVuY3Rpb24gT3ZlcmxheVJlc3VsdFZhbGlkYXRvciAoKSB7XG4gIHRoaXMuX2dlb20gPSBudWxsO1xuICB0aGlzLl9sb2NGaW5kZXIgPSBudWxsO1xuICB0aGlzLl9sb2NhdGlvbiA9IG5ldyBBcnJheSgzKS5maWxsKG51bGwpO1xuICB0aGlzLl9pbnZhbGlkTG9jYXRpb24gPSBudWxsO1xuICB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5UT0xFUkFOQ0U7XG4gIHRoaXMuX3Rlc3RDb29yZHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBhID0gYXJndW1lbnRzWzBdO1xuICB2YXIgYiA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIHJlc3VsdCA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSA9IE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IuY29tcHV0ZUJvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UoYSwgYik7XG4gIHRoaXMuX2dlb20gPSBbYSwgYiwgcmVzdWx0XTtcbiAgdGhpcy5fbG9jRmluZGVyID0gW25ldyBGdXp6eVBvaW50TG9jYXRvcih0aGlzLl9nZW9tWzBdLCB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlKSwgbmV3IEZ1enp5UG9pbnRMb2NhdG9yKHRoaXMuX2dlb21bMV0sIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UpLCBuZXcgRnV6enlQb2ludExvY2F0b3IodGhpcy5fZ2VvbVsyXSwgdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSldO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0NiA9IHsgVE9MRVJBTkNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5yZXBvcnRSZXN1bHQgPSBmdW5jdGlvbiByZXBvcnRSZXN1bHQgKG92ZXJsYXlPcCwgbG9jYXRpb24sIGV4cGVjdGVkSW50ZXJpb3IpIHtcbiAgU3lzdGVtLm91dC5wcmludGxuKCdPdmVybGF5IHJlc3VsdCBpbnZhbGlkIC0gQTonICsgTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbChsb2NhdGlvblswXSkgKyAnIEI6JyArIExvY2F0aW9uLnRvTG9jYXRpb25TeW1ib2wobG9jYXRpb25bMV0pICsgJyBleHBlY3RlZDonICsgKGV4cGVjdGVkSW50ZXJpb3IgPyAnaScgOiAnZScpICsgJyBhY3R1YWw6JyArIExvY2F0aW9uLnRvTG9jYXRpb25TeW1ib2wobG9jYXRpb25bMl0pKTtcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAob3ZlcmxheU9wKSB7XG4gIHRoaXMuYWRkVGVzdFB0cyh0aGlzLl9nZW9tWzBdKTtcbiAgdGhpcy5hZGRUZXN0UHRzKHRoaXMuX2dlb21bMV0pO1xuICB2YXIgaXNWYWxpZCA9IHRoaXMuY2hlY2tWYWxpZChvdmVybGF5T3ApO1xuICByZXR1cm4gaXNWYWxpZFxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrVmFsaWQgPSBmdW5jdGlvbiBjaGVja1ZhbGlkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBvdmVybGF5T3AgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXN0Q29vcmRzLnNpemUoKTsgaSsrKSB7XG4gICAgICB2YXIgcHQgPSB0aGlzJDEuX3Rlc3RDb29yZHMuZ2V0KGkpO1xuICAgICAgaWYgKCF0aGlzJDEuY2hlY2tWYWxpZChvdmVybGF5T3AsIHB0KSkge1xuICAgICAgICB0aGlzJDEuX2ludmFsaWRMb2NhdGlvbiA9IHB0O1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIG92ZXJsYXlPcCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2xvY2F0aW9uWzBdID0gdGhpcy5fbG9jRmluZGVyWzBdLmdldExvY2F0aW9uKHB0JDEpO1xuICAgIHRoaXMuX2xvY2F0aW9uWzFdID0gdGhpcy5fbG9jRmluZGVyWzFdLmdldExvY2F0aW9uKHB0JDEpO1xuICAgIHRoaXMuX2xvY2F0aW9uWzJdID0gdGhpcy5fbG9jRmluZGVyWzJdLmdldExvY2F0aW9uKHB0JDEpO1xuICAgIGlmIChPdmVybGF5UmVzdWx0VmFsaWRhdG9yLmhhc0xvY2F0aW9uKHRoaXMuX2xvY2F0aW9uLCBMb2NhdGlvbi5CT1VOREFSWSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiB0aGlzLmlzVmFsaWRSZXN1bHQob3ZlcmxheU9wJDEsIHRoaXMuX2xvY2F0aW9uKVxuICB9XG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuYWRkVGVzdFB0cyA9IGZ1bmN0aW9uIGFkZFRlc3RQdHMgKGcpIHtcbiAgdmFyIHB0R2VuID0gbmV3IE9mZnNldFBvaW50R2VuZXJhdG9yKGcpO1xuICB0aGlzLl90ZXN0Q29vcmRzLmFkZEFsbChwdEdlbi5nZXRQb2ludHMoNSAqIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UpKTtcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5pc1ZhbGlkUmVzdWx0ID0gZnVuY3Rpb24gaXNWYWxpZFJlc3VsdCAob3ZlcmxheU9wLCBsb2NhdGlvbikge1xuICB2YXIgZXhwZWN0ZWRJbnRlcmlvciA9IE92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AobG9jYXRpb25bMF0sIGxvY2F0aW9uWzFdLCBvdmVybGF5T3ApO1xuICB2YXIgcmVzdWx0SW5JbnRlcmlvciA9IGxvY2F0aW9uWzJdID09PSBMb2NhdGlvbi5JTlRFUklPUjtcbiAgdmFyIGlzVmFsaWQgPSAhKGV4cGVjdGVkSW50ZXJpb3IgXiByZXN1bHRJbkludGVyaW9yKTtcbiAgaWYgKCFpc1ZhbGlkKSB7IHRoaXMucmVwb3J0UmVzdWx0KG92ZXJsYXlPcCwgbG9jYXRpb24sIGV4cGVjdGVkSW50ZXJpb3IpOyB9XG4gIHJldHVybiBpc1ZhbGlkXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0SW52YWxpZExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0SW52YWxpZExvY2F0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludmFsaWRMb2NhdGlvblxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE92ZXJsYXlSZXN1bHRWYWxpZGF0b3Jcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLmhhc0xvY2F0aW9uID0gZnVuY3Rpb24gaGFzTG9jYXRpb24gKGxvY2F0aW9uLCBsb2MpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpZiAobG9jYXRpb25baV0gPT09IGxvYykgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5jb21wdXRlQm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlIChnMCwgZzEpIHtcbiAgcmV0dXJuIE1hdGgubWluKEdlb21ldHJ5U25hcHBlci5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZShnMCksIEdlb21ldHJ5U25hcHBlci5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZShnMSkpXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5pc1ZhbGlkID0gZnVuY3Rpb24gaXNWYWxpZCAoYSwgYiwgb3ZlcmxheU9wLCByZXN1bHQpIHtcbiAgdmFyIHZhbGlkYXRvciA9IG5ldyBPdmVybGF5UmVzdWx0VmFsaWRhdG9yKGEsIGIsIHJlc3VsdCk7XG4gIHJldHVybiB2YWxpZGF0b3IuaXNWYWxpZChvdmVybGF5T3ApXG59O1xuc3RhdGljQWNjZXNzb3JzJDQ2LlRPTEVSQU5DRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwLjAwMDAwMSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggT3ZlcmxheVJlc3VsdFZhbGlkYXRvciwgc3RhdGljQWNjZXNzb3JzJDQ2ICk7XG5cbi8vIG9wZXJhdGlvbi5vdmVybGF5XG5cbnZhciBHZW9tZXRyeUNvbWJpbmVyID0gZnVuY3Rpb24gR2VvbWV0cnlDb21iaW5lciAoZ2VvbXMpIHtcbiAgdGhpcy5fZ2VvbUZhY3RvcnkgPSBudWxsO1xuICB0aGlzLl9za2lwRW1wdHkgPSBmYWxzZTtcbiAgdGhpcy5faW5wdXRHZW9tcyA9IG51bGw7XG4gIHRoaXMuX2dlb21GYWN0b3J5ID0gR2VvbWV0cnlDb21iaW5lci5leHRyYWN0RmFjdG9yeShnZW9tcyk7XG4gIHRoaXMuX2lucHV0R2VvbXMgPSBnZW9tcztcbn07XG5HZW9tZXRyeUNvbWJpbmVyLnByb3RvdHlwZS5leHRyYWN0RWxlbWVudHMgPSBmdW5jdGlvbiBleHRyYWN0RWxlbWVudHMgKGdlb20sIGVsZW1zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGdlb20gPT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgZWxlbUdlb20gPSBnZW9tLmdldEdlb21ldHJ5TihpKTtcbiAgICBpZiAodGhpcyQxLl9za2lwRW1wdHkgJiYgZWxlbUdlb20uaXNFbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICBlbGVtcy5hZGQoZWxlbUdlb20pO1xuICB9XG59O1xuR2VvbWV0cnlDb21iaW5lci5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uIGNvbWJpbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbGVtcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IHRoaXMuX2lucHV0R2VvbXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGcgPSBpLm5leHQoKTtcbiAgICB0aGlzJDEuZXh0cmFjdEVsZW1lbnRzKGcsIGVsZW1zKTtcbiAgfVxuICBpZiAoZWxlbXMuc2l6ZSgpID09PSAwKSB7XG4gICAgaWYgKHRoaXMuX2dlb21GYWN0b3J5ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpXG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkoZWxlbXMpXG59O1xuR2VvbWV0cnlDb21iaW5lci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5Q29tYmluZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlDb21iaW5lclxufTtcbkdlb21ldHJ5Q29tYmluZXIuY29tYmluZSA9IGZ1bmN0aW9uIGNvbWJpbmUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tcyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29tYmluZXIgPSBuZXcgR2VvbWV0cnlDb21iaW5lcihnZW9tcyk7XG4gICAgcmV0dXJuIGNvbWJpbmVyLmNvbWJpbmUoKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBjb21iaW5lciQxID0gbmV3IEdlb21ldHJ5Q29tYmluZXIoR2VvbWV0cnlDb21iaW5lci5jcmVhdGVMaXN0KGcwLCBnMSkpO1xuICAgIHJldHVybiBjb21iaW5lciQxLmNvbWJpbmUoKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgZzAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZzIgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGNvbWJpbmVyJDIgPSBuZXcgR2VvbWV0cnlDb21iaW5lcihHZW9tZXRyeUNvbWJpbmVyLmNyZWF0ZUxpc3QoZzAkMSwgZzEkMSwgZzIpKTtcbiAgICByZXR1cm4gY29tYmluZXIkMi5jb21iaW5lKClcbiAgfVxufTtcbkdlb21ldHJ5Q29tYmluZXIuZXh0cmFjdEZhY3RvcnkgPSBmdW5jdGlvbiBleHRyYWN0RmFjdG9yeSAoZ2VvbXMpIHtcbiAgaWYgKGdlb21zLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gIHJldHVybiBnZW9tcy5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KClcbn07XG5HZW9tZXRyeUNvbWJpbmVyLmNyZWF0ZUxpc3QgPSBmdW5jdGlvbiBjcmVhdGVMaXN0ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgb2JqMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb2JqMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBsaXN0LmFkZChvYmowKTtcbiAgICBsaXN0LmFkZChvYmoxKTtcbiAgICByZXR1cm4gbGlzdFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgb2JqMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvYmoxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG9iajIgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGxpc3QkMSA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBsaXN0JDEuYWRkKG9iajAkMSk7XG4gICAgbGlzdCQxLmFkZChvYmoxJDEpO1xuICAgIGxpc3QkMS5hZGQob2JqMik7XG4gICAgcmV0dXJuIGxpc3QkMVxuICB9XG59O1xuXG52YXIgQ2FzY2FkZWRQb2x5Z29uVW5pb24gPSBmdW5jdGlvbiBDYXNjYWRlZFBvbHlnb25VbmlvbiAoKSB7XG4gIHRoaXMuX2lucHV0UG9seXMgPSBudWxsO1xuICB0aGlzLl9nZW9tRmFjdG9yeSA9IG51bGw7XG4gIHZhciBwb2x5cyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5faW5wdXRQb2x5cyA9IHBvbHlzO1xuICBpZiAodGhpcy5faW5wdXRQb2x5cyA9PT0gbnVsbCkgeyB0aGlzLl9pbnB1dFBvbHlzID0gbmV3IEFycmF5TGlzdCgpOyB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQ3ID0geyBTVFJUUkVFX05PREVfQ0FQQUNJVFk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5yZWR1Y2VUb0dlb21ldHJpZXMgPSBmdW5jdGlvbiByZWR1Y2VUb0dlb21ldHJpZXMgKGdlb21UcmVlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGdlb21zID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gZ2VvbVRyZWUuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG8gPSBpLm5leHQoKTtcbiAgICB2YXIgZ2VvbSA9IG51bGw7XG4gICAgaWYgKGhhc0ludGVyZmFjZShvLCBMaXN0KSkge1xuICAgICAgZ2VvbSA9IHRoaXMkMS51bmlvblRyZWUobyk7XG4gICAgfSBlbHNlIGlmIChvIGluc3RhbmNlb2YgR2VvbWV0cnkpIHtcbiAgICAgIGdlb20gPSBvO1xuICAgIH1cbiAgICBnZW9tcy5hZGQoZ2VvbSk7XG4gIH1cbiAgcmV0dXJuIGdlb21zXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLmV4dHJhY3RCeUVudmVsb3BlID0gZnVuY3Rpb24gZXh0cmFjdEJ5RW52ZWxvcGUgKGVudiwgZ2VvbSwgZGlzam9pbnRHZW9tcykge1xuICB2YXIgaW50ZXJzZWN0aW5nR2VvbXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBlbGVtID0gZ2VvbS5nZXRHZW9tZXRyeU4oaSk7XG4gICAgaWYgKGVsZW0uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZW52KSkgeyBpbnRlcnNlY3RpbmdHZW9tcy5hZGQoZWxlbSk7IH0gZWxzZSB7IGRpc2pvaW50R2VvbXMuYWRkKGVsZW0pOyB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkoaW50ZXJzZWN0aW5nR2VvbXMpXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnVuaW9uT3B0aW1pemVkID0gZnVuY3Rpb24gdW5pb25PcHRpbWl6ZWQgKGcwLCBnMSkge1xuICB2YXIgZzBFbnYgPSBnMC5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIHZhciBnMUVudiA9IGcxLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgaWYgKCFnMEVudi5pbnRlcnNlY3RzKGcxRW52KSkge1xuICAgIHZhciBjb21ibyA9IEdlb21ldHJ5Q29tYmluZXIuY29tYmluZShnMCwgZzEpO1xuICAgIHJldHVybiBjb21ib1xuICB9XG4gIGlmIChnMC5nZXROdW1HZW9tZXRyaWVzKCkgPD0gMSAmJiBnMS5nZXROdW1HZW9tZXRyaWVzKCkgPD0gMSkgeyByZXR1cm4gdGhpcy51bmlvbkFjdHVhbChnMCwgZzEpIH1cbiAgdmFyIGNvbW1vbkVudiA9IGcwRW52LmludGVyc2VjdGlvbihnMUVudik7XG4gIHJldHVybiB0aGlzLnVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbihnMCwgZzEsIGNvbW1vbkVudilcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoKSB7XG4gIGlmICh0aGlzLl9pbnB1dFBvbHlzID09PSBudWxsKSB7IHRocm93IG5ldyBFcnJvcigndW5pb24oKSBtZXRob2QgY2Fubm90IGJlIGNhbGxlZCB0d2ljZScpIH1cbiAgaWYgKHRoaXMuX2lucHV0UG9seXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5fZ2VvbUZhY3RvcnkgPSB0aGlzLl9pbnB1dFBvbHlzLml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKTtcbiAgdmFyIGluZGV4ID0gbmV3IFNUUnRyZWUoQ2FzY2FkZWRQb2x5Z29uVW5pb24uU1RSVFJFRV9OT0RFX0NBUEFDSVRZKTtcbiAgZm9yICh2YXIgaSA9IHRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGl0ZW0gPSBpLm5leHQoKTtcbiAgICBpbmRleC5pbnNlcnQoaXRlbS5nZXRFbnZlbG9wZUludGVybmFsKCksIGl0ZW0pO1xuICB9XG4gIHRoaXMuX2lucHV0UG9seXMgPSBudWxsO1xuICB2YXIgaXRlbVRyZWUgPSBpbmRleC5pdGVtc1RyZWUoKTtcbiAgdmFyIHVuaW9uQWxsID0gdGhpcy51bmlvblRyZWUoaXRlbVRyZWUpO1xuICByZXR1cm4gdW5pb25BbGxcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUuYmluYXJ5VW5pb24gPSBmdW5jdGlvbiBiaW5hcnlVbmlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21zID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLmJpbmFyeVVuaW9uKGdlb21zLCAwLCBnZW9tcy5zaXplKCkpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnZW9tcyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzdGFydCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZW5kID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChlbmQgLSBzdGFydCA8PSAxKSB7XG4gICAgICB2YXIgZzAgPSBDYXNjYWRlZFBvbHlnb25Vbmlvbi5nZXRHZW9tZXRyeShnZW9tcyQxLCBzdGFydCk7XG4gICAgICByZXR1cm4gdGhpcy51bmlvblNhZmUoZzAsIG51bGwpXG4gICAgfSBlbHNlIGlmIChlbmQgLSBzdGFydCA9PT0gMikge1xuICAgICAgcmV0dXJuIHRoaXMudW5pb25TYWZlKENhc2NhZGVkUG9seWdvblVuaW9uLmdldEdlb21ldHJ5KGdlb21zJDEsIHN0YXJ0KSwgQ2FzY2FkZWRQb2x5Z29uVW5pb24uZ2V0R2VvbWV0cnkoZ2VvbXMkMSwgc3RhcnQgKyAxKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1pZCA9IE1hdGgudHJ1bmMoKGVuZCArIHN0YXJ0KSAvIDIpO1xuICAgICAgdmFyIGcwJDEgPSB0aGlzLmJpbmFyeVVuaW9uKGdlb21zJDEsIHN0YXJ0LCBtaWQpO1xuICAgICAgdmFyIGcxID0gdGhpcy5iaW5hcnlVbmlvbihnZW9tcyQxLCBtaWQsIGVuZCk7XG4gICAgICByZXR1cm4gdGhpcy51bmlvblNhZmUoZzAkMSwgZzEpXG4gICAgfVxuICB9XG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnJlcGVhdGVkVW5pb24gPSBmdW5jdGlvbiByZXBlYXRlZFVuaW9uIChnZW9tcykge1xuICB2YXIgdW5pb24gPSBudWxsO1xuICBmb3IgKHZhciBpID0gZ2VvbXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGcgPSBpLm5leHQoKTtcbiAgICBpZiAodW5pb24gPT09IG51bGwpIHsgdW5pb24gPSBnLmNvcHkoKTsgfSBlbHNlIHsgdW5pb24gPSB1bmlvbi51bmlvbihnKTsgfVxuICB9XG4gIHJldHVybiB1bmlvblxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS51bmlvblNhZmUgPSBmdW5jdGlvbiB1bmlvblNhZmUgKGcwLCBnMSkge1xuICBpZiAoZzAgPT09IG51bGwgJiYgZzEgPT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZzAgPT09IG51bGwpIHsgcmV0dXJuIGcxLmNvcHkoKSB9XG4gIGlmIChnMSA9PT0gbnVsbCkgeyByZXR1cm4gZzAuY29weSgpIH1cbiAgcmV0dXJuIHRoaXMudW5pb25PcHRpbWl6ZWQoZzAsIGcxKVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS51bmlvbkFjdHVhbCA9IGZ1bmN0aW9uIHVuaW9uQWN0dWFsIChnMCwgZzEpIHtcbiAgcmV0dXJuIENhc2NhZGVkUG9seWdvblVuaW9uLnJlc3RyaWN0VG9Qb2x5Z29ucyhnMC51bmlvbihnMSkpXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnVuaW9uVHJlZSA9IGZ1bmN0aW9uIHVuaW9uVHJlZSAoZ2VvbVRyZWUpIHtcbiAgdmFyIGdlb21zID0gdGhpcy5yZWR1Y2VUb0dlb21ldHJpZXMoZ2VvbVRyZWUpO1xuICB2YXIgdW5pb24gPSB0aGlzLmJpbmFyeVVuaW9uKGdlb21zKTtcbiAgcmV0dXJuIHVuaW9uXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIHVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbiAoZzAsIGcxLCBjb21tb24pIHtcbiAgdmFyIGRpc2pvaW50UG9seXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBnMEludCA9IHRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUoY29tbW9uLCBnMCwgZGlzam9pbnRQb2x5cyk7XG4gIHZhciBnMUludCA9IHRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUoY29tbW9uLCBnMSwgZGlzam9pbnRQb2x5cyk7XG4gIHZhciB1bmlvbiA9IHRoaXMudW5pb25BY3R1YWwoZzBJbnQsIGcxSW50KTtcbiAgZGlzam9pbnRQb2x5cy5hZGQodW5pb24pO1xuICB2YXIgb3ZlcmFsbFVuaW9uID0gR2VvbWV0cnlDb21iaW5lci5jb21iaW5lKGRpc2pvaW50UG9seXMpO1xuICByZXR1cm4gb3ZlcmFsbFVuaW9uXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLmJ1ZmZlclVuaW9uID0gZnVuY3Rpb24gYnVmZmVyVW5pb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tcyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZmFjdG9yeSA9IGdlb21zLmdldCgwKS5nZXRGYWN0b3J5KCk7XG4gICAgdmFyIGdDb2xsID0gZmFjdG9yeS5idWlsZEdlb21ldHJ5KGdlb21zKTtcbiAgICB2YXIgdW5pb25BbGwgPSBnQ29sbC5idWZmZXIoMC4wKTtcbiAgICByZXR1cm4gdW5pb25BbGxcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGcwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZmFjdG9yeSQxID0gZzAuZ2V0RmFjdG9yeSgpO1xuICAgIHZhciBnQ29sbCQxID0gZmFjdG9yeSQxLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihbZzAsIGcxXSk7XG4gICAgdmFyIHVuaW9uQWxsJDEgPSBnQ29sbCQxLmJ1ZmZlcigwLjApO1xuICAgIHJldHVybiB1bmlvbkFsbCQxXG4gIH1cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENhc2NhZGVkUG9seWdvblVuaW9uXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucmVzdHJpY3RUb1BvbHlnb25zID0gZnVuY3Rpb24gcmVzdHJpY3RUb1BvbHlnb25zIChnKSB7XG4gIGlmIChoYXNJbnRlcmZhY2UoZywgUG9seWdvbmFsKSkge1xuICAgIHJldHVybiBnXG4gIH1cbiAgdmFyIHBvbHlnb25zID0gUG9seWdvbkV4dHJhY3Rlci5nZXRQb2x5Z29ucyhnKTtcbiAgaWYgKHBvbHlnb25zLnNpemUoKSA9PT0gMSkgeyByZXR1cm4gcG9seWdvbnMuZ2V0KDApIH1cbiAgcmV0dXJuIGcuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihHZW9tZXRyeUZhY3RvcnkudG9Qb2x5Z29uQXJyYXkocG9seWdvbnMpKVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKGxpc3QsIGluZGV4KSB7XG4gIGlmIChpbmRleCA+PSBsaXN0LnNpemUoKSkgeyByZXR1cm4gbnVsbCB9XG4gIHJldHVybiBsaXN0LmdldChpbmRleClcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChwb2x5cykge1xuICB2YXIgb3AgPSBuZXcgQ2FzY2FkZWRQb2x5Z29uVW5pb24ocG9seXMpO1xuICByZXR1cm4gb3AudW5pb24oKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0Ny5TVFJUUkVFX05PREVfQ0FQQUNJVFkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ2FzY2FkZWRQb2x5Z29uVW5pb24sIHN0YXRpY0FjY2Vzc29ycyQ0NyApO1xuXG52YXIgVW5pb25PcCA9IGZ1bmN0aW9uIFVuaW9uT3AgKCkge307XG5cblVuaW9uT3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Vbmlvbk9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFVuaW9uT3Bcbn07XG5Vbmlvbk9wLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKGcsIG90aGVyKSB7XG4gIGlmIChnLmlzRW1wdHkoKSB8fCBvdGhlci5pc0VtcHR5KCkpIHtcbiAgICBpZiAoZy5pc0VtcHR5KCkgJiYgb3RoZXIuaXNFbXB0eSgpKSB7IHJldHVybiBPdmVybGF5T3AuY3JlYXRlRW1wdHlSZXN1bHQoT3ZlcmxheU9wLlVOSU9OLCBnLCBvdGhlciwgZy5nZXRGYWN0b3J5KCkpIH1cbiAgICBpZiAoZy5pc0VtcHR5KCkpIHsgcmV0dXJuIG90aGVyLmNvcHkoKSB9XG4gICAgaWYgKG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gZy5jb3B5KCkgfVxuICB9XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZyk7XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24ob3RoZXIpO1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnLCBvdGhlciwgT3ZlcmxheU9wLlVOSU9OKVxufTtcblxuLy8gb3BlcmF0aW9uLnVuaW9uXG5cbi8vIG9wZXJhdGlvblxuXG4vKipcbiAqIFBvbHlmaWxsIGZvciBJRSBzdXBwb3J0XG4gKi9cblxuZXhwb3J0IHsgR2VvSlNPTlJlYWRlciwgR2VvSlNPTldyaXRlciwgT3ZlcmxheU9wLCBVbmlvbk9wLCBCdWZmZXJPcCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/turf-jsts/jsts.mjs\n");

/***/ })

};
;