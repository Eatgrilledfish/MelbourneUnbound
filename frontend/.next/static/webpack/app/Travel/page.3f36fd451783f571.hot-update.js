"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/Travel/page",{

/***/ "(app-pages-browser)/./src/app/Travel/Map.js":
/*!*******************************!*\
  !*** ./src/app/Travel/Map.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/turf */ \"(app-pages-browser)/./node_modules/@turf/turf/dist/es/index.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Map = (param)=>{\n    let { geoJsonUrl, origin, destination, searchTrigger, travelMode } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [polygons, setPolygons] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]); // 存储所有GeoJSON多边形\n    const [geoJsonData, setGeoJsonData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [apiLoaded, setApiLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // 控制API加载的状态\n    const directionsRenderer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // 动态加载Google Maps API\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadGoogleMapsApi = ()=>{\n            if (window.google && window.google.maps) {\n                setApiLoaded(true); // 设置API加载完成状态\n                return;\n            }\n            if (!document.querySelector('script[src*=\"maps.googleapis\"]')) {\n                const script = document.createElement(\"script\");\n                script.src = \"https://maps.googleapis.com/maps/api/js?key=AIzaSyA4bcHQArQWH2Qxb47goCAhbstZX0WkUZk&libraries=places,geometry\";\n                script.async = true;\n                script.defer = true;\n                script.onload = ()=>setApiLoaded(true);\n                document.head.appendChild(script);\n            }\n        };\n        loadGoogleMapsApi();\n    }, []);\n    // 初始化地图\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (apiLoaded && !map && mapRef.current) {\n            initializeMap();\n        }\n    }, [\n        apiLoaded,\n        mapRef.current\n    ]); // 依赖API加载状态和mapRef的变化\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (map && origin && destination && searchTrigger) {\n            clearRouteAndPanel(); // First, clear the current route\n            console.log(\"Searching new route\");\n            searchRoute(); // Then, search for a new route\n        }\n    }, [\n        map,\n        searchTrigger\n    ]); // 依赖于 searchTrigger\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (geoJsonUrl) {\n            fetch(geoJsonUrl).then((response)=>response.json()).then((data)=>{\n                setGeoJsonData(data); // Save fetched GeoJSON data to state\n            });\n        }\n    }, [\n        geoJsonUrl\n    ]);\n    const clearRouteAndPanel = ()=>{\n        console.log(\"Executing clearRouteAndPanel\");\n        if (directionsRenderer.current) {\n            console.log(\"DirectionsRenderer is set, clearing map and panel\");\n            directionsRenderer.current.setMap(null);\n            directionsRenderer.current.setPanel(null);\n            console.log(\"Map and panel cleared\");\n        } else {\n            console.log(\"DirectionsRenderer not set\");\n        }\n    };\n    const initializeMap = ()=>{\n        const melbourneCBD = {\n            lat: -37.8136,\n            lng: 144.9631\n        };\n        const newMap = new window.google.maps.Map(mapRef.current, {\n            center: melbourneCBD,\n            zoom: 14\n        });\n        // loading GeoJSON create multi shape\n        if (geoJsonUrl) {\n            fetch(geoJsonUrl).then((response)=>response.json()).then((data)=>{\n                const loadedPolygons = data.features.map((feature)=>{\n                    if (feature.geometry && feature.geometry.type === \"MultiPolygon\") {\n                        return feature.geometry.coordinates.map((polygonCoords)=>{\n                            const paths = polygonCoords.map((ring)=>ring.map((coords)=>({\n                                        lat: coords[1],\n                                        lng: coords[0]\n                                    })));\n                            return new google.maps.Polygon({\n                                paths: paths,\n                                map: newMap,\n                                strokeColor: \"black\",\n                                strokeOpacity: 0.8,\n                                strokeWeight: 0.5,\n                                fillColor: \"white\",\n                                fillOpacity: 0\n                            });\n                        });\n                    }\n                    return null;\n                }).filter((poly)=>poly !== null).flat();\n                setPolygons(loadedPolygons);\n            });\n        }\n        newMap.setOptions({\n            styles: mapStyles\n        });\n        setMap(newMap);\n        directionsRenderer.current = new google.maps.DirectionsRenderer();\n        directionsRenderer.current.setMap(newMap);\n        directionsRenderer.current.setPanel(document.getElementById(\"directionsPanel\"));\n    };\n    // search route\n    const searchRoute = ()=>{\n        const directionsService = new google.maps.DirectionsService();\n        const geocoder = new google.maps.Geocoder();\n        directionsRenderer.setMap(null);\n        directionsRenderer.current.setMap(map);\n        directionsRenderer.current.setPanel(document.getElementById(\"directionsPanel\"));\n        // Helper function to geocode an address\n        const geocodeAddress = (address, callback)=>{\n            geocoder.geocode({\n                \"address\": address\n            }, (results, status)=>{\n                if (status === \"OK\") {\n                    callback(results[0].geometry.location);\n                } else {\n                    alert(\"Geocode was not successful for the following reason: \" + status);\n                }\n            });\n        };\n        // Convert origin and destination from address to LatLng\n        geocodeAddress(origin, (originLatLng)=>{\n            if (!geoJsonData) {\n                console.error(\"GeoJSON data is not loaded\");\n                return;\n            }\n            geocodeAddress(destination, (destinationLatLng)=>{\n                // Once both addresses are geocoded\n                const originPoint = _turf_turf__WEBPACK_IMPORTED_MODULE_2__.point([\n                    originLatLng.lng(),\n                    originLatLng.lat()\n                ]);\n                const destinationPoint = _turf_turf__WEBPACK_IMPORTED_MODULE_2__.point([\n                    destinationLatLng.lng(),\n                    destinationLatLng.lat()\n                ]);\n                const isCloseEnough = (point)=>{\n                    return geoJsonData.features.some((feature)=>{\n                        const featurePoint = _turf_turf__WEBPACK_IMPORTED_MODULE_2__.point([\n                            feature.properties.geo_point_2d.lon,\n                            feature.properties.geo_point_2d.lat\n                        ]);\n                        const distance = _turf_turf__WEBPACK_IMPORTED_MODULE_2__.distance(point, featurePoint, {\n                            units: \"meters\"\n                        });\n                        return distance < 100;\n                    });\n                };\n                const originCloseEnough = isCloseEnough(originPoint);\n                const destinationCloseEnough = isCloseEnough(destinationPoint);\n                console.log(\"originPoint:\", originPoint);\n                console.log(\"destinationPoint:\", destinationPoint);\n                if (!originCloseEnough || !destinationCloseEnough) {\n                    alert(\"Beginning or end point is outside the defined area\");\n                    return;\n                }\n                if (originLatLng && destinationLatLng) {\n                    // Request and display the route\n                    directionsService.route({\n                        origin: originLatLng,\n                        destination: destinationLatLng,\n                        travelMode: travelMode,\n                        transitOptions: {\n                            modes: [\n                                \"BUS\",\n                                \"RAIL\"\n                            ],\n                            routingPreference: \"FEWER_TRANSFERS\" // 少换乘\n                        }\n                    }, (result, status)=>{\n                        if (status === google.maps.DirectionsStatus.OK) {\n                            directionsRenderer.setDirections(result);\n                        } else {\n                            console.error(\"Failed to display directions due to: \" + status);\n                        }\n                    });\n                }\n            });\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mapRef,\n                style: {\n                    width: \"70%\",\n                    height: \"500px\",\n                    float: \"left\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/jianqiao/myproject/MelbourneUnbound/frontend/src/app/Travel/Map.js\",\n                lineNumber: 192,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                id: \"directionsPanel\",\n                style: {\n                    width: \"30%\",\n                    height: \"500px\",\n                    float: \"right\",\n                    overflow: \"auto\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/jianqiao/myproject/MelbourneUnbound/frontend/src/app/Travel/Map.js\",\n                lineNumber: 193,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jianqiao/myproject/MelbourneUnbound/frontend/src/app/Travel/Map.js\",\n        lineNumber: 191,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Map, \"/a33oBFfimt+utD0zSn3gttvMig=\");\n_c = Map;\nconst mapStyles = [\n    {\n        \"featureType\": \"all\",\n        \"elementType\": \"labels\",\n        \"stylers\": [\n            {\n                \"visibility\": \"off\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"road\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#ffffff\"\n            }\n        ]\n    }\n];\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\nvar _c;\n$RefreshReg$(_c, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvVHJhdmVsL01hcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJEO0FBQ3hCO0FBRW5DLE1BQU1LLE1BQU07UUFBQyxFQUFFQyxVQUFVLEVBQUVDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxhQUFhLEVBQUNDLFVBQVUsRUFBRTs7SUFDeEUsTUFBTUMsU0FBU1YsNkNBQU1BLENBQUM7SUFDdEIsTUFBTSxDQUFDVyxLQUFLQyxPQUFPLEdBQUdWLCtDQUFRQSxDQUFDO0lBQy9CLE1BQU0sQ0FBQ1csVUFBVUMsWUFBWSxHQUFHWiwrQ0FBUUEsQ0FBQyxFQUFFLEdBQUksaUJBQWlCO0lBQ2hFLE1BQU0sQ0FBQ2EsYUFBYUMsZUFBZSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNlLFdBQVdDLGFBQWEsR0FBR2hCLCtDQUFRQSxDQUFDLFFBQVMsYUFBYTtJQUNqRSxNQUFNaUIscUJBQXFCbkIsNkNBQU1BLENBQUM7SUFFbEMsc0JBQXNCO0lBQ3RCQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1tQixvQkFBb0I7WUFDeEIsSUFBSUMsT0FBT0MsTUFBTSxJQUFJRCxPQUFPQyxNQUFNLENBQUNDLElBQUksRUFBRTtnQkFDdkNMLGFBQWEsT0FBUSxjQUFjO2dCQUNuQztZQUNGO1lBQ0EsSUFBSSxDQUFDTSxTQUFTQyxhQUFhLENBQUMsbUNBQW1DO2dCQUM3RCxNQUFNQyxTQUFTRixTQUFTRyxhQUFhLENBQUM7Z0JBQ3RDRCxPQUFPRSxHQUFHLEdBQUk7Z0JBQ2RGLE9BQU9HLEtBQUssR0FBRztnQkFDZkgsT0FBT0ksS0FBSyxHQUFHO2dCQUNmSixPQUFPSyxNQUFNLEdBQUcsSUFBTWIsYUFBYTtnQkFDbkNNLFNBQVNRLElBQUksQ0FBQ0MsV0FBVyxDQUFDUDtZQUM1QjtRQUNGO1FBRUFOO0lBQ0YsR0FBRyxFQUFFO0lBRUwsUUFBUTtJQUNSbkIsZ0RBQVNBLENBQUM7UUFDUixJQUFJZ0IsYUFBYSxDQUFDTixPQUFP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SUFDaEI7UUFDRSxlQUFlO1FBQ2YsZUFBZTtRQUNmLFdBQVc7WUFDVDtnQkFBRSxjQUFjO1lBQU07U0FDdkI7SUFDSDtJQUNBO1FBQ0UsZUFBZTtRQUNmLGVBQWU7UUFDZixXQUFXO1lBQ1Q7Z0JBQUUsU0FBUztZQUFVO1NBQ3RCO0lBQ0g7Q0FDRDtBQUVELCtEQUFlckUsR0FBR0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL1RyYXZlbC9NYXAuanM/OGY2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgdHVyZiBmcm9tICdAdHVyZi90dXJmJztcblxuY29uc3QgTWFwID0gKHsgZ2VvSnNvblVybCwgb3JpZ2luLCBkZXN0aW5hdGlvbiwgc2VhcmNoVHJpZ2dlcix0cmF2ZWxNb2RlIH0pID0+IHtcbiAgY29uc3QgbWFwUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbbWFwLCBzZXRNYXBdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtwb2x5Z29ucywgc2V0UG9seWdvbnNdID0gdXNlU3RhdGUoW10pOyAgLy8g5a2Y5YKo5omA5pyJR2VvSlNPTuWkmui+ueW9olxuICBjb25zdCBbZ2VvSnNvbkRhdGEsIHNldEdlb0pzb25EYXRhXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbYXBpTG9hZGVkLCBzZXRBcGlMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpOyAgLy8g5o6n5Yi2QVBJ5Yqg6L2955qE54q25oCBXG4gIGNvbnN0IGRpcmVjdGlvbnNSZW5kZXJlciA9IHVzZVJlZihudWxsKTtcblxuICAvLyDliqjmgIHliqDovb1Hb29nbGUgTWFwcyBBUElcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkR29vZ2xlTWFwc0FwaSA9ICgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcykge1xuICAgICAgICBzZXRBcGlMb2FkZWQodHJ1ZSk7ICAvLyDorr7nva5BUEnliqDovb3lrozmiJDnirbmgIFcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbc3JjKj1cIm1hcHMuZ29vZ2xlYXBpc1wiXScpKSB7XG4gICAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQuc3JjID0gYGh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9qcz9rZXk9QUl6YVN5QTRiY0hRQXJRV0gyUXhiNDdnb0NBaGJzdFpYMFdrVVprJmxpYnJhcmllcz1wbGFjZXMsZ2VvbWV0cnlgO1xuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHQuZGVmZXIgPSB0cnVlO1xuICAgICAgICBzY3JpcHQub25sb2FkID0gKCkgPT4gc2V0QXBpTG9hZGVkKHRydWUpO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGxvYWRHb29nbGVNYXBzQXBpKCk7XG4gIH0sIFtdKTtcblxuICAvLyDliJ3lp4vljJblnLDlm75cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYXBpTG9hZGVkICYmICFtYXAgJiYgbWFwUmVmLmN1cnJlbnQpIHtcbiAgICAgIGluaXRpYWxpemVNYXAoKTtcbiAgICB9XG4gIH0sIFthcGlMb2FkZWQsIG1hcFJlZi5jdXJyZW50XSk7IC8vIOS+nei1lkFQSeWKoOi9veeKtuaAgeWSjG1hcFJlZueahOWPmOWMllxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1hcCAmJiBvcmlnaW4gJiYgZGVzdGluYXRpb24gJiYgc2VhcmNoVHJpZ2dlcikge1xuICAgICAgXG4gICAgICBjbGVhclJvdXRlQW5kUGFuZWwoKTsgIC8vIEZpcnN0LCBjbGVhciB0aGUgY3VycmVudCByb3V0ZVxuICAgICAgY29uc29sZS5sb2coJ1NlYXJjaGluZyBuZXcgcm91dGUnKTtcbiAgICAgIHNlYXJjaFJvdXRlKCk7ICAvLyBUaGVuLCBzZWFyY2ggZm9yIGEgbmV3IHJvdXRlXG4gICAgfVxuICB9LCBbbWFwLCBzZWFyY2hUcmlnZ2VyXSk7IC8vIOS+nei1luS6jiBzZWFyY2hUcmlnZ2VyXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZ2VvSnNvblVybCkge1xuICAgICAgZmV0Y2goZ2VvSnNvblVybClcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICBzZXRHZW9Kc29uRGF0YShkYXRhKTsgIC8vIFNhdmUgZmV0Y2hlZCBHZW9KU09OIGRhdGEgdG8gc3RhdGVcbiAgICAgICAgfSk7XG4gICAgfVxuICB9LCBbZ2VvSnNvblVybF0pO1xuXG4gIGNvbnN0IGNsZWFyUm91dGVBbmRQYW5lbCA9ICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnRXhlY3V0aW5nIGNsZWFyUm91dGVBbmRQYW5lbCcpO1xuICAgIGlmIChkaXJlY3Rpb25zUmVuZGVyZXIuY3VycmVudCkge1xuICAgICAgY29uc29sZS5sb2coJ0RpcmVjdGlvbnNSZW5kZXJlciBpcyBzZXQsIGNsZWFyaW5nIG1hcCBhbmQgcGFuZWwnKTtcbiAgICAgIGRpcmVjdGlvbnNSZW5kZXJlci5jdXJyZW50LnNldE1hcChudWxsKTtcbiAgICAgIGRpcmVjdGlvbnNSZW5kZXJlci5jdXJyZW50LnNldFBhbmVsKG51bGwpO1xuICAgICAgY29uc29sZS5sb2coJ01hcCBhbmQgcGFuZWwgY2xlYXJlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnRGlyZWN0aW9uc1JlbmRlcmVyIG5vdCBzZXQnKTtcbiAgICB9XG4gIH07XG5cblxuXG4gIGNvbnN0IGluaXRpYWxpemVNYXAgPSAoKSA9PiB7XG4gICAgY29uc3QgbWVsYm91cm5lQ0JEID0geyBsYXQ6IC0zNy44MTM2LCBsbmc6IDE0NC45NjMxIH07XG4gICAgY29uc3QgbmV3TWFwID0gbmV3IHdpbmRvdy5nb29nbGUubWFwcy5NYXAobWFwUmVmLmN1cnJlbnQsIHtcbiAgICAgIGNlbnRlcjogbWVsYm91cm5lQ0JELFxuICAgICAgem9vbTogMTQsXG4gICAgfSk7XG5cbiAgICAvLyBsb2FkaW5nIEdlb0pTT04gY3JlYXRlIG11bHRpIHNoYXBlXG4gICAgaWYgKGdlb0pzb25VcmwpIHtcbiAgICAgIGZldGNoKGdlb0pzb25VcmwpXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgY29uc3QgbG9hZGVkUG9seWdvbnMgPSBkYXRhLmZlYXR1cmVzLm1hcChmZWF0dXJlID0+IHtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5ICYmIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKHBvbHlnb25Db29yZHMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhzID0gcG9seWdvbkNvb3Jkcy5tYXAocmluZyA9PiByaW5nLm1hcChjb29yZHMgPT4gKHsgbGF0OiBjb29yZHNbMV0sIGxuZzogY29vcmRzWzBdIH0pKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKHtcbiAgICAgICAgICAgICAgICAgIHBhdGhzOiBwYXRocyxcbiAgICAgICAgICAgICAgICAgIG1hcDogbmV3TWFwLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlQ29sb3I6ICdibGFjaycsXG4gICAgICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAwLjgsXG4gICAgICAgICAgICAgICAgICBzdHJva2VXZWlnaHQ6IDAuNSxcbiAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSkuZmlsdGVyKHBvbHkgPT4gcG9seSAhPT0gbnVsbCkuZmxhdCgpO1xuICAgICAgICAgIHNldFBvbHlnb25zKGxvYWRlZFBvbHlnb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmV3TWFwLnNldE9wdGlvbnMoeyBzdHlsZXM6IG1hcFN0eWxlcyB9KTtcbiAgICBzZXRNYXAobmV3TWFwKTtcbiAgICBkaXJlY3Rpb25zUmVuZGVyZXIuY3VycmVudCA9IG5ldyBnb29nbGUubWFwcy5EaXJlY3Rpb25zUmVuZGVyZXIoKTtcbiAgICBkaXJlY3Rpb25zUmVuZGVyZXIuY3VycmVudC5zZXRNYXAobmV3TWFwKTtcbiAgICBkaXJlY3Rpb25zUmVuZGVyZXIuY3VycmVudC5zZXRQYW5lbChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlyZWN0aW9uc1BhbmVsJykpO1xuICB9O1xuXG4gIC8vIHNlYXJjaCByb3V0ZVxuICBjb25zdCBzZWFyY2hSb3V0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBkaXJlY3Rpb25zU2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5EaXJlY3Rpb25zU2VydmljZSgpO1xuICAgIGNvbnN0IGdlb2NvZGVyID0gbmV3IGdvb2dsZS5tYXBzLkdlb2NvZGVyKCk7XG4gICAgZGlyZWN0aW9uc1JlbmRlcmVyLnNldE1hcChudWxsKTtcbiAgICBkaXJlY3Rpb25zUmVuZGVyZXIuY3VycmVudC5zZXRNYXAobWFwKTtcbiAgICBkaXJlY3Rpb25zUmVuZGVyZXIuY3VycmVudC5zZXRQYW5lbChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlyZWN0aW9uc1BhbmVsJykpO1xuXG5cblxuXG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2VvY29kZSBhbiBhZGRyZXNzXG4gICAgY29uc3QgZ2VvY29kZUFkZHJlc3MgPSAoYWRkcmVzcywgY2FsbGJhY2spID0+IHtcbiAgICAgIGdlb2NvZGVyLmdlb2NvZGUoeyAnYWRkcmVzcyc6IGFkZHJlc3MgfSwgKHJlc3VsdHMsIHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnT0snKSB7XG4gICAgICAgICAgY2FsbGJhY2socmVzdWx0c1swXS5nZW9tZXRyeS5sb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWxlcnQoJ0dlb2NvZGUgd2FzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZm9sbG93aW5nIHJlYXNvbjogJyArIHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBDb252ZXJ0IG9yaWdpbiBhbmQgZGVzdGluYXRpb24gZnJvbSBhZGRyZXNzIHRvIExhdExuZ1xuICAgIGdlb2NvZGVBZGRyZXNzKG9yaWdpbiwgKG9yaWdpbkxhdExuZykgPT4ge1xuICAgICAgaWYgKCFnZW9Kc29uRGF0YSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdHZW9KU09OIGRhdGEgaXMgbm90IGxvYWRlZCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBnZW9jb2RlQWRkcmVzcyhkZXN0aW5hdGlvbiwgKGRlc3RpbmF0aW9uTGF0TG5nKSA9PiB7XG4gICAgICAgIC8vIE9uY2UgYm90aCBhZGRyZXNzZXMgYXJlIGdlb2NvZGVkXG4gICAgICAgIGNvbnN0IG9yaWdpblBvaW50ID0gdHVyZi5wb2ludChbb3JpZ2luTGF0TG5nLmxuZygpLCBvcmlnaW5MYXRMbmcubGF0KCldKTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25Qb2ludCA9IHR1cmYucG9pbnQoW2Rlc3RpbmF0aW9uTGF0TG5nLmxuZygpLCBkZXN0aW5hdGlvbkxhdExuZy5sYXQoKV0pO1xuXG4gICAgICAgIGNvbnN0IGlzQ2xvc2VFbm91Z2ggPSAocG9pbnQpID0+IHtcbiAgICAgICAgICByZXR1cm4gZ2VvSnNvbkRhdGEuZmVhdHVyZXMuc29tZShmZWF0dXJlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVQb2ludCA9IHR1cmYucG9pbnQoW2ZlYXR1cmUucHJvcGVydGllcy5nZW9fcG9pbnRfMmQubG9uLCBmZWF0dXJlLnByb3BlcnRpZXMuZ2VvX3BvaW50XzJkLmxhdF0pO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0dXJmLmRpc3RhbmNlKHBvaW50LCBmZWF0dXJlUG9pbnQsIHsgdW5pdHM6ICdtZXRlcnMnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlIDwgMTAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9yaWdpbkNsb3NlRW5vdWdoID0gaXNDbG9zZUVub3VnaChvcmlnaW5Qb2ludCk7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uQ2xvc2VFbm91Z2ggPSBpc0Nsb3NlRW5vdWdoKGRlc3RpbmF0aW9uUG9pbnQpO1xuICAgICAgICBjb25zb2xlLmxvZygnb3JpZ2luUG9pbnQ6Jywgb3JpZ2luUG9pbnQpXG4gICAgICAgIGNvbnNvbGUubG9nKCdkZXN0aW5hdGlvblBvaW50OicsIGRlc3RpbmF0aW9uUG9pbnQpXG5cbiAgICAgICAgaWYgKCFvcmlnaW5DbG9zZUVub3VnaCB8fCAhZGVzdGluYXRpb25DbG9zZUVub3VnaCkge1xuICAgICAgICAgIGFsZXJ0KFwiQmVnaW5uaW5nIG9yIGVuZCBwb2ludCBpcyBvdXRzaWRlIHRoZSBkZWZpbmVkIGFyZWFcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9yaWdpbkxhdExuZyAmJiBkZXN0aW5hdGlvbkxhdExuZykge1xuICAgICAgICAgIC8vIFJlcXVlc3QgYW5kIGRpc3BsYXkgdGhlIHJvdXRlXG4gICAgICAgICAgZGlyZWN0aW9uc1NlcnZpY2Uucm91dGUoe1xuICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW5MYXRMbmcsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25MYXRMbmcsXG4gICAgICAgICAgICB0cmF2ZWxNb2RlOiB0cmF2ZWxNb2RlLFxuICAgICAgICAgICAgdHJhbnNpdE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgbW9kZXM6IFsnQlVTJywgJ1JBSUwnXSwgLy8g5YWs5YWx5Lqk6YCa6YCJ6aG577yM5qC55o2u6ZyA5rGC6LCD5pW0XG4gICAgICAgICAgICAgIHJvdXRpbmdQcmVmZXJlbmNlOiAnRkVXRVJfVFJBTlNGRVJTJyAvLyDlsJHmjaLkuZhcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSwgKHJlc3VsdCwgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSBnb29nbGUubWFwcy5EaXJlY3Rpb25zU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgIGRpcmVjdGlvbnNSZW5kZXJlci5zZXREaXJlY3Rpb25zKHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZGlzcGxheSBkaXJlY3Rpb25zIGR1ZSB0bzogJyArIHN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG5cblxuXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAgPGRpdiByZWY9e21hcFJlZn0gc3R5bGU9e3sgd2lkdGg6ICc3MCUnLCBoZWlnaHQ6ICc1MDBweCcsIGZsb2F0OiAnbGVmdCcgfX0+PC9kaXY+XG4gICAgICA8ZGl2IGlkPVwiZGlyZWN0aW9uc1BhbmVsXCIgc3R5bGU9e3sgd2lkdGg6ICczMCUnLCBoZWlnaHQ6ICc1MDBweCcsIGZsb2F0OiAncmlnaHQnLCBvdmVyZmxvdzogJ2F1dG8nIH19PjwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xuICBcbn07XG5cbmNvbnN0IG1hcFN0eWxlcyA9IFtcbiAge1xuICAgIFwiZmVhdHVyZVR5cGVcIjogXCJhbGxcIixcbiAgICBcImVsZW1lbnRUeXBlXCI6IFwibGFiZWxzXCIsXG4gICAgXCJzdHlsZXJzXCI6IFtcbiAgICAgIHsgXCJ2aXNpYmlsaXR5XCI6IFwib2ZmXCIgfVxuICAgIF1cbiAgfSxcbiAge1xuICAgIFwiZmVhdHVyZVR5cGVcIjogXCJyb2FkXCIsXG4gICAgXCJlbGVtZW50VHlwZVwiOiBcImdlb21ldHJ5XCIsXG4gICAgXCJzdHlsZXJzXCI6IFtcbiAgICAgIHsgXCJjb2xvclwiOiBcIiNmZmZmZmZcIiB9XG4gICAgXVxuICB9XG5dO1xuXG5leHBvcnQgZGVmYXVsdCBNYXA7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInR1cmYiLCJNYXAiLCJnZW9Kc29uVXJsIiwib3JpZ2luIiwiZGVzdGluYXRpb24iLCJzZWFyY2hUcmlnZ2VyIiwidHJhdmVsTW9kZSIsIm1hcFJlZiIsIm1hcCIsInNldE1hcCIsInBvbHlnb25zIiwic2V0UG9seWdvbnMiLCJnZW9Kc29uRGF0YSIsInNldEdlb0pzb25EYXRhIiwiYXBpTG9hZGVkIiwic2V0QXBpTG9hZGVkIiwiZGlyZWN0aW9uc1JlbmRlcmVyIiwibG9hZEdvb2dsZU1hcHNBcGkiLCJ3aW5kb3ciLCJnb29nbGUiLCJtYXBzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsInNyYyIsImFzeW5jIiwiZGVmZXIiLCJvbmxvYWQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjdXJyZW50IiwiaW5pdGlhbGl6ZU1hcCIsImNsZWFyUm91dGVBbmRQYW5lbCIsImNvbnNvbGUiLCJsb2ciLCJzZWFyY2hSb3V0ZSIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsImRhdGEiLCJzZXRQYW5lbCIsIm1lbGJvdXJuZUNCRCIsImxhdCIsImxuZyIsIm5ld01hcCIsImNlbnRlciIsInpvb20iLCJsb2FkZWRQb2x5Z29ucyIsImZlYXR1cmVzIiwiZmVhdHVyZSIsImdlb21ldHJ5IiwidHlwZSIsImNvb3JkaW5hdGVzIiwicG9seWdvbkNvb3JkcyIsInBhdGhzIiwicmluZyIsImNvb3JkcyIsIlBvbHlnb24iLCJzdHJva2VDb2xvciIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXZWlnaHQiLCJmaWxsQ29sb3IiLCJmaWxsT3BhY2l0eSIsImZpbHRlciIsInBvbHkiLCJmbGF0Iiwic2V0T3B0aW9ucyIsInN0eWxlcyIsIm1hcFN0eWxlcyIsIkRpcmVjdGlvbnNSZW5kZXJlciIsImdldEVsZW1lbnRCeUlkIiwiZGlyZWN0aW9uc1NlcnZpY2UiLCJEaXJlY3Rpb25zU2VydmljZSIsImdlb2NvZGVyIiwiR2VvY29kZXIiLCJnZW9jb2RlQWRkcmVzcyIsImFkZHJlc3MiLCJjYWxsYmFjayIsImdlb2NvZGUiLCJyZXN1bHRzIiwic3RhdHVzIiwibG9jYXRpb24iLCJhbGVydCIsIm9yaWdpbkxhdExuZyIsImVycm9yIiwiZGVzdGluYXRpb25MYXRMbmciLCJvcmlnaW5Qb2ludCIsInBvaW50IiwiZGVzdGluYXRpb25Qb2ludCIsImlzQ2xvc2VFbm91Z2giLCJzb21lIiwiZmVhdHVyZVBvaW50IiwicHJvcGVydGllcyIsImdlb19wb2ludF8yZCIsImxvbiIsImRpc3RhbmNlIiwidW5pdHMiLCJvcmlnaW5DbG9zZUVub3VnaCIsImRlc3RpbmF0aW9uQ2xvc2VFbm91Z2giLCJyb3V0ZSIsInRyYW5zaXRPcHRpb25zIiwibW9kZXMiLCJyb3V0aW5nUHJlZmVyZW5jZSIsInJlc3VsdCIsIkRpcmVjdGlvbnNTdGF0dXMiLCJPSyIsInNldERpcmVjdGlvbnMiLCJkaXYiLCJyZWYiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwiZmxvYXQiLCJpZCIsIm92ZXJmbG93Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/Travel/Map.js\n"));

/***/ })

});