"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/Travel/page",{

/***/ "(app-pages-browser)/./src/app/Travel/Map.js":
/*!*******************************!*\
  !*** ./src/app/Travel/Map.js ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _turf_turf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/turf */ \"(app-pages-browser)/./node_modules/@turf/turf/dist/es/index.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Map = (param)=>{\n    let { geoJsonUrl, origin, destination, searchTrigger, travelMode } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [map, setMap] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [polygons, setPolygons] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]); // 存储所有GeoJSON多边形\n    const [geoJsonData, setGeoJsonData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [apiLoaded, setApiLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false); // 控制API加载的状态\n    const directionsRenderer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // 动态加载Google Maps API\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadGoogleMapsApi = ()=>{\n            if (window.google && window.google.maps) {\n                setApiLoaded(true); // 设置API加载完成状态\n                return;\n            }\n            if (!document.querySelector('script[src*=\"maps.googleapis\"]')) {\n                const script = document.createElement(\"script\");\n                script.src = \"https://maps.googleapis.com/maps/api/js?key=AIzaSyA4bcHQArQWH2Qxb47goCAhbstZX0WkUZk&libraries=places,geometry\";\n                script.async = true;\n                script.defer = true;\n                script.onload = ()=>setApiLoaded(true);\n                document.head.appendChild(script);\n            }\n        };\n        loadGoogleMapsApi();\n    }, []);\n    // 初始化地图\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (apiLoaded && !map && mapRef.current) {\n            initializeMap();\n        }\n    }, [\n        apiLoaded,\n        mapRef.current\n    ]); // 依赖API加载状态和mapRef的变化\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (map && origin && destination && searchTrigger) {\n            console.log(\"Clearing route and panel\");\n            clearRouteAndPanel(); // First, clear the current route\n            console.log(\"Searching new route\");\n            searchRoute(); // Then, search for a new route\n        }\n    }, [\n        map,\n        searchTrigger\n    ]); // 依赖于 searchTrigger\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (geoJsonUrl) {\n            fetch(geoJsonUrl).then((response)=>response.json()).then((data)=>{\n                setGeoJsonData(data); // Save fetched GeoJSON data to state\n            });\n        }\n    }, [\n        geoJsonUrl\n    ]);\n    const clearRouteAndPanel = ()=>{\n        console.log(\"Executing clearRouteAndPanel\");\n        if (directionsRenderer.current) {\n            console.log(\"DirectionsRenderer is set, clearing map and panel\");\n            directionsRenderer.current.setMap(null);\n            directionsRenderer.current.setPanel(null);\n            console.log(\"Map and panel cleared\");\n        } else {\n            console.log(\"DirectionsRenderer not set\");\n        }\n    };\n    const initializeMap = ()=>{\n        const melbourneCBD = {\n            lat: -37.8136,\n            lng: 144.9631\n        };\n        const newMap = new window.google.maps.Map(mapRef.current, {\n            center: melbourneCBD,\n            zoom: 14\n        });\n        // loading GeoJSON create multi shape\n        if (geoJsonUrl) {\n            fetch(geoJsonUrl).then((response)=>response.json()).then((data)=>{\n                const loadedPolygons = data.features.map((feature)=>{\n                    if (feature.geometry && feature.geometry.type === \"MultiPolygon\") {\n                        return feature.geometry.coordinates.map((polygonCoords)=>{\n                            const paths = polygonCoords.map((ring)=>ring.map((coords)=>({\n                                        lat: coords[1],\n                                        lng: coords[0]\n                                    })));\n                            return new google.maps.Polygon({\n                                paths: paths,\n                                map: newMap,\n                                strokeColor: \"black\",\n                                strokeOpacity: 0.8,\n                                strokeWeight: 0.5,\n                                fillColor: \"white\",\n                                fillOpacity: 0\n                            });\n                        });\n                    }\n                    return null;\n                }).filter((poly)=>poly !== null).flat();\n                setPolygons(loadedPolygons);\n            });\n        }\n        newMap.setOptions({\n            styles: mapStyles\n        });\n        setMap(newMap);\n        directionsRenderer.current = new google.maps.DirectionsRenderer();\n        directionsRenderer.current.setMap(newMap);\n        directionsRenderer.current.setPanel(document.getElementById(\"directionsPanel\"));\n    };\n    // search route\n    const searchRoute = ()=>{\n        const directionsService = new google.maps.DirectionsService();\n        const geocoder = new google.maps.Geocoder();\n        let directionsRenderer = new google.maps.DirectionsRenderer({\n            map: map,\n            panel: document.getElementById(\"directionsPanel\")\n        });\n        directionsRenderer.setMap(null);\n        directionsRenderer.setMap(map);\n        directionsRenderer.setPanel(document.getElementById(\"directionsPanel\"));\n        // Helper function to geocode an address\n        const geocodeAddress = (address, callback)=>{\n            geocoder.geocode({\n                \"address\": address\n            }, (results, status)=>{\n                if (status === \"OK\") {\n                    callback(results[0].geometry.location);\n                } else {\n                    alert(\"Geocode was not successful for the following reason: \" + status);\n                }\n            });\n        };\n        // Convert origin and destination from address to LatLng\n        geocodeAddress(origin, (originLatLng)=>{\n            if (!geoJsonData) {\n                console.error(\"GeoJSON data is not loaded\");\n                return;\n            }\n            geocodeAddress(destination, (destinationLatLng)=>{\n                // Once both addresses are geocoded\n                const originPoint = _turf_turf__WEBPACK_IMPORTED_MODULE_2__.point([\n                    originLatLng.lng(),\n                    originLatLng.lat()\n                ]);\n                const destinationPoint = _turf_turf__WEBPACK_IMPORTED_MODULE_2__.point([\n                    destinationLatLng.lng(),\n                    destinationLatLng.lat()\n                ]);\n                const isCloseEnough = (point)=>{\n                    return geoJsonData.features.some((feature)=>{\n                        const featurePoint = _turf_turf__WEBPACK_IMPORTED_MODULE_2__.point([\n                            feature.properties.geo_point_2d.lon,\n                            feature.properties.geo_point_2d.lat\n                        ]);\n                        const distance = _turf_turf__WEBPACK_IMPORTED_MODULE_2__.distance(point, featurePoint, {\n                            units: \"meters\"\n                        });\n                        return distance < 100;\n                    });\n                };\n                const originCloseEnough = isCloseEnough(originPoint);\n                const destinationCloseEnough = isCloseEnough(destinationPoint);\n                console.log(\"originPoint:\", originPoint);\n                console.log(\"destinationPoint:\", destinationPoint);\n                if (!originCloseEnough || !destinationCloseEnough) {\n                    alert(\"Beginning or end point is outside the defined area\");\n                    return;\n                }\n                if (originLatLng && destinationLatLng) {\n                    // Request and display the route\n                    directionsService.route({\n                        origin: originLatLng,\n                        destination: destinationLatLng,\n                        travelMode: travelMode,\n                        transitOptions: {\n                            modes: [\n                                \"BUS\",\n                                \"RAIL\"\n                            ],\n                            routingPreference: \"FEWER_TRANSFERS\" // 少换乘\n                        }\n                    }, (result, status)=>{\n                        if (status === google.maps.DirectionsStatus.OK) {\n                            directionsRenderer.setDirections(result);\n                        } else {\n                            console.error(\"Failed to display directions due to: \" + status);\n                        }\n                    });\n                }\n            });\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: mapRef,\n                style: {\n                    width: \"70%\",\n                    height: \"500px\",\n                    float: \"left\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/jianqiao/myproject/MelbourneUnbound/frontend/src/app/Travel/Map.js\",\n                lineNumber: 197,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                id: \"directionsPanel\",\n                style: {\n                    width: \"30%\",\n                    height: \"500px\",\n                    float: \"right\",\n                    overflow: \"auto\"\n                }\n            }, void 0, false, {\n                fileName: \"/Users/jianqiao/myproject/MelbourneUnbound/frontend/src/app/Travel/Map.js\",\n                lineNumber: 198,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/jianqiao/myproject/MelbourneUnbound/frontend/src/app/Travel/Map.js\",\n        lineNumber: 196,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Map, \"/a33oBFfimt+utD0zSn3gttvMig=\");\n_c = Map;\nconst mapStyles = [\n    {\n        \"featureType\": \"all\",\n        \"elementType\": \"labels\",\n        \"stylers\": [\n            {\n                \"visibility\": \"off\"\n            }\n        ]\n    },\n    {\n        \"featureType\": \"road\",\n        \"elementType\": \"geometry\",\n        \"stylers\": [\n            {\n                \"color\": \"#ffffff\"\n            }\n        ]\n    }\n];\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\nvar _c;\n$RefreshReg$(_c, \"Map\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvVHJhdmVsL01hcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTJEO0FBQ3hCO0FBRW5DLE1BQU1LLE1BQU07UUFBQyxFQUFFQyxVQUFVLEVBQUVDLE1BQU0sRUFBRUMsV0FBVyxFQUFFQyxhQUFhLEVBQUNDLFVBQVUsRUFBRTs7SUFDeEUsTUFBTUMsU0FBU1YsNkNBQU1BLENBQUM7SUFDdEIsTUFBTSxDQUFDVyxLQUFLQyxPQUFPLEdBQUdWLCtDQUFRQSxDQUFDO0lBQy9CLE1BQU0sQ0FBQ1csVUFBVUMsWUFBWSxHQUFHWiwrQ0FBUUEsQ0FBQyxFQUFFLEdBQUksaUJBQWlCO0lBQ2hFLE1BQU0sQ0FBQ2EsYUFBYUMsZUFBZSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNlLFdBQVdDLGFBQWEsR0FBR2hCLCtDQUFRQSxDQUFDLFFBQVMsYUFBYTtJQUNqRSxNQUFNaUIscUJBQXFCbkIsNkNBQU1BLENBQUM7SUFFbEMsc0JBQXNCO0lBQ3RCQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1tQixvQkFBb0I7WUFDeEIsSUFBSUMsT0FBT0MsTUFBTSxJQUFJRCxPQUFPQyxNQUFNLENBQUNDLElBQUksRUFBRTtnQkFDdkNMLGFBQWEsT0FBUSxjQUFjO2dCQUNuQztZQUNGO1lBQ0EsSUFBSSxDQUFDTSxTQUFTQyxhQUFhLENBQUMsbUNBQW1DO2dCQUM3RCxNQUFNQyxTQUFTRixTQUFTRyxhQUFhLENBQUM7Z0JBQ3RDRCxPQUFPRSxHQUFHLEdBQUk7Z0JBQ2RGLE9BQU9HLEtBQUssR0FBRztnQkFDZkgsT0FBT0ksS0FBSyxHQUFHO2dCQUNmSixPQUFPSyxNQUFNLEdBQUcsSUFBTWIsYUFBYTtnQkFDbkNNLFNBQVNRLElBQUksQ0FBQ0MsV0FBVyxDQUFDUDtZQUM1QjtRQUNGO1FBRUFOO0lBQ0YsR0FBRyxFQUFFO0lBRUwsUUFBUTtJQUNSbkIsZ0RBQVNBLENBQUM7UUFDUixJQUFJZ0IsYUFBYSxDQUFDTixPQUFPRCxPQUFPd0IsT0FBTyxFQUFFO1lBQ3ZDQztRQUNGO0lBQ0YsR0FBRztRQUFDbEI7UUFBV1AsT0FBT3dCLE9BQU87S0FBQyxHQUFHLHNCQUFzQjtJQUV2RGpDLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSVUsT0FBT0wsVUFBVUMsZUFBZUMsZUFBZTtZQUNqRDRCLFFBQVFDLEdBQUcsQ0FBQztZQUNaQyxzQkFBdUIsaUNBQWlDO1lBQ3hERixRQUFRQyxHQUFHLENBQUM7WUFDWkUsZUFBZ0IsK0JBQStCO1FBQ2pEO0lBQ0YsR0FBRztRQUFDNUI7UUFBS0g7S0FBYyxHQUFHLG9CQUFvQjtJQUU5Q1AsZ0RBQVNBLENBQUM7UUFDUixJQUFJSSxZQUFZO1lBQ2RtQyxNQUFNbkMsWUFDSG9DLElBQUksQ0FBQ0MsQ0FBQUEsV0FBWUEsU0FBU0MsSUFBSSxJQUM5QkYsSUFBSSxDQUFDRyxDQUFBQTtnQkFDSjVCLGVBQWU0QixPQUFRLHFDQUFxQztZQUM5RDtRQUNKO0lBQ0YsR0FBRztRQUFDdkM7S0FBVztJQUVmLE1BQU1pQyxxQkFBcUI7UUFDekJGLFFBQVFDLEdBQUcsQ0FBQztRQUNaLElBQUlsQixtQkFBbUJlLE9BQU8sRUFBRTtZQUM5QkUsUUFBUUMsR0FBRyxDQUFDO1lBQ1psQixtQkFBbUJlLE9BQU8sQ0FBQ3RCLE1BQU0sQ0FBQztZQUNsQ08sbUJBQW1CZSxPQUFPLENBQUNXLFFBQVEsQ0FBQztZQUNwQ1QsUUFBUUMsR0FBRyxDQUFDO1FBQ2QsT0FBTztZQUNMRCxRQUFRQyxHQUFHLENBQUM7UUFDZDtJQUNGO0lBSUEsTUFBTUYsZ0JBQWdCO1FBQ3BCLE1BQU1XLGVBQWU7WUFBRUMsS0FBSyxDQUFDO1lBQVNDLEtBQUs7UUFBUztRQUNwRCxNQUFNQyxTQUFTLElBQUk1QixPQUFPQyxNQUFNLENBQUNDLElBQUksQ0FBQ25CLEdBQUcsQ0FBQ00sT0FBT3dCLE9BQU8sRUFBRTtZQUN4RGdCLFFBQVFKO1lBQ1JLLE1BQU07UUFDUjtRQUVBLHFDQUFxQztRQUNyQyxJQUFJOUMsWUFBWTtZQUNkbUMsTUFBTW5DLFlBQ0hvQyxJQUFJLENBQUNDLENBQUFBLFdBQVlBLFNBQVNDLElBQUksSUFDOUJGLElBQUksQ0FBQ0csQ0FBQUE7Z0JBQ0osTUFBTVEsaUJBQWlCUixLQUFLUyxRQUFRLENBQUMxQyxHQUFHLENBQUMyQyxDQUFBQTtvQkFDdkMsSUFBSUEsUUFBUUMsUUFBUSxJQUFJRCxRQUFRQyxRQUFRLENBQUNDLElBQUksS0FBSyxnQkFBZ0I7d0JBQ2hFLE9BQU9GLFFBQVFDLFFBQVEsQ0FBQ0UsV0FBVyxDQUFDOUMsR0FBRyxDQUFDK0MsQ0FBQUE7NEJBQ3RDLE1BQU1DLFFBQVFELGNBQWMvQyxHQUFHLENBQUNpRCxDQUFBQSxPQUFRQSxLQUFLakQsR0FBRyxDQUFDa0QsQ0FBQUEsU0FBVzt3Q0FBRWQsS0FBS2MsTUFBTSxDQUFDLEVBQUU7d0NBQUViLEtBQUthLE1BQU0sQ0FBQyxFQUFFO29DQUFDOzRCQUM3RixPQUFPLElBQUl2QyxPQUFPQyxJQUFJLENBQUN1QyxPQUFPLENBQUM7Z0NBQzdCSCxPQUFPQTtnQ0FDUGhELEtBQUtzQztnQ0FDTGMsYUFBYTtnQ0FDYkMsZUFBZTtnQ0FDZkMsY0FBYztnQ0FDZEMsV0FBVztnQ0FDWEMsYUFBYTs0QkFDZjt3QkFDRjtvQkFDRjtvQkFDQSxPQUFPO2dCQUNULEdBQUdDLE1BQU0sQ0FBQ0MsQ0FBQUEsT0FBUUEsU0FBUyxNQUFNQyxJQUFJO2dCQUNyQ3hELFlBQVlzQztZQUNkO1FBQ0o7UUFFQUgsT0FBT3NCLFVBQVUsQ0FBQztZQUFFQyxRQUFRQztRQUFVO1FBQ3RDN0QsT0FBT3FDO1FBQ1A5QixtQkFBbUJlLE9BQU8sR0FBRyxJQUFJWixPQUFPQyxJQUFJLENBQUNtRCxrQkFBa0I7UUFDL0R2RCxtQkFBbUJlLE9BQU8sQ0FBQ3RCLE1BQU0sQ0FBQ3FDO1FBQ2xDOUIsbUJBQW1CZSxPQUFPLENBQUNXLFFBQVEsQ0FBQ3JCLFNBQVNtRCxjQUFjLENBQUM7SUFDOUQ7SUFFQSxlQUFlO0lBQ2YsTUFBTXBDLGNBQWM7UUFDbEIsTUFBTXFDLG9CQUFvQixJQUFJdEQsT0FBT0MsSUFBSSxDQUFDc0QsaUJBQWlCO1FBQzNELE1BQU1DLFdBQVcsSUFBSXhELE9BQU9DLElBQUksQ0FBQ3dELFFBQVE7UUFFekMsSUFBSTVELHFCQUFxQixJQUFJRyxPQUFPQyxJQUFJLENBQUNtRCxrQkFBa0IsQ0FBQztZQUMxRC9ELEtBQUtBO1lBQ0xxRSxPQUFPeEQsU0FBU21ELGNBQWMsQ0FBQztRQUNqQztRQUdBeEQsbUJBQW1CUCxNQUFNLENBQUM7UUFDMUJPLG1CQUFtQlAsTUFBTSxDQUFDRDtRQUMxQlEsbUJBQW1CMEIsUUFBUSxDQUFDckIsU0FBU21ELGNBQWMsQ0FBQztRQUlwRCx3Q0FBd0M7UUFDeEMsTUFBTU0saUJBQWlCLENBQUNDLFNBQVNDO1lBQy9CTCxTQUFTTSxPQUFPLENBQUM7Z0JBQUUsV0FBV0Y7WUFBUSxHQUFHLENBQUNHLFNBQVNDO2dCQUNqRCxJQUFJQSxXQUFXLE1BQU07b0JBQ25CSCxTQUFTRSxPQUFPLENBQUMsRUFBRSxDQUFDOUIsUUFBUSxDQUFDZ0MsUUFBUTtnQkFDdkMsT0FBTztvQkFDTEMsTUFBTSwwREFBMERGO2dCQUNsRTtZQUNGO1FBQ0Y7UUFFQSx3REFBd0Q7UUFDeERMLGVBQWUzRSxRQUFRLENBQUNtRjtZQUN0QixJQUFJLENBQUMxRSxhQUFhO2dCQUNoQnFCLFFBQVFzRCxLQUFLLENBQUM7Z0JBQ2Q7WUFDRjtZQUNBVCxlQUFlMUUsYUFBYSxDQUFDb0Y7Z0JBQzNCLG1DQUFtQztnQkFDbkMsTUFBTUMsY0FBY3pGLDZDQUFVLENBQUM7b0JBQUNzRixhQUFhekMsR0FBRztvQkFBSXlDLGFBQWExQyxHQUFHO2lCQUFHO2dCQUN2RSxNQUFNK0MsbUJBQW1CM0YsNkNBQVUsQ0FBQztvQkFBQ3dGLGtCQUFrQjNDLEdBQUc7b0JBQUkyQyxrQkFBa0I1QyxHQUFHO2lCQUFHO2dCQUV0RixNQUFNZ0QsZ0JBQWdCLENBQUNGO29CQUNyQixPQUFPOUUsWUFBWXNDLFFBQVEsQ0FBQzJDLElBQUksQ0FBQzFDLENBQUFBO3dCQUMvQixNQUFNMkMsZUFBZTlGLDZDQUFVLENBQUM7NEJBQUNtRCxRQUFRNEMsVUFBVSxDQUFDQyxZQUFZLENBQUNDLEdBQUc7NEJBQUU5QyxRQUFRNEMsVUFBVSxDQUFDQyxZQUFZLENBQUNwRCxHQUFHO3lCQUFDO3dCQUMxRyxNQUFNc0QsV0FBV2xHLGdEQUFhLENBQUMwRixPQUFPSSxjQUFjOzRCQUFFSyxPQUFPO3dCQUFTO3dCQUN0RSxPQUFPRCxXQUFXO29CQUNwQjtnQkFDRjtnQkFFQSxNQUFNRSxvQkFBb0JSLGNBQWNIO2dCQUN4QyxNQUFNWSx5QkFBeUJULGNBQWNEO2dCQUM3QzFELFFBQVFDLEdBQUcsQ0FBQyxnQkFBZ0J1RDtnQkFDNUJ4RCxRQUFRQyxHQUFHLENBQUMscUJBQXFCeUQ7Z0JBRWpDLElBQUksQ0FBQ1MscUJBQXFCLENBQUNDLHdCQUF3QjtvQkFDakRoQixNQUFNO29CQUNOO2dCQUNGO2dCQUVBLElBQUlDLGdCQUFnQkUsbUJBQW1CO29CQUNyQyxnQ0FBZ0M7b0JBQ2hDZixrQkFBa0I2QixLQUFLLENBQUM7d0JBQ3RCbkcsUUFBUW1GO3dCQUNSbEYsYUFBYW9GO3dCQUNibEYsWUFBWUE7d0JBQ1ppRyxnQkFBZ0I7NEJBQ2RDLE9BQU87Z0NBQUM7Z0NBQU87NkJBQU87NEJBQ3RCQyxtQkFBbUIsa0JBQWtCLE1BQU07d0JBQzdDO29CQUNGLEdBQUcsQ0FBQ0MsUUFBUXZCO3dCQUNWLElBQUlBLFdBQVdoRSxPQUFPQyxJQUFJLENBQUN1RixnQkFBZ0IsQ0FBQ0MsRUFBRSxFQUFFOzRCQUM5QzVGLG1CQUFtQjZGLGFBQWEsQ0FBQ0g7d0JBQ25DLE9BQU87NEJBQ0x6RSxRQUFRc0QsS0FBSyxDQUFDLDBDQUEwQ0o7d0JBQzFEO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBTUEscUJBQ0UsOERBQUMyQjs7MEJBQ0MsOERBQUNBO2dCQUFJQyxLQUFLeEc7Z0JBQVF5RyxPQUFPO29CQUFFQyxPQUFPO29CQUFPQyxRQUFRO29CQUFTQyxPQUFPO2dCQUFPOzs7Ozs7MEJBQ3hFLDhEQUFDTDtnQkFBSU0sSUFBRztnQkFBa0JKLE9BQU87b0JBQUVDLE9BQU87b0JBQU9DLFFBQVE7b0JBQVNDLE9BQU87b0JBQVNFLFVBQVU7Z0JBQU87Ozs7Ozs7Ozs7OztBQUl6RztHQXRNTXBIO0tBQUFBO0FBd01OLE1BQU1xRSxZQUFZO0lBQ2hCO1FBQ0UsZUFBZTtRQUNmLGVBQWU7UUFDZixXQUFXO1lBQ1Q7Z0JBQUUsY0FBYztZQUFNO1NBQ3ZCO0lBQ0g7SUFDQTtRQUNFLGVBQWU7UUFDZixlQUFlO1FBQ2YsV0FBVztZQUNUO2dCQUFFLFNBQVM7WUFBVTtTQUN0QjtJQUNIO0NBQ0Q7QUFFRCwrREFBZXJFLEdBQUdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9UcmF2ZWwvTWFwLmpzPzhmNmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIHR1cmYgZnJvbSAnQHR1cmYvdHVyZic7XG5cbmNvbnN0IE1hcCA9ICh7IGdlb0pzb25VcmwsIG9yaWdpbiwgZGVzdGluYXRpb24sIHNlYXJjaFRyaWdnZXIsdHJhdmVsTW9kZSB9KSA9PiB7XG4gIGNvbnN0IG1hcFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW21hcCwgc2V0TWFwXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcG9seWdvbnMsIHNldFBvbHlnb25zXSA9IHVzZVN0YXRlKFtdKTsgIC8vIOWtmOWCqOaJgOaciUdlb0pTT07lpJrovrnlvaJcbiAgY29uc3QgW2dlb0pzb25EYXRhLCBzZXRHZW9Kc29uRGF0YV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2FwaUxvYWRlZCwgc2V0QXBpTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTsgIC8vIOaOp+WItkFQSeWKoOi9veeahOeKtuaAgVxuICBjb25zdCBkaXJlY3Rpb25zUmVuZGVyZXIgPSB1c2VSZWYobnVsbCk7XG5cbiAgLy8g5Yqo5oCB5Yqg6L29R29vZ2xlIE1hcHMgQVBJXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbG9hZEdvb2dsZU1hcHNBcGkgPSAoKSA9PiB7XG4gICAgICBpZiAod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMpIHtcbiAgICAgICAgc2V0QXBpTG9hZGVkKHRydWUpOyAgLy8g6K6+572uQVBJ5Yqg6L295a6M5oiQ54q25oCBXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3NyYyo9XCJtYXBzLmdvb2dsZWFwaXNcIl0nKSkge1xuICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IGBodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanM/a2V5PUFJemFTeUE0YmNIUUFyUVdIMlF4YjQ3Z29DQWhic3RaWDBXa1VaayZsaWJyYXJpZXM9cGxhY2VzLGdlb21ldHJ5YDtcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHNldEFwaUxvYWRlZCh0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkR29vZ2xlTWFwc0FwaSgpO1xuICB9LCBbXSk7XG5cbiAgLy8g5Yid5aeL5YyW5Zyw5Zu+XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFwaUxvYWRlZCAmJiAhbWFwICYmIG1hcFJlZi5jdXJyZW50KSB7XG4gICAgICBpbml0aWFsaXplTWFwKCk7XG4gICAgfVxuICB9LCBbYXBpTG9hZGVkLCBtYXBSZWYuY3VycmVudF0pOyAvLyDkvp3otZZBUEnliqDovb3nirbmgIHlkoxtYXBSZWbnmoTlj5jljJZcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXAgJiYgb3JpZ2luICYmIGRlc3RpbmF0aW9uICYmIHNlYXJjaFRyaWdnZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdDbGVhcmluZyByb3V0ZSBhbmQgcGFuZWwnKTtcbiAgICAgIGNsZWFyUm91dGVBbmRQYW5lbCgpOyAgLy8gRmlyc3QsIGNsZWFyIHRoZSBjdXJyZW50IHJvdXRlXG4gICAgICBjb25zb2xlLmxvZygnU2VhcmNoaW5nIG5ldyByb3V0ZScpO1xuICAgICAgc2VhcmNoUm91dGUoKTsgIC8vIFRoZW4sIHNlYXJjaCBmb3IgYSBuZXcgcm91dGVcbiAgICB9XG4gIH0sIFttYXAsIHNlYXJjaFRyaWdnZXJdKTsgLy8g5L6d6LWW5LqOIHNlYXJjaFRyaWdnZXJcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChnZW9Kc29uVXJsKSB7XG4gICAgICBmZXRjaChnZW9Kc29uVXJsKVxuICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgIHNldEdlb0pzb25EYXRhKGRhdGEpOyAgLy8gU2F2ZSBmZXRjaGVkIEdlb0pTT04gZGF0YSB0byBzdGF0ZVxuICAgICAgICB9KTtcbiAgICB9XG4gIH0sIFtnZW9Kc29uVXJsXSk7XG5cbiAgY29uc3QgY2xlYXJSb3V0ZUFuZFBhbmVsID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdFeGVjdXRpbmcgY2xlYXJSb3V0ZUFuZFBhbmVsJyk7XG4gICAgaWYgKGRpcmVjdGlvbnNSZW5kZXJlci5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZygnRGlyZWN0aW9uc1JlbmRlcmVyIGlzIHNldCwgY2xlYXJpbmcgbWFwIGFuZCBwYW5lbCcpO1xuICAgICAgZGlyZWN0aW9uc1JlbmRlcmVyLmN1cnJlbnQuc2V0TWFwKG51bGwpO1xuICAgICAgZGlyZWN0aW9uc1JlbmRlcmVyLmN1cnJlbnQuc2V0UGFuZWwobnVsbCk7XG4gICAgICBjb25zb2xlLmxvZygnTWFwIGFuZCBwYW5lbCBjbGVhcmVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEaXJlY3Rpb25zUmVuZGVyZXIgbm90IHNldCcpO1xuICAgIH1cbiAgfTtcblxuXG5cbiAgY29uc3QgaW5pdGlhbGl6ZU1hcCA9ICgpID0+IHtcbiAgICBjb25zdCBtZWxib3VybmVDQkQgPSB7IGxhdDogLTM3LjgxMzYsIGxuZzogMTQ0Ljk2MzEgfTtcbiAgICBjb25zdCBuZXdNYXAgPSBuZXcgd2luZG93Lmdvb2dsZS5tYXBzLk1hcChtYXBSZWYuY3VycmVudCwge1xuICAgICAgY2VudGVyOiBtZWxib3VybmVDQkQsXG4gICAgICB6b29tOiAxNCxcbiAgICB9KTtcblxuICAgIC8vIGxvYWRpbmcgR2VvSlNPTiBjcmVhdGUgbXVsdGkgc2hhcGVcbiAgICBpZiAoZ2VvSnNvblVybCkge1xuICAgICAgZmV0Y2goZ2VvSnNvblVybClcbiAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICBjb25zdCBsb2FkZWRQb2x5Z29ucyA9IGRhdGEuZmVhdHVyZXMubWFwKGZlYXR1cmUgPT4ge1xuICAgICAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgJiYgZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcy5tYXAocG9seWdvbkNvb3JkcyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aHMgPSBwb2x5Z29uQ29vcmRzLm1hcChyaW5nID0+IHJpbmcubWFwKGNvb3JkcyA9PiAoeyBsYXQ6IGNvb3Jkc1sxXSwgbG5nOiBjb29yZHNbMF0gfSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLlBvbHlnb24oe1xuICAgICAgICAgICAgICAgICAgcGF0aHM6IHBhdGhzLFxuICAgICAgICAgICAgICAgICAgbWFwOiBuZXdNYXAsXG4gICAgICAgICAgICAgICAgICBzdHJva2VDb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDAuOCxcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVdlaWdodDogMC41LFxuICAgICAgICAgICAgICAgICAgZmlsbENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9KS5maWx0ZXIocG9seSA9PiBwb2x5ICE9PSBudWxsKS5mbGF0KCk7XG4gICAgICAgICAgc2V0UG9seWdvbnMobG9hZGVkUG9seWdvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZXdNYXAuc2V0T3B0aW9ucyh7IHN0eWxlczogbWFwU3R5bGVzIH0pO1xuICAgIHNldE1hcChuZXdNYXApO1xuICAgIGRpcmVjdGlvbnNSZW5kZXJlci5jdXJyZW50ID0gbmV3IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNSZW5kZXJlcigpO1xuICAgIGRpcmVjdGlvbnNSZW5kZXJlci5jdXJyZW50LnNldE1hcChuZXdNYXApO1xuICAgIGRpcmVjdGlvbnNSZW5kZXJlci5jdXJyZW50LnNldFBhbmVsKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXJlY3Rpb25zUGFuZWwnKSk7XG4gIH07XG5cbiAgLy8gc2VhcmNoIHJvdXRlXG4gIGNvbnN0IHNlYXJjaFJvdXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGRpcmVjdGlvbnNTZXJ2aWNlID0gbmV3IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNTZXJ2aWNlKCk7XG4gICAgY29uc3QgZ2VvY29kZXIgPSBuZXcgZ29vZ2xlLm1hcHMuR2VvY29kZXIoKTtcblxuICAgIGxldCBkaXJlY3Rpb25zUmVuZGVyZXIgPSBuZXcgZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc1JlbmRlcmVyKHtcbiAgICAgIG1hcDogbWFwLFxuICAgICAgcGFuZWw6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXJlY3Rpb25zUGFuZWwnKSBcbiAgICB9KTtcbiAgICBcblxuICAgIGRpcmVjdGlvbnNSZW5kZXJlci5zZXRNYXAobnVsbCk7XG4gICAgZGlyZWN0aW9uc1JlbmRlcmVyLnNldE1hcChtYXApO1xuICAgIGRpcmVjdGlvbnNSZW5kZXJlci5zZXRQYW5lbChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlyZWN0aW9uc1BhbmVsJykpO1xuXG5cblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZW9jb2RlIGFuIGFkZHJlc3NcbiAgICBjb25zdCBnZW9jb2RlQWRkcmVzcyA9IChhZGRyZXNzLCBjYWxsYmFjaykgPT4ge1xuICAgICAgZ2VvY29kZXIuZ2VvY29kZSh7ICdhZGRyZXNzJzogYWRkcmVzcyB9LCAocmVzdWx0cywgc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdPSycpIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHRzWzBdLmdlb21ldHJ5LmxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGVydCgnR2VvY29kZSB3YXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uOiAnICsgc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIENvbnZlcnQgb3JpZ2luIGFuZCBkZXN0aW5hdGlvbiBmcm9tIGFkZHJlc3MgdG8gTGF0TG5nXG4gICAgZ2VvY29kZUFkZHJlc3Mob3JpZ2luLCAob3JpZ2luTGF0TG5nKSA9PiB7XG4gICAgICBpZiAoIWdlb0pzb25EYXRhKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0dlb0pTT04gZGF0YSBpcyBub3QgbG9hZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGdlb2NvZGVBZGRyZXNzKGRlc3RpbmF0aW9uLCAoZGVzdGluYXRpb25MYXRMbmcpID0+IHtcbiAgICAgICAgLy8gT25jZSBib3RoIGFkZHJlc3NlcyBhcmUgZ2VvY29kZWRcbiAgICAgICAgY29uc3Qgb3JpZ2luUG9pbnQgPSB0dXJmLnBvaW50KFtvcmlnaW5MYXRMbmcubG5nKCksIG9yaWdpbkxhdExuZy5sYXQoKV0pO1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvblBvaW50ID0gdHVyZi5wb2ludChbZGVzdGluYXRpb25MYXRMbmcubG5nKCksIGRlc3RpbmF0aW9uTGF0TG5nLmxhdCgpXSk7XG5cbiAgICAgICAgY29uc3QgaXNDbG9zZUVub3VnaCA9IChwb2ludCkgPT4ge1xuICAgICAgICAgIHJldHVybiBnZW9Kc29uRGF0YS5mZWF0dXJlcy5zb21lKGZlYXR1cmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZVBvaW50ID0gdHVyZi5wb2ludChbZmVhdHVyZS5wcm9wZXJ0aWVzLmdlb19wb2ludF8yZC5sb24sIGZlYXR1cmUucHJvcGVydGllcy5nZW9fcG9pbnRfMmQubGF0XSk7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHR1cmYuZGlzdGFuY2UocG9pbnQsIGZlYXR1cmVQb2ludCwgeyB1bml0czogJ21ldGVycycgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2UgPCAxMDA7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb3JpZ2luQ2xvc2VFbm91Z2ggPSBpc0Nsb3NlRW5vdWdoKG9yaWdpblBvaW50KTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25DbG9zZUVub3VnaCA9IGlzQ2xvc2VFbm91Z2goZGVzdGluYXRpb25Qb2ludCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvcmlnaW5Qb2ludDonLCBvcmlnaW5Qb2ludClcbiAgICAgICAgY29uc29sZS5sb2coJ2Rlc3RpbmF0aW9uUG9pbnQ6JywgZGVzdGluYXRpb25Qb2ludClcblxuICAgICAgICBpZiAoIW9yaWdpbkNsb3NlRW5vdWdoIHx8ICFkZXN0aW5hdGlvbkNsb3NlRW5vdWdoKSB7XG4gICAgICAgICAgYWxlcnQoXCJCZWdpbm5pbmcgb3IgZW5kIHBvaW50IGlzIG91dHNpZGUgdGhlIGRlZmluZWQgYXJlYVwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3JpZ2luTGF0TG5nICYmIGRlc3RpbmF0aW9uTGF0TG5nKSB7XG4gICAgICAgICAgLy8gUmVxdWVzdCBhbmQgZGlzcGxheSB0aGUgcm91dGVcbiAgICAgICAgICBkaXJlY3Rpb25zU2VydmljZS5yb3V0ZSh7XG4gICAgICAgICAgICBvcmlnaW46IG9yaWdpbkxhdExuZyxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbkxhdExuZyxcbiAgICAgICAgICAgIHRyYXZlbE1vZGU6IHRyYXZlbE1vZGUsXG4gICAgICAgICAgICB0cmFuc2l0T3B0aW9uczoge1xuICAgICAgICAgICAgICBtb2RlczogWydCVVMnLCAnUkFJTCddLCAvLyDlhazlhbHkuqTpgJrpgInpobnvvIzmoLnmja7pnIDmsYLosIPmlbRcbiAgICAgICAgICAgICAgcm91dGluZ1ByZWZlcmVuY2U6ICdGRVdFUl9UUkFOU0ZFUlMnIC8vIOWwkeaNouS5mFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LCAocmVzdWx0LCBzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNTdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgZGlyZWN0aW9uc1JlbmRlcmVyLnNldERpcmVjdGlvbnMocmVzdWx0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBkaXNwbGF5IGRpcmVjdGlvbnMgZHVlIHRvOiAnICsgc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cblxuXG5cblxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8ZGl2IHJlZj17bWFwUmVmfSBzdHlsZT17eyB3aWR0aDogJzcwJScsIGhlaWdodDogJzUwMHB4JywgZmxvYXQ6ICdsZWZ0JyB9fT48L2Rpdj5cbiAgICAgIDxkaXYgaWQ9XCJkaXJlY3Rpb25zUGFuZWxcIiBzdHlsZT17eyB3aWR0aDogJzMwJScsIGhlaWdodDogJzUwMHB4JywgZmxvYXQ6ICdyaWdodCcsIG92ZXJmbG93OiAnYXV0bycgfX0+PC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG4gIFxufTtcblxuY29uc3QgbWFwU3R5bGVzID0gW1xuICB7XG4gICAgXCJmZWF0dXJlVHlwZVwiOiBcImFsbFwiLFxuICAgIFwiZWxlbWVudFR5cGVcIjogXCJsYWJlbHNcIixcbiAgICBcInN0eWxlcnNcIjogW1xuICAgICAgeyBcInZpc2liaWxpdHlcIjogXCJvZmZcIiB9XG4gICAgXVxuICB9LFxuICB7XG4gICAgXCJmZWF0dXJlVHlwZVwiOiBcInJvYWRcIixcbiAgICBcImVsZW1lbnRUeXBlXCI6IFwiZ2VvbWV0cnlcIixcbiAgICBcInN0eWxlcnNcIjogW1xuICAgICAgeyBcImNvbG9yXCI6IFwiI2ZmZmZmZlwiIH1cbiAgICBdXG4gIH1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IE1hcDtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwidHVyZiIsIk1hcCIsImdlb0pzb25VcmwiLCJvcmlnaW4iLCJkZXN0aW5hdGlvbiIsInNlYXJjaFRyaWdnZXIiLCJ0cmF2ZWxNb2RlIiwibWFwUmVmIiwibWFwIiwic2V0TWFwIiwicG9seWdvbnMiLCJzZXRQb2x5Z29ucyIsImdlb0pzb25EYXRhIiwic2V0R2VvSnNvbkRhdGEiLCJhcGlMb2FkZWQiLCJzZXRBcGlMb2FkZWQiLCJkaXJlY3Rpb25zUmVuZGVyZXIiLCJsb2FkR29vZ2xlTWFwc0FwaSIsIndpbmRvdyIsImdvb2dsZSIsIm1hcHMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJzY3JpcHQiLCJjcmVhdGVFbGVtZW50Iiwic3JjIiwiYXN5bmMiLCJkZWZlciIsIm9ubG9hZCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImN1cnJlbnQiLCJpbml0aWFsaXplTWFwIiwiY29uc29sZSIsImxvZyIsImNsZWFyUm91dGVBbmRQYW5lbCIsInNlYXJjaFJvdXRlIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwiZGF0YSIsInNldFBhbmVsIiwibWVsYm91cm5lQ0JEIiwibGF0IiwibG5nIiwibmV3TWFwIiwiY2VudGVyIiwiem9vbSIsImxvYWRlZFBvbHlnb25zIiwiZmVhdHVyZXMiLCJmZWF0dXJlIiwiZ2VvbWV0cnkiLCJ0eXBlIiwiY29vcmRpbmF0ZXMiLCJwb2x5Z29uQ29vcmRzIiwicGF0aHMiLCJyaW5nIiwiY29vcmRzIiwiUG9seWdvbiIsInN0cm9rZUNvbG9yIiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdlaWdodCIsImZpbGxDb2xvciIsImZpbGxPcGFjaXR5IiwiZmlsdGVyIiwicG9seSIsImZsYXQiLCJzZXRPcHRpb25zIiwic3R5bGVzIiwibWFwU3R5bGVzIiwiRGlyZWN0aW9uc1JlbmRlcmVyIiwiZ2V0RWxlbWVudEJ5SWQiLCJkaXJlY3Rpb25zU2VydmljZSIsIkRpcmVjdGlvbnNTZXJ2aWNlIiwiZ2VvY29kZXIiLCJHZW9jb2RlciIsInBhbmVsIiwiZ2VvY29kZUFkZHJlc3MiLCJhZGRyZXNzIiwiY2FsbGJhY2siLCJnZW9jb2RlIiwicmVzdWx0cyIsInN0YXR1cyIsImxvY2F0aW9uIiwiYWxlcnQiLCJvcmlnaW5MYXRMbmciLCJlcnJvciIsImRlc3RpbmF0aW9uTGF0TG5nIiwib3JpZ2luUG9pbnQiLCJwb2ludCIsImRlc3RpbmF0aW9uUG9pbnQiLCJpc0Nsb3NlRW5vdWdoIiwic29tZSIsImZlYXR1cmVQb2ludCIsInByb3BlcnRpZXMiLCJnZW9fcG9pbnRfMmQiLCJsb24iLCJkaXN0YW5jZSIsInVuaXRzIiwib3JpZ2luQ2xvc2VFbm91Z2giLCJkZXN0aW5hdGlvbkNsb3NlRW5vdWdoIiwicm91dGUiLCJ0cmFuc2l0T3B0aW9ucyIsIm1vZGVzIiwicm91dGluZ1ByZWZlcmVuY2UiLCJyZXN1bHQiLCJEaXJlY3Rpb25zU3RhdHVzIiwiT0siLCJzZXREaXJlY3Rpb25zIiwiZGl2IiwicmVmIiwic3R5bGUiLCJ3aWR0aCIsImhlaWdodCIsImZsb2F0IiwiaWQiLCJvdmVyZmxvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/Travel/Map.js\n"));

/***/ })

});