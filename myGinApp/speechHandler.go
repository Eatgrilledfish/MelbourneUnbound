package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

type RequestData struct {
	OptimizedData json.RawMessage `json:"optimizedData"`
}

type ChatGPTResponse struct {
	Choices []struct {
		Message struct {
			Content string `json:"content"`
		} `json:"message"`
	} `json:"choices"`
}

func RequestChatGPT(c *gin.Context) {
	var requestData RequestData
	if err := c.ShouldBindJSON(&requestData); err != nil {
		fmt.Println("Error binding JSON:", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request data", "details": err.Error()})
		return
	}
	routeDataBytes, err := json.Marshal(requestData.OptimizedData)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error marshaling route data"})
		return
	}
	fmt.Println("this is routedata:", string(routeDataBytes))
	body, err := json.Marshal(map[string]interface{}{
		"model": "gpt-3.5-turbo-16k-0613",
		"messages": []map[string]interface{}{
			{
				"role":    "system",
				"content": "You are an assistant navigator for wheelchair users. Don't say if user have question can ask you, because this is a one time conversation, you will not respond him again.",
			},
			{
				"role":    "assistant",
				"content": "Hi there! As your personal navigation buddy, I'm here to help you get around smoothly and safely. Letâ€™s dive into the route data from the Open Route Service tailored just for you. I'll guide you through each turn and bump, focusing on aspects like gradients and road surface materials that are crucial for your journey",
			},
			{
				"role":    "user",
				"content": "You are an assistant navigator for wheelchair users. Analyze this route data generated by the Open Route Service. Give the user a vivid, comforting and safe feeling, navigating data descriptions and warnings of dangers, while at the same time being lively and animated, in a first-person way, like a friend! Your primary goal is to assist the wheelchair user by providing tailored advice based on specific route characteristics such as gradients and road surface materials. Offer a comprehensive navigational road report, speaking suggestively and gently in the first person. Provide thoughtful advice and a thorough debrief of the road conditions to help the user navigate the route more effectively.  Route data: " + string(routeDataBytes),
			},
		},
	})
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error marshaling request body"})
		return
	}

	responseBody, err := sendPostRequest("https://openai.api2d.net/v1/chat/completions", "xxx", body)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to request ChatGPT"})
		return
	}
	fmt.Println("API Response:", string(responseBody))

	var chatGPTResponse ChatGPTResponse
	if err := json.Unmarshal(responseBody, &chatGPTResponse); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to parse ChatGPT response"})
		return
	}
	audioContent, err := textToSpeech(chatGPTResponse.Choices[0].Message.Content, "xxx", "australiaeast")
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to convert text to speech", "details": err.Error()})
		return
	}

	// Directly return the content received from ChatGPT to test
	c.Data(http.StatusOK, "audio/mpeg", audioContent)
}

func sendPostRequest(url, apiKey string, jsonData []byte) ([]byte, error) {
	client := &http.Client{}
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return body, nil
}

func textToSpeech(text, apiKey, region string) ([]byte, error) {
	ssml := fmt.Sprintf(`<speak version="1.0" xml:lang="en-US"><voice name="en-US-EmmaMultilingualNeural">%s</voice></speak>`, text)
	url := fmt.Sprintf("https://%s.tts.speech.microsoft.com/cognitiveservices/v1", region)
	client := &http.Client{}
	req, err := http.NewRequest("POST", url, strings.NewReader(ssml))
	if err != nil {
		return nil, fmt.Errorf("creating request failed: %w", err)
	}

	req.Header.Set("Content-Type", "application/ssml+xml")
	req.Header.Set("X-Microsoft-OutputFormat", "audio-16khz-128kbitrate-mono-mp3")
	req.Header.Set("Ocp-Apim-Subscription-Key", apiKey)

	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("request to Azure TTS failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		responseBody, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("Azure TTS API error: status %d, body: %s", resp.StatusCode, responseBody) // Error string is lowercase
	}

	audioData, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading audio data failed: %w", err)
	}

	return audioData, nil
}
